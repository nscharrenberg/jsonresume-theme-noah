<!doctype html>
<html>
	<head>
	
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimal-ui">
	
	<title>Noah Scharrenberg</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">

	<style>
	@charset "UTF-8";
/**
 *
 *  Command : gulp watch or gulp styles
 *
 */
/*!
 * Bootstrap v4.0.0-beta (https://getbootstrap.com)
 * Copyright 2011-2017 The Bootstrap Authors
 * Copyright 2011-2017 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
@import url("https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap");
@media print {
  *,
*::before,
*::after {
    text-shadow: none !important;
    box-shadow: none !important;
  }

  a,
a:visited {
    text-decoration: underline;
  }

  abbr[title]::after {
    content: " (" attr(title) ")";
  }

  pre {
    white-space: pre-wrap !important;
  }

  pre,
blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }

  thead {
    display: table-header-group;
  }

  tr,
img {
    page-break-inside: avoid;
  }

  p,
h2,
h3 {
    orphans: 3;
    widows: 3;
  }

  h2,
h3 {
    page-break-after: avoid;
  }

  .navbar {
    display: none;
  }

  .badge {
    border: 1px solid #000;
  }

  .table {
    border-collapse: collapse !important;
  }
  .table td,
.table th {
    background-color: #fff !important;
  }

  .table-bordered th,
.table-bordered td {
    border: 1px solid #ddd !important;
  }
}
*,
*::before,
*::after {
  box-sizing: border-box;
}

html {
  font-family: sans-serif;
  line-height: 1.15;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  -ms-overflow-style: scrollbar;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

@-ms-viewport {
  width: device-width;
}
article, aside, dialog, figcaption, figure, footer, header, hgroup, main, nav, section {
  display: block;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 1rem;
  font-weight: normal;
  line-height: 1.5;
  color: #212529;
  text-align: left;
  background-color: #fff;
}

[tabindex="-1"]:focus {
  outline: none !important;
}

hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 0.5rem;
}

p {
  margin-top: 0;
  margin-bottom: 1rem;
}

abbr[title],
abbr[data-original-title] {
  text-decoration: underline;
  text-decoration: underline dotted;
  cursor: help;
  border-bottom: 0;
}

address {
  margin-bottom: 1rem;
  font-style: normal;
  line-height: inherit;
}

ol,
ul,
dl {
  margin-top: 0;
  margin-bottom: 1rem;
}

ol ol,
ul ul,
ol ul,
ul ol {
  margin-bottom: 0;
}

dt {
  font-weight: bold;
}

dd {
  margin-bottom: 0.5rem;
  margin-left: 0;
}

blockquote {
  margin: 0 0 1rem;
}

dfn {
  font-style: italic;
}

b,
strong {
  font-weight: bolder;
}

small {
  font-size: 80%;
}

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

a {
  color: #03a9f4;
  text-decoration: none;
  background-color: transparent;
  -webkit-text-decoration-skip: objects;
}
a:hover {
  color: #0275a8;
  text-decoration: underline;
}

a:not([href]):not([tabindex]) {
  color: inherit;
  text-decoration: none;
}
a:not([href]):not([tabindex]):focus, a:not([href]):not([tabindex]):hover {
  color: inherit;
  text-decoration: none;
}
a:not([href]):not([tabindex]):focus {
  outline: 0;
}

pre,
code,
kbd,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

pre {
  margin-top: 0;
  margin-bottom: 1rem;
  overflow: auto;
}

figure {
  margin: 0 0 1rem;
}

img {
  vertical-align: middle;
  border-style: none;
}

svg:not(:root) {
  overflow: hidden;
}

a,
area,
button,
[role=button],
input:not([type=range]),
label,
select,
summary,
textarea {
  touch-action: manipulation;
}

table {
  border-collapse: collapse;
}

caption {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
  color: #868e96;
  text-align: left;
  caption-side: bottom;
}

th {
  text-align: inherit;
}

label {
  display: inline-block;
  margin-bottom: 0.5rem;
}

button:focus {
  outline: 1px dotted;
  outline: 5px auto -webkit-focus-ring-color;
}

input,
button,
select,
optgroup,
textarea {
  margin: 0;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

button,
input {
  overflow: visible;
}

button,
select {
  text-transform: none;
}

button,
html [type=button],
[type=reset],
[type=submit] {
  -webkit-appearance: button;
}

button::-moz-focus-inner,
[type=button]::-moz-focus-inner,
[type=reset]::-moz-focus-inner,
[type=submit]::-moz-focus-inner {
  padding: 0;
  border-style: none;
}

input[type=radio],
input[type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

input[type=date],
input[type=time],
input[type=datetime-local],
input[type=month] {
  -webkit-appearance: listbox;
}

textarea {
  overflow: auto;
  resize: vertical;
}

fieldset {
  min-width: 0;
  padding: 0;
  margin: 0;
  border: 0;
}

legend {
  display: block;
  width: 100%;
  max-width: 100%;
  padding: 0;
  margin-bottom: 0.5rem;
  font-size: 1.5rem;
  line-height: inherit;
  color: inherit;
  white-space: normal;
}

progress {
  vertical-align: baseline;
}

[type=number]::-webkit-inner-spin-button,
[type=number]::-webkit-outer-spin-button {
  height: auto;
}

[type=search] {
  outline-offset: -2px;
  -webkit-appearance: none;
}

[type=search]::-webkit-search-cancel-button,
[type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

::-webkit-file-upload-button {
  font: inherit;
  -webkit-appearance: button;
}

output {
  display: inline-block;
}

summary {
  display: list-item;
}

template {
  display: none;
}

[hidden] {
  display: none !important;
}

h1, h2, h3, h4, h5, h6,
.h1, .h2, .h3, .h4, .h5, .h6 {
  margin-bottom: 0.5rem;
  font-family: inherit;
  font-weight: 500;
  line-height: 1.1;
  color: inherit;
}

h1, .h1 {
  font-size: 2.5rem;
}

h2, .h2 {
  font-size: 2rem;
}

h3, .h3 {
  font-size: 1.75rem;
}

h4, .h4 {
  font-size: 1.5rem;
}

h5, .h5 {
  font-size: 1.25rem;
}

h6, .h6 {
  font-size: 1rem;
}

.lead {
  font-size: 1.25rem;
  font-weight: 300;
}

.display-1 {
  font-size: 6rem;
  font-weight: 300;
  line-height: 1.1;
}

.display-2 {
  font-size: 5.5rem;
  font-weight: 300;
  line-height: 1.1;
}

.display-3 {
  font-size: 4.5rem;
  font-weight: 300;
  line-height: 1.1;
}

.display-4 {
  font-size: 3.5rem;
  font-weight: 300;
  line-height: 1.1;
}

hr {
  margin-top: 1rem;
  margin-bottom: 1rem;
  border: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

small,
.small {
  font-size: 80%;
  font-weight: normal;
}

mark,
.mark {
  padding: 0.2em;
  background-color: #fcf8e3;
}

.list-unstyled {
  padding-left: 0;
  list-style: none;
}

.list-inline {
  padding-left: 0;
  list-style: none;
}

.list-inline-item {
  display: inline-block;
}
.list-inline-item:not(:last-child) {
  margin-right: 5px;
}

.initialism {
  font-size: 90%;
  text-transform: uppercase;
}

.blockquote {
  margin-bottom: 1rem;
  font-size: 1.25rem;
}

.blockquote-footer {
  display: block;
  font-size: 80%;
  color: #868e96;
}
.blockquote-footer::before {
  content: "— ";
}

.img-fluid {
  max-width: 100%;
  height: auto;
}

.img-thumbnail {
  padding: 0.25rem;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 0.25rem;
  transition: all 0.2s ease-in-out;
  max-width: 100%;
  height: auto;
}

.figure {
  display: inline-block;
}

.figure-img {
  margin-bottom: 0.5rem;
  line-height: 1;
}

.figure-caption {
  font-size: 90%;
  color: #868e96;
}

code,
kbd,
pre,
samp {
  font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

code {
  padding: 0.2rem 0.4rem;
  font-size: 90%;
  color: #bd4147;
  background-color: #f8f9fa;
  border-radius: 0.25rem;
}
a > code {
  padding: 0;
  color: inherit;
  background-color: inherit;
}

kbd {
  padding: 0.2rem 0.4rem;
  font-size: 90%;
  color: #fff;
  background-color: #212529;
  border-radius: 0.2rem;
}
kbd kbd {
  padding: 0;
  font-size: 100%;
  font-weight: bold;
}

pre {
  display: block;
  margin-top: 0;
  margin-bottom: 1rem;
  font-size: 90%;
  color: #212529;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit;
  background-color: transparent;
  border-radius: 0;
}

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll;
}

.container {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: 15px;
  padding-left: 15px;
}
@media (min-width: 576px) {
  .container {
    max-width: 540px;
  }
}
@media (min-width: 768px) {
  .container {
    max-width: 720px;
  }
}
@media (min-width: 992px) {
  .container {
    max-width: 960px;
  }
}
@media (min-width: 1200px) {
  .container {
    max-width: 1140px;
  }
}

.container-fluid {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: 15px;
  padding-left: 15px;
}

.row {
  display: flex;
  flex-wrap: wrap;
  margin-right: -15px;
  margin-left: -15px;
}

.no-gutters {
  margin-right: 0;
  margin-left: 0;
}
.no-gutters > .col,
.no-gutters > [class*=col-] {
  padding-right: 0;
  padding-left: 0;
}

.col-xl,
.col-xl-auto, .col-xl-12, .col-xl-11, .col-xl-10, .col-xl-9, .col-xl-8, .col-xl-7, .col-xl-6, .col-xl-5, .col-xl-4, .col-xl-3, .col-xl-2, .col-xl-1, .col-lg,
.col-lg-auto, .col-lg-12, .col-lg-11, .col-lg-10, .col-lg-9, .col-lg-8, .col-lg-7, .col-lg-6, .col-lg-5, .col-lg-4, .col-lg-3, .col-lg-2, .col-lg-1, .col-md,
.col-md-auto, .col-md-12, .col-md-11, .col-md-10, .col-md-9, .col-md-8, .col-md-7, .col-md-6, .col-md-5, .col-md-4, .col-md-3, .col-md-2, .col-md-1, .col-sm,
.col-sm-auto, .col-sm-12, .col-sm-11, .col-sm-10, .col-sm-9, .col-sm-8, .col-sm-7, .col-sm-6, .col-sm-5, .col-sm-4, .col-sm-3, .col-sm-2, .col-sm-1, .col,
.col-auto, .col-12, .col-11, .col-10, .col-9, .col-8, .col-7, .col-6, .col-5, .col-4, .col-3, .col-2, .col-1 {
  position: relative;
  width: 100%;
  min-height: 1px;
  padding-right: 15px;
  padding-left: 15px;
}

.col {
  flex-basis: 0;
  flex-grow: 1;
  max-width: 100%;
}

.col-auto {
  flex: 0 0 auto;
  width: auto;
  max-width: none;
}

.col-1 {
  flex: 0 0 8.3333333333%;
  max-width: 8.3333333333%;
}

.col-2 {
  flex: 0 0 16.6666666667%;
  max-width: 16.6666666667%;
}

.col-3 {
  flex: 0 0 25%;
  max-width: 25%;
}

.col-4 {
  flex: 0 0 33.3333333333%;
  max-width: 33.3333333333%;
}

.col-5 {
  flex: 0 0 41.6666666667%;
  max-width: 41.6666666667%;
}

.col-6 {
  flex: 0 0 50%;
  max-width: 50%;
}

.col-7 {
  flex: 0 0 58.3333333333%;
  max-width: 58.3333333333%;
}

.col-8 {
  flex: 0 0 66.6666666667%;
  max-width: 66.6666666667%;
}

.col-9 {
  flex: 0 0 75%;
  max-width: 75%;
}

.col-10 {
  flex: 0 0 83.3333333333%;
  max-width: 83.3333333333%;
}

.col-11 {
  flex: 0 0 91.6666666667%;
  max-width: 91.6666666667%;
}

.col-12 {
  flex: 0 0 100%;
  max-width: 100%;
}

.order-1 {
  order: 1;
}

.order-2 {
  order: 2;
}

.order-3 {
  order: 3;
}

.order-4 {
  order: 4;
}

.order-5 {
  order: 5;
}

.order-6 {
  order: 6;
}

.order-7 {
  order: 7;
}

.order-8 {
  order: 8;
}

.order-9 {
  order: 9;
}

.order-10 {
  order: 10;
}

.order-11 {
  order: 11;
}

.order-12 {
  order: 12;
}

.offset-1 {
  margin-left: 8.3333333333%;
}

.offset-2 {
  margin-left: 16.6666666667%;
}

.offset-3 {
  margin-left: 25%;
}

.offset-4 {
  margin-left: 33.3333333333%;
}

.offset-5 {
  margin-left: 41.6666666667%;
}

.offset-6 {
  margin-left: 50%;
}

.offset-7 {
  margin-left: 58.3333333333%;
}

.offset-8 {
  margin-left: 66.6666666667%;
}

.offset-9 {
  margin-left: 75%;
}

.offset-10 {
  margin-left: 83.3333333333%;
}

.offset-11 {
  margin-left: 91.6666666667%;
}

@media (min-width: 576px) {
  .col-sm {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-sm-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-sm-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-sm-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-sm-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-sm-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-sm-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-sm-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-sm-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-sm-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-sm-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-sm-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-sm-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-sm-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-sm-1 {
    order: 1;
  }

  .order-sm-2 {
    order: 2;
  }

  .order-sm-3 {
    order: 3;
  }

  .order-sm-4 {
    order: 4;
  }

  .order-sm-5 {
    order: 5;
  }

  .order-sm-6 {
    order: 6;
  }

  .order-sm-7 {
    order: 7;
  }

  .order-sm-8 {
    order: 8;
  }

  .order-sm-9 {
    order: 9;
  }

  .order-sm-10 {
    order: 10;
  }

  .order-sm-11 {
    order: 11;
  }

  .order-sm-12 {
    order: 12;
  }

  .offset-sm-0 {
    margin-left: 0%;
  }

  .offset-sm-1 {
    margin-left: 8.3333333333%;
  }

  .offset-sm-2 {
    margin-left: 16.6666666667%;
  }

  .offset-sm-3 {
    margin-left: 25%;
  }

  .offset-sm-4 {
    margin-left: 33.3333333333%;
  }

  .offset-sm-5 {
    margin-left: 41.6666666667%;
  }

  .offset-sm-6 {
    margin-left: 50%;
  }

  .offset-sm-7 {
    margin-left: 58.3333333333%;
  }

  .offset-sm-8 {
    margin-left: 66.6666666667%;
  }

  .offset-sm-9 {
    margin-left: 75%;
  }

  .offset-sm-10 {
    margin-left: 83.3333333333%;
  }

  .offset-sm-11 {
    margin-left: 91.6666666667%;
  }
}
@media (min-width: 768px) {
  .col-md {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-md-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-md-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-md-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-md-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-md-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-md-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-md-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-md-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-md-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-md-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-md-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-md-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-md-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-md-1 {
    order: 1;
  }

  .order-md-2 {
    order: 2;
  }

  .order-md-3 {
    order: 3;
  }

  .order-md-4 {
    order: 4;
  }

  .order-md-5 {
    order: 5;
  }

  .order-md-6 {
    order: 6;
  }

  .order-md-7 {
    order: 7;
  }

  .order-md-8 {
    order: 8;
  }

  .order-md-9 {
    order: 9;
  }

  .order-md-10 {
    order: 10;
  }

  .order-md-11 {
    order: 11;
  }

  .order-md-12 {
    order: 12;
  }

  .offset-md-0 {
    margin-left: 0%;
  }

  .offset-md-1 {
    margin-left: 8.3333333333%;
  }

  .offset-md-2 {
    margin-left: 16.6666666667%;
  }

  .offset-md-3 {
    margin-left: 25%;
  }

  .offset-md-4 {
    margin-left: 33.3333333333%;
  }

  .offset-md-5 {
    margin-left: 41.6666666667%;
  }

  .offset-md-6 {
    margin-left: 50%;
  }

  .offset-md-7 {
    margin-left: 58.3333333333%;
  }

  .offset-md-8 {
    margin-left: 66.6666666667%;
  }

  .offset-md-9 {
    margin-left: 75%;
  }

  .offset-md-10 {
    margin-left: 83.3333333333%;
  }

  .offset-md-11 {
    margin-left: 91.6666666667%;
  }
}
@media (min-width: 992px) {
  .col-lg {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-lg-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-lg-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-lg-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-lg-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-lg-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-lg-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-lg-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-lg-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-lg-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-lg-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-lg-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-lg-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-lg-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-lg-1 {
    order: 1;
  }

  .order-lg-2 {
    order: 2;
  }

  .order-lg-3 {
    order: 3;
  }

  .order-lg-4 {
    order: 4;
  }

  .order-lg-5 {
    order: 5;
  }

  .order-lg-6 {
    order: 6;
  }

  .order-lg-7 {
    order: 7;
  }

  .order-lg-8 {
    order: 8;
  }

  .order-lg-9 {
    order: 9;
  }

  .order-lg-10 {
    order: 10;
  }

  .order-lg-11 {
    order: 11;
  }

  .order-lg-12 {
    order: 12;
  }

  .offset-lg-0 {
    margin-left: 0%;
  }

  .offset-lg-1 {
    margin-left: 8.3333333333%;
  }

  .offset-lg-2 {
    margin-left: 16.6666666667%;
  }

  .offset-lg-3 {
    margin-left: 25%;
  }

  .offset-lg-4 {
    margin-left: 33.3333333333%;
  }

  .offset-lg-5 {
    margin-left: 41.6666666667%;
  }

  .offset-lg-6 {
    margin-left: 50%;
  }

  .offset-lg-7 {
    margin-left: 58.3333333333%;
  }

  .offset-lg-8 {
    margin-left: 66.6666666667%;
  }

  .offset-lg-9 {
    margin-left: 75%;
  }

  .offset-lg-10 {
    margin-left: 83.3333333333%;
  }

  .offset-lg-11 {
    margin-left: 91.6666666667%;
  }
}
@media (min-width: 1200px) {
  .col-xl {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-xl-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-xl-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-xl-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-xl-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-xl-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-xl-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-xl-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-xl-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-xl-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-xl-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-xl-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-xl-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-xl-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-xl-1 {
    order: 1;
  }

  .order-xl-2 {
    order: 2;
  }

  .order-xl-3 {
    order: 3;
  }

  .order-xl-4 {
    order: 4;
  }

  .order-xl-5 {
    order: 5;
  }

  .order-xl-6 {
    order: 6;
  }

  .order-xl-7 {
    order: 7;
  }

  .order-xl-8 {
    order: 8;
  }

  .order-xl-9 {
    order: 9;
  }

  .order-xl-10 {
    order: 10;
  }

  .order-xl-11 {
    order: 11;
  }

  .order-xl-12 {
    order: 12;
  }

  .offset-xl-0 {
    margin-left: 0%;
  }

  .offset-xl-1 {
    margin-left: 8.3333333333%;
  }

  .offset-xl-2 {
    margin-left: 16.6666666667%;
  }

  .offset-xl-3 {
    margin-left: 25%;
  }

  .offset-xl-4 {
    margin-left: 33.3333333333%;
  }

  .offset-xl-5 {
    margin-left: 41.6666666667%;
  }

  .offset-xl-6 {
    margin-left: 50%;
  }

  .offset-xl-7 {
    margin-left: 58.3333333333%;
  }

  .offset-xl-8 {
    margin-left: 66.6666666667%;
  }

  .offset-xl-9 {
    margin-left: 75%;
  }

  .offset-xl-10 {
    margin-left: 83.3333333333%;
  }

  .offset-xl-11 {
    margin-left: 91.6666666667%;
  }
}
.table {
  width: 100%;
  max-width: 100%;
  margin-bottom: 1rem;
  background-color: transparent;
}
.table th,
.table td {
  padding: 0.75rem;
  vertical-align: top;
  border-top: 1px solid #e9ecef;
}
.table thead th {
  vertical-align: bottom;
  border-bottom: 2px solid #e9ecef;
}
.table tbody + tbody {
  border-top: 2px solid #e9ecef;
}
.table .table {
  background-color: #fff;
}

.table-sm th,
.table-sm td {
  padding: 0.3rem;
}

.table-bordered {
  border: 1px solid #e9ecef;
}
.table-bordered th,
.table-bordered td {
  border: 1px solid #e9ecef;
}
.table-bordered thead th,
.table-bordered thead td {
  border-bottom-width: 2px;
}

.table-striped tbody tr:nth-of-type(odd) {
  background-color: rgba(0, 0, 0, 0.05);
}

.table-hover tbody tr:hover {
  background-color: #F5F8FA;
}

.table-primary,
.table-primary > th,
.table-primary > td {
  background-color: #b8e7fc;
}

.table-hover .table-primary:hover {
  background-color: #a0dffb;
}
.table-hover .table-primary:hover > td,
.table-hover .table-primary:hover > th {
  background-color: #a0dffb;
}

.table-secondary,
.table-secondary > th,
.table-secondary > td {
  background-color: #dddfe2;
}

.table-hover .table-secondary:hover {
  background-color: #cfd2d6;
}
.table-hover .table-secondary:hover > td,
.table-hover .table-secondary:hover > th {
  background-color: #cfd2d6;
}

.table-success,
.table-success > th,
.table-success > td {
  background-color: #dbf0cf;
}

.table-hover .table-success:hover {
  background-color: #cceabc;
}
.table-hover .table-success:hover > td,
.table-hover .table-success:hover > th {
  background-color: #cceabc;
}

.table-info,
.table-info > th,
.table-info > td {
  background-color: #d9ecfa;
}

.table-hover .table-info:hover {
  background-color: #c2e1f7;
}
.table-hover .table-info:hover > td,
.table-hover .table-info:hover > th {
  background-color: #c2e1f7;
}

.table-warning,
.table-warning > th,
.table-warning > td {
  background-color: #fef1cf;
}

.table-hover .table-warning:hover {
  background-color: #fdeab6;
}
.table-hover .table-warning:hover > td,
.table-hover .table-warning:hover > th {
  background-color: #fdeab6;
}

.table-danger,
.table-danger > th,
.table-danger > td {
  background-color: #facfd4;
}

.table-hover .table-danger:hover {
  background-color: #f8b8bf;
}
.table-hover .table-danger:hover > td,
.table-hover .table-danger:hover > th {
  background-color: #f8b8bf;
}

.table-light,
.table-light > th,
.table-light > td {
  background-color: #fdfdfe;
}

.table-hover .table-light:hover {
  background-color: #ececf6;
}
.table-hover .table-light:hover > td,
.table-hover .table-light:hover > th {
  background-color: #ececf6;
}

.table-dark,
.table-dark > th,
.table-dark > td {
  background-color: #c6c8ca;
}

.table-hover .table-dark:hover {
  background-color: #b9bbbe;
}
.table-hover .table-dark:hover > td,
.table-hover .table-dark:hover > th {
  background-color: #b9bbbe;
}

.table-active,
.table-active > th,
.table-active > td {
  background-color: #F5F8FA;
}

.table-hover .table-active:hover {
  background-color: #e4ecf2;
}
.table-hover .table-active:hover > td,
.table-hover .table-active:hover > th {
  background-color: #e4ecf2;
}

.table .thead-dark th {
  color: #fff;
  background-color: #212529;
  border-color: #32383e;
}
.table .thead-light th {
  color: #495057;
  background-color: #e9ecef;
  border-color: #e9ecef;
}

.table-dark {
  color: #fff;
  background-color: #212529;
}
.table-dark th,
.table-dark td,
.table-dark thead th {
  border-color: #32383e;
}
.table-dark.table-bordered {
  border: 0;
}
.table-dark.table-striped tbody tr:nth-of-type(odd) {
  background-color: rgba(255, 255, 255, 0.05);
}
.table-dark.table-hover tbody tr:hover {
  background-color: rgba(255, 255, 255, 0.075);
}

@media (max-width: 575px) {
  .table-responsive-sm {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-sm.table-bordered {
    border: 0;
  }
}
@media (max-width: 767px) {
  .table-responsive-md {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-md.table-bordered {
    border: 0;
  }
}
@media (max-width: 991px) {
  .table-responsive-lg {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-lg.table-bordered {
    border: 0;
  }
}
@media (max-width: 1199px) {
  .table-responsive-xl {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-xl.table-bordered {
    border: 0;
  }
}
.table-responsive {
  display: block;
  width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  -ms-overflow-style: -ms-autohiding-scrollbar;
}
.table-responsive.table-bordered {
  border: 0;
}

.form-control {
  display: block;
  width: 100%;
  padding: 0.5rem 0.75rem;
  font-size: 1rem;
  line-height: 1.25;
  color: #495057;
  background-color: #fff;
  background-image: none;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
  transition: border-color ease-in-out 0.15s, box-shadow ease-in-out 0.15s;
}
.form-control::-ms-expand {
  background-color: transparent;
  border: 0;
}
.form-control:focus {
  color: #495057;
  background-color: #fff;
  border-color: #79d4fd;
  outline: none;
}
.form-control::placeholder {
  color: #868e96;
  opacity: 1;
}
.form-control:disabled, .form-control[readonly] {
  background-color: #e9ecef;
  opacity: 1;
}

select.form-control:not([size]):not([multiple]) {
  height: calc(2.25rem + 2px);
}
select.form-control:focus::-ms-value {
  color: #495057;
  background-color: #fff;
}

.form-control-file,
.form-control-range {
  display: block;
}

.col-form-label {
  padding-top: calc(0.5rem - 1px * 2);
  padding-bottom: calc(0.5rem - 1px * 2);
  margin-bottom: 0;
}

.col-form-label-lg {
  padding-top: calc(0.5rem - 1px * 2);
  padding-bottom: calc(0.5rem - 1px * 2);
  font-size: 1.25rem;
}

.col-form-label-sm {
  padding-top: calc(0.25rem - 1px * 2);
  padding-bottom: calc(0.25rem - 1px * 2);
  font-size: 0.875rem;
}

.col-form-legend {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
  margin-bottom: 0;
  font-size: 1rem;
}

.form-control-plaintext {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
  margin-bottom: 0;
  line-height: 1.25;
  background-color: transparent;
  border: solid transparent;
  border-width: 1px 0;
}
.form-control-plaintext.form-control-sm, .input-group-sm > .form-control-plaintext.form-control,
.input-group-sm > .form-control-plaintext.input-group-addon,
.input-group-sm > .input-group-btn > .form-control-plaintext.btn, .form-control-plaintext.form-control-lg, .input-group-lg > .form-control-plaintext.form-control,
.input-group-lg > .form-control-plaintext.input-group-addon,
.input-group-lg > .input-group-btn > .form-control-plaintext.btn {
  padding-right: 0;
  padding-left: 0;
}

.form-control-sm, .input-group-sm > .form-control,
.input-group-sm > .input-group-addon,
.input-group-sm > .input-group-btn > .btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: 0.2rem;
}

select.form-control-sm:not([size]):not([multiple]), .input-group-sm > select.form-control:not([size]):not([multiple]),
.input-group-sm > select.input-group-addon:not([size]):not([multiple]),
.input-group-sm > .input-group-btn > select.btn:not([size]):not([multiple]) {
  height: calc(1.8125rem + 2px);
}

.form-control-lg, .input-group-lg > .form-control,
.input-group-lg > .input-group-addon,
.input-group-lg > .input-group-btn > .btn {
  padding: 0.5rem 1rem;
  font-size: 1.25rem;
  line-height: 1.5;
  border-radius: 0.3rem;
}

select.form-control-lg:not([size]):not([multiple]), .input-group-lg > select.form-control:not([size]):not([multiple]),
.input-group-lg > select.input-group-addon:not([size]):not([multiple]),
.input-group-lg > .input-group-btn > select.btn:not([size]):not([multiple]) {
  height: calc(2.875rem + 2px);
}

.form-group {
  margin-bottom: 1rem;
}

.form-text {
  display: block;
  margin-top: 0.25rem;
}

.form-row {
  display: flex;
  flex-wrap: wrap;
  margin-right: -5px;
  margin-left: -5px;
}
.form-row > .col,
.form-row > [class*=col-] {
  padding-right: 5px;
  padding-left: 5px;
}

.form-check {
  position: relative;
  display: block;
  margin-bottom: 0.5rem;
}
.form-check.disabled .form-check-label {
  color: #868e96;
}

.form-check-label {
  padding-left: 1.25rem;
  margin-bottom: 0;
}

.form-check-input {
  position: absolute;
  margin-top: 0.25rem;
  margin-left: -1.25rem;
}

.form-check-inline {
  display: inline-block;
  margin-right: 0.75rem;
}
.form-check-inline .form-check-label {
  vertical-align: middle;
}

.invalid-feedback {
  display: none;
  margin-top: 0.25rem;
  font-size: 0.875rem;
  color: #ED5564;
}

.invalid-tooltip {
  position: absolute;
  top: 100%;
  z-index: 5;
  display: none;
  width: 250px;
  padding: 0.5rem;
  margin-top: 0.1rem;
  font-size: 0.875rem;
  line-height: 1;
  color: #fff;
  background-color: rgba(237, 85, 100, 0.8);
  border-radius: 0.2rem;
}

.was-validated .form-control:valid, .form-control.is-valid,
.was-validated .custom-select:valid,
.custom-select.is-valid {
  border-color: #7dc855;
}
.was-validated .form-control:valid:focus, .form-control.is-valid:focus,
.was-validated .custom-select:valid:focus,
.custom-select.is-valid:focus {
  box-shadow: 0 0 0 0.2rem rgba(125, 200, 85, 0.25);
}
.was-validated .form-control:valid ~ .valid-feedback,
.was-validated .form-control:valid ~ .valid-tooltip, .form-control.is-valid ~ .valid-feedback,
.form-control.is-valid ~ .valid-tooltip,
.was-validated .custom-select:valid ~ .valid-feedback,
.was-validated .custom-select:valid ~ .valid-tooltip,
.custom-select.is-valid ~ .valid-feedback,
.custom-select.is-valid ~ .valid-tooltip {
  display: block;
}

.was-validated .form-check-input:valid + .form-check-label, .form-check-input.is-valid + .form-check-label {
  color: #7dc855;
}

.was-validated .custom-control-input:valid ~ .custom-control-indicator, .custom-control-input.is-valid ~ .custom-control-indicator {
  background-color: rgba(125, 200, 85, 0.25);
}
.was-validated .custom-control-input:valid ~ .custom-control-description, .custom-control-input.is-valid ~ .custom-control-description {
  color: #7dc855;
}

.was-validated .custom-file-input:valid ~ .custom-file-control, .custom-file-input.is-valid ~ .custom-file-control {
  border-color: #7dc855;
}
.was-validated .custom-file-input:valid ~ .custom-file-control::before, .custom-file-input.is-valid ~ .custom-file-control::before {
  border-color: inherit;
}
.was-validated .custom-file-input:valid:focus, .custom-file-input.is-valid:focus {
  box-shadow: 0 0 0 0.2rem rgba(125, 200, 85, 0.25);
}

.was-validated .form-control:invalid, .form-control.is-invalid,
.was-validated .custom-select:invalid,
.custom-select.is-invalid {
  border-color: #ED5564;
}
.was-validated .form-control:invalid:focus, .form-control.is-invalid:focus,
.was-validated .custom-select:invalid:focus,
.custom-select.is-invalid:focus {
  box-shadow: 0 0 0 0.2rem rgba(237, 85, 100, 0.25);
}
.was-validated .form-control:invalid ~ .invalid-feedback,
.was-validated .form-control:invalid ~ .invalid-tooltip, .form-control.is-invalid ~ .invalid-feedback,
.form-control.is-invalid ~ .invalid-tooltip,
.was-validated .custom-select:invalid ~ .invalid-feedback,
.was-validated .custom-select:invalid ~ .invalid-tooltip,
.custom-select.is-invalid ~ .invalid-feedback,
.custom-select.is-invalid ~ .invalid-tooltip {
  display: block;
}

.was-validated .form-check-input:invalid + .form-check-label, .form-check-input.is-invalid + .form-check-label {
  color: #ED5564;
}

.was-validated .custom-control-input:invalid ~ .custom-control-indicator, .custom-control-input.is-invalid ~ .custom-control-indicator {
  background-color: rgba(237, 85, 100, 0.25);
}
.was-validated .custom-control-input:invalid ~ .custom-control-description, .custom-control-input.is-invalid ~ .custom-control-description {
  color: #ED5564;
}

.was-validated .custom-file-input:invalid ~ .custom-file-control, .custom-file-input.is-invalid ~ .custom-file-control {
  border-color: #ED5564;
}
.was-validated .custom-file-input:invalid ~ .custom-file-control::before, .custom-file-input.is-invalid ~ .custom-file-control::before {
  border-color: inherit;
}
.was-validated .custom-file-input:invalid:focus, .custom-file-input.is-invalid:focus {
  box-shadow: 0 0 0 0.2rem rgba(237, 85, 100, 0.25);
}

.form-inline {
  display: flex;
  flex-flow: row wrap;
  align-items: center;
}
.form-inline .form-check {
  width: 100%;
}
@media (min-width: 576px) {
  .form-inline label {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 0;
  }
  .form-inline .form-group {
    display: flex;
    flex: 0 0 auto;
    flex-flow: row wrap;
    align-items: center;
    margin-bottom: 0;
  }
  .form-inline .form-control {
    display: inline-block;
    width: auto;
    vertical-align: middle;
  }
  .form-inline .form-control-plaintext {
    display: inline-block;
  }
  .form-inline .input-group {
    width: auto;
  }
  .form-inline .form-control-label {
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .form-check {
    display: flex;
    align-items: center;
    justify-content: center;
    width: auto;
    margin-top: 0;
    margin-bottom: 0;
  }
  .form-inline .form-check-label {
    padding-left: 0;
  }
  .form-inline .form-check-input {
    position: relative;
    margin-top: 0;
    margin-right: 0.25rem;
    margin-left: 0;
  }
  .form-inline .custom-control {
    display: flex;
    align-items: center;
    justify-content: center;
    padding-left: 0;
  }
  .form-inline .custom-control-indicator {
    position: static;
    display: inline-block;
    margin-right: 0.25rem;
    vertical-align: text-bottom;
  }
  .form-inline .has-feedback .form-control-feedback {
    top: 0;
  }
}

.btn {
  display: inline-block;
  font-weight: normal;
  text-align: center;
  white-space: nowrap;
  vertical-align: middle;
  user-select: none;
  border: 1px solid transparent;
  padding: 0.5rem 0.75rem;
  font-size: 1rem;
  line-height: 1.25;
  border-radius: 0.25rem;
  transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}
.btn:focus, .btn:hover {
  text-decoration: none;
}
.btn:focus, .btn.focus {
  outline: 0;
  box-shadow: 0 0 0 3px rgba(3, 169, 244, 0.25);
}
.btn.disabled, .btn:disabled {
  opacity: 0.65;
}
.btn:active, .btn.active {
  background-image: none;
}

a.btn.disabled,
fieldset[disabled] a.btn {
  pointer-events: none;
}

.btn-primary {
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.btn-primary:hover {
  color: #fff;
  background-color: #038fce;
  border-color: #0286c2;
}
.btn-primary:focus, .btn-primary.focus {
  box-shadow: 0 0 0 3px rgba(3, 169, 244, 0.5);
}
.btn-primary.disabled, .btn-primary:disabled {
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.btn-primary:active, .btn-primary.active, .show > .btn-primary.dropdown-toggle {
  background-color: #038fce;
  background-image: none;
  border-color: #0286c2;
}

.btn-secondary {
  color: #fff;
  background-color: #868e96;
  border-color: #868e96;
}
.btn-secondary:hover {
  color: #fff;
  background-color: #727b84;
  border-color: #6c757d;
}
.btn-secondary:focus, .btn-secondary.focus {
  box-shadow: 0 0 0 3px rgba(134, 142, 150, 0.5);
}
.btn-secondary.disabled, .btn-secondary:disabled {
  background-color: #868e96;
  border-color: #868e96;
}
.btn-secondary:active, .btn-secondary.active, .show > .btn-secondary.dropdown-toggle {
  background-color: #727b84;
  background-image: none;
  border-color: #6c757d;
}

.btn-success {
  color: #111;
  background-color: #7dc855;
  border-color: #7dc855;
}
.btn-success:hover {
  color: #fff;
  background-color: #68ba3c;
  border-color: #63b139;
}
.btn-success:focus, .btn-success.focus {
  box-shadow: 0 0 0 3px rgba(125, 200, 85, 0.5);
}
.btn-success.disabled, .btn-success:disabled {
  background-color: #7dc855;
  border-color: #7dc855;
}
.btn-success:active, .btn-success.active, .show > .btn-success.dropdown-toggle {
  background-color: #68ba3c;
  background-image: none;
  border-color: #63b139;
}

.btn-info {
  color: #111;
  background-color: #78BCEE;
  border-color: #78BCEE;
}
.btn-info:hover {
  color: #111;
  background-color: #56abea;
  border-color: #4ba6e8;
}
.btn-info:focus, .btn-info.focus {
  box-shadow: 0 0 0 3px rgba(120, 188, 238, 0.5);
}
.btn-info.disabled, .btn-info:disabled {
  background-color: #78BCEE;
  border-color: #78BCEE;
}
.btn-info:active, .btn-info.active, .show > .btn-info.dropdown-toggle {
  background-color: #56abea;
  background-image: none;
  border-color: #4ba6e8;
}

.btn-warning {
  color: #111;
  background-color: #FCCE54;
  border-color: #FCCE54;
}
.btn-warning:hover {
  color: #111;
  background-color: #fbc32e;
  border-color: #fbc022;
}
.btn-warning:focus, .btn-warning.focus {
  box-shadow: 0 0 0 3px rgba(252, 206, 84, 0.5);
}
.btn-warning.disabled, .btn-warning:disabled {
  background-color: #FCCE54;
  border-color: #FCCE54;
}
.btn-warning:active, .btn-warning.active, .show > .btn-warning.dropdown-toggle {
  background-color: #fbc32e;
  background-image: none;
  border-color: #fbc022;
}

.btn-danger {
  color: #fff;
  background-color: #ED5564;
  border-color: #ED5564;
}
.btn-danger:hover {
  color: #fff;
  background-color: #e93244;
  border-color: #e8273a;
}
.btn-danger:focus, .btn-danger.focus {
  box-shadow: 0 0 0 3px rgba(237, 85, 100, 0.5);
}
.btn-danger.disabled, .btn-danger:disabled {
  background-color: #ED5564;
  border-color: #ED5564;
}
.btn-danger:active, .btn-danger.active, .show > .btn-danger.dropdown-toggle {
  background-color: #e93244;
  background-image: none;
  border-color: #e8273a;
}

.btn-light {
  color: #111;
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}
.btn-light:hover {
  color: #111;
  background-color: #e2e6ea;
  border-color: #dae0e5;
}
.btn-light:focus, .btn-light.focus {
  box-shadow: 0 0 0 3px rgba(248, 249, 250, 0.5);
}
.btn-light.disabled, .btn-light:disabled {
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}
.btn-light:active, .btn-light.active, .show > .btn-light.dropdown-toggle {
  background-color: #e2e6ea;
  background-image: none;
  border-color: #dae0e5;
}

.btn-dark {
  color: #fff;
  background-color: #343a40;
  border-color: #343a40;
}
.btn-dark:hover {
  color: #fff;
  background-color: #23272b;
  border-color: #1d2124;
}
.btn-dark:focus, .btn-dark.focus {
  box-shadow: 0 0 0 3px rgba(52, 58, 64, 0.5);
}
.btn-dark.disabled, .btn-dark:disabled {
  background-color: #343a40;
  border-color: #343a40;
}
.btn-dark:active, .btn-dark.active, .show > .btn-dark.dropdown-toggle {
  background-color: #23272b;
  background-image: none;
  border-color: #1d2124;
}

.btn-outline-primary {
  color: #03a9f4;
  background-color: transparent;
  background-image: none;
  border-color: #03a9f4;
}
.btn-outline-primary:hover {
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.btn-outline-primary:focus, .btn-outline-primary.focus {
  box-shadow: 0 0 0 3px rgba(3, 169, 244, 0.5);
}
.btn-outline-primary.disabled, .btn-outline-primary:disabled {
  color: #03a9f4;
  background-color: transparent;
}
.btn-outline-primary:active, .btn-outline-primary.active, .show > .btn-outline-primary.dropdown-toggle {
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}

.btn-outline-secondary {
  color: #868e96;
  background-color: transparent;
  background-image: none;
  border-color: #868e96;
}
.btn-outline-secondary:hover {
  color: #fff;
  background-color: #868e96;
  border-color: #868e96;
}
.btn-outline-secondary:focus, .btn-outline-secondary.focus {
  box-shadow: 0 0 0 3px rgba(134, 142, 150, 0.5);
}
.btn-outline-secondary.disabled, .btn-outline-secondary:disabled {
  color: #868e96;
  background-color: transparent;
}
.btn-outline-secondary:active, .btn-outline-secondary.active, .show > .btn-outline-secondary.dropdown-toggle {
  color: #fff;
  background-color: #868e96;
  border-color: #868e96;
}

.btn-outline-success {
  color: #7dc855;
  background-color: transparent;
  background-image: none;
  border-color: #7dc855;
}
.btn-outline-success:hover {
  color: #fff;
  background-color: #7dc855;
  border-color: #7dc855;
}
.btn-outline-success:focus, .btn-outline-success.focus {
  box-shadow: 0 0 0 3px rgba(125, 200, 85, 0.5);
}
.btn-outline-success.disabled, .btn-outline-success:disabled {
  color: #7dc855;
  background-color: transparent;
}
.btn-outline-success:active, .btn-outline-success.active, .show > .btn-outline-success.dropdown-toggle {
  color: #fff;
  background-color: #7dc855;
  border-color: #7dc855;
}

.btn-outline-info {
  color: #78BCEE;
  background-color: transparent;
  background-image: none;
  border-color: #78BCEE;
}
.btn-outline-info:hover {
  color: #fff;
  background-color: #78BCEE;
  border-color: #78BCEE;
}
.btn-outline-info:focus, .btn-outline-info.focus {
  box-shadow: 0 0 0 3px rgba(120, 188, 238, 0.5);
}
.btn-outline-info.disabled, .btn-outline-info:disabled {
  color: #78BCEE;
  background-color: transparent;
}
.btn-outline-info:active, .btn-outline-info.active, .show > .btn-outline-info.dropdown-toggle {
  color: #fff;
  background-color: #78BCEE;
  border-color: #78BCEE;
}

.btn-outline-warning {
  color: #FCCE54;
  background-color: transparent;
  background-image: none;
  border-color: #FCCE54;
}
.btn-outline-warning:hover {
  color: #fff;
  background-color: #FCCE54;
  border-color: #FCCE54;
}
.btn-outline-warning:focus, .btn-outline-warning.focus {
  box-shadow: 0 0 0 3px rgba(252, 206, 84, 0.5);
}
.btn-outline-warning.disabled, .btn-outline-warning:disabled {
  color: #FCCE54;
  background-color: transparent;
}
.btn-outline-warning:active, .btn-outline-warning.active, .show > .btn-outline-warning.dropdown-toggle {
  color: #fff;
  background-color: #FCCE54;
  border-color: #FCCE54;
}

.btn-outline-danger {
  color: #ED5564;
  background-color: transparent;
  background-image: none;
  border-color: #ED5564;
}
.btn-outline-danger:hover {
  color: #fff;
  background-color: #ED5564;
  border-color: #ED5564;
}
.btn-outline-danger:focus, .btn-outline-danger.focus {
  box-shadow: 0 0 0 3px rgba(237, 85, 100, 0.5);
}
.btn-outline-danger.disabled, .btn-outline-danger:disabled {
  color: #ED5564;
  background-color: transparent;
}
.btn-outline-danger:active, .btn-outline-danger.active, .show > .btn-outline-danger.dropdown-toggle {
  color: #fff;
  background-color: #ED5564;
  border-color: #ED5564;
}

.btn-outline-light {
  color: #f8f9fa;
  background-color: transparent;
  background-image: none;
  border-color: #f8f9fa;
}
.btn-outline-light:hover {
  color: #212529;
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}
.btn-outline-light:focus, .btn-outline-light.focus {
  box-shadow: 0 0 0 3px rgba(248, 249, 250, 0.5);
}
.btn-outline-light.disabled, .btn-outline-light:disabled {
  color: #f8f9fa;
  background-color: transparent;
}
.btn-outline-light:active, .btn-outline-light.active, .show > .btn-outline-light.dropdown-toggle {
  color: #212529;
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}

.btn-outline-dark {
  color: #343a40;
  background-color: transparent;
  background-image: none;
  border-color: #343a40;
}
.btn-outline-dark:hover {
  color: #fff;
  background-color: #343a40;
  border-color: #343a40;
}
.btn-outline-dark:focus, .btn-outline-dark.focus {
  box-shadow: 0 0 0 3px rgba(52, 58, 64, 0.5);
}
.btn-outline-dark.disabled, .btn-outline-dark:disabled {
  color: #343a40;
  background-color: transparent;
}
.btn-outline-dark:active, .btn-outline-dark.active, .show > .btn-outline-dark.dropdown-toggle {
  color: #fff;
  background-color: #343a40;
  border-color: #343a40;
}

.btn-link {
  font-weight: normal;
  color: #03a9f4;
  background-color: transparent;
  border-radius: 0;
}
.btn-link:hover {
  color: #0275a8;
  text-decoration: underline;
  background-color: transparent;
  border-color: transparent;
}
.btn-link:focus, .btn-link.focus {
  border-color: transparent;
  box-shadow: none;
}
.btn-link:disabled, .btn-link.disabled {
  color: #868e96;
}

.btn-lg, .btn-group-lg > .btn {
  padding: 0.5rem 1rem;
  font-size: 1.25rem;
  line-height: 1.5;
  border-radius: 0.3rem;
}

.btn-sm, .btn-group-sm > .btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: 0.2rem;
}

.btn-block {
  display: block;
  width: 100%;
}

.btn-block + .btn-block {
  margin-top: 0.5rem;
}

input[type=submit].btn-block,
input[type=reset].btn-block,
input[type=button].btn-block {
  width: 100%;
}

.fade {
  opacity: 0;
  transition: opacity 0.15s linear;
}
.fade.show {
  opacity: 1;
}

.collapse {
  display: none;
}
.collapse.show {
  display: block;
}

tr.collapse.show {
  display: table-row;
}

tbody.collapse.show {
  display: table-row-group;
}

.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  transition: height 0.35s ease;
}

.dropup,
.dropdown {
  position: relative;
}

.dropdown-toggle::after {
  display: inline-block;
  width: 0;
  height: 0;
  margin-left: 0.255em;
  vertical-align: 0.255em;
  content: "";
  border-top: 0.3em solid;
  border-right: 0.3em solid transparent;
  border-left: 0.3em solid transparent;
}
.dropdown-toggle:empty::after {
  margin-left: 0;
}

.dropup .dropdown-menu {
  margin-top: 0;
  margin-bottom: 0.125rem;
}
.dropup .dropdown-toggle::after {
  border-top: 0;
  border-bottom: 0.3em solid;
}

.dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 1000;
  display: none;
  float: left;
  min-width: 10rem;
  padding: 0.5rem 0;
  margin: 0.125rem 0 0;
  font-size: 1rem;
  color: #212529;
  text-align: left;
  list-style: none;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
}

.dropdown-divider {
  height: 0;
  margin: 0.5rem 0;
  overflow: hidden;
  border-top: 1px solid #e9ecef;
}

.dropdown-item {
  display: block;
  width: 100%;
  padding: 0.25rem 1.5rem;
  clear: both;
  font-weight: normal;
  color: #212529;
  text-align: inherit;
  white-space: nowrap;
  background: none;
  border: 0;
}
.dropdown-item:focus, .dropdown-item:hover {
  color: #16181b;
  text-decoration: none;
  background-color: #f8f9fa;
}
.dropdown-item.active, .dropdown-item:active {
  color: #fff;
  text-decoration: none;
  background-color: #03a9f4;
}
.dropdown-item.disabled, .dropdown-item:disabled {
  color: #868e96;
  background-color: transparent;
}

.show > a {
  outline: 0;
}

.dropdown-menu.show {
  display: block;
}

.dropdown-header {
  display: block;
  padding: 0.5rem 1.5rem;
  margin-bottom: 0;
  font-size: 0.875rem;
  color: #868e96;
  white-space: nowrap;
}

.btn-group,
.btn-group-vertical {
  position: relative;
  display: inline-flex;
  vertical-align: middle;
}
.btn-group > .btn,
.btn-group-vertical > .btn {
  position: relative;
  flex: 0 1 auto;
}
.btn-group > .btn:hover,
.btn-group-vertical > .btn:hover {
  z-index: 2;
}
.btn-group > .btn:focus, .btn-group > .btn:active, .btn-group > .btn.active,
.btn-group-vertical > .btn:focus,
.btn-group-vertical > .btn:active,
.btn-group-vertical > .btn.active {
  z-index: 2;
}
.btn-group .btn + .btn,
.btn-group .btn + .btn-group,
.btn-group .btn-group + .btn,
.btn-group .btn-group + .btn-group,
.btn-group-vertical .btn + .btn,
.btn-group-vertical .btn + .btn-group,
.btn-group-vertical .btn-group + .btn,
.btn-group-vertical .btn-group + .btn-group {
  margin-left: -1px;
}

.btn-toolbar {
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
}
.btn-toolbar .input-group {
  width: auto;
}

.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
  border-radius: 0;
}

.btn-group > .btn:first-child {
  margin-left: 0;
}
.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.btn-group > .btn:last-child:not(:first-child),
.btn-group > .dropdown-toggle:not(:first-child) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.btn-group > .btn-group {
  float: left;
}

.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}

.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.btn + .dropdown-toggle-split {
  padding-right: 0.5625rem;
  padding-left: 0.5625rem;
}
.btn + .dropdown-toggle-split::after {
  margin-left: 0;
}

.btn-sm + .dropdown-toggle-split, .btn-group-sm > .btn + .dropdown-toggle-split {
  padding-right: 0.375rem;
  padding-left: 0.375rem;
}

.btn-lg + .dropdown-toggle-split, .btn-group-lg > .btn + .dropdown-toggle-split {
  padding-right: 0.75rem;
  padding-left: 0.75rem;
}

.btn-group-vertical {
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
}
.btn-group-vertical .btn,
.btn-group-vertical .btn-group {
  width: 100%;
}
.btn-group-vertical > .btn + .btn,
.btn-group-vertical > .btn + .btn-group,
.btn-group-vertical > .btn-group + .btn,
.btn-group-vertical > .btn-group + .btn-group {
  margin-top: -1px;
  margin-left: 0;
}
.btn-group-vertical > .btn:not(:first-child):not(:last-child) {
  border-radius: 0;
}
.btn-group-vertical:first-child:not(:last-child) {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical:last-child:not(:first-child) {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}
.btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

[data-toggle=buttons] > .btn input[type=radio],
[data-toggle=buttons] > .btn input[type=checkbox],
[data-toggle=buttons] > .btn-group > .btn input[type=radio],
[data-toggle=buttons] > .btn-group > .btn input[type=checkbox] {
  position: absolute;
  clip: rect(0, 0, 0, 0);
  pointer-events: none;
}

.input-group {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
}
.input-group .form-control {
  position: relative;
  z-index: 2;
  flex: 1 1 auto;
  width: 1%;
  margin-bottom: 0;
}
.input-group .form-control:focus, .input-group .form-control:active, .input-group .form-control:hover {
  z-index: 3;
}

.input-group-addon:not(:first-child):not(:last-child),
.input-group-btn:not(:first-child):not(:last-child),
.input-group .form-control:not(:first-child):not(:last-child) {
  border-radius: 0;
}

.input-group-addon,
.input-group-btn {
  white-space: nowrap;
}

.input-group-addon {
  padding: 0.5rem 0.75rem;
  margin-bottom: 0;
  font-size: 1rem;
  font-weight: normal;
  line-height: 1.25;
  color: #495057;
  text-align: center;
  background-color: #e9ecef;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
}
.input-group-addon.form-control-sm,
.input-group-sm > .input-group-addon,
.input-group-sm > .input-group-btn > .input-group-addon.btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  border-radius: 0.2rem;
}
.input-group-addon.form-control-lg,
.input-group-lg > .input-group-addon,
.input-group-lg > .input-group-btn > .input-group-addon.btn {
  padding: 0.5rem 1rem;
  font-size: 1.25rem;
  border-radius: 0.3rem;
}
.input-group-addon input[type=radio],
.input-group-addon input[type=checkbox] {
  margin-top: 0;
}

.input-group .form-control:not(:last-child),
.input-group-addon:not(:last-child),
.input-group-btn:not(:last-child) > .btn,
.input-group-btn:not(:last-child) > .btn-group > .btn,
.input-group-btn:not(:last-child) > .dropdown-toggle,
.input-group-btn:not(:first-child) > .btn:not(:last-child):not(.dropdown-toggle),
.input-group-btn:not(:first-child) > .btn-group:not(:last-child) > .btn {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.input-group-addon:not(:last-child) {
  border-right: 0;
}

.input-group .form-control:not(:first-child),
.input-group-addon:not(:first-child),
.input-group-btn:not(:first-child) > .btn,
.input-group-btn:not(:first-child) > .btn-group > .btn,
.input-group-btn:not(:first-child) > .dropdown-toggle,
.input-group-btn:not(:last-child) > .btn:not(:first-child),
.input-group-btn:not(:last-child) > .btn-group:not(:first-child) > .btn {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.form-control + .input-group-addon:not(:first-child) {
  border-left: 0;
}

.input-group-btn {
  position: relative;
  font-size: 0;
  white-space: nowrap;
}
.input-group-btn > .btn {
  position: relative;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
}
.input-group-btn > .btn + .btn {
  margin-left: -1px;
}
.input-group-btn > .btn:focus, .input-group-btn > .btn:active, .input-group-btn > .btn:hover {
  z-index: 3;
}
.input-group-btn:not(:last-child) > .btn,
.input-group-btn:not(:last-child) > .btn-group {
  margin-right: -1px;
}
.input-group-btn:not(:first-child) > .btn,
.input-group-btn:not(:first-child) > .btn-group {
  z-index: 2;
  margin-left: -1px;
}
.input-group-btn:not(:first-child) > .btn:focus, .input-group-btn:not(:first-child) > .btn:active, .input-group-btn:not(:first-child) > .btn:hover,
.input-group-btn:not(:first-child) > .btn-group:focus,
.input-group-btn:not(:first-child) > .btn-group:active,
.input-group-btn:not(:first-child) > .btn-group:hover {
  z-index: 3;
}

.custom-control {
  position: relative;
  display: inline-flex;
  min-height: 1.5rem;
  padding-left: 1.5rem;
  margin-right: 1rem;
}

.custom-control-input {
  position: absolute;
  z-index: -1;
  opacity: 0;
}
.custom-control-input:checked ~ .custom-control-indicator {
  color: #fff;
  background-color: #03a9f4;
}
.custom-control-input:focus ~ .custom-control-indicator {
  box-shadow: 0 0 0 1px #fff, 0 0 0 3px #03a9f4;
}
.custom-control-input:active ~ .custom-control-indicator {
  color: #fff;
  background-color: #ace4fe;
}
.custom-control-input:disabled ~ .custom-control-indicator {
  background-color: #e9ecef;
}
.custom-control-input:disabled ~ .custom-control-description {
  color: #868e96;
}

.custom-control-indicator {
  position: absolute;
  top: 0.25rem;
  left: 0;
  display: block;
  width: 1rem;
  height: 1rem;
  pointer-events: none;
  user-select: none;
  background-color: #ddd;
  background-repeat: no-repeat;
  background-position: center center;
  background-size: 50% 50%;
}

.custom-checkbox .custom-control-indicator {
  border-radius: 0.25rem;
}
.custom-checkbox .custom-control-input:checked ~ .custom-control-indicator {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3E%3C/svg%3E");
}
.custom-checkbox .custom-control-input:indeterminate ~ .custom-control-indicator {
  background-color: #03a9f4;
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 4'%3E%3Cpath stroke='%23fff' d='M0 2h4'/%3E%3C/svg%3E");
}

.custom-radio .custom-control-indicator {
  border-radius: 50%;
}
.custom-radio .custom-control-input:checked ~ .custom-control-indicator {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3E%3Ccircle r='3' fill='%23fff'/%3E%3C/svg%3E");
}

.custom-controls-stacked {
  display: flex;
  flex-direction: column;
}
.custom-controls-stacked .custom-control {
  margin-bottom: 0.25rem;
}
.custom-controls-stacked .custom-control + .custom-control {
  margin-left: 0;
}

.custom-select {
  display: inline-block;
  max-width: 100%;
  height: calc(2.25rem + 2px);
  padding: 0.375rem 1.75rem 0.375rem 0.75rem;
  line-height: 1.25;
  color: #495057;
  vertical-align: middle;
  background: #fff url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") no-repeat right 0.75rem center;
  background-clip: padding-box;
  background-size: 8px 10px;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
  appearance: none;
}
.custom-select:focus {
  border-color: #79d4fd;
  outline: none;
}
.custom-select:focus::-ms-value {
  color: #495057;
  background-color: #fff;
}
.custom-select:disabled {
  color: #868e96;
  background-color: #e9ecef;
}
.custom-select::-ms-expand {
  opacity: 0;
}

.custom-select-sm {
  height: calc(1.8125rem + 2px);
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
  font-size: 75%;
}

.custom-file {
  position: relative;
  display: inline-block;
  max-width: 100%;
  height: calc(2.25rem + 2px);
  margin-bottom: 0;
}

.custom-file-input {
  min-width: 14rem;
  max-width: 100%;
  height: calc(2.25rem + 2px);
  margin: 0;
  opacity: 0;
}
.custom-file-input:focus ~ .custom-file-control {
  box-shadow: 0 0 0 0.075rem #fff, 0 0 0 0.2rem #03a9f4;
}

.custom-file-control {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  z-index: 5;
  height: calc(2.25rem + 2px);
  padding: 0.5rem 0.75rem;
  overflow: hidden;
  line-height: 1.25;
  color: #495057;
  pointer-events: none;
  user-select: none;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
}
.custom-file-control:lang(en):empty::after {
  content: "Choose file...";
}
.custom-file-control::before {
  position: absolute;
  top: 0;
  right: 0;
  z-index: 6;
  display: block;
  height: calc(2.25rem + 2px);
  padding: 0.5rem 0.75rem;
  line-height: 1.25;
  color: #495057;
  background-color: #e9ecef;
  border-left: 1px solid rgba(0, 0, 0, 0.15);
}
.custom-file-control:lang(en)::before {
  content: "Browse";
}

.nav {
  display: flex;
  flex-wrap: wrap;
  padding-left: 0;
  margin-bottom: 0;
  list-style: none;
}

.nav-link {
  display: block;
  padding: 0.5rem 1rem;
}
.nav-link:focus, .nav-link:hover {
  text-decoration: none;
}
.nav-link.disabled {
  color: #868e96;
}

.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs .nav-item {
  margin-bottom: -1px;
}
.nav-tabs .nav-link {
  border: 1px solid transparent;
  border-top-left-radius: 0.25rem;
  border-top-right-radius: 0.25rem;
}
.nav-tabs .nav-link:focus, .nav-tabs .nav-link:hover {
  border-color: #e9ecef #e9ecef #ddd;
}
.nav-tabs .nav-link.disabled {
  color: #868e96;
  background-color: transparent;
  border-color: transparent;
}
.nav-tabs .nav-link.active,
.nav-tabs .nav-item.show .nav-link {
  color: #495057;
  background-color: #fff;
  border-color: #ddd #ddd #fff;
}
.nav-tabs .dropdown-menu {
  margin-top: -1px;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

.nav-pills .nav-link {
  border-radius: 0.25rem;
}
.nav-pills .nav-link.active, .show > .nav-pills .nav-link {
  color: #fff;
  background-color: #03a9f4;
}

.nav-fill .nav-item {
  flex: 1 1 auto;
  text-align: center;
}

.nav-justified .nav-item {
  flex-basis: 0;
  flex-grow: 1;
  text-align: center;
}

.tab-content > .tab-pane {
  display: none;
}
.tab-content > .active {
  display: block;
}

.navbar {
  position: relative;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 1rem;
}
.navbar > .container,
.navbar > .container-fluid {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
}

.navbar-brand {
  display: inline-block;
  padding-top: 0.3125rem;
  padding-bottom: 0.3125rem;
  margin-right: 1rem;
  font-size: 1.25rem;
  line-height: inherit;
  white-space: nowrap;
}
.navbar-brand:focus, .navbar-brand:hover {
  text-decoration: none;
}

.navbar-nav {
  display: flex;
  flex-direction: column;
  padding-left: 0;
  margin-bottom: 0;
  list-style: none;
}
.navbar-nav .nav-link {
  padding-right: 0;
  padding-left: 0;
}
.navbar-nav .dropdown-menu {
  position: static;
  float: none;
}

.navbar-text {
  display: inline-block;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

.navbar-collapse {
  flex-basis: 100%;
  flex-grow: 1;
  align-items: center;
}

.navbar-toggler {
  padding: 0.25rem 0.75rem;
  font-size: 1.25rem;
  line-height: 1;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 0.25rem;
}
.navbar-toggler:focus, .navbar-toggler:hover {
  text-decoration: none;
}

.navbar-toggler-icon {
  display: inline-block;
  width: 1.5em;
  height: 1.5em;
  vertical-align: middle;
  content: "";
  background: no-repeat center center;
  background-size: 100% 100%;
}

@media (max-width: 575px) {
  .navbar-expand-sm > .container,
.navbar-expand-sm > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 576px) {
  .navbar-expand-sm {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-sm .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-sm .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-sm .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-sm .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-sm > .container,
.navbar-expand-sm > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-sm .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-sm .navbar-toggler {
    display: none;
  }
}
@media (max-width: 767px) {
  .navbar-expand-md > .container,
.navbar-expand-md > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 768px) {
  .navbar-expand-md {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-md .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-md .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-md .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-md .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-md > .container,
.navbar-expand-md > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-md .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-md .navbar-toggler {
    display: none;
  }
}
@media (max-width: 991px) {
  .navbar-expand-lg > .container,
.navbar-expand-lg > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 992px) {
  .navbar-expand-lg {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-lg .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-lg .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-lg .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-lg .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-lg > .container,
.navbar-expand-lg > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-lg .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-lg .navbar-toggler {
    display: none;
  }
}
@media (max-width: 1199px) {
  .navbar-expand-xl > .container,
.navbar-expand-xl > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 1200px) {
  .navbar-expand-xl {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-xl .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-xl .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-xl .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-xl .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-xl > .container,
.navbar-expand-xl > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-xl .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-xl .navbar-toggler {
    display: none;
  }
}
.navbar-expand {
  flex-direction: row;
  flex-wrap: nowrap;
  justify-content: flex-start;
}
.navbar-expand > .container,
.navbar-expand > .container-fluid {
  padding-right: 0;
  padding-left: 0;
}
.navbar-expand .navbar-nav {
  flex-direction: row;
}
.navbar-expand .navbar-nav .dropdown-menu {
  position: absolute;
}
.navbar-expand .navbar-nav .dropdown-menu-right {
  right: 0;
  left: auto;
}
.navbar-expand .navbar-nav .nav-link {
  padding-right: 0.5rem;
  padding-left: 0.5rem;
}
.navbar-expand > .container,
.navbar-expand > .container-fluid {
  flex-wrap: nowrap;
}
.navbar-expand .navbar-collapse {
  display: flex !important;
  flex-basis: auto;
}
.navbar-expand .navbar-toggler {
  display: none;
}

.navbar-light .navbar-brand {
  color: rgba(0, 0, 0, 0.9);
}
.navbar-light .navbar-brand:focus, .navbar-light .navbar-brand:hover {
  color: rgba(0, 0, 0, 0.9);
}
.navbar-light .navbar-nav .nav-link {
  color: rgba(0, 0, 0, 0.5);
}
.navbar-light .navbar-nav .nav-link:focus, .navbar-light .navbar-nav .nav-link:hover {
  color: rgba(0, 0, 0, 0.7);
}
.navbar-light .navbar-nav .nav-link.disabled {
  color: rgba(0, 0, 0, 0.3);
}
.navbar-light .navbar-nav .show > .nav-link,
.navbar-light .navbar-nav .active > .nav-link,
.navbar-light .navbar-nav .nav-link.show,
.navbar-light .navbar-nav .nav-link.active {
  color: rgba(0, 0, 0, 0.9);
}
.navbar-light .navbar-toggler {
  color: rgba(0, 0, 0, 0.5);
  border-color: rgba(0, 0, 0, 0.1);
}
.navbar-light .navbar-toggler-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(0, 0, 0, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
}
.navbar-light .navbar-text {
  color: rgba(0, 0, 0, 0.5);
}

.navbar-dark .navbar-brand {
  color: white;
}
.navbar-dark .navbar-brand:focus, .navbar-dark .navbar-brand:hover {
  color: white;
}
.navbar-dark .navbar-nav .nav-link {
  color: rgba(255, 255, 255, 0.5);
}
.navbar-dark .navbar-nav .nav-link:focus, .navbar-dark .navbar-nav .nav-link:hover {
  color: rgba(255, 255, 255, 0.75);
}
.navbar-dark .navbar-nav .nav-link.disabled {
  color: rgba(255, 255, 255, 0.25);
}
.navbar-dark .navbar-nav .show > .nav-link,
.navbar-dark .navbar-nav .active > .nav-link,
.navbar-dark .navbar-nav .nav-link.show,
.navbar-dark .navbar-nav .nav-link.active {
  color: white;
}
.navbar-dark .navbar-toggler {
  color: rgba(255, 255, 255, 0.5);
  border-color: rgba(255, 255, 255, 0.1);
}
.navbar-dark .navbar-toggler-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(255, 255, 255, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
}
.navbar-dark .navbar-text {
  color: rgba(255, 255, 255, 0.5);
}

.card {
  position: relative;
  display: flex;
  flex-direction: column;
  min-width: 0;
  word-wrap: break-word;
  background-color: #fff;
  background-clip: border-box;
  border: 1px solid rgba(0, 0, 0, 0.125);
  border-radius: 0.25rem;
}

.card-body {
  flex: 1 1 auto;
  padding: 1.25rem;
}

.card-title {
  margin-bottom: 0.75rem;
}

.card-subtitle {
  margin-top: -0.375rem;
  margin-bottom: 0;
}

.card-text:last-child {
  margin-bottom: 0;
}

.card-link:hover {
  text-decoration: none;
}
.card-link + .card-link {
  margin-left: 1.25rem;
}

.card > .list-group:first-child .list-group-item:first-child {
  border-top-left-radius: 0.25rem;
  border-top-right-radius: 0.25rem;
}
.card > .list-group:last-child .list-group-item:last-child {
  border-bottom-right-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}
.card .card-header + .list-group > .list-group-item:first-child {
  border-top: 0;
}

.card-header {
  padding: 0.75rem 1.25rem;
  margin-bottom: 0;
  background-color: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid rgba(0, 0, 0, 0.125);
}
.card-header:first-child {
  border-radius: calc(0.25rem - 1px) calc(0.25rem - 1px) 0 0;
}

.card-footer {
  padding: 0.75rem 1.25rem;
  background-color: rgba(0, 0, 0, 0.03);
  border-top: 1px solid rgba(0, 0, 0, 0.125);
}
.card-footer:last-child {
  border-radius: 0 0 calc(0.25rem - 1px) calc(0.25rem - 1px);
}

.card-header-tabs {
  margin-right: -0.625rem;
  margin-bottom: -0.75rem;
  margin-left: -0.625rem;
  border-bottom: 0;
}

.card-header-pills {
  margin-right: -0.625rem;
  margin-left: -0.625rem;
}

.card-img-overlay {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  padding: 1.25rem;
}

.card-img {
  width: 100%;
  border-radius: calc(0.25rem - 1px);
}

.card-img-top {
  width: 100%;
  border-top-left-radius: calc(0.25rem - 1px);
  border-top-right-radius: calc(0.25rem - 1px);
}

.card-img-bottom {
  width: 100%;
  border-bottom-right-radius: calc(0.25rem - 1px);
  border-bottom-left-radius: calc(0.25rem - 1px);
}

.card-deck {
  display: flex;
  flex-direction: column;
}
.card-deck .card {
  margin-bottom: 15px;
}
@media (min-width: 576px) {
  .card-deck {
    flex-flow: row wrap;
    margin-right: -15px;
    margin-left: -15px;
  }
  .card-deck .card {
    display: flex;
    flex: 1 0 0%;
    flex-direction: column;
    margin-right: 15px;
    margin-bottom: 0;
    margin-left: 15px;
  }
}

.card-group {
  display: flex;
  flex-direction: column;
}
.card-group .card {
  margin-bottom: 15px;
}
@media (min-width: 576px) {
  .card-group {
    flex-flow: row wrap;
  }
  .card-group .card {
    flex: 1 0 0%;
    margin-bottom: 0;
  }
  .card-group .card + .card {
    margin-left: 0;
    border-left: 0;
  }
  .card-group .card:first-child {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }
  .card-group .card:first-child .card-img-top {
    border-top-right-radius: 0;
  }
  .card-group .card:first-child .card-img-bottom {
    border-bottom-right-radius: 0;
  }
  .card-group .card:last-child {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }
  .card-group .card:last-child .card-img-top {
    border-top-left-radius: 0;
  }
  .card-group .card:last-child .card-img-bottom {
    border-bottom-left-radius: 0;
  }
  .card-group .card:not(:first-child):not(:last-child) {
    border-radius: 0;
  }
  .card-group .card:not(:first-child):not(:last-child) .card-img-top,
.card-group .card:not(:first-child):not(:last-child) .card-img-bottom {
    border-radius: 0;
  }
}

.card-columns .card {
  margin-bottom: 0.75rem;
}
@media (min-width: 576px) {
  .card-columns {
    column-count: 3;
    column-gap: 1.25rem;
  }
  .card-columns .card {
    display: inline-block;
    width: 100%;
  }
}

.breadcrumb {
  display: flex;
  flex-wrap: wrap;
  padding: 0.75rem 1rem;
  margin-bottom: 1rem;
  list-style: none;
  background-color: #e9ecef;
  border-radius: 0.25rem;
}

.breadcrumb-item + .breadcrumb-item::before {
  display: inline-block;
  padding-right: 0.5rem;
  padding-left: 0.5rem;
  color: #868e96;
  content: "/";
}
.breadcrumb-item + .breadcrumb-item:hover::before {
  text-decoration: underline;
}
.breadcrumb-item + .breadcrumb-item:hover::before {
  text-decoration: none;
}
.breadcrumb-item.active {
  color: #868e96;
}

.pagination {
  display: flex;
  padding-left: 0;
  list-style: none;
  border-radius: 0.25rem;
}

.page-item:first-child .page-link {
  margin-left: 0;
  border-top-left-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}
.page-item:last-child .page-link {
  border-top-right-radius: 0.25rem;
  border-bottom-right-radius: 0.25rem;
}
.page-item.active .page-link {
  z-index: 2;
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.page-item.disabled .page-link {
  color: #868e96;
  pointer-events: none;
  background-color: #fff;
  border-color: #ddd;
}

.page-link {
  position: relative;
  display: block;
  padding: 0.5rem 0.75rem;
  margin-left: -1px;
  line-height: 1.25;
  color: #03a9f4;
  background-color: #fff;
  border: 1px solid #ddd;
}
.page-link:focus, .page-link:hover {
  color: #0275a8;
  text-decoration: none;
  background-color: #e9ecef;
  border-color: #ddd;
}

.pagination-lg .page-link {
  padding: 0.75rem 1.5rem;
  font-size: 1.25rem;
  line-height: 1.5;
}
.pagination-lg .page-item:first-child .page-link {
  border-top-left-radius: 0.3rem;
  border-bottom-left-radius: 0.3rem;
}
.pagination-lg .page-item:last-child .page-link {
  border-top-right-radius: 0.3rem;
  border-bottom-right-radius: 0.3rem;
}

.pagination-sm .page-link {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
}
.pagination-sm .page-item:first-child .page-link {
  border-top-left-radius: 0.2rem;
  border-bottom-left-radius: 0.2rem;
}
.pagination-sm .page-item:last-child .page-link {
  border-top-right-radius: 0.2rem;
  border-bottom-right-radius: 0.2rem;
}

.badge {
  display: inline-block;
  padding: 0.25em 0.4em;
  font-size: 75%;
  font-weight: bold;
  line-height: 1;
  text-align: center;
  white-space: nowrap;
  vertical-align: baseline;
  border-radius: 0.25rem;
}
.badge:empty {
  display: none;
}

.btn .badge {
  position: relative;
  top: -1px;
}

.badge-pill {
  padding-right: 0.6em;
  padding-left: 0.6em;
  border-radius: 10rem;
}

.badge-primary {
  color: #fff;
  background-color: #03a9f4;
}
.badge-primary[href]:focus, .badge-primary[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #0286c2;
}

.badge-secondary {
  color: #fff;
  background-color: #868e96;
}
.badge-secondary[href]:focus, .badge-secondary[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #6c757d;
}

.badge-success {
  color: #111;
  background-color: #7dc855;
}
.badge-success[href]:focus, .badge-success[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #63b139;
}

.badge-info {
  color: #111;
  background-color: #78BCEE;
}
.badge-info[href]:focus, .badge-info[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #4ba6e8;
}

.badge-warning {
  color: #111;
  background-color: #FCCE54;
}
.badge-warning[href]:focus, .badge-warning[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #fbc022;
}

.badge-danger {
  color: #fff;
  background-color: #ED5564;
}
.badge-danger[href]:focus, .badge-danger[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #e8273a;
}

.badge-light {
  color: #111;
  background-color: #f8f9fa;
}
.badge-light[href]:focus, .badge-light[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #dae0e5;
}

.badge-dark {
  color: #fff;
  background-color: #343a40;
}
.badge-dark[href]:focus, .badge-dark[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #1d2124;
}

.jumbotron {
  padding: 2rem 1rem;
  margin-bottom: 2rem;
  background-color: #e9ecef;
  border-radius: 0.3rem;
}
@media (min-width: 576px) {
  .jumbotron {
    padding: 4rem 2rem;
  }
}

.jumbotron-fluid {
  padding-right: 0;
  padding-left: 0;
  border-radius: 0;
}

.alert {
  padding: 0.75rem 1.25rem;
  margin-bottom: 1rem;
  border: 1px solid transparent;
  border-radius: 0.25rem;
}

.alert-heading {
  color: inherit;
}

.alert-link {
  font-weight: bold;
}

.alert-dismissible .close {
  position: relative;
  top: -0.75rem;
  right: -1.25rem;
  padding: 0.75rem 1.25rem;
  color: inherit;
}

.alert-primary {
  color: #02587f;
  background-color: #cdeefd;
  border-color: #b8e7fc;
}
.alert-primary hr {
  border-top-color: #a0dffb;
}
.alert-primary .alert-link {
  color: #01354d;
}

.alert-secondary {
  color: #464a4e;
  background-color: #e7e8ea;
  border-color: #dddfe2;
}
.alert-secondary hr {
  border-top-color: #cfd2d6;
}
.alert-secondary .alert-link {
  color: #2e3133;
}

.alert-success {
  color: #41682c;
  background-color: #e5f4dd;
  border-color: #dbf0cf;
}
.alert-success hr {
  border-top-color: #cceabc;
}
.alert-success .alert-link {
  color: #2b441d;
}

.alert-info {
  color: #3e627c;
  background-color: #e4f2fc;
  border-color: #d9ecfa;
}
.alert-info hr {
  border-top-color: #c2e1f7;
}
.alert-info .alert-link {
  color: #2d475a;
}

.alert-warning {
  color: #836b2c;
  background-color: #fef5dd;
  border-color: #fef1cf;
}
.alert-warning hr {
  border-top-color: #fdeab6;
}
.alert-warning .alert-link {
  color: #5d4c1f;
}

.alert-danger {
  color: #7b2c34;
  background-color: #fbdde0;
  border-color: #facfd4;
}
.alert-danger hr {
  border-top-color: #f8b8bf;
}
.alert-danger .alert-link {
  color: #551f24;
}

.alert-light {
  color: #818182;
  background-color: #fefefe;
  border-color: #fdfdfe;
}
.alert-light hr {
  border-top-color: #ececf6;
}
.alert-light .alert-link {
  color: #686868;
}

.alert-dark {
  color: #1b1e21;
  background-color: #d6d8d9;
  border-color: #c6c8ca;
}
.alert-dark hr {
  border-top-color: #b9bbbe;
}
.alert-dark .alert-link {
  color: #040505;
}

@keyframes progress-bar-stripes {
  from {
    background-position: 1rem 0;
  }
  to {
    background-position: 0 0;
  }
}
.progress {
  display: flex;
  height: 1rem;
  overflow: hidden;
  font-size: 0.75rem;
  background-color: #e9ecef;
  border-radius: 0.25rem;
}

.progress-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  background-color: #03a9f4;
}

.progress-bar-striped {
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-size: 1rem 1rem;
}

.progress-bar-animated {
  animation: progress-bar-stripes 1s linear infinite;
}

.media {
  display: flex;
  align-items: flex-start;
}

.media-body {
  flex: 1;
}

.list-group {
  display: flex;
  flex-direction: column;
  padding-left: 0;
  margin-bottom: 0;
}

.list-group-item-action {
  width: 100%;
  color: #495057;
  text-align: inherit;
}
.list-group-item-action:focus, .list-group-item-action:hover {
  color: #495057;
  text-decoration: none;
  background-color: #f8f9fa;
}
.list-group-item-action:active {
  color: #212529;
  background-color: #e9ecef;
}

.list-group-item {
  position: relative;
  display: block;
  padding: 0.75rem 1.25rem;
  margin-bottom: -1px;
  background-color: #fff;
  border: 1px solid rgba(0, 0, 0, 0.125);
}
.list-group-item:first-child {
  border-top-left-radius: 0.25rem;
  border-top-right-radius: 0.25rem;
}
.list-group-item:last-child {
  margin-bottom: 0;
  border-bottom-right-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}
.list-group-item:focus, .list-group-item:hover {
  text-decoration: none;
}
.list-group-item.disabled, .list-group-item:disabled {
  color: #868e96;
  background-color: #fff;
}
.list-group-item.active {
  z-index: 2;
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}

.list-group-flush .list-group-item {
  border-right: 0;
  border-left: 0;
  border-radius: 0;
}
.list-group-flush:first-child .list-group-item:first-child {
  border-top: 0;
}
.list-group-flush:last-child .list-group-item:last-child {
  border-bottom: 0;
}

.list-group-item-primary {
  color: #02587f;
  background-color: #b8e7fc;
}

a.list-group-item-primary,
button.list-group-item-primary {
  color: #02587f;
}
a.list-group-item-primary:focus, a.list-group-item-primary:hover,
button.list-group-item-primary:focus,
button.list-group-item-primary:hover {
  color: #02587f;
  background-color: #a0dffb;
}
a.list-group-item-primary.active,
button.list-group-item-primary.active {
  color: #fff;
  background-color: #02587f;
  border-color: #02587f;
}

.list-group-item-secondary {
  color: #464a4e;
  background-color: #dddfe2;
}

a.list-group-item-secondary,
button.list-group-item-secondary {
  color: #464a4e;
}
a.list-group-item-secondary:focus, a.list-group-item-secondary:hover,
button.list-group-item-secondary:focus,
button.list-group-item-secondary:hover {
  color: #464a4e;
  background-color: #cfd2d6;
}
a.list-group-item-secondary.active,
button.list-group-item-secondary.active {
  color: #fff;
  background-color: #464a4e;
  border-color: #464a4e;
}

.list-group-item-success {
  color: #41682c;
  background-color: #dbf0cf;
}

a.list-group-item-success,
button.list-group-item-success {
  color: #41682c;
}
a.list-group-item-success:focus, a.list-group-item-success:hover,
button.list-group-item-success:focus,
button.list-group-item-success:hover {
  color: #41682c;
  background-color: #cceabc;
}
a.list-group-item-success.active,
button.list-group-item-success.active {
  color: #fff;
  background-color: #41682c;
  border-color: #41682c;
}

.list-group-item-info {
  color: #3e627c;
  background-color: #d9ecfa;
}

a.list-group-item-info,
button.list-group-item-info {
  color: #3e627c;
}
a.list-group-item-info:focus, a.list-group-item-info:hover,
button.list-group-item-info:focus,
button.list-group-item-info:hover {
  color: #3e627c;
  background-color: #c2e1f7;
}
a.list-group-item-info.active,
button.list-group-item-info.active {
  color: #fff;
  background-color: #3e627c;
  border-color: #3e627c;
}

.list-group-item-warning {
  color: #836b2c;
  background-color: #fef1cf;
}

a.list-group-item-warning,
button.list-group-item-warning {
  color: #836b2c;
}
a.list-group-item-warning:focus, a.list-group-item-warning:hover,
button.list-group-item-warning:focus,
button.list-group-item-warning:hover {
  color: #836b2c;
  background-color: #fdeab6;
}
a.list-group-item-warning.active,
button.list-group-item-warning.active {
  color: #fff;
  background-color: #836b2c;
  border-color: #836b2c;
}

.list-group-item-danger {
  color: #7b2c34;
  background-color: #facfd4;
}

a.list-group-item-danger,
button.list-group-item-danger {
  color: #7b2c34;
}
a.list-group-item-danger:focus, a.list-group-item-danger:hover,
button.list-group-item-danger:focus,
button.list-group-item-danger:hover {
  color: #7b2c34;
  background-color: #f8b8bf;
}
a.list-group-item-danger.active,
button.list-group-item-danger.active {
  color: #fff;
  background-color: #7b2c34;
  border-color: #7b2c34;
}

.list-group-item-light {
  color: #818182;
  background-color: #fdfdfe;
}

a.list-group-item-light,
button.list-group-item-light {
  color: #818182;
}
a.list-group-item-light:focus, a.list-group-item-light:hover,
button.list-group-item-light:focus,
button.list-group-item-light:hover {
  color: #818182;
  background-color: #ececf6;
}
a.list-group-item-light.active,
button.list-group-item-light.active {
  color: #fff;
  background-color: #818182;
  border-color: #818182;
}

.list-group-item-dark {
  color: #1b1e21;
  background-color: #c6c8ca;
}

a.list-group-item-dark,
button.list-group-item-dark {
  color: #1b1e21;
}
a.list-group-item-dark:focus, a.list-group-item-dark:hover,
button.list-group-item-dark:focus,
button.list-group-item-dark:hover {
  color: #1b1e21;
  background-color: #b9bbbe;
}
a.list-group-item-dark.active,
button.list-group-item-dark.active {
  color: #fff;
  background-color: #1b1e21;
  border-color: #1b1e21;
}

.close {
  float: right;
  font-size: 1.5rem;
  font-weight: bold;
  line-height: 1;
  color: #000;
  text-shadow: 0 1px 0 #fff;
  opacity: 0.5;
}
.close:focus, .close:hover {
  color: #000;
  text-decoration: none;
  opacity: 0.75;
}

button.close {
  padding: 0;
  background: transparent;
  border: 0;
  -webkit-appearance: none;
}

.modal-open {
  overflow: hidden;
}

.modal {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1050;
  display: none;
  overflow: hidden;
  outline: 0;
}
.modal.fade .modal-dialog {
  transition: transform 0.3s ease-out;
  transform: translate(0, -25%);
}
.modal.show .modal-dialog {
  transform: translate(0, 0);
}

.modal-open .modal {
  overflow-x: hidden;
  overflow-y: auto;
}

.modal-dialog {
  position: relative;
  width: auto;
  margin: 10px;
  pointer-events: none;
}

.modal-content {
  position: relative;
  display: flex;
  flex-direction: column;
  pointer-events: auto;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 0.3rem;
  outline: 0;
}

.modal-backdrop {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1040;
  background-color: #000;
}
.modal-backdrop.fade {
  opacity: 0;
}
.modal-backdrop.show {
  opacity: 0.5;
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 15px;
  border-bottom: 1px solid #e9ecef;
}
.modal-header .close {
  margin-left: auto;
}

.modal-title {
  margin-bottom: 0;
  line-height: 1.5;
}

.modal-body {
  position: relative;
  flex: 1 1 auto;
  padding: 15px;
}

.modal-footer {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 15px;
  border-top: 1px solid #e9ecef;
}
.modal-footer > :not(:first-child) {
  margin-left: 0.25rem;
}
.modal-footer > :not(:last-child) {
  margin-right: 0.25rem;
}

.modal-scrollbar-measure {
  position: absolute;
  top: -9999px;
  width: 50px;
  height: 50px;
  overflow: scroll;
}

@media (min-width: 576px) {
  .modal-dialog {
    max-width: 500px;
    margin: 30px auto;
  }

  .modal-sm {
    max-width: 300px;
  }
}
@media (min-width: 992px) {
  .modal-lg {
    max-width: 800px;
  }
}
.tooltip {
  position: absolute;
  z-index: 1070;
  display: block;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-style: normal;
  font-weight: normal;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: 0.875rem;
  word-wrap: break-word;
  opacity: 0;
}
.tooltip.show {
  opacity: 0.9;
}
.tooltip .arrow {
  position: absolute;
  display: block;
  width: 5px;
  height: 5px;
}
.tooltip.bs-tooltip-top, .tooltip.bs-tooltip-auto[x-placement^=top] {
  padding: 5px 0;
}
.tooltip.bs-tooltip-top .arrow, .tooltip.bs-tooltip-auto[x-placement^=top] .arrow {
  bottom: 0;
}
.tooltip.bs-tooltip-top .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=top] .arrow::before {
  margin-left: -3px;
  content: "";
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.bs-tooltip-right, .tooltip.bs-tooltip-auto[x-placement^=right] {
  padding: 0 5px;
}
.tooltip.bs-tooltip-right .arrow, .tooltip.bs-tooltip-auto[x-placement^=right] .arrow {
  left: 0;
}
.tooltip.bs-tooltip-right .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=right] .arrow::before {
  margin-top: -3px;
  content: "";
  border-width: 5px 5px 5px 0;
  border-right-color: #000;
}
.tooltip.bs-tooltip-bottom, .tooltip.bs-tooltip-auto[x-placement^=bottom] {
  padding: 5px 0;
}
.tooltip.bs-tooltip-bottom .arrow, .tooltip.bs-tooltip-auto[x-placement^=bottom] .arrow {
  top: 0;
}
.tooltip.bs-tooltip-bottom .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=bottom] .arrow::before {
  margin-left: -3px;
  content: "";
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.tooltip.bs-tooltip-left, .tooltip.bs-tooltip-auto[x-placement^=left] {
  padding: 0 5px;
}
.tooltip.bs-tooltip-left .arrow, .tooltip.bs-tooltip-auto[x-placement^=left] .arrow {
  right: 0;
}
.tooltip.bs-tooltip-left .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=left] .arrow::before {
  right: 0;
  margin-top: -3px;
  content: "";
  border-width: 5px 0 5px 5px;
  border-left-color: #000;
}
.tooltip .arrow::before {
  position: absolute;
  border-color: transparent;
  border-style: solid;
}

.tooltip-inner {
  max-width: 200px;
  padding: 3px 8px;
  color: #fff;
  text-align: center;
  background-color: #000;
  border-radius: 0.25rem;
}

.popover {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1060;
  display: block;
  max-width: 276px;
  padding: 1px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-style: normal;
  font-weight: normal;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: 0.875rem;
  word-wrap: break-word;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 0.3rem;
}
.popover .arrow {
  position: absolute;
  display: block;
  width: 10px;
  height: 5px;
}
.popover .arrow::before,
.popover .arrow::after {
  position: absolute;
  display: block;
  border-color: transparent;
  border-style: solid;
}
.popover .arrow::before {
  content: "";
  border-width: 11px;
}
.popover .arrow::after {
  content: "";
  border-width: 11px;
}
.popover.bs-popover-top, .popover.bs-popover-auto[x-placement^=top] {
  margin-bottom: 10px;
}
.popover.bs-popover-top .arrow, .popover.bs-popover-auto[x-placement^=top] .arrow {
  bottom: 0;
}
.popover.bs-popover-top .arrow::before, .popover.bs-popover-auto[x-placement^=top] .arrow::before,
.popover.bs-popover-top .arrow::after,
.popover.bs-popover-auto[x-placement^=top] .arrow::after {
  border-bottom-width: 0;
}
.popover.bs-popover-top .arrow::before, .popover.bs-popover-auto[x-placement^=top] .arrow::before {
  bottom: -11px;
  margin-left: -6px;
  border-top-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-top .arrow::after, .popover.bs-popover-auto[x-placement^=top] .arrow::after {
  bottom: -10px;
  margin-left: -6px;
  border-top-color: #fff;
}
.popover.bs-popover-right, .popover.bs-popover-auto[x-placement^=right] {
  margin-left: 10px;
}
.popover.bs-popover-right .arrow, .popover.bs-popover-auto[x-placement^=right] .arrow {
  left: 0;
}
.popover.bs-popover-right .arrow::before, .popover.bs-popover-auto[x-placement^=right] .arrow::before,
.popover.bs-popover-right .arrow::after,
.popover.bs-popover-auto[x-placement^=right] .arrow::after {
  margin-top: -8px;
  border-left-width: 0;
}
.popover.bs-popover-right .arrow::before, .popover.bs-popover-auto[x-placement^=right] .arrow::before {
  left: -11px;
  border-right-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-right .arrow::after, .popover.bs-popover-auto[x-placement^=right] .arrow::after {
  left: -10px;
  border-right-color: #fff;
}
.popover.bs-popover-bottom, .popover.bs-popover-auto[x-placement^=bottom] {
  margin-top: 10px;
}
.popover.bs-popover-bottom .arrow, .popover.bs-popover-auto[x-placement^=bottom] .arrow {
  top: 0;
}
.popover.bs-popover-bottom .arrow::before, .popover.bs-popover-auto[x-placement^=bottom] .arrow::before,
.popover.bs-popover-bottom .arrow::after,
.popover.bs-popover-auto[x-placement^=bottom] .arrow::after {
  margin-left: -7px;
  border-top-width: 0;
}
.popover.bs-popover-bottom .arrow::before, .popover.bs-popover-auto[x-placement^=bottom] .arrow::before {
  top: -11px;
  border-bottom-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-bottom .arrow::after, .popover.bs-popover-auto[x-placement^=bottom] .arrow::after {
  top: -10px;
  border-bottom-color: #fff;
}
.popover.bs-popover-bottom .popover-header::before, .popover.bs-popover-auto[x-placement^=bottom] .popover-header::before {
  position: absolute;
  top: 0;
  left: 50%;
  display: block;
  width: 20px;
  margin-left: -10px;
  content: "";
  border-bottom: 1px solid #f7f7f7;
}
.popover.bs-popover-left, .popover.bs-popover-auto[x-placement^=left] {
  margin-right: 10px;
}
.popover.bs-popover-left .arrow, .popover.bs-popover-auto[x-placement^=left] .arrow {
  right: 0;
}
.popover.bs-popover-left .arrow::before, .popover.bs-popover-auto[x-placement^=left] .arrow::before,
.popover.bs-popover-left .arrow::after,
.popover.bs-popover-auto[x-placement^=left] .arrow::after {
  margin-top: -8px;
  border-right-width: 0;
}
.popover.bs-popover-left .arrow::before, .popover.bs-popover-auto[x-placement^=left] .arrow::before {
  right: -11px;
  border-left-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-left .arrow::after, .popover.bs-popover-auto[x-placement^=left] .arrow::after {
  right: -10px;
  border-left-color: #fff;
}
.popover-header {
  padding: 8px 14px;
  margin-bottom: 0;
  font-size: 1rem;
  color: inherit;
  background-color: #f7f7f7;
  border-bottom: 1px solid #ebebeb;
  border-top-left-radius: calc(0.3rem - 1px);
  border-top-right-radius: calc(0.3rem - 1px);
}
.popover-header:empty {
  display: none;
}

.popover-body {
  padding: 9px 14px;
  color: #212529;
}

.carousel {
  position: relative;
}

.carousel-inner {
  position: relative;
  width: 100%;
  overflow: hidden;
}

.carousel-item {
  position: relative;
  display: none;
  align-items: center;
  width: 100%;
  transition: transform 0.6s ease;
  backface-visibility: hidden;
  perspective: 1000px;
}

.carousel-item.active,
.carousel-item-next,
.carousel-item-prev {
  display: block;
}

.carousel-item-next,
.carousel-item-prev {
  position: absolute;
  top: 0;
}

.carousel-item-next.carousel-item-left,
.carousel-item-prev.carousel-item-right {
  transform: translateX(0);
}
@supports (transform-style: preserve-3d) {
  .carousel-item-next.carousel-item-left,
.carousel-item-prev.carousel-item-right {
    transform: translate3d(0, 0, 0);
  }
}

.carousel-item-next,
.active.carousel-item-right {
  transform: translateX(100%);
}
@supports (transform-style: preserve-3d) {
  .carousel-item-next,
.active.carousel-item-right {
    transform: translate3d(100%, 0, 0);
  }
}

.carousel-item-prev,
.active.carousel-item-left {
  transform: translateX(-100%);
}
@supports (transform-style: preserve-3d) {
  .carousel-item-prev,
.active.carousel-item-left {
    transform: translate3d(-100%, 0, 0);
  }
}

.carousel-control-prev,
.carousel-control-next {
  position: absolute;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 15%;
  color: #fff;
  text-align: center;
  opacity: 0.5;
}
.carousel-control-prev:focus, .carousel-control-prev:hover,
.carousel-control-next:focus,
.carousel-control-next:hover {
  color: #fff;
  text-decoration: none;
  outline: 0;
  opacity: 0.9;
}

.carousel-control-prev {
  left: 0;
}

.carousel-control-next {
  right: 0;
}

.carousel-control-prev-icon,
.carousel-control-next-icon {
  display: inline-block;
  width: 20px;
  height: 20px;
  background: transparent no-repeat center center;
  background-size: 100% 100%;
}

.carousel-control-prev-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M4 0l-4 4 4 4 1.5-1.5-2.5-2.5 2.5-2.5-1.5-1.5z'/%3E%3C/svg%3E");
}

.carousel-control-next-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M1.5 0l-1.5 1.5 2.5 2.5-2.5 2.5 1.5 1.5 4-4-4-4z'/%3E%3C/svg%3E");
}

.carousel-indicators {
  position: absolute;
  right: 0;
  bottom: 10px;
  left: 0;
  z-index: 15;
  display: flex;
  justify-content: center;
  padding-left: 0;
  margin-right: 15%;
  margin-left: 15%;
  list-style: none;
}
.carousel-indicators li {
  position: relative;
  flex: 0 1 auto;
  width: 30px;
  height: 3px;
  margin-right: 3px;
  margin-left: 3px;
  text-indent: -999px;
  background-color: rgba(255, 255, 255, 0.5);
}
.carousel-indicators li::before {
  position: absolute;
  top: -10px;
  left: 0;
  display: inline-block;
  width: 100%;
  height: 10px;
  content: "";
}
.carousel-indicators li::after {
  position: absolute;
  bottom: -10px;
  left: 0;
  display: inline-block;
  width: 100%;
  height: 10px;
  content: "";
}
.carousel-indicators .active {
  background-color: #fff;
}

.carousel-caption {
  position: absolute;
  right: 15%;
  bottom: 20px;
  left: 15%;
  z-index: 10;
  padding-top: 20px;
  padding-bottom: 20px;
  color: #fff;
  text-align: center;
}

.align-baseline {
  vertical-align: baseline !important;
}

.align-top {
  vertical-align: top !important;
}

.align-middle {
  vertical-align: middle !important;
}

.align-bottom {
  vertical-align: bottom !important;
}

.align-text-bottom {
  vertical-align: text-bottom !important;
}

.align-text-top {
  vertical-align: text-top !important;
}

.bg-primary {
  background-color: #03a9f4 !important;
}

a.bg-primary:focus, a.bg-primary:hover {
  background-color: #0286c2 !important;
}

.bg-secondary {
  background-color: #868e96 !important;
}

a.bg-secondary:focus, a.bg-secondary:hover {
  background-color: #6c757d !important;
}

.bg-success {
  background-color: #7dc855 !important;
}

a.bg-success:focus, a.bg-success:hover {
  background-color: #63b139 !important;
}

.bg-info {
  background-color: #78BCEE !important;
}

a.bg-info:focus, a.bg-info:hover {
  background-color: #4ba6e8 !important;
}

.bg-warning {
  background-color: #FCCE54 !important;
}

a.bg-warning:focus, a.bg-warning:hover {
  background-color: #fbc022 !important;
}

.bg-danger {
  background-color: #ED5564 !important;
}

a.bg-danger:focus, a.bg-danger:hover {
  background-color: #e8273a !important;
}

.bg-light {
  background-color: #f8f9fa !important;
}

a.bg-light:focus, a.bg-light:hover {
  background-color: #dae0e5 !important;
}

.bg-dark {
  background-color: #343a40 !important;
}

a.bg-dark:focus, a.bg-dark:hover {
  background-color: #1d2124 !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-transparent {
  background-color: transparent !important;
}

.border {
  border: 1px solid #e9ecef !important;
}

.border-0 {
  border: 0 !important;
}

.border-top-0 {
  border-top: 0 !important;
}

.border-right-0 {
  border-right: 0 !important;
}

.border-bottom-0 {
  border-bottom: 0 !important;
}

.border-left-0 {
  border-left: 0 !important;
}

.border-primary {
  border-color: #03a9f4 !important;
}

.border-secondary {
  border-color: #868e96 !important;
}

.border-success {
  border-color: #7dc855 !important;
}

.border-info {
  border-color: #78BCEE !important;
}

.border-warning {
  border-color: #FCCE54 !important;
}

.border-danger {
  border-color: #ED5564 !important;
}

.border-light {
  border-color: #f8f9fa !important;
}

.border-dark {
  border-color: #343a40 !important;
}

.border-white {
  border-color: #fff !important;
}

.rounded {
  border-radius: 0.25rem !important;
}

.rounded-top {
  border-top-left-radius: 0.25rem !important;
  border-top-right-radius: 0.25rem !important;
}

.rounded-right {
  border-top-right-radius: 0.25rem !important;
  border-bottom-right-radius: 0.25rem !important;
}

.rounded-bottom {
  border-bottom-right-radius: 0.25rem !important;
  border-bottom-left-radius: 0.25rem !important;
}

.rounded-left {
  border-top-left-radius: 0.25rem !important;
  border-bottom-left-radius: 0.25rem !important;
}

.rounded-circle {
  border-radius: 50% !important;
}

.rounded-0 {
  border-radius: 0 !important;
}

.clearfix::after {
  display: block;
  clear: both;
  content: "";
}

.d-none {
  display: none !important;
}

.d-inline {
  display: inline !important;
}

.d-inline-block {
  display: inline-block !important;
}

.d-block {
  display: block !important;
}

.d-table {
  display: table !important;
}

.d-table-cell {
  display: table-cell !important;
}

.d-flex {
  display: flex !important;
}

.d-inline-flex {
  display: inline-flex !important;
}

@media (min-width: 576px) {
  .d-sm-none {
    display: none !important;
  }

  .d-sm-inline {
    display: inline !important;
  }

  .d-sm-inline-block {
    display: inline-block !important;
  }

  .d-sm-block {
    display: block !important;
  }

  .d-sm-table {
    display: table !important;
  }

  .d-sm-table-cell {
    display: table-cell !important;
  }

  .d-sm-flex {
    display: flex !important;
  }

  .d-sm-inline-flex {
    display: inline-flex !important;
  }
}
@media (min-width: 768px) {
  .d-md-none {
    display: none !important;
  }

  .d-md-inline {
    display: inline !important;
  }

  .d-md-inline-block {
    display: inline-block !important;
  }

  .d-md-block {
    display: block !important;
  }

  .d-md-table {
    display: table !important;
  }

  .d-md-table-cell {
    display: table-cell !important;
  }

  .d-md-flex {
    display: flex !important;
  }

  .d-md-inline-flex {
    display: inline-flex !important;
  }
}
@media (min-width: 992px) {
  .d-lg-none {
    display: none !important;
  }

  .d-lg-inline {
    display: inline !important;
  }

  .d-lg-inline-block {
    display: inline-block !important;
  }

  .d-lg-block {
    display: block !important;
  }

  .d-lg-table {
    display: table !important;
  }

  .d-lg-table-cell {
    display: table-cell !important;
  }

  .d-lg-flex {
    display: flex !important;
  }

  .d-lg-inline-flex {
    display: inline-flex !important;
  }
}
@media (min-width: 1200px) {
  .d-xl-none {
    display: none !important;
  }

  .d-xl-inline {
    display: inline !important;
  }

  .d-xl-inline-block {
    display: inline-block !important;
  }

  .d-xl-block {
    display: block !important;
  }

  .d-xl-table {
    display: table !important;
  }

  .d-xl-table-cell {
    display: table-cell !important;
  }

  .d-xl-flex {
    display: flex !important;
  }

  .d-xl-inline-flex {
    display: inline-flex !important;
  }
}
.d-print-block {
  display: none !important;
}
@media print {
  .d-print-block {
    display: block !important;
  }
}

.d-print-inline {
  display: none !important;
}
@media print {
  .d-print-inline {
    display: inline !important;
  }
}

.d-print-inline-block {
  display: none !important;
}
@media print {
  .d-print-inline-block {
    display: inline-block !important;
  }
}

@media print {
  .d-print-none {
    display: none !important;
  }
}

.embed-responsive {
  position: relative;
  display: block;
  width: 100%;
  padding: 0;
  overflow: hidden;
}
.embed-responsive::before {
  display: block;
  content: "";
}
.embed-responsive .embed-responsive-item,
.embed-responsive iframe,
.embed-responsive embed,
.embed-responsive object,
.embed-responsive video {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 0;
}

.embed-responsive-21by9::before {
  padding-top: 42.8571428571%;
}

.embed-responsive-16by9::before {
  padding-top: 56.25%;
}

.embed-responsive-4by3::before {
  padding-top: 75%;
}

.embed-responsive-1by1::before {
  padding-top: 100%;
}

.flex-row {
  flex-direction: row !important;
}

.flex-column {
  flex-direction: column !important;
}

.flex-row-reverse {
  flex-direction: row-reverse !important;
}

.flex-column-reverse {
  flex-direction: column-reverse !important;
}

.flex-wrap {
  flex-wrap: wrap !important;
}

.flex-nowrap {
  flex-wrap: nowrap !important;
}

.flex-wrap-reverse {
  flex-wrap: wrap-reverse !important;
}

.justify-content-start {
  justify-content: flex-start !important;
}

.justify-content-end {
  justify-content: flex-end !important;
}

.justify-content-center {
  justify-content: center !important;
}

.justify-content-between {
  justify-content: space-between !important;
}

.justify-content-around {
  justify-content: space-around !important;
}

.align-items-start {
  align-items: flex-start !important;
}

.align-items-end {
  align-items: flex-end !important;
}

.align-items-center {
  align-items: center !important;
}

.align-items-baseline {
  align-items: baseline !important;
}

.align-items-stretch {
  align-items: stretch !important;
}

.align-content-start {
  align-content: flex-start !important;
}

.align-content-end {
  align-content: flex-end !important;
}

.align-content-center {
  align-content: center !important;
}

.align-content-between {
  align-content: space-between !important;
}

.align-content-around {
  align-content: space-around !important;
}

.align-content-stretch {
  align-content: stretch !important;
}

.align-self-auto {
  align-self: auto !important;
}

.align-self-start {
  align-self: flex-start !important;
}

.align-self-end {
  align-self: flex-end !important;
}

.align-self-center {
  align-self: center !important;
}

.align-self-baseline {
  align-self: baseline !important;
}

.align-self-stretch {
  align-self: stretch !important;
}

@media (min-width: 576px) {
  .flex-sm-row {
    flex-direction: row !important;
  }

  .flex-sm-column {
    flex-direction: column !important;
  }

  .flex-sm-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-sm-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-sm-wrap {
    flex-wrap: wrap !important;
  }

  .flex-sm-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-sm-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-sm-start {
    justify-content: flex-start !important;
  }

  .justify-content-sm-end {
    justify-content: flex-end !important;
  }

  .justify-content-sm-center {
    justify-content: center !important;
  }

  .justify-content-sm-between {
    justify-content: space-between !important;
  }

  .justify-content-sm-around {
    justify-content: space-around !important;
  }

  .align-items-sm-start {
    align-items: flex-start !important;
  }

  .align-items-sm-end {
    align-items: flex-end !important;
  }

  .align-items-sm-center {
    align-items: center !important;
  }

  .align-items-sm-baseline {
    align-items: baseline !important;
  }

  .align-items-sm-stretch {
    align-items: stretch !important;
  }

  .align-content-sm-start {
    align-content: flex-start !important;
  }

  .align-content-sm-end {
    align-content: flex-end !important;
  }

  .align-content-sm-center {
    align-content: center !important;
  }

  .align-content-sm-between {
    align-content: space-between !important;
  }

  .align-content-sm-around {
    align-content: space-around !important;
  }

  .align-content-sm-stretch {
    align-content: stretch !important;
  }

  .align-self-sm-auto {
    align-self: auto !important;
  }

  .align-self-sm-start {
    align-self: flex-start !important;
  }

  .align-self-sm-end {
    align-self: flex-end !important;
  }

  .align-self-sm-center {
    align-self: center !important;
  }

  .align-self-sm-baseline {
    align-self: baseline !important;
  }

  .align-self-sm-stretch {
    align-self: stretch !important;
  }
}
@media (min-width: 768px) {
  .flex-md-row {
    flex-direction: row !important;
  }

  .flex-md-column {
    flex-direction: column !important;
  }

  .flex-md-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-md-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-md-wrap {
    flex-wrap: wrap !important;
  }

  .flex-md-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-md-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-md-start {
    justify-content: flex-start !important;
  }

  .justify-content-md-end {
    justify-content: flex-end !important;
  }

  .justify-content-md-center {
    justify-content: center !important;
  }

  .justify-content-md-between {
    justify-content: space-between !important;
  }

  .justify-content-md-around {
    justify-content: space-around !important;
  }

  .align-items-md-start {
    align-items: flex-start !important;
  }

  .align-items-md-end {
    align-items: flex-end !important;
  }

  .align-items-md-center {
    align-items: center !important;
  }

  .align-items-md-baseline {
    align-items: baseline !important;
  }

  .align-items-md-stretch {
    align-items: stretch !important;
  }

  .align-content-md-start {
    align-content: flex-start !important;
  }

  .align-content-md-end {
    align-content: flex-end !important;
  }

  .align-content-md-center {
    align-content: center !important;
  }

  .align-content-md-between {
    align-content: space-between !important;
  }

  .align-content-md-around {
    align-content: space-around !important;
  }

  .align-content-md-stretch {
    align-content: stretch !important;
  }

  .align-self-md-auto {
    align-self: auto !important;
  }

  .align-self-md-start {
    align-self: flex-start !important;
  }

  .align-self-md-end {
    align-self: flex-end !important;
  }

  .align-self-md-center {
    align-self: center !important;
  }

  .align-self-md-baseline {
    align-self: baseline !important;
  }

  .align-self-md-stretch {
    align-self: stretch !important;
  }
}
@media (min-width: 992px) {
  .flex-lg-row {
    flex-direction: row !important;
  }

  .flex-lg-column {
    flex-direction: column !important;
  }

  .flex-lg-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-lg-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-lg-wrap {
    flex-wrap: wrap !important;
  }

  .flex-lg-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-lg-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-lg-start {
    justify-content: flex-start !important;
  }

  .justify-content-lg-end {
    justify-content: flex-end !important;
  }

  .justify-content-lg-center {
    justify-content: center !important;
  }

  .justify-content-lg-between {
    justify-content: space-between !important;
  }

  .justify-content-lg-around {
    justify-content: space-around !important;
  }

  .align-items-lg-start {
    align-items: flex-start !important;
  }

  .align-items-lg-end {
    align-items: flex-end !important;
  }

  .align-items-lg-center {
    align-items: center !important;
  }

  .align-items-lg-baseline {
    align-items: baseline !important;
  }

  .align-items-lg-stretch {
    align-items: stretch !important;
  }

  .align-content-lg-start {
    align-content: flex-start !important;
  }

  .align-content-lg-end {
    align-content: flex-end !important;
  }

  .align-content-lg-center {
    align-content: center !important;
  }

  .align-content-lg-between {
    align-content: space-between !important;
  }

  .align-content-lg-around {
    align-content: space-around !important;
  }

  .align-content-lg-stretch {
    align-content: stretch !important;
  }

  .align-self-lg-auto {
    align-self: auto !important;
  }

  .align-self-lg-start {
    align-self: flex-start !important;
  }

  .align-self-lg-end {
    align-self: flex-end !important;
  }

  .align-self-lg-center {
    align-self: center !important;
  }

  .align-self-lg-baseline {
    align-self: baseline !important;
  }

  .align-self-lg-stretch {
    align-self: stretch !important;
  }
}
@media (min-width: 1200px) {
  .flex-xl-row {
    flex-direction: row !important;
  }

  .flex-xl-column {
    flex-direction: column !important;
  }

  .flex-xl-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-xl-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-xl-wrap {
    flex-wrap: wrap !important;
  }

  .flex-xl-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-xl-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-xl-start {
    justify-content: flex-start !important;
  }

  .justify-content-xl-end {
    justify-content: flex-end !important;
  }

  .justify-content-xl-center {
    justify-content: center !important;
  }

  .justify-content-xl-between {
    justify-content: space-between !important;
  }

  .justify-content-xl-around {
    justify-content: space-around !important;
  }

  .align-items-xl-start {
    align-items: flex-start !important;
  }

  .align-items-xl-end {
    align-items: flex-end !important;
  }

  .align-items-xl-center {
    align-items: center !important;
  }

  .align-items-xl-baseline {
    align-items: baseline !important;
  }

  .align-items-xl-stretch {
    align-items: stretch !important;
  }

  .align-content-xl-start {
    align-content: flex-start !important;
  }

  .align-content-xl-end {
    align-content: flex-end !important;
  }

  .align-content-xl-center {
    align-content: center !important;
  }

  .align-content-xl-between {
    align-content: space-between !important;
  }

  .align-content-xl-around {
    align-content: space-around !important;
  }

  .align-content-xl-stretch {
    align-content: stretch !important;
  }

  .align-self-xl-auto {
    align-self: auto !important;
  }

  .align-self-xl-start {
    align-self: flex-start !important;
  }

  .align-self-xl-end {
    align-self: flex-end !important;
  }

  .align-self-xl-center {
    align-self: center !important;
  }

  .align-self-xl-baseline {
    align-self: baseline !important;
  }

  .align-self-xl-stretch {
    align-self: stretch !important;
  }
}
.float-left {
  float: left !important;
}

.float-right {
  float: right !important;
}

.float-none {
  float: none !important;
}

@media (min-width: 576px) {
  .float-sm-left {
    float: left !important;
  }

  .float-sm-right {
    float: right !important;
  }

  .float-sm-none {
    float: none !important;
  }
}
@media (min-width: 768px) {
  .float-md-left {
    float: left !important;
  }

  .float-md-right {
    float: right !important;
  }

  .float-md-none {
    float: none !important;
  }
}
@media (min-width: 992px) {
  .float-lg-left {
    float: left !important;
  }

  .float-lg-right {
    float: right !important;
  }

  .float-lg-none {
    float: none !important;
  }
}
@media (min-width: 1200px) {
  .float-xl-left {
    float: left !important;
  }

  .float-xl-right {
    float: right !important;
  }

  .float-xl-none {
    float: none !important;
  }
}
.position-static {
  position: static !important;
}

.position-relative {
  position: relative !important;
}

.position-absolute {
  position: absolute !important;
}

.position-fixed {
  position: fixed !important;
}

.position-sticky {
  position: sticky !important;
}

.fixed-top {
  position: fixed;
  top: 0;
  right: 0;
  left: 0;
  z-index: 1030;
}

.fixed-bottom {
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1030;
}

@supports (position: sticky) {
  .sticky-top {
    position: sticky;
    top: 0;
    z-index: 1020;
  }
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  clip-path: inset(50%);
  border: 0;
}

.sr-only-focusable:active, .sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  overflow: visible;
  clip: auto;
  white-space: normal;
  clip-path: none;
}

.w-25 {
  width: 25% !important;
}

.w-50 {
  width: 50% !important;
}

.w-75 {
  width: 75% !important;
}

.w-100 {
  width: 100% !important;
}

.h-25 {
  height: 25% !important;
}

.h-50 {
  height: 50% !important;
}

.h-75 {
  height: 75% !important;
}

.h-100 {
  height: 100% !important;
}

.mw-100 {
  max-width: 100% !important;
}

.mh-100 {
  max-height: 100% !important;
}

.m-0 {
  margin: 0 !important;
}

.mt-0,
.my-0 {
  margin-top: 0 !important;
}

.mr-0,
.mx-0 {
  margin-right: 0 !important;
}

.mb-0,
.my-0 {
  margin-bottom: 0 !important;
}

.ml-0,
.mx-0 {
  margin-left: 0 !important;
}

.m-1 {
  margin: 0.25rem !important;
}

.mt-1,
.my-1 {
  margin-top: 0.25rem !important;
}

.mr-1,
.mx-1 {
  margin-right: 0.25rem !important;
}

.mb-1,
.my-1 {
  margin-bottom: 0.25rem !important;
}

.ml-1,
.mx-1 {
  margin-left: 0.25rem !important;
}

.m-2 {
  margin: 0.5rem !important;
}

.mt-2,
.my-2 {
  margin-top: 0.5rem !important;
}

.mr-2,
.mx-2 {
  margin-right: 0.5rem !important;
}

.mb-2,
.my-2 {
  margin-bottom: 0.5rem !important;
}

.ml-2,
.mx-2 {
  margin-left: 0.5rem !important;
}

.m-3 {
  margin: 1rem !important;
}

.mt-3,
.my-3 {
  margin-top: 1rem !important;
}

.mr-3,
.mx-3 {
  margin-right: 1rem !important;
}

.mb-3,
.my-3 {
  margin-bottom: 1rem !important;
}

.ml-3,
.mx-3 {
  margin-left: 1rem !important;
}

.m-4 {
  margin: 1.5rem !important;
}

.mt-4,
.my-4 {
  margin-top: 1.5rem !important;
}

.mr-4,
.mx-4 {
  margin-right: 1.5rem !important;
}

.mb-4,
.my-4 {
  margin-bottom: 1.5rem !important;
}

.ml-4,
.mx-4 {
  margin-left: 1.5rem !important;
}

.m-5 {
  margin: 3rem !important;
}

.mt-5,
.my-5 {
  margin-top: 3rem !important;
}

.mr-5,
.mx-5 {
  margin-right: 3rem !important;
}

.mb-5,
.my-5 {
  margin-bottom: 3rem !important;
}

.ml-5,
.mx-5 {
  margin-left: 3rem !important;
}

.p-0 {
  padding: 0 !important;
}

.pt-0,
.py-0 {
  padding-top: 0 !important;
}

.pr-0,
.px-0 {
  padding-right: 0 !important;
}

.pb-0,
.py-0 {
  padding-bottom: 0 !important;
}

.pl-0,
.px-0 {
  padding-left: 0 !important;
}

.p-1 {
  padding: 0.25rem !important;
}

.pt-1,
.py-1 {
  padding-top: 0.25rem !important;
}

.pr-1,
.px-1 {
  padding-right: 0.25rem !important;
}

.pb-1,
.py-1 {
  padding-bottom: 0.25rem !important;
}

.pl-1,
.px-1 {
  padding-left: 0.25rem !important;
}

.p-2 {
  padding: 0.5rem !important;
}

.pt-2,
.py-2 {
  padding-top: 0.5rem !important;
}

.pr-2,
.px-2 {
  padding-right: 0.5rem !important;
}

.pb-2,
.py-2 {
  padding-bottom: 0.5rem !important;
}

.pl-2,
.px-2 {
  padding-left: 0.5rem !important;
}

.p-3 {
  padding: 1rem !important;
}

.pt-3,
.py-3 {
  padding-top: 1rem !important;
}

.pr-3,
.px-3 {
  padding-right: 1rem !important;
}

.pb-3,
.py-3 {
  padding-bottom: 1rem !important;
}

.pl-3,
.px-3 {
  padding-left: 1rem !important;
}

.p-4 {
  padding: 1.5rem !important;
}

.pt-4,
.py-4 {
  padding-top: 1.5rem !important;
}

.pr-4,
.px-4 {
  padding-right: 1.5rem !important;
}

.pb-4,
.py-4 {
  padding-bottom: 1.5rem !important;
}

.pl-4,
.px-4 {
  padding-left: 1.5rem !important;
}

.p-5 {
  padding: 3rem !important;
}

.pt-5,
.py-5 {
  padding-top: 3rem !important;
}

.pr-5,
.px-5 {
  padding-right: 3rem !important;
}

.pb-5,
.py-5 {
  padding-bottom: 3rem !important;
}

.pl-5,
.px-5 {
  padding-left: 3rem !important;
}

.m-auto {
  margin: auto !important;
}

.mt-auto,
.my-auto {
  margin-top: auto !important;
}

.mr-auto,
.mx-auto {
  margin-right: auto !important;
}

.mb-auto,
.my-auto {
  margin-bottom: auto !important;
}

.ml-auto,
.mx-auto {
  margin-left: auto !important;
}

@media (min-width: 576px) {
  .m-sm-0 {
    margin: 0 !important;
  }

  .mt-sm-0,
.my-sm-0 {
    margin-top: 0 !important;
  }

  .mr-sm-0,
.mx-sm-0 {
    margin-right: 0 !important;
  }

  .mb-sm-0,
.my-sm-0 {
    margin-bottom: 0 !important;
  }

  .ml-sm-0,
.mx-sm-0 {
    margin-left: 0 !important;
  }

  .m-sm-1 {
    margin: 0.25rem !important;
  }

  .mt-sm-1,
.my-sm-1 {
    margin-top: 0.25rem !important;
  }

  .mr-sm-1,
.mx-sm-1 {
    margin-right: 0.25rem !important;
  }

  .mb-sm-1,
.my-sm-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-sm-1,
.mx-sm-1 {
    margin-left: 0.25rem !important;
  }

  .m-sm-2 {
    margin: 0.5rem !important;
  }

  .mt-sm-2,
.my-sm-2 {
    margin-top: 0.5rem !important;
  }

  .mr-sm-2,
.mx-sm-2 {
    margin-right: 0.5rem !important;
  }

  .mb-sm-2,
.my-sm-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-sm-2,
.mx-sm-2 {
    margin-left: 0.5rem !important;
  }

  .m-sm-3 {
    margin: 1rem !important;
  }

  .mt-sm-3,
.my-sm-3 {
    margin-top: 1rem !important;
  }

  .mr-sm-3,
.mx-sm-3 {
    margin-right: 1rem !important;
  }

  .mb-sm-3,
.my-sm-3 {
    margin-bottom: 1rem !important;
  }

  .ml-sm-3,
.mx-sm-3 {
    margin-left: 1rem !important;
  }

  .m-sm-4 {
    margin: 1.5rem !important;
  }

  .mt-sm-4,
.my-sm-4 {
    margin-top: 1.5rem !important;
  }

  .mr-sm-4,
.mx-sm-4 {
    margin-right: 1.5rem !important;
  }

  .mb-sm-4,
.my-sm-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-sm-4,
.mx-sm-4 {
    margin-left: 1.5rem !important;
  }

  .m-sm-5 {
    margin: 3rem !important;
  }

  .mt-sm-5,
.my-sm-5 {
    margin-top: 3rem !important;
  }

  .mr-sm-5,
.mx-sm-5 {
    margin-right: 3rem !important;
  }

  .mb-sm-5,
.my-sm-5 {
    margin-bottom: 3rem !important;
  }

  .ml-sm-5,
.mx-sm-5 {
    margin-left: 3rem !important;
  }

  .p-sm-0 {
    padding: 0 !important;
  }

  .pt-sm-0,
.py-sm-0 {
    padding-top: 0 !important;
  }

  .pr-sm-0,
.px-sm-0 {
    padding-right: 0 !important;
  }

  .pb-sm-0,
.py-sm-0 {
    padding-bottom: 0 !important;
  }

  .pl-sm-0,
.px-sm-0 {
    padding-left: 0 !important;
  }

  .p-sm-1 {
    padding: 0.25rem !important;
  }

  .pt-sm-1,
.py-sm-1 {
    padding-top: 0.25rem !important;
  }

  .pr-sm-1,
.px-sm-1 {
    padding-right: 0.25rem !important;
  }

  .pb-sm-1,
.py-sm-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-sm-1,
.px-sm-1 {
    padding-left: 0.25rem !important;
  }

  .p-sm-2 {
    padding: 0.5rem !important;
  }

  .pt-sm-2,
.py-sm-2 {
    padding-top: 0.5rem !important;
  }

  .pr-sm-2,
.px-sm-2 {
    padding-right: 0.5rem !important;
  }

  .pb-sm-2,
.py-sm-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-sm-2,
.px-sm-2 {
    padding-left: 0.5rem !important;
  }

  .p-sm-3 {
    padding: 1rem !important;
  }

  .pt-sm-3,
.py-sm-3 {
    padding-top: 1rem !important;
  }

  .pr-sm-3,
.px-sm-3 {
    padding-right: 1rem !important;
  }

  .pb-sm-3,
.py-sm-3 {
    padding-bottom: 1rem !important;
  }

  .pl-sm-3,
.px-sm-3 {
    padding-left: 1rem !important;
  }

  .p-sm-4 {
    padding: 1.5rem !important;
  }

  .pt-sm-4,
.py-sm-4 {
    padding-top: 1.5rem !important;
  }

  .pr-sm-4,
.px-sm-4 {
    padding-right: 1.5rem !important;
  }

  .pb-sm-4,
.py-sm-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-sm-4,
.px-sm-4 {
    padding-left: 1.5rem !important;
  }

  .p-sm-5 {
    padding: 3rem !important;
  }

  .pt-sm-5,
.py-sm-5 {
    padding-top: 3rem !important;
  }

  .pr-sm-5,
.px-sm-5 {
    padding-right: 3rem !important;
  }

  .pb-sm-5,
.py-sm-5 {
    padding-bottom: 3rem !important;
  }

  .pl-sm-5,
.px-sm-5 {
    padding-left: 3rem !important;
  }

  .m-sm-auto {
    margin: auto !important;
  }

  .mt-sm-auto,
.my-sm-auto {
    margin-top: auto !important;
  }

  .mr-sm-auto,
.mx-sm-auto {
    margin-right: auto !important;
  }

  .mb-sm-auto,
.my-sm-auto {
    margin-bottom: auto !important;
  }

  .ml-sm-auto,
.mx-sm-auto {
    margin-left: auto !important;
  }
}
@media (min-width: 768px) {
  .m-md-0 {
    margin: 0 !important;
  }

  .mt-md-0,
.my-md-0 {
    margin-top: 0 !important;
  }

  .mr-md-0,
.mx-md-0 {
    margin-right: 0 !important;
  }

  .mb-md-0,
.my-md-0 {
    margin-bottom: 0 !important;
  }

  .ml-md-0,
.mx-md-0 {
    margin-left: 0 !important;
  }

  .m-md-1 {
    margin: 0.25rem !important;
  }

  .mt-md-1,
.my-md-1 {
    margin-top: 0.25rem !important;
  }

  .mr-md-1,
.mx-md-1 {
    margin-right: 0.25rem !important;
  }

  .mb-md-1,
.my-md-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-md-1,
.mx-md-1 {
    margin-left: 0.25rem !important;
  }

  .m-md-2 {
    margin: 0.5rem !important;
  }

  .mt-md-2,
.my-md-2 {
    margin-top: 0.5rem !important;
  }

  .mr-md-2,
.mx-md-2 {
    margin-right: 0.5rem !important;
  }

  .mb-md-2,
.my-md-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-md-2,
.mx-md-2 {
    margin-left: 0.5rem !important;
  }

  .m-md-3 {
    margin: 1rem !important;
  }

  .mt-md-3,
.my-md-3 {
    margin-top: 1rem !important;
  }

  .mr-md-3,
.mx-md-3 {
    margin-right: 1rem !important;
  }

  .mb-md-3,
.my-md-3 {
    margin-bottom: 1rem !important;
  }

  .ml-md-3,
.mx-md-3 {
    margin-left: 1rem !important;
  }

  .m-md-4 {
    margin: 1.5rem !important;
  }

  .mt-md-4,
.my-md-4 {
    margin-top: 1.5rem !important;
  }

  .mr-md-4,
.mx-md-4 {
    margin-right: 1.5rem !important;
  }

  .mb-md-4,
.my-md-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-md-4,
.mx-md-4 {
    margin-left: 1.5rem !important;
  }

  .m-md-5 {
    margin: 3rem !important;
  }

  .mt-md-5,
.my-md-5 {
    margin-top: 3rem !important;
  }

  .mr-md-5,
.mx-md-5 {
    margin-right: 3rem !important;
  }

  .mb-md-5,
.my-md-5 {
    margin-bottom: 3rem !important;
  }

  .ml-md-5,
.mx-md-5 {
    margin-left: 3rem !important;
  }

  .p-md-0 {
    padding: 0 !important;
  }

  .pt-md-0,
.py-md-0 {
    padding-top: 0 !important;
  }

  .pr-md-0,
.px-md-0 {
    padding-right: 0 !important;
  }

  .pb-md-0,
.py-md-0 {
    padding-bottom: 0 !important;
  }

  .pl-md-0,
.px-md-0 {
    padding-left: 0 !important;
  }

  .p-md-1 {
    padding: 0.25rem !important;
  }

  .pt-md-1,
.py-md-1 {
    padding-top: 0.25rem !important;
  }

  .pr-md-1,
.px-md-1 {
    padding-right: 0.25rem !important;
  }

  .pb-md-1,
.py-md-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-md-1,
.px-md-1 {
    padding-left: 0.25rem !important;
  }

  .p-md-2 {
    padding: 0.5rem !important;
  }

  .pt-md-2,
.py-md-2 {
    padding-top: 0.5rem !important;
  }

  .pr-md-2,
.px-md-2 {
    padding-right: 0.5rem !important;
  }

  .pb-md-2,
.py-md-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-md-2,
.px-md-2 {
    padding-left: 0.5rem !important;
  }

  .p-md-3 {
    padding: 1rem !important;
  }

  .pt-md-3,
.py-md-3 {
    padding-top: 1rem !important;
  }

  .pr-md-3,
.px-md-3 {
    padding-right: 1rem !important;
  }

  .pb-md-3,
.py-md-3 {
    padding-bottom: 1rem !important;
  }

  .pl-md-3,
.px-md-3 {
    padding-left: 1rem !important;
  }

  .p-md-4 {
    padding: 1.5rem !important;
  }

  .pt-md-4,
.py-md-4 {
    padding-top: 1.5rem !important;
  }

  .pr-md-4,
.px-md-4 {
    padding-right: 1.5rem !important;
  }

  .pb-md-4,
.py-md-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-md-4,
.px-md-4 {
    padding-left: 1.5rem !important;
  }

  .p-md-5 {
    padding: 3rem !important;
  }

  .pt-md-5,
.py-md-5 {
    padding-top: 3rem !important;
  }

  .pr-md-5,
.px-md-5 {
    padding-right: 3rem !important;
  }

  .pb-md-5,
.py-md-5 {
    padding-bottom: 3rem !important;
  }

  .pl-md-5,
.px-md-5 {
    padding-left: 3rem !important;
  }

  .m-md-auto {
    margin: auto !important;
  }

  .mt-md-auto,
.my-md-auto {
    margin-top: auto !important;
  }

  .mr-md-auto,
.mx-md-auto {
    margin-right: auto !important;
  }

  .mb-md-auto,
.my-md-auto {
    margin-bottom: auto !important;
  }

  .ml-md-auto,
.mx-md-auto {
    margin-left: auto !important;
  }
}
@media (min-width: 992px) {
  .m-lg-0 {
    margin: 0 !important;
  }

  .mt-lg-0,
.my-lg-0 {
    margin-top: 0 !important;
  }

  .mr-lg-0,
.mx-lg-0 {
    margin-right: 0 !important;
  }

  .mb-lg-0,
.my-lg-0 {
    margin-bottom: 0 !important;
  }

  .ml-lg-0,
.mx-lg-0 {
    margin-left: 0 !important;
  }

  .m-lg-1 {
    margin: 0.25rem !important;
  }

  .mt-lg-1,
.my-lg-1 {
    margin-top: 0.25rem !important;
  }

  .mr-lg-1,
.mx-lg-1 {
    margin-right: 0.25rem !important;
  }

  .mb-lg-1,
.my-lg-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-lg-1,
.mx-lg-1 {
    margin-left: 0.25rem !important;
  }

  .m-lg-2 {
    margin: 0.5rem !important;
  }

  .mt-lg-2,
.my-lg-2 {
    margin-top: 0.5rem !important;
  }

  .mr-lg-2,
.mx-lg-2 {
    margin-right: 0.5rem !important;
  }

  .mb-lg-2,
.my-lg-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-lg-2,
.mx-lg-2 {
    margin-left: 0.5rem !important;
  }

  .m-lg-3 {
    margin: 1rem !important;
  }

  .mt-lg-3,
.my-lg-3 {
    margin-top: 1rem !important;
  }

  .mr-lg-3,
.mx-lg-3 {
    margin-right: 1rem !important;
  }

  .mb-lg-3,
.my-lg-3 {
    margin-bottom: 1rem !important;
  }

  .ml-lg-3,
.mx-lg-3 {
    margin-left: 1rem !important;
  }

  .m-lg-4 {
    margin: 1.5rem !important;
  }

  .mt-lg-4,
.my-lg-4 {
    margin-top: 1.5rem !important;
  }

  .mr-lg-4,
.mx-lg-4 {
    margin-right: 1.5rem !important;
  }

  .mb-lg-4,
.my-lg-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-lg-4,
.mx-lg-4 {
    margin-left: 1.5rem !important;
  }

  .m-lg-5 {
    margin: 3rem !important;
  }

  .mt-lg-5,
.my-lg-5 {
    margin-top: 3rem !important;
  }

  .mr-lg-5,
.mx-lg-5 {
    margin-right: 3rem !important;
  }

  .mb-lg-5,
.my-lg-5 {
    margin-bottom: 3rem !important;
  }

  .ml-lg-5,
.mx-lg-5 {
    margin-left: 3rem !important;
  }

  .p-lg-0 {
    padding: 0 !important;
  }

  .pt-lg-0,
.py-lg-0 {
    padding-top: 0 !important;
  }

  .pr-lg-0,
.px-lg-0 {
    padding-right: 0 !important;
  }

  .pb-lg-0,
.py-lg-0 {
    padding-bottom: 0 !important;
  }

  .pl-lg-0,
.px-lg-0 {
    padding-left: 0 !important;
  }

  .p-lg-1 {
    padding: 0.25rem !important;
  }

  .pt-lg-1,
.py-lg-1 {
    padding-top: 0.25rem !important;
  }

  .pr-lg-1,
.px-lg-1 {
    padding-right: 0.25rem !important;
  }

  .pb-lg-1,
.py-lg-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-lg-1,
.px-lg-1 {
    padding-left: 0.25rem !important;
  }

  .p-lg-2 {
    padding: 0.5rem !important;
  }

  .pt-lg-2,
.py-lg-2 {
    padding-top: 0.5rem !important;
  }

  .pr-lg-2,
.px-lg-2 {
    padding-right: 0.5rem !important;
  }

  .pb-lg-2,
.py-lg-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-lg-2,
.px-lg-2 {
    padding-left: 0.5rem !important;
  }

  .p-lg-3 {
    padding: 1rem !important;
  }

  .pt-lg-3,
.py-lg-3 {
    padding-top: 1rem !important;
  }

  .pr-lg-3,
.px-lg-3 {
    padding-right: 1rem !important;
  }

  .pb-lg-3,
.py-lg-3 {
    padding-bottom: 1rem !important;
  }

  .pl-lg-3,
.px-lg-3 {
    padding-left: 1rem !important;
  }

  .p-lg-4 {
    padding: 1.5rem !important;
  }

  .pt-lg-4,
.py-lg-4 {
    padding-top: 1.5rem !important;
  }

  .pr-lg-4,
.px-lg-4 {
    padding-right: 1.5rem !important;
  }

  .pb-lg-4,
.py-lg-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-lg-4,
.px-lg-4 {
    padding-left: 1.5rem !important;
  }

  .p-lg-5 {
    padding: 3rem !important;
  }

  .pt-lg-5,
.py-lg-5 {
    padding-top: 3rem !important;
  }

  .pr-lg-5,
.px-lg-5 {
    padding-right: 3rem !important;
  }

  .pb-lg-5,
.py-lg-5 {
    padding-bottom: 3rem !important;
  }

  .pl-lg-5,
.px-lg-5 {
    padding-left: 3rem !important;
  }

  .m-lg-auto {
    margin: auto !important;
  }

  .mt-lg-auto,
.my-lg-auto {
    margin-top: auto !important;
  }

  .mr-lg-auto,
.mx-lg-auto {
    margin-right: auto !important;
  }

  .mb-lg-auto,
.my-lg-auto {
    margin-bottom: auto !important;
  }

  .ml-lg-auto,
.mx-lg-auto {
    margin-left: auto !important;
  }
}
@media (min-width: 1200px) {
  .m-xl-0 {
    margin: 0 !important;
  }

  .mt-xl-0,
.my-xl-0 {
    margin-top: 0 !important;
  }

  .mr-xl-0,
.mx-xl-0 {
    margin-right: 0 !important;
  }

  .mb-xl-0,
.my-xl-0 {
    margin-bottom: 0 !important;
  }

  .ml-xl-0,
.mx-xl-0 {
    margin-left: 0 !important;
  }

  .m-xl-1 {
    margin: 0.25rem !important;
  }

  .mt-xl-1,
.my-xl-1 {
    margin-top: 0.25rem !important;
  }

  .mr-xl-1,
.mx-xl-1 {
    margin-right: 0.25rem !important;
  }

  .mb-xl-1,
.my-xl-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-xl-1,
.mx-xl-1 {
    margin-left: 0.25rem !important;
  }

  .m-xl-2 {
    margin: 0.5rem !important;
  }

  .mt-xl-2,
.my-xl-2 {
    margin-top: 0.5rem !important;
  }

  .mr-xl-2,
.mx-xl-2 {
    margin-right: 0.5rem !important;
  }

  .mb-xl-2,
.my-xl-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-xl-2,
.mx-xl-2 {
    margin-left: 0.5rem !important;
  }

  .m-xl-3 {
    margin: 1rem !important;
  }

  .mt-xl-3,
.my-xl-3 {
    margin-top: 1rem !important;
  }

  .mr-xl-3,
.mx-xl-3 {
    margin-right: 1rem !important;
  }

  .mb-xl-3,
.my-xl-3 {
    margin-bottom: 1rem !important;
  }

  .ml-xl-3,
.mx-xl-3 {
    margin-left: 1rem !important;
  }

  .m-xl-4 {
    margin: 1.5rem !important;
  }

  .mt-xl-4,
.my-xl-4 {
    margin-top: 1.5rem !important;
  }

  .mr-xl-4,
.mx-xl-4 {
    margin-right: 1.5rem !important;
  }

  .mb-xl-4,
.my-xl-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-xl-4,
.mx-xl-4 {
    margin-left: 1.5rem !important;
  }

  .m-xl-5 {
    margin: 3rem !important;
  }

  .mt-xl-5,
.my-xl-5 {
    margin-top: 3rem !important;
  }

  .mr-xl-5,
.mx-xl-5 {
    margin-right: 3rem !important;
  }

  .mb-xl-5,
.my-xl-5 {
    margin-bottom: 3rem !important;
  }

  .ml-xl-5,
.mx-xl-5 {
    margin-left: 3rem !important;
  }

  .p-xl-0 {
    padding: 0 !important;
  }

  .pt-xl-0,
.py-xl-0 {
    padding-top: 0 !important;
  }

  .pr-xl-0,
.px-xl-0 {
    padding-right: 0 !important;
  }

  .pb-xl-0,
.py-xl-0 {
    padding-bottom: 0 !important;
  }

  .pl-xl-0,
.px-xl-0 {
    padding-left: 0 !important;
  }

  .p-xl-1 {
    padding: 0.25rem !important;
  }

  .pt-xl-1,
.py-xl-1 {
    padding-top: 0.25rem !important;
  }

  .pr-xl-1,
.px-xl-1 {
    padding-right: 0.25rem !important;
  }

  .pb-xl-1,
.py-xl-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-xl-1,
.px-xl-1 {
    padding-left: 0.25rem !important;
  }

  .p-xl-2 {
    padding: 0.5rem !important;
  }

  .pt-xl-2,
.py-xl-2 {
    padding-top: 0.5rem !important;
  }

  .pr-xl-2,
.px-xl-2 {
    padding-right: 0.5rem !important;
  }

  .pb-xl-2,
.py-xl-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-xl-2,
.px-xl-2 {
    padding-left: 0.5rem !important;
  }

  .p-xl-3 {
    padding: 1rem !important;
  }

  .pt-xl-3,
.py-xl-3 {
    padding-top: 1rem !important;
  }

  .pr-xl-3,
.px-xl-3 {
    padding-right: 1rem !important;
  }

  .pb-xl-3,
.py-xl-3 {
    padding-bottom: 1rem !important;
  }

  .pl-xl-3,
.px-xl-3 {
    padding-left: 1rem !important;
  }

  .p-xl-4 {
    padding: 1.5rem !important;
  }

  .pt-xl-4,
.py-xl-4 {
    padding-top: 1.5rem !important;
  }

  .pr-xl-4,
.px-xl-4 {
    padding-right: 1.5rem !important;
  }

  .pb-xl-4,
.py-xl-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-xl-4,
.px-xl-4 {
    padding-left: 1.5rem !important;
  }

  .p-xl-5 {
    padding: 3rem !important;
  }

  .pt-xl-5,
.py-xl-5 {
    padding-top: 3rem !important;
  }

  .pr-xl-5,
.px-xl-5 {
    padding-right: 3rem !important;
  }

  .pb-xl-5,
.py-xl-5 {
    padding-bottom: 3rem !important;
  }

  .pl-xl-5,
.px-xl-5 {
    padding-left: 3rem !important;
  }

  .m-xl-auto {
    margin: auto !important;
  }

  .mt-xl-auto,
.my-xl-auto {
    margin-top: auto !important;
  }

  .mr-xl-auto,
.mx-xl-auto {
    margin-right: auto !important;
  }

  .mb-xl-auto,
.my-xl-auto {
    margin-bottom: auto !important;
  }

  .ml-xl-auto,
.mx-xl-auto {
    margin-left: auto !important;
  }
}
.text-justify {
  text-align: justify !important;
}

.text-nowrap {
  white-space: nowrap !important;
}

.text-truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.text-left {
  text-align: left !important;
}

.text-right {
  text-align: right !important;
}

.text-center {
  text-align: center !important;
}

@media (min-width: 576px) {
  .text-sm-left {
    text-align: left !important;
  }

  .text-sm-right {
    text-align: right !important;
  }

  .text-sm-center {
    text-align: center !important;
  }
}
@media (min-width: 768px) {
  .text-md-left {
    text-align: left !important;
  }

  .text-md-right {
    text-align: right !important;
  }

  .text-md-center {
    text-align: center !important;
  }
}
@media (min-width: 992px) {
  .text-lg-left {
    text-align: left !important;
  }

  .text-lg-right {
    text-align: right !important;
  }

  .text-lg-center {
    text-align: center !important;
  }
}
@media (min-width: 1200px) {
  .text-xl-left {
    text-align: left !important;
  }

  .text-xl-right {
    text-align: right !important;
  }

  .text-xl-center {
    text-align: center !important;
  }
}
.text-lowercase {
  text-transform: lowercase !important;
}

.text-uppercase {
  text-transform: uppercase !important;
}

.text-capitalize {
  text-transform: capitalize !important;
}

.font-weight-light {
  font-weight: 300 !important;
}

.font-weight-normal {
  font-weight: normal !important;
}

.font-weight-bold {
  font-weight: bold !important;
}

.font-italic {
  font-style: italic !important;
}

.text-white {
  color: #fff !important;
}

.text-primary {
  color: #03a9f4 !important;
}

a.text-primary:focus, a.text-primary:hover {
  color: #0286c2 !important;
}

.text-secondary {
  color: #868e96 !important;
}

a.text-secondary:focus, a.text-secondary:hover {
  color: #6c757d !important;
}

.text-success {
  color: #7dc855 !important;
}

a.text-success:focus, a.text-success:hover {
  color: #63b139 !important;
}

.text-info {
  color: #78BCEE !important;
}

a.text-info:focus, a.text-info:hover {
  color: #4ba6e8 !important;
}

.text-warning {
  color: #FCCE54 !important;
}

a.text-warning:focus, a.text-warning:hover {
  color: #fbc022 !important;
}

.text-danger {
  color: #ED5564 !important;
}

a.text-danger:focus, a.text-danger:hover {
  color: #e8273a !important;
}

.text-light {
  color: #f8f9fa !important;
}

a.text-light:focus, a.text-light:hover {
  color: #dae0e5 !important;
}

.text-dark {
  color: #343a40 !important;
}

a.text-dark:focus, a.text-dark:hover {
  color: #1d2124 !important;
}

.text-muted {
  color: #868e96 !important;
}

.text-hide {
  font: 0/0 a;
  color: transparent;
  text-shadow: none;
  background-color: transparent;
  border: 0;
}

.visible {
  visibility: visible !important;
}

.invisible {
  visibility: hidden !important;
}

/*
 * Should be at top of all other
 */
/*

@include tablet-and-phone {
    display: none;
}

*/
@media (max-width: 1031px) {
  .responsive {
    text-align: center !important;
  }
  .responsive h1, .responsive h2, .responsive h3, .responsive p, .responsive a, .responsive .text-left, .responsive .text-right, .responsive img {
    text-align: center !important;
  }
}
@media (max-width: 420px) {
  .responsive-phone {
    text-align: center;
  }
}
/* =Transition
-------------------------------------------------------------- */
body {
  color: #86939e;
  font-family: "Roboto", sans-serif, serif;
  font-size: 14px;
  height: 100%;
  line-height: 1.5;
  font-weight: 300;
  letter-spacing: 0.2px;
  padding-right: 0 !important;
}

a {
  color: #03a9f4;
}
a:hover, a:active, a:focus {
  outline: none;
  text-decoration: none;
  color: #03a9f4;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  color: #606676;
  font-weight: 300;
  font-family: "Roboto", sans-serif;
}

.h5 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 4px;
  text-transform: uppercase;
}

p {
  font-size: 14px;
  font-weight: 300;
  letter-spacing: 0.2px;
}

img {
  max-width: 100%;
}

ul li {
  list-style: none;
  font-weight: 300;
}
ul li i {
  padding-right: 15px;
}

header h2 {
  line-height: 60px;
}

.overflow-hide {
  overflow: hidden;
}

.section {
  padding: 50px 0;
}
.section header {
  text-align: center;
  padding-bottom: 50px;
}

.section-heading {
  text-align: center;
  padding-bottom: 40px;
}

.section-title {
  font-weight: 300;
  color: #43484d;
}
@media (min-width: 1031px) {
  .section-title {
    font-size: 52px;
  }
}

.section-subtitle {
  font-size: 22px;
  font-weight: 100;
  line-height: 32px;
  color: #5e6977;
  width: 55%;
  margin: 20px auto 40px;
}

.page .search-section, .page .page-header {
  padding: 30px;
}
.page .search-section h1, .page .page-header h1 {
  font-size: 28px;
}
.page .search-section h1 small, .page .page-header h1 small {
  background: #03a9f4;
  color: #fff;
  font-size: 14px;
  font-weight: 300;
  padding: 3px 10px;
  vertical-align: middle;
}

#page_wrap {
  height: 100%;
  overflow-x: hidden;
  position: relative;
  transition: all 0.5s ease 0s;
  width: 100%;
}

.offcanvas #page_wrap {
  overflow: hidden;
  position: absolute;
}

.offcanvas #page_wrap::after {
  background: rgba(245, 248, 250, 0.7) none repeat scroll 0 0;
  bottom: 0;
  content: "";
  left: 0;
  position: absolute;
  right: 0;
  top: 0;
  transition: all 2s ease 0s;
  z-index: 101;
}

@media (min-width: 1031px) {
  .enable-offcanvas .paper-nav-toggle,
.enable-offcanvas #paper-offcanvas {
    display: block;
  }
}
.block {
  font-size: 14px;
}
.block img {
  border-radius: 3px;
  margin: 15px 0 20px;
  max-width: 100%;
}

.service-sidebar.sidebar-wrapper {
  background-color: #f9f9fb;
  border-radius: 5px;
  margin-bottom: 35px;
  padding: 20px;
}
.service-sidebar.sidebar-wrapper h2 {
  font-size: 24px;
  font-weight: normal;
  line-height: 36px;
  padding-bottom: 0;
  text-transform: capitalize;
}

.paper-block {
  padding: 15px;
  border: 3px solid #f5f8fa;
  border-radius: 3px;
  margin-bottom: 30px;
}

@media (min-width: 1400px) {
  .inside {
    margin: 0 auto;
    background: #fff;
    width: 80%;
  }
}
.card-header {
  position: relative;
}
.card-header .card-handle {
  position: absolute;
  right: 20px;
}

.content-wrapper {
  padding: 40px 0;
}

.section {
  padding: 50px 0;
}
.section header {
  text-align: center;
  padding-bottom: 50px;
}
.section header h1 {
  text-transform: uppercase;
}

/***************************** Header ****************************/
.section {
  margin-top: 80px;
  margin-bottom: 80px;
}
.section header {
  text-align: center;
  padding: 40px;
}

.social {
  list-style: none;
  padding-bottom: 35px;
  padding-top: 15px;
}
.social li {
  display: inline-block;
  border-radius: 50%;
  color: #fff;
  height: 40px;
  line-height: 40px;
  width: 40px;
  font-size: 18px;
  margin-right: 15px;
  text-align: center;
}
.social li a {
  color: #fff;
}
.social li i {
  padding: 0;
}
.social.square li {
  border-radius: 0;
}
.social.rounded li {
  border-radius: 10px;
}

.facebook {
  background: #507cbe;
}

.twitter {
  background: #63cdf1;
}

.gplus {
  background: #f16261;
}

.instagram {
  background: #444444;
}

.youtube {
  background: #CA3737;
}

.linkedin {
  background: #90cadd;
}

.github {
  background: #24292e;
}

.skype {
  background: #00aff0;
}

.lh-0 {
  line-height: 0;
}

.lh-05 {
  line-height: 0.5;
}

.lh-10 {
  line-height: 1;
}

.lh-15 {
  line-height: 1.5;
}

.lh-20 {
  line-height: 2;
}

.lh-25 {
  line-height: 2.5;
}

.p-t-0 {
  padding-top: 0 !important;
}

.p-t-10 {
  padding-top: 10px !important;
}

.p-b-10 {
  padding-bottom: 10px !important;
}

.p-t-20 {
  padding-top: 20px !important;
}

.p-b-20 {
  padding-bottom: 20px !important;
}

.p-t-40 {
  padding-top: 40px !important;
}

.p-b-40 {
  padding-bottom: 40px !important;
}

.p-t-80 {
  padding-top: 80px !important;
}

.p-b-80 {
  padding-bottom: 80px !important;
}

.p-b-100 {
  padding-bottom: 100px !important;
}

.p-t-100 {
  padding-top: 100px !important;
}

.p-t-b-10 {
  padding-top: 10px !important;
  padding-bottom: 10px !important;
}

.p-t-b-20 {
  padding-top: 20px !important;
  padding-bottom: 20px !important;
}

.p-t-b-40 {
  padding-top: 40px !important;
  padding-bottom: 40px !important;
}

.p-t-b-50 {
  padding-top: 50px !important;
  padding-bottom: 50px !important;
}

.p-t-b-80 {
  padding: 80px 0 !important;
}

.p-t-b-100 {
  padding: 100px 0 !important;
}

.p-10 {
  padding: 10px !important;
}

.p-40 {
  padding: 40px !important;
}

.p-t-50 {
  padding-top: 50px !important;
}

.m-t-50 {
  margin-top: 50px !important;
}

.m-t-150 {
  margin-top: 150px;
}
@media (max-width: 1031px) {
  .m-t-150 {
    margin-top: 50px;
  }
}

.m-b-50 {
  margin-bottom: 50px !important;
}

.m-t-b-50 {
  margin: 50px 0 !important;
}

.p-b-0 {
  padding-bottom: 0 !important;
}

.b-b {
  border-bottom: 1px solid #e1e8ee !important;
}

@media (min-width: 1031px) {
  .b-r {
    border-right: 1px solid #e1e8ee;
  }

  .b-l {
    border-left: 1px solid #e1e8ee;
  }

  .b-r-o {
    border-right: 1px solid rgba(0, 0, 0, 0.09);
  }

  .b-l-o {
    border-left: 1px solid rgba(0, 0, 0, 0.09);
  }
}
.b-t {
  border-top: 1px solid #e1e8ee;
}

.b-t-b {
  border-top: 1px solid #e1e8ee;
  border-bottom: 1px solid #e1e8ee;
}

.border {
  border: 1px solid #e1e8ee;
}

.section-text-white h1, .section-text-white h2, .section-text-white h3, .section-text-white h4, .section-text-white h5, .section-text-white h6, .section-text-white p, .section-text-white span {
  color: #fff !important;
}

.no-p {
  padding: 0 !important;
}

.no-m {
  margin: 0 !important;
}

.no-b, .b-0, .no-b .mainnav, .no-b li {
  border: medium none !important;
}

.no-r, .r-0 {
  border-radius: 0 !important;
}

.separator {
  border-bottom: 1px solid #edf0f2;
}

.grid img {
  border-radius: 0;
}

.r-3 {
  border-radius: 3px !important;
}

.r-5 {
  border-radius: 5px !important;
}

.r-10 {
  border-radius: 10px !important;
}

.r-15 {
  border-radius: 15px !important;
}

.r-20 {
  border-radius: 20px !important;
}

.r-30 {
  border-radius: 30px !important;
}

.paper-card {
  background: #fff;
  padding: 40px;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.1);
}

.shadow {
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.1);
}

.shadow1 {
  box-shadow: 0 3px 9px 0 rgba(0, 0, 0, 0.26);
}

.shadow2 {
  box-shadow: 0 0 25px 0 #e5f0fa;
}

.no-shadow {
  box-shadow: none !important;
}

.text-big-bold {
  font-size: 62px;
  font-weight: 800;
  line-height: 62px;
}

.font-weight-lighter, .thin {
  font-weight: 100 !important;
}

.font-weight-bolder, .bolder {
  font-weight: 900 !important;
}

.l-s-1 {
  letter-spacing: 0.2rem;
}

.l-s-2 {
  letter-spacing: 0.4rem;
}

.l-s-3 {
  letter-spacing: 0.6rem;
}

.l-s-4 {
  letter-spacing: 0.8rem;
}

.l-s-5 {
  letter-spacing: 1rem;
}

.s-12 {
  font-size: 12px !important;
}

.s-14 {
  font-size: 14px !important;
}

.s-18 {
  font-size: 18px !important;
}

.s-24 {
  font-size: 24px !important;
}

.s-36 {
  font-size: 36px !important;
}

@media (min-width: 1031px) {
  .s-48 {
    font-size: 48px !important;
  }
}

@media (min-width: 1031px) {
  .s-64 {
    font-size: 64px !important;
  }
}

@media (min-width: 1031px) {
  .s-128 {
    font-size: 128px !important;
  }
}

.s-256 {
  font-size: 256px !important;
}
@media (max-width: 420px) {
  .s-256 {
    font-size: 128px !important;
  }
}

.img-40 {
  width: 40px;
  height: 40px;
}

.w-10 {
  width: 10%;
}

.w-15 {
  width: 15%;
}

.img-80 {
  width: 80px;
}

.img-100 {
  width: 100px;
}

.img-150 {
  width: 150px;
}

.height-50 {
  height: 50px;
}

.height-90 {
  height: 90px;
}

.height-100 {
  height: 100px;
}

.height-full {
  background: #F3F5F8;
  min-height: 100vh;
}

.width-400 {
  max-width: 400px;
}

.width-250 {
  width: 250px !important;
}

.width-900 {
  max-width: 900px;
}

.img-border {
  padding: 5px;
  border: 1px solid #e1e8ee;
}

.text-white {
  color: #fff !important;
}
.text-white p,
.text-white h1,
.text-white h2,
.text-white h3,
.text-white h4,
.text-white h5,
.text-white h6,
.text-white p,
.text-white span,
.text-white strong,
.text-white a,
.text-white b,
.text-white li,
.text-white i {
  color: #fff !important;
}

.text-blue {
  color: #4ea9e0 !important;
}

.text-red {
  color: #e84c3d !important;
}

.text-green {
  color: #40d17d !important;
}

.text-purple {
  color: #9b58b5 !important;
}

.text-black {
  color: #000 !important;
}

.text-yellow {
  color: #f1c40f !important;
}

.white {
  background: #fff !important;
}

.light {
  background-color: #F5F8FA;
}

.light-2 {
  background: #F6FAFD;
}

.text-light-blue {
  color: #03a9f4 !important;
}

.light-blue {
  background-color: #03a9f4 !important;
}

.dark-blue {
  background-color: #26374A !important;
}

.blue4 {
  background-color: #274da8 !important;
}

.blue3 {
  background-color: #375EBC !important;
}

.blue2 {
  background-color: #4CA5E8 !important;
}

.blue1 {
  background-color: #78BCEE !important;
}

.success {
  background-color: #68ba3c !important;
}

.strawberry, .danger {
  background-color: #ED5564 !important;
}

.sunfollower, warning {
  background-color: #FCCE54 !important;
}

.grey-black {
  background-color: #454545 !important;
}

.dark-grey {
  background-color: #2B2D34 !important;
}

.paper-white {
  background: #f5f8fa;
}

.mint {
  background-color: #45CFC0 !important;
}

.gradient {
  border: none;
  background: #4c88ef;
  background: -webkit-gradient(linear, left top, right bottom, color-stop(0%, #4c88ef), color-stop(100%, #17e4d9));
  background: -webkit-linear-gradient(-45deg, #4c88ef 0%, #17e4d9 100%);
  background: -webkit-linear-gradient(315deg, #4c88ef 0%, #17e4d9 100%);
  background: linear-gradient(135deg, #4c88ef 0%, #17e4d9 100%);
}

.gradient-green {
  background-image: linear-gradient(45deg, #00E3AE 0%, #9BE15D 100%);
}

.center {
  margin: 0 auto;
}

.border-list li {
  border-bottom: 1px solid #eee;
}
.border-list li:last-child {
  border: none;
}

@media (min-width: 1031px) {
  .big-heading {
    font-size: 72px;
  }
}
.parallel {
  overflow-x: hidden;
  width: 100%;
}
@media (min-width: 1031px) {
  .parallel {
    overflow: hidden;
    position: fixed;
  }
}

.overlay-light::before {
  content: "";
  background: rgba(255, 255, 255, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.overlay-light::before {
  content: "";
  background: rgba(255, 255, 255, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.overlay-light::before {
  content: "";
  background: rgba(255, 255, 255, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.overlay-dark::before {
  content: "";
  background: rgba(0, 0, 0, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.section {
  position: relative;
}

.relative {
  position: relative !important;
}

.fixed {
  position: fixed !important;
}

[data-bg-repeat=false] {
  background-repeat: no-repeat !important;
}

[data-bg-possition=bottom] {
  background-position: bottom !important;
}

[data-bg-possition=top] {
  background-position: top !important;
}

[data-bg-possition=center] {
  background-position: center !important;
}

[data-bg-possition=centerleft] {
  background-position: center left !important;
}

.grid [class*=col-], .grid figure {
  padding: 0;
  margin: 0;
}
@media (min-width: 1031px) {
  .grid.grid-border [class*=col-] {
    border-right: 1px solid #eee;
  }
  .grid.grid-border [class*=col-]:last-child {
    border-right: 0;
  }
  .grid.grid-border.row {
    border-top: 1px solid #eee;
  }
  .grid.grid-border.row:nth-of-type(1) {
    border-top: none !important;
  }
}

ul.list-group.list-group-striped li:nth-of-type(even) {
  background: #F5F8FA;
}
ul.list-group.list-group-hover li:hover {
  background: red;
}

.mdb-color.lighten-5 {
  background-color: #D0D6E2 !important;
}

.mdb-color.lighten-4 {
  background-color: #B1BACE !important;
}

.mdb-color.lighten-3 {
  background-color: #929FBA !important;
}

.mdb-color.lighten-2 {
  background-color: #7283A7 !important;
}

.mdb-color.lighten-1 {
  background-color: #59698D !important;
}

.mdb-color {
  background-color: #45526E !important;
}

.mdb-color-text {
  color: #45526E !important;
}

.mdb-color.darken-1 {
  background-color: #3B465E !important;
}

.mdb-color.darken-2 {
  background-color: #2E3951 !important;
}

.mdb-color.darken-3 {
  background-color: #1C2A48 !important;
}

.mdb-color.darken-4 {
  background-color: #1C2331 !important;
}

.red.lighten-5 {
  background-color: #FFEBEE !important;
}

.red.lighten-4 {
  background-color: #FFCDD2 !important;
}

.red.lighten-3 {
  background-color: #EF9A9A !important;
}

.red.lighten-2 {
  background-color: #E57373 !important;
}

.red.lighten-1 {
  background-color: #EF5350 !important;
}

.red {
  background-color: #F44336 !important;
}

.red-text {
  color: #F44336 !important;
}

.red.darken-1 {
  background-color: #E53935 !important;
}

.red.darken-2 {
  background-color: #D32F2F !important;
}

.red.darken-3 {
  background-color: #C62828 !important;
}

.red.darken-4 {
  background-color: #B71C1C !important;
}

.red.accent-1 {
  background-color: #FF8A80 !important;
}

.red.accent-2 {
  background-color: #FF5252 !important;
}

.red.accent-3 {
  background-color: #FF1744 !important;
}

.red.accent-4 {
  background-color: #D50000 !important;
}

.pink.lighten-5 {
  background-color: #fce4ec !important;
}

.pink.lighten-4 {
  background-color: #f8bbd0 !important;
}

.pink.lighten-3 {
  background-color: #f48fb1 !important;
}

.pink.lighten-2 {
  background-color: #f06292 !important;
}

.pink.lighten-1 {
  background-color: #ec407a !important;
}

.pink {
  background-color: #e91e63 !important;
}

.pink-text {
  color: #e91e63 !important;
}

.pink.darken-1 {
  background-color: #d81b60 !important;
}

.pink.darken-2 {
  background-color: #c2185b !important;
}

.pink.darken-3 {
  background-color: #ad1457 !important;
}

.pink.darken-4 {
  background-color: #880e4f !important;
}

.pink.accent-1 {
  background-color: #ff80ab !important;
}

.pink.accent-2 {
  background-color: #ff4081 !important;
}

.pink.accent-3 {
  background-color: #f50057 !important;
}

.pink.accent-4 {
  background-color: #c51162 !important;
}

.purple.lighten-5 {
  background-color: #f3e5f5 !important;
}

.purple.lighten-4 {
  background-color: #e1bee7 !important;
}

.purple.lighten-3 {
  background-color: #ce93d8 !important;
}

.purple.lighten-2 {
  background-color: #ba68c8 !important;
}

.purple.lighten-1 {
  background-color: #ab47bc !important;
}

.purple {
  background-color: #9c27b0 !important;
}

.purple-text {
  color: #9c27b0 !important;
}

.purple.darken-1 {
  background-color: #8e24aa !important;
}

.purple.darken-2 {
  background-color: #7b1fa2 !important;
}

.purple.darken-3 {
  background-color: #6a1b9a !important;
}

.purple.darken-4 {
  background-color: #4a148c !important;
}

.purple.accent-1 {
  background-color: #ea80fc !important;
}

.purple.accent-2 {
  background-color: #e040fb !important;
}

.purple.accent-3 {
  background-color: #d500f9 !important;
}

.purple.accent-4 {
  background-color: #aa00ff !important;
}

.deep-purple.lighten-5 {
  background-color: #ede7f6 !important;
}

.deep-purple.lighten-4 {
  background-color: #d1c4e9 !important;
}

.deep-purple.lighten-3 {
  background-color: #b39ddb !important;
}

.deep-purple.lighten-2 {
  background-color: #9575cd !important;
}

.deep-purple.lighten-1 {
  background-color: #7e57c2 !important;
}

.deep-purple {
  background-color: #673ab7 !important;
}

.deep-purple-text {
  color: #673ab7 !important;
}

.deep-purple.darken-1 {
  background-color: #5e35b1 !important;
}

.deep-purple.darken-2 {
  background-color: #512da8 !important;
}

.deep-purple.darken-3 {
  background-color: #4527a0 !important;
}

.deep-purple.darken-4 {
  background-color: #311b92 !important;
}

.deep-purple.accent-1 {
  background-color: #b388ff !important;
}

.deep-purple.accent-2 {
  background-color: #7c4dff !important;
}

.deep-purple.accent-3 {
  background-color: #651fff !important;
}

.deep-purple.accent-4 {
  background-color: #6200ea !important;
}

.indigo.lighten-5 {
  background-color: #e8eaf6 !important;
}

.indigo.lighten-4 {
  background-color: #c5cae9 !important;
}

.indigo.lighten-3 {
  background-color: #9fa8da !important;
}

.indigo.lighten-2 {
  background-color: #7986cb !important;
}

.indigo.lighten-1 {
  background-color: #5c6bc0 !important;
}

.indigo {
  background-color: #3f51b5 !important;
}

.indigo-text {
  color: #3f51b5 !important;
}

.indigo.darken-1 {
  background-color: #3949ab !important;
}

.indigo.darken-2 {
  background-color: #303f9f !important;
}

.indigo.darken-3 {
  background-color: #283593 !important;
}

.indigo.darken-4 {
  background-color: #1a237e !important;
}

.indigo.accent-1 {
  background-color: #8c9eff !important;
}

.indigo.accent-2 {
  background-color: #536dfe !important;
}

.indigo.accent-3 {
  background-color: #3d5afe !important;
}

.indigo.accent-4 {
  background-color: #304ffe !important;
}

.blue.lighten-5 {
  background-color: #E3F2FD !important;
}

.blue.lighten-4 {
  background-color: #BBDEFB !important;
}

.blue.lighten-3 {
  background-color: #90CAF9 !important;
}

.blue.lighten-2 {
  background-color: #64B5F6 !important;
}

.blue.lighten-1 {
  background-color: #42A5F5 !important;
}

.blue {
  background-color: #2196F3 !important;
}

.blue-text {
  color: #2196F3 !important;
}

.blue.darken-1 {
  background-color: #1E88E5 !important;
}

.blue.darken-2 {
  background-color: #1976D2 !important;
}

.blue.darken-3 {
  background-color: #1565C0 !important;
}

.blue.darken-4 {
  background-color: #0D47A1 !important;
}

.blue.accent-1 {
  background-color: #82B1FF !important;
}

.blue.accent-2 {
  background-color: #448AFF !important;
}

.blue.accent-3 {
  background-color: #2979FF !important;
}

.blue.accent-4 {
  background-color: #2962FF !important;
}

.light-blue.lighten-5 {
  background-color: #e1f5fe !important;
}

.light-blue.lighten-4 {
  background-color: #b3e5fc !important;
}

.light-blue.lighten-3 {
  background-color: #81d4fa !important;
}

.light-blue.lighten-2 {
  background-color: #4fc3f7 !important;
}

.light-blue.lighten-1 {
  background-color: #29b6f6 !important;
}

.light-blue {
  background-color: #03a9f4 !important;
}

.light-blue-text {
  color: #03a9f4 !important;
}

.light-blue.darken-1 {
  background-color: #039be5 !important;
}

.light-blue.darken-2 {
  background-color: #0288d1 !important;
}

.light-blue.darken-3 {
  background-color: #0277bd !important;
}

.light-blue.darken-4 {
  background-color: #01579b !important;
}

.light-blue.accent-1 {
  background-color: #80d8ff !important;
}

.light-blue.accent-2 {
  background-color: #40c4ff !important;
}

.light-blue.accent-3 {
  background-color: #00b0ff !important;
}

.light-blue.accent-4 {
  background-color: #0091ea !important;
}

.cyan.lighten-5 {
  background-color: #e0f7fa !important;
}

.cyan.lighten-4 {
  background-color: #b2ebf2 !important;
}

.cyan.lighten-3 {
  background-color: #80deea !important;
}

.cyan.lighten-2 {
  background-color: #4dd0e1 !important;
}

.cyan.lighten-1 {
  background-color: #26c6da !important;
}

.cyan {
  background-color: #00bcd4 !important;
}

.cyan-text {
  color: #00bcd4 !important;
}

.cyan.darken-1 {
  background-color: #00acc1 !important;
}

.cyan.darken-2 {
  background-color: #0097a7 !important;
}

.cyan.darken-3 {
  background-color: #00838f !important;
}

.cyan.darken-4 {
  background-color: #006064 !important;
}

.cyan.accent-1 {
  background-color: #84ffff !important;
}

.cyan.accent-2 {
  background-color: #18ffff !important;
}

.cyan.accent-3 {
  background-color: #00e5ff !important;
}

.cyan.accent-4 {
  background-color: #00b8d4 !important;
}

.teal.lighten-5 {
  background-color: #e0f2f1 !important;
}

.teal.lighten-4 {
  background-color: #b2dfdb !important;
}

.teal.lighten-3 {
  background-color: #80cbc4 !important;
}

.teal.lighten-2 {
  background-color: #4db6ac !important;
}

.teal.lighten-1 {
  background-color: #26a69a !important;
}

.teal {
  background-color: #009688 !important;
}

.teal-text {
  color: #009688 !important;
}

.teal.darken-1 {
  background-color: #00897b !important;
}

.teal.darken-2 {
  background-color: #00796b !important;
}

.teal.darken-3 {
  background-color: #00695c !important;
}

.teal.darken-4 {
  background-color: #004d40 !important;
}

.teal.accent-1 {
  background-color: #a7ffeb !important;
}

.teal.accent-2 {
  background-color: #64ffda !important;
}

.teal.accent-3 {
  background-color: #1de9b6 !important;
}

.teal.accent-4 {
  background-color: #00bfa5 !important;
}

.green.lighten-5 {
  background-color: #E8F5E9 !important;
}

.green.lighten-4 {
  background-color: #C8E6C9 !important;
}

.green.lighten-3 {
  background-color: #A5D6A7 !important;
}

.green.lighten-2 {
  background-color: #81C784 !important;
}

.green.lighten-1 {
  background-color: #66BB6A !important;
}

.green {
  background-color: #4CAF50 !important;
}

.green-text {
  color: #4CAF50 !important;
}

.green.darken-1 {
  background-color: #43A047 !important;
}

.green.darken-2 {
  background-color: #388E3C !important;
}

.green.darken-3 {
  background-color: #2E7D32 !important;
}

.green.darken-4 {
  background-color: #1B5E20 !important;
}

.green.accent-1 {
  background-color: #B9F6CA !important;
}

.green.accent-2 {
  background-color: #69F0AE !important;
}

.green.accent-3 {
  background-color: #00E676 !important;
}

.green.accent-4 {
  background-color: #00C853 !important;
}

.light-green.lighten-5 {
  background-color: #f1f8e9 !important;
}

.light-green.lighten-4 {
  background-color: #dcedc8 !important;
}

.light-green.lighten-3 {
  background-color: #c5e1a5 !important;
}

.light-green.lighten-2 {
  background-color: #aed581 !important;
}

.light-green.lighten-1 {
  background-color: #9ccc65 !important;
}

.light-green {
  background-color: #8bc34a !important;
}

.light-green-text {
  color: #8bc34a !important;
}

.light-green.darken-1 {
  background-color: #7cb342 !important;
}

.light-green.darken-2 {
  background-color: #689f38 !important;
}

.light-green.darken-3 {
  background-color: #558b2f !important;
}

.light-green.darken-4 {
  background-color: #33691e !important;
}

.light-green.accent-1 {
  background-color: #ccff90 !important;
}

.light-green.accent-2 {
  background-color: #b2ff59 !important;
}

.light-green.accent-3 {
  background-color: #76ff03 !important;
}

.light-green.accent-4 {
  background-color: #64dd17 !important;
}

.lime.lighten-5 {
  background-color: #f9fbe7 !important;
}

.lime.lighten-4 {
  background-color: #f0f4c3 !important;
}

.lime.lighten-3 {
  background-color: #e6ee9c !important;
}

.lime.lighten-2 {
  background-color: #dce775 !important;
}

.lime.lighten-1 {
  background-color: #d4e157 !important;
}

.lime {
  background-color: #cddc39 !important;
}

.lime-text {
  color: #cddc39 !important;
}

.lime.darken-1 {
  background-color: #c0ca33 !important;
}

.lime.darken-2 {
  background-color: #afb42b !important;
}

.lime.darken-3 {
  background-color: #9e9d24 !important;
}

.lime.darken-4 {
  background-color: #827717 !important;
}

.lime.accent-1 {
  background-color: #f4ff81 !important;
}

.lime.accent-2 {
  background-color: #eeff41 !important;
}

.lime.accent-3 {
  background-color: #c6ff00 !important;
}

.lime.accent-4 {
  background-color: #aeea00 !important;
}

.yellow.lighten-5 {
  background-color: #fffde7 !important;
}

.yellow.lighten-4 {
  background-color: #fff9c4 !important;
}

.yellow.lighten-3 {
  background-color: #fff59d !important;
}

.yellow.lighten-2 {
  background-color: #fff176 !important;
}

.yellow.lighten-1 {
  background-color: #ffee58 !important;
}

.yellow {
  background-color: #ffeb3b !important;
}

.yellow-text {
  color: #ffeb3b !important;
}

.yellow.darken-1 {
  background-color: #fdd835 !important;
}

.yellow.darken-2 {
  background-color: #fbc02d !important;
}

.yellow.darken-3 {
  background-color: #f9a825 !important;
}

.yellow.darken-4 {
  background-color: #f57f17 !important;
}

.yellow.accent-1 {
  background-color: #ffff8d !important;
}

.yellow.accent-2 {
  background-color: #ffff00 !important;
}

.yellow.accent-3 {
  background-color: #ffea00 !important;
}

.yellow.accent-4 {
  background-color: #ffd600 !important;
}

.amber.lighten-5 {
  background-color: #fff8e1 !important;
}

.amber.lighten-4 {
  background-color: #ffecb3 !important;
}

.amber.lighten-3 {
  background-color: #ffe082 !important;
}

.amber.lighten-2 {
  background-color: #ffd54f !important;
}

.amber.lighten-1 {
  background-color: #ffca28 !important;
}

.amber {
  background-color: #ffc107 !important;
}

.amber-text {
  color: #ffc107 !important;
}

.amber.darken-1 {
  background-color: #ffb300 !important;
}

.amber.darken-2 {
  background-color: #ffa000 !important;
}

.amber.darken-3 {
  background-color: #ff8f00 !important;
}

.amber.darken-4 {
  background-color: #ff6f00 !important;
}

.amber.accent-1 {
  background-color: #ffe57f !important;
}

.amber.accent-2 {
  background-color: #ffd740 !important;
}

.amber.accent-3 {
  background-color: #ffc400 !important;
}

.amber.accent-4 {
  background-color: #ffab00 !important;
}

.orange.lighten-5 {
  background-color: #fff3e0 !important;
}

.orange.lighten-4 {
  background-color: #ffe0b2 !important;
}

.orange.lighten-3 {
  background-color: #ffcc80 !important;
}

.orange.lighten-2 {
  background-color: #ffb74d !important;
}

.orange.lighten-1 {
  background-color: #ffa726 !important;
}

.orange {
  background-color: #ff9800 !important;
}

.orange-text {
  color: #ff9800 !important;
}

.orange.darken-1 {
  background-color: #fb8c00 !important;
}

.orange.darken-2 {
  background-color: #f57c00 !important;
}

.orange.darken-3 {
  background-color: #ef6c00 !important;
}

.orange.darken-4 {
  background-color: #e65100 !important;
}

.orange.accent-1 {
  background-color: #ffd180 !important;
}

.orange.accent-2 {
  background-color: #ffab40 !important;
}

.orange.accent-3 {
  background-color: #ff9100 !important;
}

.orange.accent-4 {
  background-color: #ff6d00 !important;
}

.deep-orange.lighten-5 {
  background-color: #fbe9e7 !important;
}

.deep-orange.lighten-4 {
  background-color: #ffccbc !important;
}

.deep-orange.lighten-3 {
  background-color: #ffab91 !important;
}

.deep-orange.lighten-2 {
  background-color: #ff8a65 !important;
}

.deep-orange.lighten-1 {
  background-color: #ff7043 !important;
}

.deep-orange {
  background-color: #ff5722 !important;
}

.deep-orange-text {
  color: #ff5722 !important;
}

.deep-orange.darken-1 {
  background-color: #f4511e !important;
}

.deep-orange.darken-2 {
  background-color: #e64a19 !important;
}

.deep-orange.darken-3 {
  background-color: #d84315 !important;
}

.deep-orange.darken-4 {
  background-color: #bf360c !important;
}

.deep-orange.accent-1 {
  background-color: #ff9e80 !important;
}

.deep-orange.accent-2 {
  background-color: #ff6e40 !important;
}

.deep-orange.accent-3 {
  background-color: #ff3d00 !important;
}

.deep-orange.accent-4 {
  background-color: #dd2c00 !important;
}

.brown.lighten-5 {
  background-color: #efebe9 !important;
}

.brown.lighten-4 {
  background-color: #d7ccc8 !important;
}

.brown.lighten-3 {
  background-color: #bcaaa4 !important;
}

.brown.lighten-2 {
  background-color: #a1887f !important;
}

.brown.lighten-1 {
  background-color: #8d6e63 !important;
}

.brown {
  background-color: #795548 !important;
}

.brown-text {
  color: #795548 !important;
}

.brown.darken-1 {
  background-color: #6d4c41 !important;
}

.brown.darken-2 {
  background-color: #5d4037 !important;
}

.brown.darken-3 {
  background-color: #4e342e !important;
}

.brown.darken-4 {
  background-color: #3e2723 !important;
}

.blue-grey.lighten-5 {
  background-color: #eceff1 !important;
}

.blue-grey.lighten-4 {
  background-color: #cfd8dc !important;
}

.blue-grey.lighten-3 {
  background-color: #b0bec5 !important;
}

.blue-grey.lighten-2 {
  background-color: #90a4ae !important;
}

.blue-grey.lighten-1 {
  background-color: #78909c !important;
}

.blue-grey {
  background-color: #607d8b !important;
}

.blue-grey-text {
  color: #607d8b !important;
}

.blue-grey.darken-1 {
  background-color: #546e7a !important;
}

.blue-grey.darken-2 {
  background-color: #455a64 !important;
}

.blue-grey.darken-3 {
  background-color: #37474f !important;
}

.blue-grey.darken-4 {
  background-color: #263238 !important;
}

.grey.lighten-5 {
  background-color: #fafafa !important;
}

.grey.lighten-4 {
  background-color: #f5f5f5 !important;
}

.grey.lighten-3 {
  background-color: #eeeeee !important;
}

.grey.lighten-2 {
  background-color: #e0e0e0 !important;
}

.grey.lighten-1 {
  background-color: #bdbdbd !important;
}

.grey {
  background-color: #9e9e9e !important;
}

.grey-text {
  color: #9e9e9e !important;
}

.grey.darken-1 {
  background-color: #757575 !important;
}

.grey.darken-2 {
  background-color: #616161 !important;
}

.grey.darken-3 {
  background-color: #424242 !important;
}

.grey.darken-4 {
  background-color: #212121 !important;
}

.shades.black {
  background-color: #000000 !important;
}

.shades.white {
  background-color: #FFFFFF !important;
}

.shades.transparent {
  background-color: transparent !important;
}

.black {
  background-color: #000000 !important;
}

.black-text {
  color: #000000 !important;
}

.white {
  background-color: #FFFFFF !important;
}

.white-text {
  color: #FFFFFF !important;
}

.transparent {
  background-color: transparent !important;
}

.transparent-text {
  color: transparent !important;
}

.light-blue-text {
  color: #82B1FF !important;
}

.dark-grey-text {
  color: #4f4f4f !important;
}

.danger-color {
  background-color: #ED5564 !important;
}

.danger-color-dark {
  background-color: #CC0000 !important;
}

.warning-color {
  background-color: #FCCE54 !important;
}

.warning-color-dark {
  background-color: #FF8800 !important;
}

.success-color {
  background-color: #7dc855 !important;
}

.success-color-dark {
  background-color: #007E33 !important;
}

.info-color {
  background-color: #78BCEE !important;
}

.info-color-dark {
  background-color: #0099CC !important;
}

.default-color {
  background-color: #2BBBAD !important;
}

.default-color-dark {
  background-color: #00695c !important;
}

.primary-color {
  background-color: #4285F4 !important;
}

.primary-color-dark {
  background-color: #0d47a1 !important;
}

.secondary-color {
  background-color: #aa66cc !important;
}

.secondary-color-dark {
  background-color: #9933CC !important;
}

.elegant-color {
  background-color: #2E2E2E !important;
}

.elegant-color-dark {
  background-color: #212121 !important;
}

.stylish-color {
  background-color: #4B515D !important;
}

.stylish-color-dark {
  background-color: #3E4551 !important;
}

.special-color {
  background-color: #37474F !important;
}

.special-color-dark {
  background-color: #263238 !important;
}

.unique-color {
  background-color: #3F729B !important;
}

.unique-color-dark {
  background-color: #1C2331 !important;
}

.mdb-color {
  background-color: #45526E !important;
}

.rgba-blue-light {
  background-color: rgba(3, 169, 244, 0.3) !important;
}

.rgba-red-light {
  background-color: rgba(244, 67, 54, 0.3) !important;
}

.rgba-pink-light {
  background-color: rgba(233, 30, 99, 0.3) !important;
}

.rgba-purple-light {
  background-color: rgba(156, 39, 176, 0.3) !important;
}

.rgba-indigo-light {
  background-color: rgba(63, 81, 181, 0.3) !important;
}

.rgba-cyan-light {
  background-color: rgba(0, 188, 212, 0.3) !important;
}

.rgba-teal-light {
  background-color: rgba(0, 150, 136, 0.3) !important;
}

.rgba-green-light {
  background-color: rgba(76, 175, 80, 0.3) !important;
}

.rgba-lime-light {
  background-color: rgba(205, 220, 57, 0.3) !important;
}

.rgba-yellow-light {
  background-color: rgba(255, 235, 59, 0.3) !important;
}

.rgba-orange-light {
  background-color: rgba(255, 152, 0, 0.3) !important;
}

.rgba-brown-light {
  background-color: rgba(121, 85, 72, 0.3) !important;
}

.rgba-grey-light {
  background-color: rgba(158, 158, 158, 0.3) !important;
}

.rgba-bluegrey-light {
  background-color: rgba(96, 125, 139, 0.3) !important;
}

.rgba-black-light {
  background-color: rgba(0, 0, 0, 0.3) !important;
}

.rgba-stylish-light {
  background-color: rgba(62, 69, 81, 0.3) !important;
}

.rgba-white-light {
  background-color: rgba(255, 255, 255, 0.3) !important;
}

.rgba-blue-strong {
  background-color: rgba(3, 169, 244, 0.7) !important;
}

.rgba-red-strong {
  background-color: rgba(244, 67, 54, 0.7) !important;
}

.rgba-pink-strong {
  background-color: rgba(233, 30, 99, 0.7) !important;
}

.rgba-purple-strong {
  background-color: rgba(156, 39, 176, 0.7) !important;
}

.rgba-indigo-strong {
  background-color: rgba(63, 81, 181, 0.7) !important;
}

.rgba-cyan-strong {
  background-color: rgba(0, 188, 212, 0.7) !important;
}

.rgba-teal-strong {
  background-color: rgba(0, 150, 136, 0.7) !important;
}

.rgba-green-strong {
  background-color: rgba(76, 175, 80, 0.7) !important;
}

.rgba-lime-strong {
  background-color: rgba(205, 220, 57, 0.7) !important;
}

.rgba-yellow-strong {
  background-color: rgba(255, 235, 59, 0.7) !important;
}

.rgba-orange-strong {
  background-color: rgba(255, 152, 0, 0.7) !important;
}

.rgba-brown-strong {
  background-color: rgba(121, 85, 72, 0.7) !important;
}

.rgba-grey-strong {
  background-color: rgba(158, 158, 158, 0.7) !important;
}

.rgba-bluegrey-strong {
  background-color: rgba(96, 125, 139, 0.7) !important;
}

.rgba-black-strong {
  background-color: rgba(0, 0, 0, 0.7) !important;
}

.rgba-stylish-strong {
  background-color: rgba(62, 69, 81, 0.7) !important;
}

.rgba-white-strong {
  background-color: rgba(255, 255, 255, 0.7) !important;
}

.rgba-blue-slight {
  background-color: rgba(3, 169, 244, 0.1) !important;
}

.rgba-red-slight {
  background-color: rgba(244, 67, 54, 0.1) !important;
}

.rgba-pink-slight {
  background-color: rgba(233, 30, 99, 0.1) !important;
}

.rgba-purple-slight {
  background-color: rgba(156, 39, 176, 0.1) !important;
}

.rgba-indigo-slight {
  background-color: rgba(63, 81, 181, 0.1) !important;
}

.rgba-cyan-slight {
  background-color: rgba(0, 188, 212, 0.1) !important;
}

.rgba-teal-slight {
  background-color: rgba(0, 150, 136, 0.1) !important;
}

.rgba-green-slight {
  background-color: rgba(76, 175, 80, 0.1) !important;
}

.rgba-lime-slight {
  background-color: rgba(205, 220, 57, 0.1) !important;
}

.rgba-yellow-slight {
  background-color: rgba(255, 235, 59, 0.1) !important;
}

.rgba-orange-slight {
  background-color: rgba(255, 152, 0, 0.1) !important;
}

.rgba-brown-slight {
  background-color: rgba(121, 85, 72, 0.1) !important;
}

.rgba-grey-slight {
  background-color: rgba(158, 158, 158, 0.1) !important;
}

.rgba-bluegrey-slight {
  background-color: rgba(96, 125, 139, 0.1) !important;
}

.rgba-black-slight {
  background-color: rgba(0, 0, 0, 0.1) !important;
}

.rgba-stylish-slight {
  background-color: rgba(62, 69, 81, 0.1) !important;
}

.rgba-white-slight {
  background-color: rgba(255, 255, 255, 0.1) !important;
}

.bg-primary {
  background-color: #4285F4 !important;
}

.bg-danger {
  background-color: #ED5564 !important;
}

.bg-warning {
  background-color: #FF8800 !important;
}

.bg-success {
  background-color: #7dc855 !important;
}

.bg-info {
  background-color: #78BCEE !important;
}

.bg-default {
  background-color: #2BBBAD !important;
}

.bg-secondary {
  background-color: #aa66cc !important;
}

.bg-elegant {
  background-color: #2E2E2E !important;
}

.bg-unique {
  background-color: #880e4f !important;
}

.bg-dark-green {
  background-color: #388E3C !important;
}

.bg-mdb-color {
  background-color: #59698D !important;
}

.bg-red {
  background-color: #D32F2F !important;
}

.bg-pink {
  background-color: #ec407a !important;
}

.bg-purple {
  background-color: #8e24aa !important;
}

.bg-deep-purple {
  background-color: #512da8 !important;
}

.bg-indigo {
  background-color: #3f51b5 !important;
}

.bg-blue {
  background-color: #1976D2 !important;
}

.bg-light-blue {
  background-color: #82B1FF !important;
}

.bg-cyan {
  background-color: #00bcd4 !important;
}

.bg-teal {
  background-color: #00796b !important;
}

.bg-green {
  background-color: #388E3C !important;
}

.bg-light-green {
  background-color: #8bc34a !important;
}

.bg-lime {
  background-color: #afb42b !important;
}

.bg-yellow {
  background-color: #fbc02d !important;
}

.bg-amber {
  background-color: #ffa000 !important;
}

.bg-orange {
  background-color: #f57c00 !important;
}

.bg-deep-orange {
  background-color: #ff7043 !important;
}

.bg-brown {
  background-color: #795548 !important;
}

.bg-grey {
  background-color: #616161 !important;
}

.bg-blue-grey {
  background-color: #78909c !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-black {
  background-color: #000 !important;
}

.zolkusowy-gradient {
  background: #00ff90;
  background: -moz-linear-gradient(top, #00ff90 0%, #59ffdd 47%, #ffff00 100%);
  background: -webkit-linear-gradient(top, #00ff90 0%, #59ffdd 47%, #ffff00 100%);
  background: linear-gradient(to bottom, #00ff90 0%, #59ffdd 47%, #ffff00 100%);
}

/*
 * Basic or Must have Elements
 * You might not want to comment or delete them
 */
footer {
  background-color: #fff;
  border-top: 1px solid #eee;
  padding: 35px 0 0;
}
@media (max-width: 420px) {
  footer .brand {
    text-align: center;
  }
}
footer h6 {
  font-weight: 400;
}
footer .brand img {
  padding-top: 50px;
  padding-bottom: 50px;
}
footer ul {
  padding: 0;
}
footer .footer-links {
  padding-top: 5px;
}
footer .footer-links li {
  display: block;
  list-style: none;
}
footer .footer-links li a {
  color: #86939e;
  line-height: 26px;
}
footer .footer-links li a:hover {
  color: #03a9f4;
}
footer .social {
  padding: 20px 0;
}
footer .copyright {
  color: #5e6977;
}
footer li {
  position: relative;
}
footer .customeIconList {
  margin-top: 30px;
}
footer .customeIconList li {
  position: relative;
  padding-left: 15px;
  display: block;
  margin-bottom: 25px;
}
footer ul.customeIconList > li {
  padding-left: 30px;
}
footer .customeIconList li .icon {
  position: absolute;
  top: 0;
  left: 0;
  font-size: 16px;
  color: #5fb7ea;
}
footer hr {
  border-top: 1px solid rgba(255, 255, 255, 0.05);
}
footer .copyrights {
  padding: 10px 0;
  font-weight: 300;
}

.user_profile {
  width: 200px;
  border: 1px solid #eee;
  background: #fff;
  padding: 5px;
  border-radius: 50%;
}

/***************************** 3- Topics ****************************/
.topics {
  padding: 50px 0;
}
.topics header {
  border-bottom: 1px solid #eee;
  position: relative;
}
.topics header h2 {
  font-size: 38px;
  font-weight: 300;
  font-family: "Roboto", sans-serif;
  color: #43484d;
}
.topics header p {
  font-size: 16px;
  font-weight: 300;
  font-family: "Roboto", sans-serif;
  color: #5e6977;
}
.topics .topics-btn {
  margin-top: 30px;
}
.topics .topics-btn .btn {
  margin-top: 60px;
  color: #358ed7;
}
.topics .topics-btn span {
  display: inline;
  padding-left: 30px;
}
.topics .topic-header {
  font-size: 18px;
  font-weight: 400;
  font-family: "Roboto", sans-serif;
  color: #43484d;
  text-decoration: none;
}

.media-border {
  border-bottom: 1px solid #eeeeee;
}

.topics-wrapper {
  border-radius: 5px;
  margin-bottom: 40px;
}
.topics-wrapper h3 {
  padding: 0;
}
.topics-wrapper .topics-list {
  padding: 20px 0;
}
.topics-wrapper .topics-list li {
  list-style: none;
  line-height: 35px;
}
.topics-wrapper .topics-list li a {
  padding-left: 25px;
  color: #86939e;
  font-size: 12px;
  font-weight: 400;
  text-decoration: none;
  outline: 0 none;
}
.topics-wrapper .topics-list li a:hover {
  color: #03a9f4;
}
.topics-wrapper .topics-list li:before {
  color: #b5bfc7;
  font-size: 18px;
}
.topics-wrapper .topics-meta {
  padding: 7px 0;
  margin: 0;
  border-top: 1px solid #e1e8ee;
}
.topics-wrapper .topics-meta li {
  list-style: none;
  display: inline-block;
  color: #5e6977;
  font-size: 14px;
  font-weight: 300;
  padding-right: 10px;
}
.topics-wrapper .icon {
  color: #4ea9e0;
  font-size: 24px;
  font-weight: bold;
  margin-right: 15px;
}

.topics-wrapper.border-style {
  border: 3px solid #e1e8ee;
}
.topics-wrapper.border-style h3 {
  padding: 20px 40px 0;
}
.topics-wrapper.border-style .topics-list {
  padding: 20px 40px;
}
.topics-wrapper.border-style .topics-list li {
  position: relative;
  padding-left: 5px;
}
.topics-wrapper.border-style .topics-meta {
  background: #f5f8fa;
  padding: 7px 10px;
  text-align: center;
  border-top: 1px solid #e1e8ee;
}

/*
 * Templates Specific Styles
 */
.bg-icon-plane {
  background-image: url("../img/icon/icon-plane.png");
  background-repeat: no-repeat;
}

.template-resume .contactBar .icon {
  padding: 15px;
}
.template-resume .resume-header {
  background-color: #f5f8fa;
  background-position: bottom center;
  color: #86939e;
  padding-top: 150px;
  padding-bottom: 150px;
  border-bottom: 1px solid #e1e8ee;
  z-index: -1;
  text-align: center;
}
.template-resume .resume-header h1 {
  font-size: 48px;
  color: #86939e;
  text-transform: capitalize;
  font-weight: 100;
}
.template-resume .resume-header .subtitle {
  font-size: 24px;
  padding: 35px 0;
}
.template-resume .profiles {
  text-align: center;
}

.resume2 .resume-header {
  padding: 78px 0;
}

/*
 * Components
 */
.paper-timeline {
  list-style: none;
  position: relative;
}

.paper-timeline:before {
  top: 30px;
  bottom: 0;
  position: absolute;
  content: " ";
  width: 3px;
  background-color: #f5f8fa;
  left: 50%;
  margin-left: -1.5px;
  z-index: -1;
}

.paper-timeline .clearFix {
  clear: both;
  height: 0;
}

.start-icon svg {
  display: block;
  margin: 0 auto;
  margin-bottom: 0px;
  color: #dfe7ed;
  font-size: 64px;
  background-color: #fff;
}

.end-icon svg {
  display: block;
  margin: 0 auto;
  margin-bottom: 0px;
  color: #f5f8fa;
  font-size: 15px;
  background-color: #fff;
}

.paper-timeline {
  color: #86939e;
  padding-bottom: 80px;
}
.paper-timeline .timeline-item h3 {
  font-size: 18px;
  font-weight: 400;
  color: #86939e;
}
.paper-timeline .left::after {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  right: 0;
  top: 50%;
  width: 66px;
}
.paper-timeline .right::before {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  left: 0;
  top: 50%;
  width: 66px;
}
.paper-timeline .mini .left::after {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  right: 0;
  top: 50%;
  width: 56px;
}
.paper-timeline .mini .right::before {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  left: 0;
  top: 50%;
  width: 56px;
}
.paper-timeline .timeline-panel {
  border: 3px solid #f5f8fa;
  border-radius: 5px;
  padding: 20px 30px 10px;
  position: relative;
  background: #fff;
}
@media (max-width: 980px) {
  .paper-timeline .timeline-panel {
    margin-top: 30px;
  }
  .paper-timeline .left::after {
    border: none !important;
  }
  .paper-timeline .right::before {
    border: none !important;
  }
}

.contactBar {
  margin-top: -80px;
  z-index: 96;
}
.contactBar .contacts {
  border: 1px solid #e1e8ee;
  border-radius: 5px;
  background: #fff;
  text-align: center;
}
.contactBar .contacts a {
  color: #86939e;
}
.contactBar .icon {
  padding: 30px;
  font-size: 48px;
  display: block;
}
.contactBar img {
  padding: 25px;
}
.contactBar .grey {
  background: #fbfcfd;
}
.contactBar .btn {
  margin-top: 45px;
  padding: 18px 70px;
}
.contactBar p {
  margin-bottom: 20px;
}
@media (max-width: 980px) {
  .contactBar .btn {
    margin-bottom: 22px;
    margin-top: 22px;
  }
}

.contactIcon {
  color: #dfe7ed;
  font-size: 64px;
  margin-top: 25px;
  margin-bottom: 25px;
}

.service-blocks .service-block {
  margin-bottom: 35px;
}
.service-blocks .service-block .service-icon {
  float: left;
}
.service-blocks .service-block .service-icon svg {
  border-radius: 100%;
  color: #86939e;
  height: 70px;
  width: 70px;
  display: flex;
  flex-direction: column;
}
.service-blocks .service-block:hover .service-icon svg {
  opacity: 0.5;
}
.service-blocks .service-block .service-icon svg {
  font-size: 60px;
  color: #dfe7ed;
}
.service-blocks .service-block .service-icon svg::before {
  font-size: 60px;
  color: #dfe7ed;
}
.service-blocks .service-block .service-content {
  overflow: hidden;
}
.service-blocks .service-block .service-content h3 {
  font-size: 18px;
  margin-bottom: 10px;
  font-weight: 400;
}
.service-blocks .service-block .service-content h3 a {
  color: #606676;
}
.service-blocks .service-block .service-content h3 a:hover {
  color: #03a9f4;
}
.service-blocks .service-block .btn {
  margin: 20px 0 10px 0;
}
.service-blocks .service-block.s1 .service-icon {
  float: none;
}
.service-blocks .service-block.s2 {
  padding: 20px;
}
.service-blocks .service-block.s2 .service-icon svg::before {
  font-size: 40px;
}
.service-blocks .center {
  text-align: center;
}
.service-blocks .center .service-icon {
  float: none !important;
}
.service-blocks .center .service-icon svg {
  margin: 0 auto;
}

.single-service-contents {
  padding: 100px 0 65px;
}

/*# sourceMappingURL=app.css.map */

	</style>
	
	</head>
	<body>
		<div id="app">
			<main class="template-resume resume2">
				<section class="resume-header bg-icon-plane">
					<div class="container">
						<div class="row">
							<div class="col-8 mx-md-auto">
								<h1>Noah Scharrenberg</h1>
			
								<p class="subtitle">Software Engineer</p>
			
									<img src="https://www.arion.run/wp-content/uploads/2020/02/noah-ddw.png" alt="Noah Scharrenberg" class="user_profile">
			
									<ul class="social">
											<li class="linkedin">
												<a href="https://www.linkedin.com/in/nscharrenberg/" target="_blank" title="nscharrenberg on linkedin">
													<i class="fab fa-linkedin"></i>
												</a>
											</li>
											<li class="github">
												<a href="https://github.com/nscharrenberg" target="_blank" title="nscharrenberg on github">
													<i class="fab fa-github"></i>
												</a>
											</li>
									</ul>
							</div>
						</div>
					</div>
				</section>
			
				<section class="contactBar">
					<div class="container">
						<div class="row contacts">
								<div class="col-md">
									<span>
										<i class="fas fa-link contactIcon"></i>
									</span>
			
									<p>
										<a href="https://nscharrenberg.nl"> https://nscharrenberg.nl</a>
									</p>
								</div>
			
								<div class="col-md">
									<span>
										<i class="fas fa-envelope-open contactIcon"></i>
									</span>
			
									<p>
										<a href="nscharrenberg@hotmail.com"> nscharrenberg@hotmail.com</a>
									</p>
								</div>
			
						</div>
					</div>
				</section>
			<section id="work">
				<h2>Work</h2>
				<div class="item">
					<h3 class="name">
						Student aan huis
					</h3>
					<div class="date">
						<span class="startDate">
							2016-08-01
						</span>
						<span class="endDate">
							- 2018-08-31
						</span>
					</div>
					<div class="position">
						IT Support
					</div>
					<div class="website">
						<a href="https://www.studentaanhuis.nl/">https://www.studentaanhuis.nl/</a>
					</div>
					<div class="summary">
						<p>Solving and teaching IT related problems at location for customers from diffirent target groups.</p>
					</div>
				</div>
				<div class="item">
					<h3 class="name">
						Bearingpoint Caribbean
					</h3>
					<div class="date">
						<span class="startDate">
							2018-08-01
						</span>
						<span class="endDate">
							- 2019-01-31
						</span>
					</div>
					<div class="position">
						Blockchain Intern
					</div>
					<div class="website">
						<a href="https://www.bearingpointcaribbean.com/en/">https://www.bearingpointcaribbean.com/en/</a>
					</div>
					<div class="summary">
						<p>Performing research on the possibilities of Blockchain within the companies portfolio, providing an advisory report regarding and a basic prototype with Blockchain integration on an existing system.</p>
					</div>
				</div>
				<div class="item">
					<h3 class="name">
						ATO-Gear
					</h3>
					<div class="date">
						<span class="startDate">
							2020-01-01
						</span>
						<span class="endDate">
							- Present
						</span>
					</div>
					<div class="position">
						Intern
					</div>
					<div class="website">
						<a href="https://www.arion.run/">https://www.arion.run/</a>
					</div>
					<div class="summary">
						<p>Researching the implementation of a conversational AI within the Arion app, to avoid users from touching their phone during running.</p>
					</div>
				</div>
			</section>
			<section id="volunteer">
				<h2>Volunteer</h2>
				<div class="item">
					<h3 class="company">
						Stichting DOG
					</h3>
					<div class="date">
						<span class="startDate">
							2018-09-01
						</span>
						<span class="endDate">
							- 2019-01-22
						</span>
					</div>
					<div class="position">
						Volunteer
					</div>
					<div class="website">
						<a href="https://stichtingdog.org/">https://stichtingdog.org/</a>
					</div>
					<div class="summary">
						<p>Helping with the maintenance of the terrain and caretaking of the dogs.</p>
					</div>
				</div>
			</section>
			<section id="education">
				<h2>Education</h2>
				<div class="item">
					<div class="date">
						<span class="startDate">
							2016-08-01
						</span>
						<span class="endDate">
							- Present
						</span>
					</div>
					<div class="institution">
						Fontys University of Applied Sciences
					</div>
					<div class="area">
						Software Engineering
					</div>
					<div class="studyType">
						Bachelor of Science
					</div>
				</div>
			</section>
			<section id="skills">
				<h2>Skills</h2>
				<div class="item">
					<div class="name">
						Web Development
					</div>
					<div class="level">
						<em>Advanced</em>
					</div>
					<ul class="keywords">
						<li>HTML</li>
						<li>CSS</li>
						<li>Javascript</li>
						<li>Vue</li>
						<li>Angular</li>
						<li>React</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Mobile Development
					</div>
					<div class="level">
						<em>Beginner</em>
					</div>
					<ul class="keywords">
						<li>React-Native</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Java
					</div>
					<div class="level">
						<em>Advanced</em>
					</div>
					<ul class="keywords">
						<li>Java EE</li>
						<li>Sprint</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Blockchain
					</div>
					<div class="level">
						<em>Advanced</em>
					</div>
				</div>
				<div class="item">
					<div class="name">
						C#
					</div>
					<div class="level">
						<em>Average</em>
					</div>
					<ul class="keywords">
						<li>ASP.NET</li>
						<li>.NET Core</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Artificial Intelligence
					</div>
					<div class="level">
						<em>Beginner</em>
					</div>
				</div>
			</section>
			<section id="languages">
				<h2>Languages</h2>
				<div class="item">
					<div class="language">
						Dutch
					</div>
					<div class="fluency">
						<em>Native speaker</em>
					</div>
				</div>
				<div class="item">
					<div class="language">
						English
					</div>
					<div class="fluency">
						<em>Good</em>
					</div>
				</div>
				<div class="item">
					<div class="language">
						Deutsch
					</div>
					<div class="fluency">
						<em>Basic</em>
					</div>
				</div>
			</section>
			<section id="interests">
				<h2>Interests</h2>
				<div class="item">
					<div class="name">
						New or Interesting Technologies
					</div>
					<ul class="keywords">
						<li>Artificial Intelligence</li>
						<li>Blockchain</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Movies &amp; Series
					</div>
				</div>
				<div class="item">
					<div class="name">
						Music
					</div>
				</div>
				<div class="item">
					<div class="name">
						Traveling
					</div>
				</div>
			</section>
			</main>
		</div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script>
		<script>
			/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = &quot;&quot;;

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Boot everything we need for paper front end
	 * We are using Gulp webpack to include scripts because
	 * its supper simple
	 */

	__webpack_require__(2);

	__webpack_require__(219);

	__webpack_require__(220);

	__webpack_require__(222);

	__webpack_require__(223);

	__webpack_require__(224);

	__webpack_require__(226);

	__webpack_require__(227);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 * Scripts common for both Admin &amp; Front End.
	 */
	__webpack_require__(3);

	window.$ = window.jQuery = __webpack_require__(5);

	__webpack_require__(6);

	__webpack_require__(7);

	window.Popper = __webpack_require__(8);

	__webpack_require__(9);

	__webpack_require__(10);

	__webpack_require__(11);

	__webpack_require__(12);

	__webpack_require__(14);

	__webpack_require__(15);

	__webpack_require__(16);

	__webpack_require__(18); // Masonary + isotope + portfolio filter

	__webpack_require__(27);

	__webpack_require__(29);

	__webpack_require__(31);

	__webpack_require__(32);

	__webpack_require__(215);

	__webpack_require__(217);

	__webpack_require__(218);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var NProgress = __webpack_require__(4);
	document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
	    NProgress.start();
	});
	window.addEventListener(&#x27;load&#x27;, function() {
	    var body = document.body;
	    var loader = document.getElementById(&#x27;loader&#x27;);
	    body.classList.add(&#x27;loaded&#x27;);
	    loader.classList.add(&#x27;loader-fade&#x27;);
	    NProgress.done();
	}, true);

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
	 * @license MIT */

	;(function(root, factory) {

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === &#x27;object&#x27;) {
	    module.exports = factory();
	  } else {
	    root.NProgress = factory();
	  }

	})(this, function() {
	  var NProgress = {};

	  NProgress.version = &#x27;0.2.0&#x27;;

	  var Settings = NProgress.settings = {
	    minimum: 0.08,
	    easing: &#x27;ease&#x27;,
	    positionUsing: &#x27;&#x27;,
	    speed: 200,
	    trickle: true,
	    trickleRate: 0.02,
	    trickleSpeed: 800,
	    showSpinner: true,
	    barSelector: &#x27;[role=&quot;bar&quot;]&#x27;,
	    spinnerSelector: &#x27;[role=&quot;spinner&quot;]&#x27;,
	    parent: &#x27;body&#x27;,
	    template: &#x27;&lt;div class=&quot;bar&quot; role=&quot;bar&quot;&gt;&lt;div class=&quot;peg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;spinner&quot; role=&quot;spinner&quot;&gt;&lt;div class=&quot;spinner-icon&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;
	  };

	  /**
	   * Updates configuration.
	   *
	   *     NProgress.configure({
	   *       minimum: 0.1
	   *     });
	   */
	  NProgress.configure = function(options) {
	    var key, value;
	    for (key in options) {
	      value = options[key];
	      if (value !== undefined &amp;&amp; options.hasOwnProperty(key)) Settings[key] = value;
	    }

	    return this;
	  };

	  /**
	   * Last number.
	   */

	  NProgress.status = null;

	  /**
	   * Sets the progress bar status, where &#x60;n&#x60; is a number from &#x60;0.0&#x60; to &#x60;1.0&#x60;.
	   *
	   *     NProgress.set(0.4);
	   *     NProgress.set(1.0);
	   */

	  NProgress.set = function(n) {
	    var started = NProgress.isStarted();

	    n = clamp(n, Settings.minimum, 1);
	    NProgress.status = (n === 1 ? null : n);

	    var progress = NProgress.render(!started),
	        bar      = progress.querySelector(Settings.barSelector),
	        speed    = Settings.speed,
	        ease     = Settings.easing;

	    progress.offsetWidth; /* Repaint */

	    queue(function(next) {
	      // Set positionUsing if it hasn&#x27;t already been set
	      if (Settings.positionUsing === &#x27;&#x27;) Settings.positionUsing = NProgress.getPositioningCSS();

	      // Add transition
	      css(bar, barPositionCSS(n, speed, ease));

	      if (n === 1) {
	        // Fade out
	        css(progress, { 
	          transition: &#x27;none&#x27;, 
	          opacity: 1 
	        });
	        progress.offsetWidth; /* Repaint */

	        setTimeout(function() {
	          css(progress, { 
	            transition: &#x27;all &#x27; + speed + &#x27;ms linear&#x27;, 
	            opacity: 0 
	          });
	          setTimeout(function() {
	            NProgress.remove();
	            next();
	          }, speed);
	        }, speed);
	      } else {
	        setTimeout(next, speed);
	      }
	    });

	    return this;
	  };

	  NProgress.isStarted = function() {
	    return typeof NProgress.status === &#x27;number&#x27;;
	  };

	  /**
	   * Shows the progress bar.
	   * This is the same as setting the status to 0%, except that it doesn&#x27;t go backwards.
	   *
	   *     NProgress.start();
	   *
	   */
	  NProgress.start = function() {
	    if (!NProgress.status) NProgress.set(0);

	    var work = function() {
	      setTimeout(function() {
	        if (!NProgress.status) return;
	        NProgress.trickle();
	        work();
	      }, Settings.trickleSpeed);
	    };

	    if (Settings.trickle) work();

	    return this;
	  };

	  /**
	   * Hides the progress bar.
	   * This is the *sort of* the same as setting the status to 100%, with the
	   * difference being &#x60;done()&#x60; makes some placebo effect of some realistic motion.
	   *
	   *     NProgress.done();
	   *
	   * If &#x60;true&#x60; is passed, it will show the progress bar even if its hidden.
	   *
	   *     NProgress.done(true);
	   */

	  NProgress.done = function(force) {
	    if (!force &amp;&amp; !NProgress.status) return this;

	    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
	  };

	  /**
	   * Increments by a random amount.
	   */

	  NProgress.inc = function(amount) {
	    var n = NProgress.status;

	    if (!n) {
	      return NProgress.start();
	    } else {
	      if (typeof amount !== &#x27;number&#x27;) {
	        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
	      }

	      n = clamp(n + amount, 0, 0.994);
	      return NProgress.set(n);
	    }
	  };

	  NProgress.trickle = function() {
	    return NProgress.inc(Math.random() * Settings.trickleRate);
	  };

	  /**
	   * Waits for all supplied jQuery promises and
	   * increases the progress as the promises resolve.
	   *
	   * @param $promise jQUery Promise
	   */
	  (function() {
	    var initial = 0, current = 0;

	    NProgress.promise = function($promise) {
	      if (!$promise || $promise.state() === &quot;resolved&quot;) {
	        return this;
	      }

	      if (current === 0) {
	        NProgress.start();
	      }

	      initial++;
	      current++;

	      $promise.always(function() {
	        current--;
	        if (current === 0) {
	            initial = 0;
	            NProgress.done();
	        } else {
	            NProgress.set((initial - current) / initial);
	        }
	      });

	      return this;
	    };

	  })();

	  /**
	   * (Internal) renders the progress bar markup based on the &#x60;template&#x60;
	   * setting.
	   */

	  NProgress.render = function(fromStart) {
	    if (NProgress.isRendered()) return document.getElementById(&#x27;nprogress&#x27;);

	    addClass(document.documentElement, &#x27;nprogress-busy&#x27;);
	    
	    var progress = document.createElement(&#x27;div&#x27;);
	    progress.id = &#x27;nprogress&#x27;;
	    progress.innerHTML = Settings.template;

	    var bar      = progress.querySelector(Settings.barSelector),
	        perc     = fromStart ? &#x27;-100&#x27; : toBarPerc(NProgress.status || 0),
	        parent   = document.querySelector(Settings.parent),
	        spinner;
	    
	    css(bar, {
	      transition: &#x27;all 0 linear&#x27;,
	      transform: &#x27;translate3d(&#x27; + perc + &#x27;%,0,0)&#x27;
	    });

	    if (!Settings.showSpinner) {
	      spinner = progress.querySelector(Settings.spinnerSelector);
	      spinner &amp;&amp; removeElement(spinner);
	    }

	    if (parent != document.body) {
	      addClass(parent, &#x27;nprogress-custom-parent&#x27;);
	    }

	    parent.appendChild(progress);
	    return progress;
	  };

	  /**
	   * Removes the element. Opposite of render().
	   */

	  NProgress.remove = function() {
	    removeClass(document.documentElement, &#x27;nprogress-busy&#x27;);
	    removeClass(document.querySelector(Settings.parent), &#x27;nprogress-custom-parent&#x27;);
	    var progress = document.getElementById(&#x27;nprogress&#x27;);
	    progress &amp;&amp; removeElement(progress);
	  };

	  /**
	   * Checks if the progress bar is rendered.
	   */

	  NProgress.isRendered = function() {
	    return !!document.getElementById(&#x27;nprogress&#x27;);
	  };

	  /**
	   * Determine which positioning CSS rule to use.
	   */

	  NProgress.getPositioningCSS = function() {
	    // Sniff on document.body.style
	    var bodyStyle = document.body.style;

	    // Sniff prefixes
	    var vendorPrefix = (&#x27;WebkitTransform&#x27; in bodyStyle) ? &#x27;Webkit&#x27; :
	                       (&#x27;MozTransform&#x27; in bodyStyle) ? &#x27;Moz&#x27; :
	                       (&#x27;msTransform&#x27; in bodyStyle) ? &#x27;ms&#x27; :
	                       (&#x27;OTransform&#x27; in bodyStyle) ? &#x27;O&#x27; : &#x27;&#x27;;

	    if (vendorPrefix + &#x27;Perspective&#x27; in bodyStyle) {
	      // Modern browsers with 3D support, e.g. Webkit, IE10
	      return &#x27;translate3d&#x27;;
	    } else if (vendorPrefix + &#x27;Transform&#x27; in bodyStyle) {
	      // Browsers without 3D support, e.g. IE9
	      return &#x27;translate&#x27;;
	    } else {
	      // Browsers without translate() support, e.g. IE7-8
	      return &#x27;margin&#x27;;
	    }
	  };

	  /**
	   * Helpers
	   */

	  function clamp(n, min, max) {
	    if (n &lt; min) return min;
	    if (n &gt; max) return max;
	    return n;
	  }

	  /**
	   * (Internal) converts a percentage (&#x60;0..1&#x60;) to a bar translateX
	   * percentage (&#x60;-100%..0%&#x60;).
	   */

	  function toBarPerc(n) {
	    return (-1 + n) * 100;
	  }


	  /**
	   * (Internal) returns the correct CSS for changing the bar&#x27;s
	   * position given an n percentage, and speed and ease from Settings
	   */

	  function barPositionCSS(n, speed, ease) {
	    var barCSS;

	    if (Settings.positionUsing === &#x27;translate3d&#x27;) {
	      barCSS = { transform: &#x27;translate3d(&#x27;+toBarPerc(n)+&#x27;%,0,0)&#x27; };
	    } else if (Settings.positionUsing === &#x27;translate&#x27;) {
	      barCSS = { transform: &#x27;translate(&#x27;+toBarPerc(n)+&#x27;%,0)&#x27; };
	    } else {
	      barCSS = { &#x27;margin-left&#x27;: toBarPerc(n)+&#x27;%&#x27; };
	    }

	    barCSS.transition = &#x27;all &#x27;+speed+&#x27;ms &#x27;+ease;

	    return barCSS;
	  }

	  /**
	   * (Internal) Queues a function to be executed.
	   */

	  var queue = (function() {
	    var pending = [];
	    
	    function next() {
	      var fn = pending.shift();
	      if (fn) {
	        fn(next);
	      }
	    }

	    return function(fn) {
	      pending.push(fn);
	      if (pending.length == 1) next();
	    };
	  })();

	  /**
	   * (Internal) Applies css properties to an element, similar to the jQuery 
	   * css method.
	   *
	   * While this helper does assist with vendor prefixed property names, it 
	   * does not perform any manipulation of values prior to setting styles.
	   */

	  var css = (function() {
	    var cssPrefixes = [ &#x27;Webkit&#x27;, &#x27;O&#x27;, &#x27;Moz&#x27;, &#x27;ms&#x27; ],
	        cssProps    = {};

	    function camelCase(string) {
	      return string.replace(/^-ms-/, &#x27;ms-&#x27;).replace(/-([\da-z])/gi, function(match, letter) {
	        return letter.toUpperCase();
	      });
	    }

	    function getVendorProp(name) {
	      var style = document.body.style;
	      if (name in style) return name;

	      var i = cssPrefixes.length,
	          capName = name.charAt(0).toUpperCase() + name.slice(1),
	          vendorName;
	      while (i--) {
	        vendorName = cssPrefixes[i] + capName;
	        if (vendorName in style) return vendorName;
	      }

	      return name;
	    }

	    function getStyleProp(name) {
	      name = camelCase(name);
	      return cssProps[name] || (cssProps[name] = getVendorProp(name));
	    }

	    function applyCss(element, prop, value) {
	      prop = getStyleProp(prop);
	      element.style[prop] = value;
	    }

	    return function(element, properties) {
	      var args = arguments,
	          prop, 
	          value;

	      if (args.length == 2) {
	        for (prop in properties) {
	          value = properties[prop];
	          if (value !== undefined &amp;&amp; properties.hasOwnProperty(prop)) applyCss(element, prop, value);
	        }
	      } else {
	        applyCss(element, args[1], args[2]);
	      }
	    }
	  })();

	  /**
	   * (Internal) Determines if an element or space separated list of class names contains a class name.
	   */

	  function hasClass(element, name) {
	    var list = typeof element == &#x27;string&#x27; ? element : classList(element);
	    return list.indexOf(&#x27; &#x27; + name + &#x27; &#x27;) &gt;= 0;
	  }

	  /**
	   * (Internal) Adds a class to an element.
	   */

	  function addClass(element, name) {
	    var oldList = classList(element),
	        newList = oldList + name;

	    if (hasClass(oldList, name)) return; 

	    // Trim the opening space.
	    element.className = newList.substring(1);
	  }

	  /**
	   * (Internal) Removes a class from an element.
	   */

	  function removeClass(element, name) {
	    var oldList = classList(element),
	        newList;

	    if (!hasClass(element, name)) return;

	    // Replace the class name.
	    newList = oldList.replace(&#x27; &#x27; + name + &#x27; &#x27;, &#x27; &#x27;);

	    // Trim the opening and closing spaces.
	    element.className = newList.substring(1, newList.length - 1);
	  }

	  /**
	   * (Internal) Gets a space separated list of the class names on the element. 
	   * The list is wrapped with a single space on each end to facilitate finding 
	   * matches within the list.
	   */

	  function classList(element) {
	    return (&#x27; &#x27; + (element.className || &#x27;&#x27;) + &#x27; &#x27;).replace(/\s+/gi, &#x27; &#x27;);
	  }

	  /**
	   * (Internal) Removes an element from the DOM.
	   */

	  function removeElement(element) {
	    element &amp;&amp; element.parentNode &amp;&amp; element.parentNode.removeChild(element);
	  }

	  return NProgress;
	});



/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		&quot;use strict&quot;;

		if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) {

			// For CommonJS and CommonJS-like environments where a proper &#x60;window&#x60;
			// is present, execute the factory and get jQuery.
			// For environments that do not have a &#x60;window&#x60; with a &#x60;document&#x60;
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real &#x60;window&#x60;.
			// e.g. var jQuery = require(&quot;jquery&quot;)(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( &quot;jQuery requires a window with a document&quot; );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal ) {

	// Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	&quot;use strict&quot;;

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};

	var isFunction = function isFunction( obj ) {

	      // Support: Chrome &lt;=57, Firefox &lt;=52
	      // In some browsers, typeof returns &quot;function&quot; for HTML &lt;object&gt; elements
	      // (i.e., &#x60;typeof document.createElement( &quot;object&quot; ) === &quot;function&quot;&#x60;).
	      // We don&#x27;t want to classify *any* DOM node as a function.
	      return typeof obj === &quot;function&quot; &amp;&amp; typeof obj.nodeType !== &quot;number&quot;;
	  };


	var isWindow = function isWindow( obj ) {
			return obj != null &amp;&amp; obj === obj.window;
		};




		var preservedScriptAttributes = {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc = doc || document;

			var i,
				script = doc.createElement( &quot;script&quot; );

			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] = node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj == null ) {
			return obj + &quot;&quot;;
		}

		// Support: Android &lt;=2.3 only (functionish RegExp)
		return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
			class2type[ toString.call( obj ) ] || &quot;object&quot; :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = &quot;3.3.1&quot;,

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor &#x27;enhanced&#x27;
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android &lt;=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num &lt; 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i &lt; 0 ? len : 0 );
			return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array&#x27;s method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === &quot;boolean&quot; ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== &quot;object&quot; &amp;&amp; !isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i &lt; length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we&#x27;re merging plain objects or arrays
					if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src &amp;&amp; Array.isArray( src ) ? src : [];

						} else {
							clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don&#x27;t bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== &quot;[object Object]&quot; ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., &#x60;Object.create( null )&#x60;) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, &quot;constructor&quot; ) &amp;&amp; proto.constructor;
			return typeof Ctor === &quot;function&quot; &amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i &lt; length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android &lt;=4.0 only
		trim: function( text ) {
			return text == null ?
				&quot;&quot; :
				( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === &quot;string&quot; ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android &lt;=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j &lt; len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i &lt; length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i &lt; length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === &quot;function&quot; ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( &quot;Boolean Number String Function Array Date RegExp Object Error Symbol&quot;.split( &quot; &quot; ),
	function( i, name ) {
		class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// &#x60;in&#x60; check used to prevent JIT error (gh-2145)
		// hasOwn isn&#x27;t used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,
			type = toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type === &quot;array&quot; || length === 0 ||
			typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = &quot;sizzle&quot; + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it&#x27;s faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i &lt; len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = &quot;(?:\\\\.|[\\w-]|[^\0-\\xa0])+&quot;,

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + identifier + &quot;)(?:&quot; + whitespace +
			// Operator (capture 2)
			&quot;*([*^$|!~]?=)&quot; + whitespace +
			// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;
			&quot;*(?:&#x27;((?:\\\\.|[^\\\\&#x27;])*)&#x27;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot; + identifier + &quot;))|)&quot; + whitespace +
			&quot;*\\]&quot;,

		pseudos = &quot;:(&quot; + identifier + &quot;)(?:\\((&quot; +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			&quot;(&#x27;((?:\\\\.|[^\\\\&#x27;])*)&#x27;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot; +
			// 2. simple (capture 6)
			&quot;((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes + &quot;)*)|&quot; +
			// 3. anything else (capture 2)
			&quot;.*&quot; +
			&quot;)\\)|)&quot;,

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + &quot;+&quot;, &quot;g&quot; ),
		rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),

		rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
		rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),

		rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]&#x27;\&quot;]*?)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),

		matchExpr = {
			&quot;ID&quot;: new RegExp( &quot;^#(&quot; + identifier + &quot;)&quot; ),
			&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + identifier + &quot;)&quot; ),
			&quot;TAG&quot;: new RegExp( &quot;^(&quot; + identifier + &quot;|[*])&quot; ),
			&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
			&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
			&quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
				&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
				&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
			&quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
			// For use in libraries implementing .is()
			// We use this for POS matching in &#x60;select&#x60;
			&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
				whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = &quot;0x&quot; + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox&lt;24
			// Workaround erroneous numeric interpretation of +&quot;0x&quot;
			return high !== high || escapedWhitespace ?
				escaped :
				high &lt; 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === &quot;\0&quot; ) {
					return &quot;\uFFFD&quot;;
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + &quot;\\&quot; + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + &quot; &quot;;
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return &quot;\\&quot; + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a &quot;Permission Denied&quot;
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true &amp;&amp; (&quot;form&quot; in elem || &quot;label&quot; in elem);
			},
			{ dir: &quot;parentNode&quot;, next: &quot;legend&quot; }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android&lt;4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE&lt;9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can&#x27;t trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context &amp;&amp; context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== &quot;string&quot; || !selector ||
			nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a &quot;get*By*&quot; DOM method
				// (excepting DocumentFragment context, where the methods don&#x27;t exist)
				if ( nodeType !== 11 &amp;&amp; (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext &amp;&amp; (elem = newContext.getElementById( m )) &amp;&amp;
								contains( context, elem ) &amp;&amp;
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp;
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &amp;&amp;
					!compilerCache[ selector + &quot; &quot; ] &amp;&amp;
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE &lt;=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== &quot;object&quot; ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( &quot;id&quot; )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( &quot;id&quot;, (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = &quot;#&quot; + nid + &quot; &quot; + toSelector( groups[i] );
						}
						newSelector = groups.join( &quot;,&quot; );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( &quot;id&quot; );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + &quot; &quot; ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement(&quot;fieldset&quot;);

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split(&quot;|&quot;),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b &amp;&amp; a,
			diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === &quot;input&quot; &amp;&amp; elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] &gt; legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( &quot;form&quot; in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a &quot;form&quot; property.
				if ( elem.parentNode &amp;&amp; elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( &quot;label&quot; in elem ) {
						if ( &quot;label&quot; in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &amp;&amp;
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can&#x27;t be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn&#x27;t
			// even exist on them, let alone have a boolean value.
			} else if ( &quot;label&quot; in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context &amp;&amp; typeof context.getElementsByTagName !== &quot;undefined&quot; &amp;&amp; context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn&#x27;t yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws &quot;permission denied&quot; errors (jQuery #13936)
		if ( preferredDoc !== document &amp;&amp;
			(subWindow = document.defaultView) &amp;&amp; subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( &quot;unload&quot;, unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( &quot;onunload&quot;, unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE&lt;8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = &quot;i&quot;;
			return !el.getAttribute(&quot;className&quot;);
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName(&quot;*&quot;) returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment(&quot;&quot;) );
			return !el.getElementsByTagName(&quot;*&quot;).length;
		});

		// Support: IE&lt;9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE&lt;10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don&#x27;t pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter[&quot;ID&quot;] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute(&quot;id&quot;) === attrId;
				};
			};
			Expr.find[&quot;ID&quot;] = function( id, context ) {
				if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter[&quot;ID&quot;] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== &quot;undefined&quot; &amp;&amp;
						elem.getAttributeNode(&quot;id&quot;);
					return node &amp;&amp; node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find[&quot;ID&quot;] = function( id, context ) {
				if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode(&quot;id&quot;);
						if ( node &amp;&amp; node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode(&quot;id&quot;);
							if ( node &amp;&amp; node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don&#x27;t have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === &quot;*&quot; ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
			if ( typeof context.getElementsByClassName !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever &#x60;document.activeElement&#x60; is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE&#x27;s treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = &quot;&lt;a id=&#x27;&quot; + expando + &quot;&#x27;&gt;&lt;/a&gt;&quot; +
					&quot;&lt;select id=&#x27;&quot; + expando + &quot;-\r\\&#x27; msallowcapture=&#x27;&#x27;&gt;&quot; +
					&quot;&lt;option selected=&#x27;&#x27;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll(&quot;[msallowcapture^=&#x27;&#x27;]&quot;).length ) {
					rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:&#x27;&#x27;|\&quot;\&quot;)&quot; );
				}

				// Support: IE8
				// Boolean attributes and &quot;value&quot; are not treated correctly
				if ( !el.querySelectorAll(&quot;[selected]&quot;).length ) {
					rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
				}

				// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+
				if ( !el.querySelectorAll( &quot;[id~=&quot; + expando + &quot;-]&quot; ).length ) {
					rbuggyQSA.push(&quot;~=&quot;);
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(&quot;:checked&quot;).length ) {
					rbuggyQSA.push(&quot;:checked&quot;);
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page &#x60;selector#id sibling-combinator selector&#x60; fails
				if ( !el.querySelectorAll( &quot;a#&quot; + expando + &quot;+*&quot; ).length ) {
					rbuggyQSA.push(&quot;.#.+[+~]&quot;);
				}
			});

			assert(function( el ) {
				el.innerHTML = &quot;&lt;a href=&#x27;&#x27; disabled=&#x27;disabled&#x27;&gt;&lt;/a&gt;&quot; +
					&quot;&lt;select disabled=&#x27;disabled&#x27;&gt;&lt;option/&gt;&lt;/select&gt;&quot;;

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement(&quot;input&quot;);
				input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
				el.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll(&quot;[name=d]&quot;).length ) {
					rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?=&quot; );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(&quot;:enabled&quot;).length !== 2 ) {
					rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
				}

				// Support: IE9-11+
				// IE&#x27;s :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(&quot;:disabled&quot;).length !== 2 ) {
					rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll(&quot;*,:x&quot;);
				rbuggyQSA.push(&quot;,.*:&quot;);
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it&#x27;s possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, &quot;*&quot; );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, &quot;[s!=&#x27;&#x27;]:x&quot; );
				rbuggyMatches.push( &quot;!=&quot;, pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
		rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b &amp;&amp; b.parentNode;
				return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare &amp; 1 ||
				(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare &amp; 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, &quot;=&#x27;$1&#x27;]&quot; );

		if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
			!compilerCache[ expr + &quot; &quot; ] &amp;&amp;
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9&#x27;s matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length &gt; 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don&#x27;t get fooled by Object.prototype properties (jQuery #13807)
			val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + &quot;&quot;).replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = &quot;&quot;,
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === &quot;string&quot; ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
			&quot; &quot;: { dir: &quot;parentNode&quot; },
			&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
			&quot;~&quot;: { dir: &quot;previousSibling&quot; }
		},

		preFilter: {
			&quot;ATTR&quot;: function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );

				if ( match[2] === &quot;~=&quot; ) {
					match[3] = &quot; &quot; + match[3] + &quot; &quot;;
				}

				return match.slice( 0, 4 );
			},

			&quot;CHILD&quot;: function( match ) {
				/* matches from matchExpr[&quot;CHILD&quot;]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			&quot;PSEUDO&quot;: function( match ) {
				var excess,
					unquoted = !match[6] &amp;&amp; match[2];

				if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || &quot;&quot;;

				// Strip excess characters from unquoted arguments
				} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &amp;&amp;
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			&quot;TAG&quot;: function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === &quot;*&quot; ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
					};
			},

			&quot;CLASS&quot;: function( className ) {
				var pattern = classCache[ className + &quot; &quot; ];

				return pattern ||
					(pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== &quot;undefined&quot; &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
					});
			},

			&quot;ATTR&quot;: function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === &quot;!=&quot;;
					}
					if ( !operator ) {
						return true;
					}

					result += &quot;&quot;;

					return operator === &quot;=&quot; ? result === check :
						operator === &quot;!=&quot; ? result !== check :
						operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
						operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
						operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
						operator === &quot;~=&quot; ? ( &quot; &quot; + result.replace( rwhitespace, &quot; &quot; ) + &quot; &quot; ).indexOf( check ) &gt; -1 :
						operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
						false;
				};
			},

			&quot;CHILD&quot;: function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
					forward = type.slice( -4 ) !== &quot;last&quot;,
					ofType = what === &quot;of-type&quot;;

				return first === 1 &amp;&amp; last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
							parent = elem.parentNode,
							name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
							useCache = !xml &amp;&amp; !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven&#x27;t yet done so)
									start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on &#x60;parent&#x60;
							if ( forward &amp;&amp; useCache ) {

								// Seek &#x60;elem&#x60; from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE &lt;9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
								diff = nodeIndex &amp;&amp; cache[ 2 ];
								node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||

									// Fallback to seeking &#x60;elem&#x60; from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on &#x60;parent&#x60; and break
									if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE &lt;9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek &#x60;elem&#x60; from the start
									while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &amp;&amp;
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE &lt;9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
						}
					};
			},

			&quot;PSEUDO&quot;: function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length &gt; 1 ) {
					args = [ pseudo, pseudo, &quot;&quot;, argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			&quot;not&quot;: markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by &#x60;matcher&#x60;
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don&#x27;t keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			&quot;has&quot;: markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length &gt; 0;
				};
			}),

			&quot;contains&quot;: markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
				};
			}),

			// &quot;Whether an element is represented by a :lang() selector
			// is based solely on the element&#x27;s language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by &quot;-&quot;.
			// The matching of C against the element&#x27;s language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name.&quot;
			// http://www.w3.org/TR/selectors/#lang-pseudo
			&quot;lang&quot;: markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || &quot;&quot;) ) {
					Sizzle.error( &quot;unsupported lang: &quot; + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
						}
					} while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			&quot;target&quot;: function( elem ) {
				var hash = window.location &amp;&amp; window.location.hash;
				return hash &amp;&amp; hash.slice( 1 ) === elem.id;
			},

			&quot;root&quot;: function( elem ) {
				return elem === docElem;
			},

			&quot;focus&quot;: function( elem ) {
				return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			&quot;enabled&quot;: createDisabledPseudo( false ),
			&quot;disabled&quot;: createDisabledPseudo( true ),

			&quot;checked&quot;: function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
			},

			&quot;selected&quot;: function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			&quot;empty&quot;: function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType &lt; 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType &lt; 6 ) {
						return false;
					}
				}
				return true;
			},

			&quot;parent&quot;: function( elem ) {
				return !Expr.pseudos[&quot;empty&quot;]( elem );
			},

			// Element/input types
			&quot;header&quot;: function( elem ) {
				return rheader.test( elem.nodeName );
			},

			&quot;input&quot;: function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			&quot;button&quot;: function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
			},

			&quot;text&quot;: function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
					elem.type === &quot;text&quot; &amp;&amp;

					// Support: IE&lt;8
					// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;
					( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === &quot;text&quot; );
			},

			// Position-in-collection
			&quot;first&quot;: createPositionalPseudo(function() {
				return [ 0 ];
			}),

			&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument &lt; 0 ? argument + length : argument ];
			}),

			&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i &lt; length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i &lt; length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument &lt; 0 ? argument + length : argument;
				for ( ; --i &gt;= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument &lt; 0 ? argument + length : argument;
				for ( ; ++i &lt; length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + &quot; &quot; ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don&#x27;t consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, &quot; &quot; )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we&#x27;re just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = &quot;&quot;;
		for ( ; i &lt; len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base &amp;&amp; key === &quot;parentNode&quot;,
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can&#x27;t set arbitrary data on XML nodes, so they don&#x27;t benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE &lt;9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip &amp;&amp; skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &amp;&amp;
								oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we&#x27;re done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length &gt; 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i &lt; len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i &lt; len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &amp;&amp;
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) &gt; -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i &lt; len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j &lt; len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i &gt; 1 &amp;&amp; elementMatcher( matchers ),
						i &gt; 1 &amp;&amp; toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element &#x60;*&#x60;
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
						).replace( rtrim, &quot;$1&quot; ),
						matcher,
						i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
						j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
						j &lt; len &amp;&amp; toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length &gt; 0,
			byElement = elementMatchers.length &gt; 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = &quot;0&quot;,
					unmatched = seed &amp;&amp; [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE&lt;9, Safari
				// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
				for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {
					if ( byElement &amp;&amp; elem ) {
						j = 0;
						if ( !context &amp;&amp; elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher &amp;&amp; elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// &#x60;i&#x60; is now the count of elements visited above, and adding it to &#x60;matchedCount&#x60;
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., &#x60;matchedCount&#x60;
				// equals &#x60;i&#x60;), unless we didn&#x27;t visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string &quot;0&quot; &#x60;i&#x60; allows &#x60;i&#x60; to remain a string only in that
				// case, which will result in a &quot;00&quot; &#x60;matchedCount&#x60; that differs from &#x60;i&#x60; but is also
				// numerically zero.
				if ( bySet &amp;&amp; i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount &gt; 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
						( matchedCount + setMatchers.length ) &gt; 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + &quot; &quot; ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle&#x27;s compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === &quot;function&quot; &amp;&amp; selector,
			match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
					context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length &amp;&amp; toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide &#x60;match&#x60; to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren&#x27;t passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement(&quot;fieldset&quot;) ) &amp; 1;
	});

	// Support: IE&lt;8
	// Prevent attribute/property &quot;interpolation&quot;
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;/a&gt;&quot;;
		return el.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
	}) ) {
		addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
			}
		});
	}

	// Support: IE&lt;9
	// Use defaultValue in place of getAttribute(&quot;value&quot;)
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = &quot;&lt;input/&gt;&quot;;
		el.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
		return el.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;;
	}) ) {
		addHandle( &quot;value&quot;, function( elem, name, isXML ) {
			if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE&lt;9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute(&quot;disabled&quot;) == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ &quot;:&quot; ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) &amp;&amp; elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== &quot;string&quot; ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) &gt; -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = &quot;:not(&quot; + expr + &quot;)&quot;;
		}

		if ( elems.length === 1 &amp;&amp; elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== &quot;string&quot; ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i &lt; len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i &lt; len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len &gt; 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&#x27;t return true for a doc with two &quot;p&quot;.
				typeof selector === &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with &lt;)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === &quot;string&quot; ) {
				if ( selector[ 0 ] === &quot;&lt;&quot; &amp;&amp;
					selector[ selector.length - 1 ] === &quot;&gt;&quot; &amp;&amp;
					selector.length &gt;= 3 ) {

					// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match &amp;&amp; ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -&gt; $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i &lt; l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== &quot;string&quot; &amp;&amp; jQuery( selectors );

			// Positional selectors never match, since there&#x27;s no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i &lt; l; i++ ) {
					for ( cur = this[ i ]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType &lt; 11 &amp;&amp; ( targets ?
							targets.index( cur ) &gt; -1 :

							// Don&#x27;t pass non-elements to Sizzle
							cur.nodeType === 1 &amp;&amp;
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length &gt; 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] &amp;&amp; this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === &quot;string&quot; ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) &amp;&amp; cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, &quot;parentNode&quot; );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, &quot;parentNode&quot;, until );
		},
		next: function( elem ) {
			return sibling( elem, &quot;nextSibling&quot; );
		},
		prev: function( elem ) {
			return sibling( elem, &quot;previousSibling&quot; );
		},
		nextAll: function( elem ) {
			return dir( elem, &quot;nextSibling&quot; );
		},
		prevAll: function( elem ) {
			return dir( elem, &quot;previousSibling&quot; );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, &quot;nextSibling&quot;, until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, &quot;previousSibling&quot;, until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, &quot;iframe&quot; ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser &lt;=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don&#x27;t support it.
	        if ( nodeName( elem, &quot;template&quot; ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== &quot;Until&quot; ) {
				selector = until;
			}

			if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length &gt; 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * &quot;fired&quot; multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest &quot;memorized&quot;
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === &quot;string&quot; ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex &lt; list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &amp;&amp;
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn&#x27;t re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we&#x27;re done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we&#x27;re done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = &quot;&quot;;
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory &amp;&amp; !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg &amp;&amp; arg.length &amp;&amp; toType( arg ) !== &quot;string&quot; ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory &amp;&amp; !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index &lt;= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) &gt; -1 :
						list.length &gt; 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = &quot;&quot;;
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory &amp;&amp; !firing ) {
						list = memory = &quot;&quot;;
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value &amp;&amp; isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value &amp;&amp; isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control &#x60;resolve&#x60; arguments by letting Array#slice cast boolean &#x60;noValue&#x60; to integer:
				// * false: [ value ].slice( 0 ) =&gt; resolve( value )
				// * true: [ value ].slice( 1 ) =&gt; resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn&#x27;t unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks( &quot;memory&quot; ),
						jQuery.Callbacks( &quot;memory&quot; ), 2 ],
					[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
						jQuery.Callbacks( &quot;once memory&quot; ), 0, &quot;resolved&quot; ],
					[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
						jQuery.Callbacks( &quot;once memory&quot; ), 1, &quot;rejected&quot; ]
				],
				state = &quot;pending&quot;,
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					&quot;catch&quot;: function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) &amp;&amp; fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn &amp;&amp; fn.apply( this, arguments );
									if ( returned &amp;&amp; isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + &quot;With&quot; ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth &lt; maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( &quot;Thenable self-resolution&quot; );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve &#x60;then&#x60; only once
										then = returned &amp;&amp;

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === &quot;object&quot; ||
												typeof returned === &quot;function&quot; ) &amp;&amp;
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 &gt;= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it&#x27;s otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = &quot;resolved&quot; (i.e., fulfilled)
							// state = &quot;rejected&quot;
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + &quot;With&quot; ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + &quot;With&quot; ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining &lt;= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === &quot;pending&quot; ||
					isFunction( resolveValues[ i ] &amp;&amp; resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console &amp;&amp; window.console.warn &amp;&amp; error &amp;&amp; rerrorNames.test( error.name ) ) {
			window.console.warn( &quot;jQuery.Deferred exception: &quot; + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we&#x27;re already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( &quot;DOMContentLoaded&quot;, completed );
		window.removeEventListener( &quot;load&quot;, completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE &lt;=9 - 10 only
	// Older IE sometimes signals &quot;interactive&quot; too soon
	if ( document.readyState === &quot;complete&quot; ||
		( document.readyState !== &quot;loading&quot; &amp;&amp; !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( &quot;DOMContentLoaded&quot;, completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( &quot;load&quot;, completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it&#x27;s a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === &quot;object&quot; ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i &lt; len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE &lt;=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === &quot;string&quot; ) {
				cache[ camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] &amp;&amp; owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the &quot;read&quot; path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key &amp;&amp; typeof key === &quot;string&quot; ) &amp;&amp; value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the &quot;set&quot; path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there&#x27;s no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome &lt;=35 - 45
				// Webkit &amp; Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined &amp;&amp; !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module&#x27;s maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.
	//	4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === &quot;true&quot; ) {
			return true;
		}

		if ( data === &quot;false&quot; ) {
			return false;
		}

		if ( data === &quot;null&quot; ) {
			return null;
		}

		// Only convert to a number if it doesn&#x27;t change the string
		if ( data === +data + &quot;&quot; ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {
			name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$&amp;&quot; ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === &quot;string&quot; ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn&#x27;t changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem &amp;&amp; elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 &amp;&amp; !dataPriv.get( elem, &quot;hasDataAttrs&quot; ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, &quot;hasDataAttrs&quot;, true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === &quot;object&quot; ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// &#x60;value&#x60; parameter was not undefined. An empty jQuery object
				// will result in &#x60;undefined&#x60; for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem &amp;&amp; value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to &quot;discover&quot; the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn&#x27;t exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length &gt; 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || &quot;fx&quot;;

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === &quot;inprogress&quot; ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === &quot;fx&quot; ) {
					queue.unshift( &quot;inprogress&quot; );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength &amp;&amp; hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + &quot;queueHooks&quot;;
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( &quot;once memory&quot; ).add( function() {
					dataPriv.remove( elem, [ type + &quot;queue&quot;, key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== &quot;string&quot; ) {
				data = type;
				type = &quot;fx&quot;;
				setter--;
			}

			if ( arguments.length &lt; setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === &quot;fx&quot; &amp;&amp; queue[ 0 ] !== &quot;inprogress&quot; ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || &quot;fx&quot;, [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== &quot;string&quot; ) {
				obj = type;
				type = undefined;
			}
			type = type || &quot;fx&quot;;

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + &quot;queueHooks&quot; );
				if ( tmp &amp;&amp; tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( &quot;^(?:([+-])=|)(&quot; + pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; );


	var cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === &quot;none&quot; ||
				elem.style.display === &quot;&quot; &amp;&amp;

				// Otherwise, check computed style
				// Support: Firefox &lt;=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &amp;&amp;

				jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot;;
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, &quot;&quot; );
				},
			initial = currentValue(),
			unit = valueParts &amp;&amp; valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== &quot;px&quot; &amp;&amp; +initial ) &amp;&amp;
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit &amp;&amp; initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox &lt;=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) &lt;= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, &quot;display&quot; );

		temp.parentNode.removeChild( temp );

		if ( display === &quot;none&quot; ) {
			display = &quot;block&quot;;
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index &lt; length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === &quot;none&quot; ) {
					values[ index ] = dataPriv.get( elem, &quot;display&quot; ) || null;
					if ( !values[ index ] ) {
						elem.style.display = &quot;&quot;;
					}
				}
				if ( elem.style.display === &quot;&quot; &amp;&amp; isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== &quot;none&quot; ) {
					values[ index ] = &quot;none&quot;;

					// Remember what we&#x27;re overwriting
					dataPriv.set( elem, &quot;display&quot;, display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index &lt; length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === &quot;boolean&quot; ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /&lt;([a-z][^\/\0&gt;\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE &lt;=9 only
		option: [ 1, &quot;&lt;select multiple=&#x27;multiple&#x27;&gt;&quot;, &quot;&lt;/select&gt;&quot; ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting &lt;tbody&gt; or other required elements.
		thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
		col: [ 2, &quot;&lt;table&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
		tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
		td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],

		_default: [ 0, &quot;&quot;, &quot;&quot; ]
	};

	// Support: IE &lt;=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE &lt;=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
			ret = context.getElementsByTagName( tag || &quot;*&quot; );

		} else if ( typeof context.querySelectorAll !== &quot;undefined&quot; ) {
			ret = context.querySelectorAll( tag || &quot;*&quot; );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag &amp;&amp; nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i &lt; l; i++ ) {
			dataPriv.set(
				elems[ i ],
				&quot;globalEval&quot;,
				!refElements || dataPriv.get( refElements[ i ], &quot;globalEval&quot; )
			);
		}
	}


	var rhtml = /&lt;|&amp;#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i &lt; l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === &quot;object&quot; ) {

					// Support: Android &lt;=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( &quot;div&quot; ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android &lt;=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = &quot;&quot;;
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = &quot;&quot;;

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection &amp;&amp; jQuery.inArray( elem, selection ) &gt; -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), &quot;script&quot; );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || &quot;&quot; ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( &quot;div&quot; ) ),
			input = document.createElement( &quot;input&quot; );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// &#x60;name&#x60; and &#x60;type&#x60; must use .setAttribute for WWA (#14901)
		input.setAttribute( &quot;type&quot;, &quot;radio&quot; );
		input.setAttribute( &quot;checked&quot;, &quot;checked&quot; );
		input.setAttribute( &quot;name&quot;, &quot;t&quot; );

		div.appendChild( input );

		// Support: Android &lt;=4.1 only
		// Older WebKit doesn&#x27;t clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE &lt;=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = &quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;;
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE &lt;=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === &quot;object&quot; ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== &quot;string&quot; ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null &amp;&amp; fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === &quot;string&quot; ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards&#x27; addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don&#x27;t attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element&#x27;s event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== &quot;undefined&quot; &amp;&amp; jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( &quot;.&quot; )
				}, handleObjIn );

				// Init the event handler queue if we&#x27;re the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element&#x27;s handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) &amp;&amp; dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &amp;&amp;
					new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
						( !handler || handler.guid === handleObj.guid ) &amp;&amp;
						( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
						( !selector || selector === handleObj.selector ||
							selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount &amp;&amp; !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it&#x27;s no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, &quot;handle events&quot; );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, &quot;events&quot; ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i &lt; arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &amp;&amp;
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &amp;&amp;

				// Support: IE &lt;=9
				// Black-hole SVG &lt;use&gt; instance trees (trac-13180)
				cur.nodeType &amp;&amp;

				// Support: Firefox &lt;=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key &quot;clicks&quot; of radio inputs, which can have &#x60;button&#x60; -1 (gh-2343)
				!( event.type === &quot;click&quot; &amp;&amp; event.button &gt;= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don&#x27;t check non-elements (#13208)
					// Don&#x27;t process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 &amp;&amp; !( event.type === &quot;click&quot; &amp;&amp; cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i &lt; delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don&#x27;t conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + &quot; &quot;;

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) &gt; -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount &lt; handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: &quot;focusin&quot;
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() &amp;&amp; this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: &quot;focusout&quot;
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === &quot;checkbox&quot; &amp;&amp; this.click &amp;&amp; nodeName( this, &quot;input&quot; ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don&#x27;t fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, &quot;a&quot; );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn&#x27;t alert if the returnValue field is not set.
					if ( event.result !== undefined &amp;&amp; event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This &quot;if&quot; is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the &#x27;new&#x27; keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src &amp;&amp; src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &amp;&amp;

					// Support: Android &lt;=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari &lt;=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target &amp;&amp; src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn&#x27;t have one
		this.timeStamp = src &amp;&amp; src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e &amp;&amp; !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e &amp;&amp; !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e &amp;&amp; !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		&quot;char&quot;: true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null &amp;&amp; rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which &amp;&amp; button !== undefined &amp;&amp; rmouseEvent.test( event.type ) ) {
				if ( button &amp; 1 ) {
					return 1;
				}

				if ( button &amp; 2 ) {
					return 3;
				}

				if ( button &amp; 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: &quot;mouseover&quot;,
		mouseleave: &quot;mouseout&quot;,
		pointerenter: &quot;pointerover&quot;,
		pointerleave: &quot;pointerout&quot;
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target &amp;&amp; !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + &quot;.&quot; + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === &quot;object&quot; ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === &quot;function&quot; ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi,

		/* eslint-enable */

		// Support: IE &lt;=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /&lt;script|&lt;style|&lt;link/i,

		// checked=&quot;checked&quot; or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, &quot;table&quot; ) &amp;&amp;
			nodeName( content.nodeType !== 11 ? content : content.firstChild, &quot;tr&quot; ) ) {

			return jQuery( elem ).children( &quot;tbody&quot; )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( &quot;type&quot; ) !== null ) + &quot;/&quot; + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || &quot;&quot; ).slice( 0, 5 ) === &quot;true/&quot; ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( &quot;type&quot; );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );

		// We can&#x27;t cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l &gt; 1 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp;
					!support.checkClone &amp;&amp; rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i &lt; l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android &lt;=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, &quot;script&quot; ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i &lt; hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp;
							!dataPriv.access( node, &quot;globalEval&quot; ) &amp;&amp;
							jQuery.contains( doc, node ) ) {

							if ( node.src &amp;&amp; ( node.type || &quot;&quot; ).toLowerCase()  !== &quot;module&quot; ) {

								// Optional AJAX dependency, but won&#x27;t run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, &quot;&quot; ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData &amp;&amp; node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, &quot;script&quot; ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked &amp;&amp; ( elem.nodeType === 1 || elem.nodeType === 11 ) &amp;&amp;
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, &quot;script&quot; );
			if ( destElements.length &gt; 0 ) {
				setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove&#x27;s overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome &lt;=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome &lt;=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = &quot;&quot;;
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
					!wrapMap[ ( rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i &lt; l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) &lt; 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: &quot;append&quot;,
		prependTo: &quot;prepend&quot;,
		insertBefore: &quot;before&quot;,
		insertAfter: &quot;after&quot;,
		replaceAll: &quot;replaceWith&quot;
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i &lt;= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android &lt;=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( &quot;^(&quot; + pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; );

	var getStyles = function( elem ) {

			// Support: IE &lt;=11 only, Firefox &lt;=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle = new RegExp( cssExpand.join( &quot;|&quot; ), &quot;i&quot; );



	( function() {

		// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout
		// so they&#x27;re executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText = &quot;position:absolute;left:-11111px;width:60px;&quot; +
				&quot;margin-top:1px;padding:0;border:0&quot;;
			div.style.cssText =
				&quot;position:relative;display:block;box-sizing:border-box;overflow:scroll;&quot; +
				&quot;margin:auto;border:1px;padding:1px;&quot; +
				&quot;width:60%;top:1%&quot;;
			documentElement.appendChild( container ).appendChild( div );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== &quot;1%&quot;;

			// Support: Android 4.0 - 4.3 only, Firefox &lt;=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

			// Support: Android 4.0 - 4.3 only, Safari &lt;=9.1 - 10.1, iOS &lt;=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn&#x27;t
			div.style.right = &quot;60%&quot;;
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position = &quot;absolute&quot;;
			scrollboxSizeVal = div.offsetWidth === 36 || &quot;absolute&quot;;

			documentElement.removeChild( container );

			// Nullify the div so it wouldn&#x27;t be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container = document.createElement( &quot;div&quot; ),
			div = document.createElement( &quot;div&quot; );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE &lt;=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = &quot;content-box&quot;;
		div.cloneNode( true ).style.backgroundClip = &quot;&quot;;
		support.clearCloneStyle = div.style.backgroundClip === &quot;content-box&quot;;

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css(&#x27;filter&#x27;) (IE 9 only, #12537)
		//   .css(&#x27;--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the &quot;awesome hack by Dean Edwards&quot;
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() &amp;&amp; rnumnonpx.test( ret ) &amp;&amp; rboxStyle.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE &lt;=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + &quot;&quot; :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we&#x27;ll check on the first run if it&#x27;s really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it&#x27;s not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
		cssNormalTransform = {
			letterSpacing: &quot;0&quot;,
			fontWeight: &quot;400&quot;
		},

		cssPrefixes = [ &quot;Webkit&quot;, &quot;Moz&quot;, &quot;ms&quot; ],
		emptyStyle = document.createElement( &quot;div&quot; ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || &quot;px&quot; ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === &quot;width&quot; ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ) {
			return 0;
		}

		for ( ; i &lt; 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === &quot;margin&quot; ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we&#x27;re seeking &quot;padding&quot; or &quot;border&quot; or &quot;margin&quot;
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );

				// For &quot;border&quot; or &quot;margin&quot;, add border
				if ( box !== &quot;padding&quot; ) {
					delta += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
				}

			// If we get here with a border-box (content + padding + border), we&#x27;re seeking &quot;content&quot; or
			// &quot;padding&quot; or &quot;margin&quot;
			} else {

				// For &quot;content&quot;, subtract padding
				if ( box === &quot;content&quot; ) {
					delta -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
				}

				// For &quot;content&quot; or &quot;padding&quot;, subtract border
				if ( box !== &quot;margin&quot; ) {
					delta -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox &amp;&amp; computedVal &gt;= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),
			val = curCSS( elem, dimension, styles ),
			isBorderBox = jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
			valueIsBorderBox = isBorderBox;

		// Support: Firefox &lt;=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = &quot;auto&quot;;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = valueIsBorderBox &amp;&amp;
			( support.boxSizingReliable() || val === elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is &quot;auto&quot;
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android &lt;=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val === &quot;auto&quot; ||
			!parseFloat( val ) &amp;&amp; jQuery.css( elem, &quot;display&quot;, false, styles ) === &quot;inline&quot; ) {

			val = elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox = true;
		}

		// Normalize &quot;&quot; and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element&#x27;s box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + &quot;px&quot;;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, &quot;opacity&quot; );
						return ret === &quot;&quot; ? &quot;1&quot; : ret;
					}
				}
			}
		},

		// Don&#x27;t automatically add &quot;px&quot; to these possibly-unitless properties
		cssNumber: {
			&quot;animationIterationCount&quot;: true,
			&quot;columnCount&quot;: true,
			&quot;fillOpacity&quot;: true,
			&quot;flexGrow&quot;: true,
			&quot;flexShrink&quot;: true,
			&quot;fontWeight&quot;: true,
			&quot;lineHeight&quot;: true,
			&quot;opacity&quot;: true,
			&quot;order&quot;: true,
			&quot;orphans&quot;: true,
			&quot;widows&quot;: true,
			&quot;zIndex&quot;: true,
			&quot;zoom&quot;: true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don&#x27;t set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we&#x27;re working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we&#x27;re working with the right name. We don&#x27;t
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we&#x27;re setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert &quot;+=&quot; or &quot;-=&quot; to relative numbers (#7345)
				if ( type === &quot;string&quot; &amp;&amp; ( ret = rcssNum.exec( value ) ) &amp;&amp; ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = &quot;number&quot;;
				}

				// Make sure that null and NaN values aren&#x27;t set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === &quot;number&quot; ) {
					value += ret &amp;&amp; ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? &quot;&quot; : &quot;px&quot; );
				}

				// background-* props affect original clone&#x27;s values
				if ( !support.clearCloneStyle &amp;&amp; value === &quot;&quot; &amp;&amp; name.indexOf( &quot;background&quot; ) === 0 ) {
					style[ name ] = &quot;inherit&quot;;
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( &quot;set&quot; in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp;
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we&#x27;re working with the right name. We don&#x27;t
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert &quot;normal&quot; to computed value
			if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === &quot;&quot; || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ &quot;height&quot;, &quot;width&quot; ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) &amp;&amp;

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth &amp; zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE &lt;=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
					subtract = extra &amp;&amp; boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox &amp;&amp; support.scrollboxSize() === styles.position ) {
					subtract -= Math.ceil(
						elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, &quot;border&quot;, false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract &amp;&amp; ( matches = rcssNum.exec( value ) ) &amp;&amp;
					( matches[ 3 ] || &quot;px&quot; ) !== &quot;px&quot; ) {

					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, &quot;marginLeft&quot; ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + &quot;px&quot;;
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: &quot;&quot;,
		padding: &quot;&quot;,
		border: &quot;Width&quot;
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === &quot;string&quot; ? value.split( &quot; &quot; ) : [ value ];

				for ( ; i &lt; 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== &quot;margin&quot; ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i &lt; len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length &gt; 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks &amp;&amp; hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks &amp;&amp; hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null &amp;&amp; tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as &quot;10px&quot; are parsed to Float;
				// complex values such as &quot;rotate(1rad)&quot; are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, &quot;&quot; );

				// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
				return !result || result === &quot;auto&quot; ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &amp;&amp;
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE &lt;=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: &quot;swing&quot;
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat &lt;1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false &amp;&amp; window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i &lt; 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ &quot;*&quot; ] ),
			index = 0,
			length = collection.length;
		for ( ; index &lt; length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We&#x27;re done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = &quot;width&quot; in props || &quot;height&quot; in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType &amp;&amp; isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, &quot;fxshow&quot; );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, &quot;fx&quot; );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === &quot;toggle&quot;;
				if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {

					// Pretend to be hidden if this is a &quot;show&quot; and
					// there is still data from a stopped show/hide
					if ( value === &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict &quot;overflow&quot; and &quot;display&quot; styles during box animations
		if ( isBox &amp;&amp; elem.nodeType === 1 ) {

			// Support: IE &lt;=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow &amp;&amp; dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, &quot;display&quot; );
			}
			display = jQuery.css( elem, &quot;display&quot; );
			if ( display === &quot;none&quot; ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, &quot;display&quot; );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === &quot;inline&quot; || display === &quot;inline-block&quot; &amp;&amp; restoreDisplay != null ) {
				if ( jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === &quot;none&quot; ? &quot;&quot; : display;
						}
					}
					style.display = &quot;inline-block&quot;;
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = &quot;hidden&quot;;
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( &quot;hidden&quot; in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, &quot;fxshow&quot;, { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so &#x60;.stop().toggle()&#x60; &quot;reverses&quot;
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a &quot;hide&quot; animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, &quot;fxshow&quot; );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won&#x27;t overwrite existing keys.
				// Reusing &#x27;index&#x27; because we have the correct &quot;name&quot;
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don&#x27;t match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won&#x27;t allow us to use &#x60;1 - ( 0.5 || 0 )&#x60; (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index &lt; length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there&#x27;s more to do, yield
				if ( percent &lt; 1 &amp;&amp; length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index &lt; length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index &lt; length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			&quot;*&quot;: [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ &quot;*&quot; ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index &lt; length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn &amp;&amp; easing ||
				isFunction( speed ) &amp;&amp; speed,
			duration: speed,
			easing: fn &amp;&amp; easing || easing &amp;&amp; !isFunction( easing ) &amp;&amp; easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== &quot;number&quot; ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = &quot;fx&quot;;
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( &quot;opacity&quot;, 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won&#x27;t be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, &quot;finish&quot; ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== &quot;string&quot; ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue &amp;&amp; type !== false ) {
				this.queue( type || &quot;fx&quot;, [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null &amp;&amp; type + &quot;queueHooks&quot;,
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] &amp;&amp; data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &amp;&amp;
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn&#x27;t forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || &quot;fx&quot;;
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + &quot;queue&quot; ],
					hooks = data[ type + &quot;queueHooks&quot; ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks &amp;&amp; hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index &lt; length; index++ ) {
					if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === &quot;boolean&quot; ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( &quot;show&quot; ),
		slideUp: genFx( &quot;hide&quot; ),
		slideToggle: genFx( &quot;toggle&quot; ),
		fadeIn: { opacity: &quot;show&quot; },
		fadeOut: { opacity: &quot;hide&quot; },
		fadeToggle: { opacity: &quot;toggle&quot; }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = Date.now();

		for ( ; i &lt; timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() &amp;&amp; timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || &quot;fx&quot;;

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( &quot;input&quot; ),
			select = document.createElement( &quot;select&quot; ),
			opt = select.appendChild( document.createElement( &quot;option&quot; ) );

		input.type = &quot;checkbox&quot;;

		// Support: Android &lt;=4.3 only
		// Default value for a checkbox should be &quot;on&quot;
		support.checkOn = input.value !== &quot;&quot;;

		// Support: IE &lt;=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE &lt;=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( &quot;input&quot; );
		input.value = &quot;t&quot;;
		input.type = &quot;radio&quot;;
		support.radioValue = input.value === &quot;t&quot;;
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don&#x27;t get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === &quot;undefined&quot; ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + &quot;&quot; );
				return value;
			}

			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp;
						nodeName( elem, &quot;input&quot; ) ) {
						var val = elem.value;
						elem.setAttribute( &quot;type&quot;, value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value &amp;&amp; value.match( rnothtmlwhite );

			if ( attrNames &amp;&amp; elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don&#x27;t get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE &lt;=9 - 11 only
					// elem.tabIndex doesn&#x27;t always return the
					// correct value when it hasn&#x27;t been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, &quot;tabindex&quot; );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &amp;&amp;
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			&quot;for&quot;: &quot;htmlFor&quot;,
			&quot;class&quot;: &quot;className&quot;
		}
	} );

	// Support: IE &lt;=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule &quot;no-unused-expressions&quot; is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: &quot;off&quot; */

				var parent = elem.parentNode;
				if ( parent &amp;&amp; parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: &quot;off&quot; */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		&quot;tabIndex&quot;,
		&quot;readOnly&quot;,
		&quot;maxLength&quot;,
		&quot;cellSpacing&quot;,
		&quot;cellPadding&quot;,
		&quot;rowSpan&quot;,
		&quot;colSpan&quot;,
		&quot;useMap&quot;,
		&quot;frameBorder&quot;,
		&quot;contentEditable&quot;
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( &quot; &quot; );
		}


	function getClass( elem ) {
		return elem.getAttribute &amp;&amp; elem.getAttribute( &quot;class&quot; ) || &quot;&quot;;
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === &quot;string&quot; ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) {
								cur += clazz + &quot; &quot;;
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( &quot;class&quot;, finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( &quot;class&quot;, &quot;&quot; );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt; -1 ) {
								cur = cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( &quot;class&quot;, finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === &quot;string&quot; || Array.isArray( value );

			if ( typeof stateVal === &quot;boolean&quot; &amp;&amp; isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === &quot;boolean&quot; ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, &quot;__className__&quot;, className );
					}

					// If the element has a class name or if we&#x27;re passed &#x60;false&#x60;,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( &quot;class&quot;,
							className || value === false ?
							&quot;&quot; :
							dataPriv.get( this, &quot;__className__&quot; ) || &quot;&quot;
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = &quot; &quot; + selector + &quot; &quot;;
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &amp;&amp;
					( &quot; &quot; + stripAndCollapse( getClass( elem ) ) + &quot; &quot; ).indexOf( className ) &gt; -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &amp;&amp;
						&quot;get&quot; in hooks &amp;&amp;
						( ret = hooks.get( elem, &quot;value&quot; ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === &quot;string&quot; ) {
						return ret.replace( rreturn, &quot;&quot; );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? &quot;&quot; : ret;
				}

				return;
			}

			valueIsFunction = isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as &quot;&quot;; convert numbers to string
				if ( val == null ) {
					val = &quot;&quot;;

				} else if ( typeof val === &quot;number&quot; ) {
					val += &quot;&quot;;

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? &quot;&quot; : value + &quot;&quot;;
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( &quot;set&quot; in hooks ) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, &quot;value&quot; );
					return val != null ?
						val :

						// Support: IE &lt;=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === &quot;select-one&quot;,
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index &lt; 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i &lt; max; i++ ) {
						option = options[ i ];

						// Support: IE &lt;=9 only
						// IE8-9 doesn&#x27;t update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &amp;&amp;

								// Don&#x27;t return options that are disabled or in a disabled optgroup
								!option.disabled &amp;&amp;
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don&#x27;t need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt; -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) &gt; -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( &quot;value&quot; ) === null ? &quot;on&quot; : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin = &quot;onfocusin&quot; in window;


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
				namespaces = hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split( &quot;.&quot; ) : [];

			cur = lastElement = tmp = elem = elem || document;

			// Don&#x27;t do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we&#x27;re not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( &quot;.&quot; ) &gt; -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( &quot;.&quot; );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( &quot;:&quot; ) &lt; 0 &amp;&amp; &quot;on&quot; + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event );

			// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( &quot;.&quot; );
			event.rnamespace = event.namespace ?
				new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i &gt; 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp;
					dataPriv.get( cur, &quot;handle&quot; );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype &amp;&amp; cur[ ontype ];
				if ( handle &amp;&amp; handle.apply &amp;&amp; acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &amp;&amp;
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don&#x27;t do default actions on window, that&#x27;s where global variables be (#6170)
					if ( ontype &amp;&amp; isFunction( elem[ type ] ) &amp;&amp; !isWindow( elem ) ) {

						// Don&#x27;t re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for &#x60;focus(in | out)&#x60; events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox &lt;=44
	// Firefox doesn&#x27;t have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome &lt;=48 - 49, Safari &lt;=9.0 - 9.1
	// focus(in | out) events fire after focus &amp; blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = Date.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== &quot;string&quot; ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, &quot;text/xml&quot; );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
			jQuery.error( &quot;Invalid XML: &quot; + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; &amp;&amp; v != null ? i : &quot;&quot; ) + &quot;]&quot;,
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional &amp;&amp; toType( obj ) === &quot;object&quot; ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; +
					encodeURIComponent( value == null ? &quot;&quot; : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( &quot;&amp;&quot; );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for &quot;elements&quot; to filter or add form elements
				var elements = jQuery.prop( this, &quot;elements&quot; );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works
				return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
					rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&amp;])_=[^&amp;]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol &quot;*&quot; can be used
		 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol &quot;*&quot; can be used
		 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = &quot;*/&quot;.concat( &quot;*&quot; ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( &quot;a&quot; );
		originAnchor.href = location.href;

	// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to &quot;*&quot;
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== &quot;string&quot; ) {
				func = dataTypeExpression;
				dataTypeExpression = &quot;*&quot;;
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === &quot;+&quot; ) {
						dataType = dataType.slice( 1 ) || &quot;*&quot;;
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp;
					!seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );
	}

	// A special extend for ajax options
	// that takes &quot;flat&quot; options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === &quot;*&quot; ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( &quot;Content-Type&quot; );
			}
		}

		// Check if we&#x27;re dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There&#x27;s only work to do if current dataType is non-auto
				if ( current === &quot;*&quot; ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( &quot; &quot; );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
									converters[ &quot;* &quot; + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv &amp;&amp; s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: &quot;parsererror&quot;,
									error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current
								};
							}
						}
					}
				}
			}
		}

		return { state: &quot;success&quot;, data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: &quot;GET&quot;,
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				&quot;*&quot;: allTypes,
				text: &quot;text/plain&quot;,
				html: &quot;text/html&quot;,
				xml: &quot;application/xml, text/xml&quot;,
				json: &quot;application/json, text/javascript&quot;
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: &quot;responseXML&quot;,
				text: &quot;responseText&quot;,
				json: &quot;responseJSON&quot;
			},

			// Data converters
			// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
			converters: {

				// Convert anything to text
				&quot;* text&quot;: String,

				// Text to html (true = no transformation)
				&quot;text html&quot;: true,

				// Evaluate text as a json expression
				&quot;text json&quot;: JSON.parse,

				// Parse text as xml
				&quot;text xml&quot;: jQuery.parseXML
			},

			// For options that shouldn&#x27;t be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn&#x27;t be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === &quot;object&quot; ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &amp;&amp;
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( &quot;once memory&quot; ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = &quot;canceled&quot;,

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + &quot;&quot; )
				.replace( rprotocol, location.protocol + &quot;//&quot; );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || &quot;*&quot; ).toLowerCase().match( rnothtmlwhite ) || [ &quot;&quot; ];

			// A cross-domain request is in order when the origin doesn&#x27;t match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( &quot;a&quot; );

				// Support: IE &lt;=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE &lt;=8 - 11 only
					// Anchor&#x27;s host property isn&#x27;t correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + &quot;//&quot; + originAnchor.host !==
						urlAnchor.protocol + &quot;//&quot; + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don&#x27;t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event &amp;&amp; s.global;

			// Watch for a new set of requests
			if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
				jQuery.event.trigger( &quot;ajaxStart&quot; );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we&#x27;re toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, &quot;&quot; );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data &amp;&amp; ( s.processData || typeof s.data === &quot;string&quot; ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data;

					// #9682: remove data so that it&#x27;s not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, &quot;$1&quot; );
					uncached = ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change &#x27;%20&#x27; to &#x27;+&#x27; if this is encoded form body content (gh-2658)
			} else if ( s.data &amp;&amp; s.processData &amp;&amp;
				( s.contentType || &quot;&quot; ).indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 ) {
				s.data = s.data.replace( r20, &quot;+&quot; );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				&quot;Accept&quot;,
				s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
					s.accepts[ &quot;*&quot; ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &amp;&amp;
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = &quot;abort&quot;;

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, &quot;No Transport&quot; );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( &quot;timeout&quot; );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || &quot;&quot;;

				// Set readyState
				jqXHR.readyState = status &gt; 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( &quot;Last-Modified&quot; );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( &quot;etag&quot; );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === &quot;HEAD&quot; ) {
						statusText = &quot;nocontent&quot;;

					// if not modified
					} else if ( status === 304 ) {
						statusText = &quot;notmodified&quot;;

					// If we have data, let&#x27;s convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = &quot;error&quot;;
						if ( status &lt; 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( &quot;ajaxStop&quot; );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, &quot;json&quot; );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, &quot;script&quot; );
		}
	} );

	jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) &amp;&amp; url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: &quot;GET&quot;,
			dataType: &quot;script&quot;,
			cache: true,
			async: false,
			global: false,
			&quot;throws&quot;: true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( &quot;body&quot; ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE &lt;=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won&#x27;t change header if already provided.
					if ( !options.crossDomain &amp;&amp; !headers[ &quot;X-Requested-With&quot; ] ) {
						headers[ &quot;X-Requested-With&quot; ] = &quot;XMLHttpRequest&quot;;
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;

								if ( type === &quot;abort&quot; ) {
									xhr.abort();
								} else if ( type === &quot;error&quot; ) {

									// Support: IE &lt;=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== &quot;number&quot; ) {
										complete( 0, &quot;error&quot; );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE &lt;=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || &quot;text&quot; ) !== &quot;text&quot;  ||
										typeof xhr.responseText !== &quot;string&quot; ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( &quot;error&quot; );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( &quot;abort&quot; );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent &amp;&amp; options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn&#x27;t been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: &quot;text/javascript, application/javascript, &quot; +
				&quot;application/ecmascript, application/x-ecmascript&quot;
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			&quot;text script&quot;: function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache&#x27;s special case and crossDomain
	jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = &quot;GET&quot;;
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( &quot;script&quot;, function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( &quot;&lt;script&gt;&quot; ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						&quot;load error&quot;,
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === &quot;error&quot; ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&amp;|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: &quot;callback&quot;,
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?
				&quot;url&quot; :
				typeof s.data === &quot;string&quot; &amp;&amp;
					( s.contentType || &quot;&quot; )
						.indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 &amp;&amp;
					rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
			);

		// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ &quot;script json&quot; ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + &quot; was not called&quot; );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = &quot;json&quot;;

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn&#x27;t exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn&#x27;t screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer &amp;&amp; isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return &quot;script&quot;;
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( &quot;&quot; ).body;
		body.innerHTML = &quot;&lt;form&gt;&lt;/form&gt;&lt;form&gt;&lt;/form&gt;&quot;;
		return body.childNodes.length === 2;
	} )();


	// Argument &quot;data&quot; should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== &quot;string&quot; ) {
			return [];
		}
		if ( typeof context === &quot;boolean&quot; ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( &quot;&quot; );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document&#x27;s URL (gh-2965)
				base = context.createElement( &quot;base&quot; );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts &amp;&amp; [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts &amp;&amp; scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( &quot; &quot; );

		if ( off &gt; -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it&#x27;s a function
		if ( isFunction( params ) ) {

			// We assume that it&#x27;s the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
			type = &quot;POST&quot;;
		}

		// If we have elements to modify, make the request
		if ( self.length &gt; 0 ) {
			jQuery.ajax( {
				url: url,

				// If &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || &quot;GET&quot;,
				dataType: &quot;html&quot;,
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE &#x27;Permission Denied&#x27; errors
					jQuery( &quot;&lt;div&gt;&quot; ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets &quot;data&quot;, &quot;status&quot;, &quot;jqXHR&quot;
			// but they are ignored because response was set above.
			// If it fails, this function gets &quot;jqXHR&quot;, &quot;status&quot;, &quot;error&quot;
			} ).always( callback &amp;&amp; function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		&quot;ajaxStart&quot;,
		&quot;ajaxStop&quot;,
		&quot;ajaxComplete&quot;,
		&quot;ajaxError&quot;,
		&quot;ajaxSuccess&quot;,
		&quot;ajaxSend&quot;
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, &quot;position&quot; ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === &quot;static&quot; ) {
				elem.style.position = &quot;relative&quot;;
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, &quot;top&quot; );
			curCSSLeft = jQuery.css( elem, &quot;left&quot; );
			calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp;
				( curCSSTop + curCSSLeft ).indexOf( &quot;auto&quot; ) &gt; -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( &quot;using&quot; in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element&#x27;s border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE &lt;=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element&#x27;s margin box to its offset parent&#x27;s padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &amp;&amp;
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &amp;&amp;
					jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent &amp;&amp; offsetParent !== elem &amp;&amp; offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, &quot;borderTopWidth&quot;, true );
					parentOffset.left += jQuery.css( offsetParent, &quot;borderLeftWidth&quot;, true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot; }, function( method, prop ) {
		var top = &quot;pageYOffset&quot; === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari &lt;=7 - 9.1, Chrome &lt;=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + &quot;px&quot; :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
		jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ),
					extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( &quot;outer&quot; ) === 0 ?
							elem[ &quot;inner&quot; + name ] :
							elem.document.documentElement[ &quot;client&quot; + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
							elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
							doc[ &quot;client&quot; + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( &quot;blur focus focusin focusout resize scroll click dblclick &quot; +
		&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
		&quot;change select submit keydown keypress keyup contextmenu&quot; ).split( &quot; &quot; ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length &gt; 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, &quot;**&quot; ) :
				this.off( types, selector || &quot;**&quot;, fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === &quot;string&quot; ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;

	jQuery.now = Date.now;

	jQuery.isNumeric = function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === &quot;number&quot; || type === &quot;string&quot; ) &amp;&amp;

			// parseFloat NaNs numeric-cast false positives (&quot;&quot;)
			// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep &amp;&amp; window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/*! modernizr 3.5.0 (Custom Build) | MIT *
	 * https://modernizr.com/download/?-applicationcache-backgrounds-borderimage-borderradius-boxshadow-cors-cssanimations-csscolumns-cssgradients-cssreflections-cssremunit-cssscrollbar-csstransforms-csstransforms3d-csstransitions-devicemotion_deviceorientation-fileinput-filereader-filesystem-flexbox-flexboxlegacy-fontface-formattribute-formvalidation-fullscreen-generatedcontent-hashchange-history-hsla-ie8compat-input-inputtypes-json-localstorage-multiplebgs-opacity-overflowscrolling-placeholder-postmessage-rgba-sessionstorage-strictmode-textshadow-domprefixes-hasevent-prefixed-prefixes-setclasses-testallprops-testprop-teststyles !*/
	!function(e,t,n){function r(e){var t=S.className,n=Modernizr._config.classPrefix||&quot;&quot;;if(C&amp;&amp;(t=t.baseVal),Modernizr._config.enableJSClass){var r=new RegExp(&quot;(^|\\s)&quot;+n+&quot;no-js(\\s|$)&quot;);t=t.replace(r,&quot;$1&quot;+n+&quot;js$2&quot;)}Modernizr._config.enableClasses&amp;&amp;(t+=&quot; &quot;+n+e.join(&quot; &quot;+n),C?S.className.baseVal=t:S.className=t)}function i(e,t){return typeof e===t}function o(){var e,t,n,r,o,s,a;for(var d in x)if(x.hasOwnProperty(d)){if(e=[],t=x[d],t.name&amp;&amp;(e.push(t.name.toLowerCase()),t.options&amp;&amp;t.options.aliases&amp;&amp;t.options.aliases.length))for(n=0;n&lt;t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(r=i(t.fn,&quot;function&quot;)?t.fn():t.fn,o=0;o&lt;e.length;o++)s=e[o],a=s.split(&quot;.&quot;),1===a.length?Modernizr[a[0]]=r:(!Modernizr[a[0]]||Modernizr[a[0]]instanceof Boolean||(Modernizr[a[0]]=new Boolean(Modernizr[a[0]])),Modernizr[a[0]][a[1]]=r),b.push((r?&quot;&quot;:&quot;no-&quot;)+a.join(&quot;-&quot;))}}function s(){return&quot;function&quot;!=typeof t.createElement?t.createElement(arguments[0]):C?t.createElementNS.call(t,&quot;http://www.w3.org/2000/svg&quot;,arguments[0]):t.createElement.apply(t,arguments)}function a(e){return e.replace(/([a-z])-([a-z])/g,function(e,t,n){return t+n.toUpperCase()}).replace(/^-/,&quot;&quot;)}function d(e,t){return!!~(&quot;&quot;+e).indexOf(t)}function l(){var e=t.body;return e||(e=s(C?&quot;svg&quot;:&quot;body&quot;),e.fake=!0),e}function u(e,n,r,i){var o,a,d,u,c=&quot;modernizr&quot;,f=s(&quot;div&quot;),p=l();if(parseInt(r,10))for(;r--;)d=s(&quot;div&quot;),d.id=i?i[r]:c+(r+1),f.appendChild(d);return o=s(&quot;style&quot;),o.type=&quot;text/css&quot;,o.id=&quot;s&quot;+c,(p.fake?p:f).appendChild(o),p.appendChild(f),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(t.createTextNode(e)),f.id=c,p.fake&amp;&amp;(p.style.background=&quot;&quot;,p.style.overflow=&quot;hidden&quot;,u=S.style.overflow,S.style.overflow=&quot;hidden&quot;,S.appendChild(p)),a=n(f,e),p.fake?(p.parentNode.removeChild(p),S.style.overflow=u,S.offsetHeight):f.parentNode.removeChild(f),!!a}function c(e,t){return function(){return e.apply(t,arguments)}}function f(e,t,n){var r;for(var o in e)if(e[o]in t)return n===!1?e[o]:(r=t[e[o]],i(r,&quot;function&quot;)?c(r,n||t):r);return!1}function p(t,n,r){var i;if(&quot;getComputedStyle&quot;in e){i=getComputedStyle.call(e,t,n);var o=e.console;if(null!==i)r&amp;&amp;(i=i.getPropertyValue(r));else if(o){var s=o.error?&quot;error&quot;:&quot;log&quot;;o[s].call(o,&quot;getComputedStyle returning null, its possible modernizr test results are inaccurate&quot;)}}else i=!n&amp;&amp;t.currentStyle&amp;&amp;t.currentStyle[r];return i}function m(e){return e.replace(/([A-Z])/g,function(e,t){return&quot;-&quot;+t.toLowerCase()}).replace(/^ms-/,&quot;-ms-&quot;)}function h(t,r){var i=t.length;if(&quot;CSS&quot;in e&amp;&amp;&quot;supports&quot;in e.CSS){for(;i--;)if(e.CSS.supports(m(t[i]),r))return!0;return!1}if(&quot;CSSSupportsRule&quot;in e){for(var o=[];i--;)o.push(&quot;(&quot;+m(t[i])+&quot;:&quot;+r+&quot;)&quot;);return o=o.join(&quot; or &quot;),u(&quot;@supports (&quot;+o+&quot;) { #modernizr { position: absolute; } }&quot;,function(e){return&quot;absolute&quot;==p(e,null,&quot;position&quot;)})}return n}function g(e,t,r,o){function l(){c&amp;&amp;(delete I.style,delete I.modElem)}if(o=i(o,&quot;undefined&quot;)?!1:o,!i(r,&quot;undefined&quot;)){var u=h(e,r);if(!i(u,&quot;undefined&quot;))return u}for(var c,f,p,m,g,v=[&quot;modernizr&quot;,&quot;tspan&quot;,&quot;samp&quot;];!I.style&amp;&amp;v.length;)c=!0,I.modElem=s(v.shift()),I.style=I.modElem.style;for(p=e.length,f=0;p&gt;f;f++)if(m=e[f],g=I.style[m],d(m,&quot;-&quot;)&amp;&amp;(m=a(m)),I.style[m]!==n){if(o||i(r,&quot;undefined&quot;))return l(),&quot;pfx&quot;==t?m:!0;try{I.style[m]=r}catch(y){}if(I.style[m]!=g)return l(),&quot;pfx&quot;==t?m:!0}return l(),!1}function v(e,t,n,r,o){var s=e.charAt(0).toUpperCase()+e.slice(1),a=(e+&quot; &quot;+M.join(s+&quot; &quot;)+s).split(&quot; &quot;);return i(t,&quot;string&quot;)||i(t,&quot;undefined&quot;)?g(a,t,r,o):(a=(e+&quot; &quot;+z.join(s+&quot; &quot;)+s).split(&quot; &quot;),f(a,t,n))}function y(e,t,r){return v(e,n,n,t,r)}var b=[],x=[],T={_version:&quot;3.5.0&quot;,_config:{classPrefix:&quot;&quot;,enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){x.push({name:e,fn:t,options:n})},addAsyncTest:function(e){x.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=T,Modernizr=new Modernizr,Modernizr.addTest(&quot;applicationcache&quot;,&quot;applicationCache&quot;in e),Modernizr.addTest(&quot;cors&quot;,&quot;XMLHttpRequest&quot;in e&amp;&amp;&quot;withCredentials&quot;in new XMLHttpRequest),Modernizr.addTest(&quot;ie8compat&quot;,!e.addEventListener&amp;&amp;!!t.documentMode&amp;&amp;7===t.documentMode),Modernizr.addTest(&quot;history&quot;,function(){var t=navigator.userAgent;return-1===t.indexOf(&quot;Android 2.&quot;)&amp;&amp;-1===t.indexOf(&quot;Android 4.0&quot;)||-1===t.indexOf(&quot;Mobile Safari&quot;)||-1!==t.indexOf(&quot;Chrome&quot;)||-1!==t.indexOf(&quot;Windows Phone&quot;)||&quot;file:&quot;===location.protocol?e.history&amp;&amp;&quot;pushState&quot;in e.history:!1}),Modernizr.addTest(&quot;json&quot;,&quot;JSON&quot;in e&amp;&amp;&quot;parse&quot;in JSON&amp;&amp;&quot;stringify&quot;in JSON),Modernizr.addTest(&quot;postmessage&quot;,&quot;postMessage&quot;in e),Modernizr.addTest(&quot;strictmode&quot;,function(){&quot;use strict&quot;;return!this}()),Modernizr.addTest(&quot;devicemotion&quot;,&quot;DeviceMotionEvent&quot;in e),Modernizr.addTest(&quot;deviceorientation&quot;,&quot;DeviceOrientationEvent&quot;in e),Modernizr.addTest(&quot;filereader&quot;,!!(e.File&amp;&amp;e.FileList&amp;&amp;e.FileReader)),Modernizr.addTest(&quot;localstorage&quot;,function(){var e=&quot;modernizr&quot;;try{return localStorage.setItem(e,e),localStorage.removeItem(e),!0}catch(t){return!1}}),Modernizr.addTest(&quot;sessionstorage&quot;,function(){var e=&quot;modernizr&quot;;try{return sessionStorage.setItem(e,e),sessionStorage.removeItem(e),!0}catch(t){return!1}});var w=T._config.usePrefixes?&quot; -webkit- -moz- -o- -ms- &quot;.split(&quot; &quot;):[&quot;&quot;,&quot;&quot;];T._prefixes=w;var S=t.documentElement,C=&quot;svg&quot;===S.nodeName.toLowerCase(),k=&quot;Moz O ms Webkit&quot;,z=T._config.usePrefixes?k.toLowerCase().split(&quot; &quot;):[];T._domPrefixes=z;var A=function(){function e(e,t){var i;return e?(t&amp;&amp;&quot;string&quot;!=typeof t||(t=s(t||&quot;div&quot;)),e=&quot;on&quot;+e,i=e in t,!i&amp;&amp;r&amp;&amp;(t.setAttribute||(t=s(&quot;div&quot;)),t.setAttribute(e,&quot;&quot;),i=&quot;function&quot;==typeof t[e],t[e]!==n&amp;&amp;(t[e]=n),t.removeAttribute(e)),i):!1}var r=!(&quot;onblur&quot;in t.documentElement);return e}();T.hasEvent=A,Modernizr.addTest(&quot;hashchange&quot;,function(){return A(&quot;hashchange&quot;,e)===!1?!1:t.documentMode===n||t.documentMode&gt;7}),Modernizr.addTest(&quot;cssgradients&quot;,function(){for(var e,t=&quot;background-image:&quot;,n=&quot;gradient(linear,left top,right bottom,from(#9f9),to(white));&quot;,r=&quot;&quot;,i=0,o=w.length-1;o&gt;i;i++)e=0===i?&quot;to &quot;:&quot;&quot;,r+=t+w[i]+&quot;linear-gradient(&quot;+e+&quot;left top, #9f9, white);&quot;;Modernizr._config.usePrefixes&amp;&amp;(r+=t+&quot;-webkit-&quot;+n);var a=s(&quot;a&quot;),d=a.style;return d.cssText=r,(&quot;&quot;+d.backgroundImage).indexOf(&quot;gradient&quot;)&gt;-1}),Modernizr.addTest(&quot;multiplebgs&quot;,function(){var e=s(&quot;a&quot;).style;return e.cssText=&quot;background:url(https://),url(https://),red url(https://)&quot;,/(url\s*\(.*?){3}/.test(e.background)}),Modernizr.addTest(&quot;opacity&quot;,function(){var e=s(&quot;a&quot;).style;return e.cssText=w.join(&quot;opacity:.55;&quot;),/^0.55$/.test(e.opacity)}),Modernizr.addTest(&quot;cssremunit&quot;,function(){var e=s(&quot;a&quot;).style;try{e.fontSize=&quot;3rem&quot;}catch(t){}return/rem/.test(e.fontSize)}),Modernizr.addTest(&quot;rgba&quot;,function(){var e=s(&quot;a&quot;).style;return e.cssText=&quot;background-color:rgba(150,255,150,.5)&quot;,(&quot;&quot;+e.backgroundColor).indexOf(&quot;rgba&quot;)&gt;-1}),Modernizr.addTest(&quot;fileinput&quot;,function(){if(navigator.userAgent.match(/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\/(1.0|2.0|2.5|3.0))/))return!1;var e=s(&quot;input&quot;);return e.type=&quot;file&quot;,!e.disabled}),Modernizr.addTest(&quot;formattribute&quot;,function(){var e,n=s(&quot;form&quot;),r=s(&quot;input&quot;),i=s(&quot;div&quot;),o=&quot;formtest&quot;+(new Date).getTime(),a=!1;n.id=o;try{r.setAttribute(&quot;form&quot;,o)}catch(d){t.createAttribute&amp;&amp;(e=t.createAttribute(&quot;form&quot;),e.nodeValue=o,r.setAttributeNode(e))}return i.appendChild(n),i.appendChild(r),S.appendChild(i),a=n.elements&amp;&amp;1===n.elements.length&amp;&amp;r.form==n,i.parentNode.removeChild(i),a}),Modernizr.addTest(&quot;placeholder&quot;,&quot;placeholder&quot;in s(&quot;input&quot;)&amp;&amp;&quot;placeholder&quot;in s(&quot;textarea&quot;));var _=s(&quot;input&quot;),E=&quot;autocomplete autofocus list placeholder max min multiple pattern required step&quot;.split(&quot; &quot;),O={};Modernizr.input=function(t){for(var n=0,r=t.length;r&gt;n;n++)O[t[n]]=!!(t[n]in _);return O.list&amp;&amp;(O.list=!(!s(&quot;datalist&quot;)||!e.HTMLDataListElement)),O}(E);var P=&quot;search tel url email datetime date month week time datetime-local number range color&quot;.split(&quot; &quot;),L={};Modernizr.inputtypes=function(e){for(var r,i,o,s=e.length,a=&quot;1)&quot;,d=0;s&gt;d;d++)_.setAttribute(&quot;type&quot;,r=e[d]),o=&quot;text&quot;!==_.type&amp;&amp;&quot;style&quot;in _,o&amp;&amp;(_.value=a,_.style.cssText=&quot;position:absolute;visibility:hidden;&quot;,/^range$/.test(r)&amp;&amp;_.style.WebkitAppearance!==n?(S.appendChild(_),i=t.defaultView,o=i.getComputedStyle&amp;&amp;&quot;textfield&quot;!==i.getComputedStyle(_,null).WebkitAppearance&amp;&amp;0!==_.offsetHeight,S.removeChild(_)):/^(search|tel)$/.test(r)||(o=/^(url|email)$/.test(r)?_.checkValidity&amp;&amp;_.checkValidity()===!1:_.value!=a)),L[e[d]]=!!o;return L}(P),Modernizr.addTest(&quot;hsla&quot;,function(){var e=s(&quot;a&quot;).style;return e.cssText=&quot;background-color:hsla(120,40%,100%,.5)&quot;,d(e.backgroundColor,&quot;rgba&quot;)||d(e.backgroundColor,&quot;hsla&quot;)});var R=&quot;CSS&quot;in e&amp;&amp;&quot;supports&quot;in e.CSS,N=&quot;supportsCSS&quot;in e;Modernizr.addTest(&quot;supports&quot;,R||N);var M=T._config.usePrefixes?k.split(&quot; &quot;):[];T._cssomPrefixes=M;var B=function(t){var r,i=w.length,o=e.CSSRule;if(&quot;undefined&quot;==typeof o)return n;if(!t)return!1;if(t=t.replace(/^@/,&quot;&quot;),r=t.replace(/-/g,&quot;_&quot;).toUpperCase()+&quot;_RULE&quot;,r in o)return&quot;@&quot;+t;for(var s=0;i&gt;s;s++){var a=w[s],d=a.toUpperCase()+&quot;_&quot;+r;if(d in o)return&quot;@-&quot;+a.toLowerCase()+&quot;-&quot;+t}return!1};T.atRule=B;var W=T.testStyles=u,j=function(){var e=navigator.userAgent,t=e.match(/w(eb)?osbrowser/gi),n=e.match(/windows phone/gi)&amp;&amp;e.match(/iemobile\/([0-9])+/gi)&amp;&amp;parseFloat(RegExp.$1)&gt;=9;return t||n}();j?Modernizr.addTest(&quot;fontface&quot;,!1):W(&#x27;@font-face {font-family:&quot;font&quot;;src:url(&quot;https://&quot;)}&#x27;,function(e,n){var r=t.getElementById(&quot;smodernizr&quot;),i=r.sheet||r.styleSheet,o=i?i.cssRules&amp;&amp;i.cssRules[0]?i.cssRules[0].cssText:i.cssText||&quot;&quot;:&quot;&quot;,s=/src/i.test(o)&amp;&amp;0===o.indexOf(n.split(&quot; &quot;)[0]);Modernizr.addTest(&quot;fontface&quot;,s)}),W(&#x27;#modernizr{font:0/0 a}#modernizr:after{content:&quot;:)&quot;;visibility:hidden;font:7px/1 a}&#x27;,function(e){Modernizr.addTest(&quot;generatedcontent&quot;,e.offsetHeight&gt;=6)}),W(&quot;#modernizr{overflow: scroll; width: 40px; height: 40px; }#&quot;+w.join(&quot;scrollbar{width:10px} #modernizr::&quot;).split(&quot;#&quot;).slice(1).join(&quot;#&quot;)+&quot;scrollbar{width:10px}&quot;,function(e){Modernizr.addTest(&quot;cssscrollbar&quot;,&quot;scrollWidth&quot;in e&amp;&amp;30==e.scrollWidth)}),Modernizr.addTest(&quot;formvalidation&quot;,function(){var t=s(&quot;form&quot;);if(!(&quot;checkValidity&quot;in t&amp;&amp;&quot;addEventListener&quot;in t))return!1;if(&quot;reportValidity&quot;in t)return!0;var n,r=!1;return Modernizr.formvalidationapi=!0,t.addEventListener(&quot;submit&quot;,function(t){(!e.opera||e.operamini)&amp;&amp;t.preventDefault(),t.stopPropagation()},!1),t.innerHTML=&#x27;&lt;input name=&quot;modTest&quot; required=&quot;required&quot; /&gt;&lt;button&gt;&lt;/button&gt;&#x27;,W(&quot;#modernizr form{position:absolute;top:-99999em}&quot;,function(e){e.appendChild(t),n=t.getElementsByTagName(&quot;input&quot;)[0],n.addEventListener(&quot;invalid&quot;,function(e){r=!0,e.preventDefault(),e.stopPropagation()},!1),Modernizr.formvalidationmessage=!!n.validationMessage,t.getElementsByTagName(&quot;button&quot;)[0].click()}),r});var q={elem:s(&quot;modernizr&quot;)};Modernizr._q.push(function(){delete q.elem});var I={style:q.elem.style};Modernizr._q.unshift(function(){delete I.style});var V=T.testProp=function(e,t,r){return g([e],n,t,r)};Modernizr.addTest(&quot;textshadow&quot;,V(&quot;textShadow&quot;,&quot;1px 1px&quot;)),T.testAllProps=v;var F=T.prefixed=function(e,t,n){return 0===e.indexOf(&quot;@&quot;)?B(e):(-1!=e.indexOf(&quot;-&quot;)&amp;&amp;(e=a(e)),t?v(e,t,n):v(e,&quot;pfx&quot;))};Modernizr.addTest(&quot;fullscreen&quot;,!(!F(&quot;exitFullscreen&quot;,t,!1)&amp;&amp;!F(&quot;cancelFullScreen&quot;,t,!1))),Modernizr.addTest(&quot;filesystem&quot;,!!F(&quot;requestFileSystem&quot;,e)),T.testAllProps=y,Modernizr.addTest(&quot;cssanimations&quot;,y(&quot;animationName&quot;,&quot;a&quot;,!0)),Modernizr.addTest(&quot;backgroundsize&quot;,y(&quot;backgroundSize&quot;,&quot;100%&quot;,!0)),Modernizr.addTest(&quot;borderradius&quot;,y(&quot;borderRadius&quot;,&quot;0px&quot;,!0)),Modernizr.addTest(&quot;borderimage&quot;,y(&quot;borderImage&quot;,&quot;url() 1&quot;,!0)),Modernizr.addTest(&quot;boxshadow&quot;,y(&quot;boxShadow&quot;,&quot;1px 1px&quot;,!0)),function(){Modernizr.addTest(&quot;csscolumns&quot;,function(){var e=!1,t=y(&quot;columnCount&quot;);try{e=!!t,e&amp;&amp;(e=new Boolean(e))}catch(n){}return e});for(var e,t,n=[&quot;Width&quot;,&quot;Span&quot;,&quot;Fill&quot;,&quot;Gap&quot;,&quot;Rule&quot;,&quot;RuleColor&quot;,&quot;RuleStyle&quot;,&quot;RuleWidth&quot;,&quot;BreakBefore&quot;,&quot;BreakAfter&quot;,&quot;BreakInside&quot;],r=0;r&lt;n.length;r++)e=n[r].toLowerCase(),t=y(&quot;column&quot;+n[r]),(&quot;breakbefore&quot;===e||&quot;breakafter&quot;===e||&quot;breakinside&quot;==e)&amp;&amp;(t=t||y(n[r])),Modernizr.addTest(&quot;csscolumns.&quot;+e,t)}(),Modernizr.addTest(&quot;flexbox&quot;,y(&quot;flexBasis&quot;,&quot;1px&quot;,!0)),Modernizr.addTest(&quot;flexboxlegacy&quot;,y(&quot;boxDirection&quot;,&quot;reverse&quot;,!0)),Modernizr.addTest(&quot;overflowscrolling&quot;,y(&quot;overflowScrolling&quot;,&quot;touch&quot;,!0)),Modernizr.addTest(&quot;cssreflections&quot;,y(&quot;boxReflect&quot;,&quot;above&quot;,!0)),Modernizr.addTest(&quot;csstransforms&quot;,function(){return-1===navigator.userAgent.indexOf(&quot;Android 2.&quot;)&amp;&amp;y(&quot;transform&quot;,&quot;scale(1)&quot;,!0)}),Modernizr.addTest(&quot;csstransforms3d&quot;,function(){var e=!!y(&quot;perspective&quot;,&quot;1px&quot;,!0),t=Modernizr._config.usePrefixes;if(e&amp;&amp;(!t||&quot;webkitPerspective&quot;in S.style)){var n,r=&quot;#modernizr{width:0;height:0}&quot;;Modernizr.supports?n=&quot;@supports (perspective: 1px)&quot;:(n=&quot;@media (transform-3d)&quot;,t&amp;&amp;(n+=&quot;,(-webkit-transform-3d)&quot;)),n+=&quot;{#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}&quot;,W(r+n,function(t){e=7===t.offsetWidth&amp;&amp;18===t.offsetHeight})}return e}),Modernizr.addTest(&quot;csstransitions&quot;,y(&quot;transition&quot;,&quot;all&quot;,!0)),o(),r(b),delete T.addTest,delete T.addAsyncTest;for(var H=0;H&lt;Modernizr._q.length;H++)Modernizr._q[H]();e.Modernizr=Modernizr}(window,document);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * jQuery Easing v1.4.1 - http://gsgd.co.uk/sandbox/jquery/easing/
	 * Open source under the BSD License.
	 * Copyright © 2008 George McGinley Smith
	 * All rights reserved.
	 * https://raw.github.com/gdsmith/jquery-easing/master/LICENSE
	 */

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
	            return factory($);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) {
	        exports = factory(require(&#x27;jquery&#x27;));
	    } else {
	        factory(jQuery);
	    }
	})(function ($) {

	// Preserve the original jQuery &quot;swing&quot; easing as &quot;jswing&quot;
	    $.easing.jswing = $.easing.swing;

	    var pow = Math.pow,
	        sqrt = Math.sqrt,
	        sin = Math.sin,
	        cos = Math.cos,
	        PI = Math.PI,
	        c1 = 1.70158,
	        c2 = c1 * 1.525,
	        c3 = c1 + 1,
	        c4 = ( 2 * PI ) / 3,
	        c5 = ( 2 * PI ) / 4.5;

	// x is the fraction of animation progress, in the range 0..1
	    function bounceOut(x) {
	        var n1 = 7.5625,
	            d1 = 2.75;
	        if (x &lt; 1 / d1) {
	            return n1 * x * x;
	        } else if (x &lt; 2 / d1) {
	            return n1 * (x -= (1.5 / d1)) * x + 0.75;
	        } else if (x &lt; 2.5 / d1) {
	            return n1 * (x -= (2.25 / d1)) * x + 0.9375;
	        } else {
	            return n1 * (x -= (2.625 / d1)) * x + 0.984375;
	        }
	    }

	    $.extend($.easing,
	        {
	            def: &#x27;easeOutQuad&#x27;,
	            swing: function (x) {
	                return $.easing[$.easing.def](x);
	            },
	            easeInQuad: function (x) {
	                return x * x;
	            },
	            easeOutQuad: function (x) {
	                return 1 - ( 1 - x ) * ( 1 - x );
	            },
	            easeInOutQuad: function (x) {
	                return x &lt; 0.5 ?
	                    2 * x * x :
	                    1 - pow(-2 * x + 2, 2) / 2;
	            },
	            easeInCubic: function (x) {
	                return x * x * x;
	            },
	            easeOutCubic: function (x) {
	                return 1 - pow(1 - x, 3);
	            },
	            easeInOutCubic: function (x) {
	                return x &lt; 0.5 ?
	                    4 * x * x * x :
	                    1 - pow(-2 * x + 2, 3) / 2;
	            },
	            easeInQuart: function (x) {
	                return x * x * x * x;
	            },
	            easeOutQuart: function (x) {
	                return 1 - pow(1 - x, 4);
	            },
	            easeInOutQuart: function (x) {
	                return x &lt; 0.5 ?
	                    8 * x * x * x * x :
	                    1 - pow(-2 * x + 2, 4) / 2;
	            },
	            easeInQuint: function (x) {
	                return x * x * x * x * x;
	            },
	            easeOutQuint: function (x) {
	                return 1 - pow(1 - x, 5);
	            },
	            easeInOutQuint: function (x) {
	                return x &lt; 0.5 ?
	                    16 * x * x * x * x * x :
	                    1 - pow(-2 * x + 2, 5) / 2;
	            },
	            easeInSine: function (x) {
	                return 1 - cos(x * PI / 2);
	            },
	            easeOutSine: function (x) {
	                return sin(x * PI / 2);
	            },
	            easeInOutSine: function (x) {
	                return -( cos(PI * x) - 1 ) / 2;
	            },
	            easeInExpo: function (x) {
	                return x === 0 ? 0 : pow(2, 10 * x - 10);
	            },
	            easeOutExpo: function (x) {
	                return x === 1 ? 1 : 1 - pow(2, -10 * x);
	            },
	            easeInOutExpo: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 : x &lt; 0.5 ?
	                    pow(2, 20 * x - 10) / 2 :
	                    ( 2 - pow(2, -20 * x + 10) ) / 2;
	            },
	            easeInCirc: function (x) {
	                return 1 - sqrt(1 - pow(x, 2));
	            },
	            easeOutCirc: function (x) {
	                return sqrt(1 - pow(x - 1, 2));
	            },
	            easeInOutCirc: function (x) {
	                return x &lt; 0.5 ?
	                    ( 1 - sqrt(1 - pow(2 * x, 2)) ) / 2 :
	                    ( sqrt(1 - pow(-2 * x + 2, 2)) + 1 ) / 2;
	            },
	            easeInElastic: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 :
	                    -pow(2, 10 * x - 10) * sin(( x * 10 - 10.75 ) * c4);
	            },
	            easeOutElastic: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 :
	                    pow(2, -10 * x) * sin(( x * 10 - 0.75 ) * c4) + 1;
	            },
	            easeInOutElastic: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 : x &lt; 0.5 ?
	                    -( pow(2, 20 * x - 10) * sin(( 20 * x - 11.125 ) * c5)) / 2 :
	                    pow(2, -20 * x + 10) * sin(( 20 * x - 11.125 ) * c5) / 2 + 1;
	            },
	            easeInBack: function (x) {
	                return c3 * x * x * x - c1 * x * x;
	            },
	            easeOutBack: function (x) {
	                return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
	            },
	            easeInOutBack: function (x) {
	                return x &lt; 0.5 ?
	                    ( pow(2 * x, 2) * ( ( c2 + 1 ) * 2 * x - c2 ) ) / 2 :
	                    ( pow(2 * x - 2, 2) * ( ( c2 + 1 ) * ( x * 2 - 2 ) + c2 ) + 2 ) / 2;
	            },
	            easeInBounce: function (x) {
	                return 1 - bounceOut(1 - x);
	            },
	            easeOutBounce: bounceOut,
	            easeInOutBounce: function (x) {
	                return x &lt; 0.5 ?
	                    ( 1 - bounceOut(1 - 2 * x) ) / 2 :
	                    ( 1 + bounceOut(2 * x - 1) ) / 2;
	            }
	        });

	});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**!
	 * @fileOverview Kickass library to create and place poppers near their reference elements.
	 * @version 1.14.1
	 * @license
	 * Copyright (c) 2016 Federico Zivolo and contributors
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the &quot;Software&quot;), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define(factory) :
		(global.Popper = factory());
	}(this, (function () { &#x27;use strict&#x27;;

	var isBrowser = typeof window !== &#x27;undefined&#x27; &amp;&amp; typeof document !== &#x27;undefined&#x27;;
	var longerTimeoutBrowsers = [&#x27;Edge&#x27;, &#x27;Trident&#x27;, &#x27;Firefox&#x27;];
	var timeoutDuration = 0;
	for (var i = 0; i &lt; longerTimeoutBrowsers.length; i += 1) {
	  if (isBrowser &amp;&amp; navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) &gt;= 0) {
	    timeoutDuration = 1;
	    break;
	  }
	}

	function microtaskDebounce(fn) {
	  var called = false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called = true;
	    window.Promise.resolve().then(function () {
	      called = false;
	      fn();
	    });
	  };
	}

	function taskDebounce(fn) {
	  var scheduled = false;
	  return function () {
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        fn();
	      }, timeoutDuration);
	    }
	  };
	}

	var supportsMicroTasks = isBrowser &amp;&amp; window.Promise;

	/**
	* Create a debounced version of a method, that&#x27;s asynchronously deferred
	* but called in the minimum time possible.
	*
	* @method
	* @memberof Popper.Utils
	* @argument {Function} fn
	* @returns {Function}
	*/
	var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

	/**
	 * Check if the given variable is a function
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Any} functionToCheck - variable to check
	 * @returns {Boolean} answer to: is a function?
	 */
	function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck &amp;&amp; getType.toString.call(functionToCheck) === &#x27;[object Function]&#x27;;
	}

	/**
	 * Get CSS computed property of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Eement} element
	 * @argument {String} property
	 */
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !== 1) {
	    return [];
	  }
	  // NOTE: 1 DOM access here
	  var css = getComputedStyle(element, null);
	  return property ? css[property] : css;
	}

	/**
	 * Returns the parentNode or the host of the element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} parent
	 */
	function getParentNode(element) {
	  if (element.nodeName === &#x27;HTML&#x27;) {
	    return element;
	  }
	  return element.parentNode || element.host;
	}

	/**
	 * Returns the scrolling parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} scroll parent
	 */
	function getScrollParent(element) {
	  // Return body, &#x60;getScroll&#x60; will take care to get the correct &#x60;scrollTop&#x60; from it
	  if (!element) {
	    return document.body;
	  }

	  switch (element.nodeName) {
	    case &#x27;HTML&#x27;:
	    case &#x27;BODY&#x27;:
	      return element.ownerDocument.body;
	    case &#x27;#document&#x27;:
	      return element.body;
	  }

	  // Firefox want us to check &#x60;-x&#x60; and &#x60;-y&#x60; variations as well

	  var _getStyleComputedProp = getStyleComputedProperty(element),
	      overflow = _getStyleComputedProp.overflow,
	      overflowX = _getStyleComputedProp.overflowX,
	      overflowY = _getStyleComputedProp.overflowY;

	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }

	  return getScrollParent(getParentNode(element));
	}

	/**
	 * Tells if you are running Internet Explorer
	 * @method
	 * @memberof Popper.Utils
	 * @argument {number} version to check
	 * @returns {Boolean} isIE
	 */
	var cache = {};

	var isIE = function () {
	  var version = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : &#x27;all&#x27;;

	  version = version.toString();
	  if (cache.hasOwnProperty(version)) {
	    return cache[version];
	  }
	  switch (version) {
	    case &#x27;11&#x27;:
	      cache[version] = navigator.userAgent.indexOf(&#x27;Trident&#x27;) !== -1;
	      break;
	    case &#x27;10&#x27;:
	      cache[version] = navigator.appVersion.indexOf(&#x27;MSIE 10&#x27;) !== -1;
	      break;
	    case &#x27;all&#x27;:
	      cache[version] = navigator.userAgent.indexOf(&#x27;Trident&#x27;) !== -1 || navigator.userAgent.indexOf(&#x27;MSIE&#x27;) !== -1;
	      break;
	  }

	  //Set IE
	  cache.all = cache.all || Object.keys(cache).some(function (key) {
	    return cache[key];
	  });
	  return cache[version];
	};

	/**
	 * Returns the offset parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} offset parent
	 */
	function getOffsetParent(element) {
	  if (!element) {
	    return document.documentElement;
	  }

	  var noOffsetParent = isIE(10) ? document.body : null;

	  // NOTE: 1 DOM access here
	  var offsetParent = element.offsetParent;
	  // Skip hidden elements which don&#x27;t have an offsetParent
	  while (offsetParent === noOffsetParent &amp;&amp; element.nextElementSibling) {
	    offsetParent = (element = element.nextElementSibling).offsetParent;
	  }

	  var nodeName = offsetParent &amp;&amp; offsetParent.nodeName;

	  if (!nodeName || nodeName === &#x27;BODY&#x27; || nodeName === &#x27;HTML&#x27;) {
	    return element ? element.ownerDocument.documentElement : document.documentElement;
	  }

	  // .offsetParent will return the closest TD or TABLE in case
	  // no offsetParent is present, I hate this job...
	  if ([&#x27;TD&#x27;, &#x27;TABLE&#x27;].indexOf(offsetParent.nodeName) !== -1 &amp;&amp; getStyleComputedProperty(offsetParent, &#x27;position&#x27;) === &#x27;static&#x27;) {
	    return getOffsetParent(offsetParent);
	  }

	  return offsetParent;
	}

	function isOffsetContainer(element) {
	  var nodeName = element.nodeName;

	  if (nodeName === &#x27;BODY&#x27;) {
	    return false;
	  }
	  return nodeName === &#x27;HTML&#x27; || getOffsetParent(element.firstElementChild) === element;
	}

	/**
	 * Finds the root node (document, shadowDOM root) of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} node
	 * @returns {Element} root node
	 */
	function getRoot(node) {
	  if (node.parentNode !== null) {
	    return getRoot(node.parentNode);
	  }

	  return node;
	}

	/**
	 * Finds the offset parent common to the two provided nodes
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element1
	 * @argument {Element} element2
	 * @returns {Element} common offset parent
	 */
	function findCommonOffsetParent(element1, element2) {
	  // This check is needed to avoid errors in case one of the elements isn&#x27;t defined for any reason
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }

	  // Here we make sure to give as &quot;start&quot; the element that comes first in the DOM
	  var order = element1.compareDocumentPosition(element2) &amp; Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;

	  // Get common ancestor container
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;

	  // Both nodes are inside #document

	  if (element1 !== commonAncestorContainer &amp;&amp; element2 !== commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }

	    return getOffsetParent(commonAncestorContainer);
	  }

	  // one of the nodes is inside shadowDOM, find which one
	  var element1root = getRoot(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}

	/**
	 * Gets the scroll value of the given element in the given side (top and left)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {String} side &#x60;top&#x60; or &#x60;left&#x60;
	 * @returns {number} amount of scrolled pixels
	 */
	function getScroll(element) {
	  var side = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &#x27;top&#x27;;

	  var upperSide = side === &#x27;top&#x27; ? &#x27;scrollTop&#x27; : &#x27;scrollLeft&#x27;;
	  var nodeName = element.nodeName;

	  if (nodeName === &#x27;BODY&#x27; || nodeName === &#x27;HTML&#x27;) {
	    var html = element.ownerDocument.documentElement;
	    var scrollingElement = element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }

	  return element[upperSide];
	}

	/*
	 * Sum or subtract the element scroll values (left and top) from a given rect object
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} rect - Rect object you want to change
	 * @param {HTMLElement} element - The element from the function reads the scroll values
	 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
	 * @return {Object} rect - The modifier rect object
	 */
	function includeScroll(rect, element) {
	  var subtract = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;

	  var scrollTop = getScroll(element, &#x27;top&#x27;);
	  var scrollLeft = getScroll(element, &#x27;left&#x27;);
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}

	/*
	 * Helper to detect borders of a given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {CSSStyleDeclaration} styles
	 * Result of &#x60;getStyleComputedProperty&#x60; on the given element
	 * @param {String} axis - &#x60;x&#x60; or &#x60;y&#x60;
	 * @return {number} borders - The borders size of the given axis
	 */

	function getBordersSize(styles, axis) {
	  var sideA = axis === &#x27;x&#x27; ? &#x27;Left&#x27; : &#x27;Top&#x27;;
	  var sideB = sideA === &#x27;Left&#x27; ? &#x27;Right&#x27; : &#x27;Bottom&#x27;;

	  return parseFloat(styles[&#x27;border&#x27; + sideA + &#x27;Width&#x27;], 10) + parseFloat(styles[&#x27;border&#x27; + sideB + &#x27;Width&#x27;], 10);
	}

	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body[&#x27;offset&#x27; + axis], body[&#x27;scroll&#x27; + axis], html[&#x27;client&#x27; + axis], html[&#x27;offset&#x27; + axis], html[&#x27;scroll&#x27; + axis], isIE(10) ? html[&#x27;offset&#x27; + axis] + computedStyle[&#x27;margin&#x27; + (axis === &#x27;Height&#x27; ? &#x27;Top&#x27; : &#x27;Left&#x27;)] + computedStyle[&#x27;margin&#x27; + (axis === &#x27;Height&#x27; ? &#x27;Bottom&#x27; : &#x27;Right&#x27;)] : 0);
	}

	function getWindowSizes() {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE(10) &amp;&amp; getComputedStyle(html);

	  return {
	    height: getSize(&#x27;Height&#x27;, body, html, computedStyle),
	    width: getSize(&#x27;Width&#x27;, body, html, computedStyle)
	  };
	}

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError(&quot;Cannot call a class as a function&quot;);
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i &lt; props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if (&quot;value&quot; in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();





	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i &lt; arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	/**
	 * Given element offsets, generate an output similar to getBoundingClientRect
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} offsets
	 * @returns {Object} ClientRect like output
	 */
	function getClientRect(offsets) {
	  return _extends({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}

	/**
	 * Get bounding client rect of given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} element
	 * @return {Object} client rect
	 */
	function getBoundingClientRect(element) {
	  var rect = {};

	  // IE10 10 FIX: Please, don&#x27;t ask, the element isn&#x27;t
	  // considered in DOM in some circumstances...
	  // This isn&#x27;t reproducible in IE10 compatibility mode of IE11
	  try {
	    if (isIE(10)) {
	      rect = element.getBoundingClientRect();
	      var scrollTop = getScroll(element, &#x27;top&#x27;);
	      var scrollLeft = getScroll(element, &#x27;left&#x27;);
	      rect.top += scrollTop;
	      rect.left += scrollLeft;
	      rect.bottom += scrollTop;
	      rect.right += scrollLeft;
	    } else {
	      rect = element.getBoundingClientRect();
	    }
	  } catch (e) {}

	  var result = {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };

	  // subtract scrollbar size from sizes
	  var sizes = element.nodeName === &#x27;HTML&#x27; ? getWindowSizes() : {};
	  var width = sizes.width || element.clientWidth || result.right - result.left;
	  var height = sizes.height || element.clientHeight || result.bottom - result.top;

	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;

	  // if an hypothetical scrollbar is detected, we must be sure it&#x27;s not a &#x60;border&#x60;
	  // we make this check conditional for performance reasons
	  if (horizScrollbar || vertScrollbar) {
	    var styles = getStyleComputedProperty(element);
	    horizScrollbar -= getBordersSize(styles, &#x27;x&#x27;);
	    vertScrollbar -= getBordersSize(styles, &#x27;y&#x27;);

	    result.width -= horizScrollbar;
	    result.height -= vertScrollbar;
	  }

	  return getClientRect(result);
	}

	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var fixedPosition = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;

	  var isIE10 = isIE(10);
	  var isHTML = parent.nodeName === &#x27;HTML&#x27;;
	  var childrenRect = getBoundingClientRect(children);
	  var parentRect = getBoundingClientRect(parent);
	  var scrollParent = getScrollParent(children);

	  var styles = getStyleComputedProperty(parent);
	  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
	  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

	  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
	  if (fixedPosition &amp;&amp; parent.nodeName === &#x27;HTML&#x27;) {
	    parentRect.top = Math.max(parentRect.top, 0);
	    parentRect.left = Math.max(parentRect.left, 0);
	  }
	  var offsets = getClientRect({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;

	  // Subtract margins of documentElement in case it&#x27;s being used as parent
	  // we do this only on HTML because it&#x27;s the only element that behaves
	  // differently when margins are applied to it. The margins are included in
	  // the box of the documentElement, in the other cases not.
	  if (!isIE10 &amp;&amp; isHTML) {
	    var marginTop = parseFloat(styles.marginTop, 10);
	    var marginLeft = parseFloat(styles.marginLeft, 10);

	    offsets.top -= borderTopWidth - marginTop;
	    offsets.bottom -= borderTopWidth - marginTop;
	    offsets.left -= borderLeftWidth - marginLeft;
	    offsets.right -= borderLeftWidth - marginLeft;

	    // Attach marginTop and marginLeft because in some circumstances we may need them
	    offsets.marginTop = marginTop;
	    offsets.marginLeft = marginLeft;
	  }

	  if (isIE10 &amp;&amp; !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent &amp;&amp; scrollParent.nodeName !== &#x27;BODY&#x27;) {
	    offsets = includeScroll(offsets, parent);
	  }

	  return offsets;
	}

	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var excludeScroll = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;

	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);

	  var scrollTop = !excludeScroll ? getScroll(html) : 0;
	  var scrollLeft = !excludeScroll ? getScroll(html, &#x27;left&#x27;) : 0;

	  var offset = {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };

	  return getClientRect(offset);
	}

	/**
	 * Check if the given element is fixed or is inside a fixed parent
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {Element} customContainer
	 * @returns {Boolean} answer to &quot;isFixed?&quot;
	 */
	function isFixed(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === &#x27;BODY&#x27; || nodeName === &#x27;HTML&#x27;) {
	    return false;
	  }
	  if (getStyleComputedProperty(element, &#x27;position&#x27;) === &#x27;fixed&#x27;) {
	    return true;
	  }
	  return isFixed(getParentNode(element));
	}

	/**
	 * Finds the first parent of an element that has a transformed property defined
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} first transformed parent or documentElement
	 */

	function getFixedPositionOffsetParent(element) {
	  // This check is needed to avoid errors in case one of the elements isn&#x27;t defined for any reason
	  if (!element || !element.parentElement || isIE()) {
	    return document.documentElement;
	  }
	  var el = element.parentElement;
	  while (el &amp;&amp; getStyleComputedProperty(el, &#x27;transform&#x27;) === &#x27;none&#x27;) {
	    el = el.parentElement;
	  }
	  return el || document.documentElement;
	}

	/**
	 * Computed the boundaries limits and return them
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} popper
	 * @param {HTMLElement} reference
	 * @param {number} padding
	 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
	 * @param {Boolean} fixedPosition - Is in fixed position mode
	 * @returns {Object} Coordinates of the boundaries
	 */
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  var fixedPosition = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : false;

	  // NOTE: 1 DOM access here

	  var boundaries = { top: 0, left: 0 };
	  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

	  // Handle viewport case
	  if (boundariesElement === &#x27;viewport&#x27;) {
	    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
	  } else {
	    // Handle other cases based on DOM element used as boundaries
	    var boundariesNode = void 0;
	    if (boundariesElement === &#x27;scrollParent&#x27;) {
	      boundariesNode = getScrollParent(getParentNode(reference));
	      if (boundariesNode.nodeName === &#x27;BODY&#x27;) {
	        boundariesNode = popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement === &#x27;window&#x27;) {
	      boundariesNode = popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode = boundariesElement;
	    }

	    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

	    // In case of HTML, we need a different computation
	    if (boundariesNode.nodeName === &#x27;HTML&#x27; &amp;&amp; !isFixed(offsetParent)) {
	      var _getWindowSizes = getWindowSizes(),
	          height = _getWindowSizes.height,
	          width = _getWindowSizes.width;

	      boundaries.top += offsets.top - offsets.marginTop;
	      boundaries.bottom = height + offsets.top;
	      boundaries.left += offsets.left - offsets.marginLeft;
	      boundaries.right = width + offsets.left;
	    } else {
	      // for all the other DOM elements, this one is good
	      boundaries = offsets;
	    }
	  }

	  // Add paddings
	  boundaries.left += padding;
	  boundaries.top += padding;
	  boundaries.right -= padding;
	  boundaries.bottom -= padding;

	  return boundaries;
	}

	function getArea(_ref) {
	  var width = _ref.width,
	      height = _ref.height;

	  return width * height;
	}

	/**
	 * Utility used to transform the &#x60;auto&#x60; placement to the placement with more
	 * available space.
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : 0;

	  if (placement.indexOf(&#x27;auto&#x27;) === -1) {
	    return placement;
	  }

	  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

	  var rects = {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };

	  var sortedAreas = Object.keys(rects).map(function (key) {
	    return _extends({
	      key: key
	    }, rects[key], {
	      area: getArea(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });

	  var filteredAreas = sortedAreas.filter(function (_ref2) {
	    var width = _ref2.width,
	        height = _ref2.height;
	    return width &gt;= popper.clientWidth &amp;&amp; height &gt;= popper.clientHeight;
	  });

	  var computedPlacement = filteredAreas.length &gt; 0 ? filteredAreas[0].key : sortedAreas[0].key;

	  var variation = placement.split(&#x27;-&#x27;)[1];

	  return computedPlacement + (variation ? &#x27;-&#x27; + variation : &#x27;&#x27;);
	}

	/**
	 * Get offsets to the reference element
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} state
	 * @param {Element} popper - the popper element
	 * @param {Element} reference - the reference element (the popper will be relative to this)
	 * @param {Element} fixedPosition - is in fixed position mode
	 * @returns {Object} An object containing the offsets which will be applied to the popper
	 */
	function getReferenceOffsets(state, popper, reference) {
	  var fixedPosition = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : null;

	  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
	}

	/**
	 * Get the outer sizes of the given element (offset size + margins)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Object} object containing width and height properties
	 */
	function getOuterSizes(element) {
	  var styles = getComputedStyle(element);
	  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
	  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
	  var result = {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}

	/**
	 * Get the opposite placement of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement
	 * @returns {String} flipped placement
	 */
	function getOppositePlacement(placement) {
	  var hash = { left: &#x27;right&#x27;, right: &#x27;left&#x27;, bottom: &#x27;top&#x27;, top: &#x27;bottom&#x27; };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}

	/**
	 * Get offsets to the popper
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} position - CSS position the Popper will get applied
	 * @param {HTMLElement} popper - the popper element
	 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
	 * @param {String} placement - one of the valid placement options
	 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
	 */
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement = placement.split(&#x27;-&#x27;)[0];

	  // Get popper node sizes
	  var popperRect = getOuterSizes(popper);

	  // Add position, width and height to our offsets object
	  var popperOffsets = {
	    width: popperRect.width,
	    height: popperRect.height
	  };

	  // depending by the popper placement we have to compute its offsets slightly differently
	  var isHoriz = [&#x27;right&#x27;, &#x27;left&#x27;].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? &#x27;top&#x27; : &#x27;left&#x27;;
	  var secondarySide = isHoriz ? &#x27;left&#x27; : &#x27;top&#x27;;
	  var measurement = isHoriz ? &#x27;height&#x27; : &#x27;width&#x27;;
	  var secondaryMeasurement = !isHoriz ? &#x27;height&#x27; : &#x27;width&#x27;;

	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
	    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	  }

	  return popperOffsets;
	}

	/**
	 * Mimics the &#x60;find&#x60; method of Array
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function find(arr, check) {
	  // use native find if supported
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }

	  // use &#x60;filter&#x60; to obtain the same behavior of &#x60;find&#x60;
	  return arr.filter(check)[0];
	}

	/**
	 * Return the index of the matching object
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function findIndex(arr, prop, value) {
	  // use native findIndex if supported
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] === value;
	    });
	  }

	  // use &#x60;find&#x60; + &#x60;indexOf&#x60; if &#x60;findIndex&#x60; isn&#x27;t supported
	  var match = find(arr, function (obj) {
	    return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}

	/**
	 * Loop trough the list of modifiers and run them in order,
	 * each of them will then edit the data object.
	 * @method
	 * @memberof Popper.Utils
	 * @param {dataObject} data
	 * @param {Array} modifiers
	 * @param {String} ends - Optional modifier name used as stopper
	 * @returns {dataObject}
	 */
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, &#x27;name&#x27;, ends));

	  modifiersToRun.forEach(function (modifier) {
	    if (modifier[&#x27;function&#x27;]) {
	      // eslint-disable-line dot-notation
	      console.warn(&#x27;&#x60;modifier.function&#x60; is deprecated, use &#x60;modifier.fn&#x60;!&#x27;);
	    }
	    var fn = modifier[&#x27;function&#x27;] || modifier.fn; // eslint-disable-line dot-notation
	    if (modifier.enabled &amp;&amp; isFunction(fn)) {
	      // Add properties to offsets to make them a complete clientRect object
	      // we do this before each modifier to make sure the previous one doesn&#x27;t
	      // mess with these values
	      data.offsets.popper = getClientRect(data.offsets.popper);
	      data.offsets.reference = getClientRect(data.offsets.reference);

	      data = fn(data, modifier);
	    }
	  });

	  return data;
	}

	/**
	 * Updates the position of the popper, computing the new offsets and applying
	 * the new style.&lt;br /&gt;
	 * Prefer &#x60;scheduleUpdate&#x60; over &#x60;update&#x60; because of performance reasons.
	 * @method
	 * @memberof Popper
	 */
	function update() {
	  // if popper is destroyed, don&#x27;t perform any further update
	  if (this.state.isDestroyed) {
	    return;
	  }

	  var data = {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };

	  // compute reference element offsets
	  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit &#x60;placement&#x60; if needed
	  // and refer to originalPlacement to know the original value
	  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

	  // store the computed placement inside &#x60;originalPlacement&#x60;
	  data.originalPlacement = data.placement;

	  data.positionFixed = this.options.positionFixed;

	  // compute the popper offsets
	  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
	  data.offsets.popper.position = this.options.positionFixed ? &#x27;fixed&#x27; : &#x27;absolute&#x27;;

	  // run the modifiers
	  data = runModifiers(this.modifiers, data);

	  // the first &#x60;update&#x60; will call &#x60;onCreate&#x60; callback
	  // the other ones will call &#x60;onUpdate&#x60; callback
	  if (!this.state.isCreated) {
	    this.state.isCreated = true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}

	/**
	 * Helper used to know if the given modifier is enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @returns {Boolean}
	 */
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref) {
	    var name = _ref.name,
	        enabled = _ref.enabled;
	    return enabled &amp;&amp; name === modifierName;
	  });
	}

	/**
	 * Get the prefixed supported property name
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} property (camelCase)
	 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
	 */
	function getSupportedPropertyName(property) {
	  var prefixes = [false, &#x27;ms&#x27;, &#x27;Webkit&#x27;, &#x27;Moz&#x27;, &#x27;O&#x27;];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

	  for (var i = 0; i &lt; prefixes.length; i++) {
	    var prefix = prefixes[i];
	    var toCheck = prefix ? &#x27;&#x27; + prefix + upperProp : property;
	    if (typeof document.body.style[toCheck] !== &#x27;undefined&#x27;) {
	      return toCheck;
	    }
	  }
	  return null;
	}

	/**
	 * Destroy the popper
	 * @method
	 * @memberof Popper
	 */
	function destroy() {
	  this.state.isDestroyed = true;

	  // touch DOM only if &#x60;applyStyle&#x60; modifier is enabled
	  if (isModifierEnabled(this.modifiers, &#x27;applyStyle&#x27;)) {
	    this.popper.removeAttribute(&#x27;x-placement&#x27;);
	    this.popper.style.position = &#x27;&#x27;;
	    this.popper.style.top = &#x27;&#x27;;
	    this.popper.style.left = &#x27;&#x27;;
	    this.popper.style.right = &#x27;&#x27;;
	    this.popper.style.bottom = &#x27;&#x27;;
	    this.popper.style.willChange = &#x27;&#x27;;
	    this.popper.style[getSupportedPropertyName(&#x27;transform&#x27;)] = &#x27;&#x27;;
	  }

	  this.disableEventListeners();

	  // remove the popper if user explicity asked for the deletion on destroy
	  // do not use &#x60;remove&#x60; because IE11 doesn&#x27;t support it
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}

	/**
	 * Get the window associated with the element
	 * @argument {Element} element
	 * @returns {Window}
	 */
	function getWindow(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}

	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === &#x27;BODY&#x27;;
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, { passive: true });

	  if (!isBody) {
	    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}

	/**
	 * Setup needed event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function setupEventListeners(reference, options, state, updateBound) {
	  // Resize event listener on window
	  state.updateBound = updateBound;
	  getWindow(reference).addEventListener(&#x27;resize&#x27;, state.updateBound, { passive: true });

	  // Scroll event listener on scroll parents
	  var scrollElement = getScrollParent(reference);
	  attachToScrollParents(scrollElement, &#x27;scroll&#x27;, state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;

	  return state;
	}

	/**
	 * It will add resize/scroll events and start recalculating
	 * position of the popper element when they are triggered.
	 * @method
	 * @memberof Popper
	 */
	function enableEventListeners() {
	  if (!this.state.eventsEnabled) {
	    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}

	/**
	 * Remove event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function removeEventListeners(reference, state) {
	  // Remove resize event listener on window
	  getWindow(reference).removeEventListener(&#x27;resize&#x27;, state.updateBound);

	  // Remove scroll event listener on scroll parents
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener(&#x27;scroll&#x27;, state.updateBound);
	  });

	  // Reset state
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}

	/**
	 * It will remove resize/scroll events and won&#x27;t recalculate popper position
	 * when they are triggered. It also won&#x27;t trigger onUpdate callback anymore,
	 * unless you call &#x60;update&#x60; method manually.
	 * @method
	 * @memberof Popper
	 */
	function disableEventListeners() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state = removeEventListeners(this.reference, this.state);
	  }
	}

	/**
	 * Tells if a given input is a number
	 * @method
	 * @memberof Popper.Utils
	 * @param {*} input to check
	 * @return {Boolean}
	 */
	function isNumeric(n) {
	  return n !== &#x27;&#x27; &amp;&amp; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
	}

	/**
	 * Set the style to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the style to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setStyles(element, styles) {
	  Object.keys(styles).forEach(function (prop) {
	    var unit = &#x27;&#x27;;
	    // add unit if the value is numeric and is one of the following
	    if ([&#x27;width&#x27;, &#x27;height&#x27;, &#x27;top&#x27;, &#x27;right&#x27;, &#x27;bottom&#x27;, &#x27;left&#x27;].indexOf(prop) !== -1 &amp;&amp; isNumeric(styles[prop])) {
	      unit = &#x27;px&#x27;;
	    }
	    element.style[prop] = styles[prop] + unit;
	  });
	}

	/**
	 * Set the attributes to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the attributes to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setAttributes(element, attributes) {
	  Object.keys(attributes).forEach(function (prop) {
	    var value = attributes[prop];
	    if (value !== false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} data.styles - List of style properties - values to apply to popper element
	 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The same data object
	 */
	function applyStyle(data) {
	  // any property present in &#x60;data.styles&#x60; will be applied to the popper,
	  // in this way we can make the 3rd party modifiers add custom styles to it
	  // Be aware, modifiers could override the properties defined in the previous
	  // lines of this modifier!
	  setStyles(data.instance.popper, data.styles);

	  // any property present in &#x60;data.attributes&#x60; will be applied to the popper,
	  // they will be set as HTML attributes of the element
	  setAttributes(data.instance.popper, data.attributes);

	  // if arrowElement is defined and arrowStyles has some properties
	  if (data.arrowElement &amp;&amp; Object.keys(data.arrowStyles).length) {
	    setStyles(data.arrowElement, data.arrowStyles);
	  }

	  return data;
	}

	/**
	 * Set the x-placement attribute before everything else because it could be used
	 * to add margins to the popper margins needs to be calculated to get the
	 * correct popper offsets.
	 * @method
	 * @memberof Popper.modifiers
	 * @param {HTMLElement} reference - The reference element used to position the popper
	 * @param {HTMLElement} popper - The HTML element used as popper
	 * @param {Object} options - Popper.js options
	 */
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  // compute reference element offsets
	  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit &#x60;placement&#x60; if needed
	  // and refer to originalPlacement to know the original value
	  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

	  popper.setAttribute(&#x27;x-placement&#x27;, placement);

	  // Apply &#x60;position&#x60; to popper before anything else because
	  // without the position applied we can&#x27;t guarantee correct computations
	  setStyles(popper, { position: options.positionFixed ? &#x27;fixed&#x27; : &#x27;absolute&#x27; });

	  return options;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeStyle(data, options) {
	  var x = options.x,
	      y = options.y;
	  var popper = data.offsets.popper;

	  // Remove this legacy support in Popper.js v2

	  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === &#x27;applyStyle&#x27;;
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
	    console.warn(&#x27;WARNING: &#x60;gpuAcceleration&#x60; option moved to &#x60;computeStyle&#x60; modifier and will not be supported in future versions of Popper.js!&#x27;);
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

	  var offsetParent = getOffsetParent(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect(offsetParent);

	  // Styles
	  var styles = {
	    position: popper.position
	  };

	  // floor sides to avoid blurry text
	  var offsets = {
	    left: Math.floor(popper.left),
	    top: Math.floor(popper.top),
	    bottom: Math.floor(popper.bottom),
	    right: Math.floor(popper.right)
	  };

	  var sideA = x === &#x27;bottom&#x27; ? &#x27;top&#x27; : &#x27;bottom&#x27;;
	  var sideB = y === &#x27;right&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;

	  // if gpuAcceleration is set to &#x60;true&#x60; and transform is supported,
	  //  we use &#x60;translate3d&#x60; to apply the position to the popper we
	  // automatically use the supported prefixed version if needed
	  var prefixedProperty = getSupportedPropertyName(&#x27;transform&#x27;);

	  // now, let&#x27;s make a step back and look at this code closely (wtf?)
	  // If the content of the popper grows once it&#x27;s been positioned, it
	  // may happen that the popper gets misplaced because of the new content
	  // overflowing its reference element
	  // To avoid this problem, we provide two options (x and y), which allow
	  // the consumer to define the offset origin.
	  // If we position a popper on top of a reference element, we can set
	  // &#x60;x&#x60; to &#x60;top&#x60; to make the popper grow towards its top instead of
	  // its bottom.
	  var left = void 0,
	      top = void 0;
	  if (sideA === &#x27;bottom&#x27;) {
	    top = -offsetParentRect.height + offsets.bottom;
	  } else {
	    top = offsets.top;
	  }
	  if (sideB === &#x27;right&#x27;) {
	    left = -offsetParentRect.width + offsets.right;
	  } else {
	    left = offsets.left;
	  }
	  if (gpuAcceleration &amp;&amp; prefixedProperty) {
	    styles[prefixedProperty] = &#x27;translate3d(&#x27; + left + &#x27;px, &#x27; + top + &#x27;px, 0)&#x27;;
	    styles[sideA] = 0;
	    styles[sideB] = 0;
	    styles.willChange = &#x27;transform&#x27;;
	  } else {
	    // othwerise, we use the standard &#x60;top&#x60;, &#x60;left&#x60;, &#x60;bottom&#x60; and &#x60;right&#x60; properties
	    var invertTop = sideA === &#x27;bottom&#x27; ? -1 : 1;
	    var invertLeft = sideB === &#x27;right&#x27; ? -1 : 1;
	    styles[sideA] = top * invertTop;
	    styles[sideB] = left * invertLeft;
	    styles.willChange = sideA + &#x27;, &#x27; + sideB;
	  }

	  // Attributes
	  var attributes = {
	    &#x27;x-placement&#x27;: data.placement
	  };

	  // Update &#x60;data&#x60; attributes, styles and arrowStyles
	  data.attributes = _extends({}, attributes, data.attributes);
	  data.styles = _extends({}, styles, data.styles);
	  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

	  return data;
	}

	/**
	 * Helper used to know if the given modifier depends from another one.&lt;br /&gt;
	 * It checks if the needed modifier is listed and enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Array} modifiers - list of modifiers
	 * @param {String} requestingName - name of requesting modifier
	 * @param {String} requestedName - name of requested modifier
	 * @returns {Boolean}
	 */
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting = find(modifiers, function (_ref) {
	    var name = _ref.name;
	    return name === requestingName;
	  });

	  var isRequired = !!requesting &amp;&amp; modifiers.some(function (modifier) {
	    return modifier.name === requestedName &amp;&amp; modifier.enabled &amp;&amp; modifier.order &lt; requesting.order;
	  });

	  if (!isRequired) {
	    var _requesting = &#x27;&#x60;&#x27; + requestingName + &#x27;&#x60;&#x27;;
	    var requested = &#x27;&#x60;&#x27; + requestedName + &#x27;&#x60;&#x27;;
	    console.warn(requested + &#x27; modifier is required by &#x27; + _requesting + &#x27; modifier in order to work, be sure to include it before &#x27; + _requesting + &#x27;!&#x27;);
	  }
	  return isRequired;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function arrow(data, options) {
	  var _data$offsets$arrow;

	  // arrow depends on keepTogether in order to work
	  if (!isModifierRequired(data.instance.modifiers, &#x27;arrow&#x27;, &#x27;keepTogether&#x27;)) {
	    return data;
	  }

	  var arrowElement = options.element;

	  // if arrowElement is a string, suppose it&#x27;s a CSS selector
	  if (typeof arrowElement === &#x27;string&#x27;) {
	    arrowElement = data.instance.popper.querySelector(arrowElement);

	    // if arrowElement is not found, don&#x27;t run the modifier
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    // if the arrowElement isn&#x27;t a query selector we must check that the
	    // provided DOM node is child of its popper node
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn(&#x27;WARNING: &#x60;arrow.element&#x60; must be child of its popper element!&#x27;);
	      return data;
	    }
	  }

	  var placement = data.placement.split(&#x27;-&#x27;)[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isVertical = [&#x27;left&#x27;, &#x27;right&#x27;].indexOf(placement) !== -1;

	  var len = isVertical ? &#x27;height&#x27; : &#x27;width&#x27;;
	  var sideCapitalized = isVertical ? &#x27;Top&#x27; : &#x27;Left&#x27;;
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? &#x27;left&#x27; : &#x27;top&#x27;;
	  var opSide = isVertical ? &#x27;bottom&#x27; : &#x27;right&#x27;;
	  var arrowElementSize = getOuterSizes(arrowElement)[len];

	  //
	  // extends keepTogether behavior making sure the popper and its
	  // reference have enough pixels in conjuction
	  //

	  // top/left side
	  if (reference[opSide] - arrowElementSize &lt; popper[side]) {
	    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  // bottom/right side
	  if (reference[side] + arrowElementSize &gt; popper[opSide]) {
	    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect(data.offsets.popper);

	  // compute center of the popper
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

	  // Compute the sideValue using the updated popper offsets
	  // take popper margin in account because we don&#x27;t have this info available
	  var css = getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide = parseFloat(css[&#x27;margin&#x27; + sideCapitalized], 10);
	  var popperBorderSide = parseFloat(css[&#x27;border&#x27; + sideCapitalized + &#x27;Width&#x27;], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

	  // prevent arrowElement from being placed not contiguously to its popper
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, &#x27;&#x27;), _data$offsets$arrow);

	  return data;
	}

	/**
	 * Get the opposite placement variation of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement variation
	 * @returns {String} flipped placement variation
	 */
	function getOppositeVariation(variation) {
	  if (variation === &#x27;end&#x27;) {
	    return &#x27;start&#x27;;
	  } else if (variation === &#x27;start&#x27;) {
	    return &#x27;end&#x27;;
	  }
	  return variation;
	}

	/**
	 * List of accepted placements to use as values of the &#x60;placement&#x60; option.&lt;br /&gt;
	 * Valid placements are:
	 * - &#x60;auto&#x60;
	 * - &#x60;top&#x60;
	 * - &#x60;right&#x60;
	 * - &#x60;bottom&#x60;
	 * - &#x60;left&#x60;
	 *
	 * Each placement can have a variation from this list:
	 * - &#x60;-start&#x60;
	 * - &#x60;-end&#x60;
	 *
	 * Variations are interpreted easily if you think of them as the left to right
	 * written languages. Horizontally (&#x60;top&#x60; and &#x60;bottom&#x60;), &#x60;start&#x60; is left and &#x60;end&#x60;
	 * is right.&lt;br /&gt;
	 * Vertically (&#x60;left&#x60; and &#x60;right&#x60;), &#x60;start&#x60; is top and &#x60;end&#x60; is bottom.
	 *
	 * Some valid examples are:
	 * - &#x60;top-end&#x60; (on top of reference, right aligned)
	 * - &#x60;right-start&#x60; (on right of reference, top aligned)
	 * - &#x60;bottom&#x60; (on bottom, centered)
	 * - &#x60;auto-right&#x60; (on the side with more space available, alignment depends by placement)
	 *
	 * @static
	 * @type {Array}
	 * @enum {String}
	 * @readonly
	 * @method placements
	 * @memberof Popper
	 */
	var placements = [&#x27;auto-start&#x27;, &#x27;auto&#x27;, &#x27;auto-end&#x27;, &#x27;top-start&#x27;, &#x27;top&#x27;, &#x27;top-end&#x27;, &#x27;right-start&#x27;, &#x27;right&#x27;, &#x27;right-end&#x27;, &#x27;bottom-end&#x27;, &#x27;bottom&#x27;, &#x27;bottom-start&#x27;, &#x27;left-end&#x27;, &#x27;left&#x27;, &#x27;left-start&#x27;];

	// Get rid of &#x60;auto&#x60; &#x60;auto-start&#x60; and &#x60;auto-end&#x60;
	var validPlacements = placements.slice(3);

	/**
	 * Given an initial placement, returns all the subsequent placements
	 * clockwise (or counter-clockwise).
	 *
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement - A valid placement (it accepts variations)
	 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
	 * @returns {Array} placements including their variations
	 */
	function clockwise(placement) {
	  var counter = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;

	  var index = validPlacements.indexOf(placement);
	  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}

	var BEHAVIORS = {
	  FLIP: &#x27;flip&#x27;,
	  CLOCKWISE: &#x27;clockwise&#x27;,
	  COUNTERCLOCKWISE: &#x27;counterclockwise&#x27;
	};

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function flip(data, options) {
	  // if &#x60;inner&#x60; modifier is enabled, we can&#x27;t use the &#x60;flip&#x60; modifier
	  if (isModifierEnabled(data.instance.modifiers, &#x27;inner&#x27;)) {
	    return data;
	  }

	  if (data.flipped &amp;&amp; data.placement === data.originalPlacement) {
	    // seems like flip is trying to loop, probably there&#x27;s not enough space on any of the flippable sides
	    return data;
	  }

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

	  var placement = data.placement.split(&#x27;-&#x27;)[0];
	  var placementOpposite = getOppositePlacement(placement);
	  var variation = data.placement.split(&#x27;-&#x27;)[1] || &#x27;&#x27;;

	  var flipOrder = [];

	  switch (options.behavior) {
	    case BEHAVIORS.FLIP:
	      flipOrder = [placement, placementOpposite];
	      break;
	    case BEHAVIORS.CLOCKWISE:
	      flipOrder = clockwise(placement);
	      break;
	    case BEHAVIORS.COUNTERCLOCKWISE:
	      flipOrder = clockwise(placement, true);
	      break;
	    default:
	      flipOrder = options.behavior;
	  }

	  flipOrder.forEach(function (step, index) {
	    if (placement !== step || flipOrder.length === index + 1) {
	      return data;
	    }

	    placement = data.placement.split(&#x27;-&#x27;)[0];
	    placementOpposite = getOppositePlacement(placement);

	    var popperOffsets = data.offsets.popper;
	    var refOffsets = data.offsets.reference;

	    // using floor because the reference offsets may contain decimals we are not going to consider here
	    var floor = Math.floor;
	    var overlapsRef = placement === &#x27;left&#x27; &amp;&amp; floor(popperOffsets.right) &gt; floor(refOffsets.left) || placement === &#x27;right&#x27; &amp;&amp; floor(popperOffsets.left) &lt; floor(refOffsets.right) || placement === &#x27;top&#x27; &amp;&amp; floor(popperOffsets.bottom) &gt; floor(refOffsets.top) || placement === &#x27;bottom&#x27; &amp;&amp; floor(popperOffsets.top) &lt; floor(refOffsets.bottom);

	    var overflowsLeft = floor(popperOffsets.left) &lt; floor(boundaries.left);
	    var overflowsRight = floor(popperOffsets.right) &gt; floor(boundaries.right);
	    var overflowsTop = floor(popperOffsets.top) &lt; floor(boundaries.top);
	    var overflowsBottom = floor(popperOffsets.bottom) &gt; floor(boundaries.bottom);

	    var overflowsBoundaries = placement === &#x27;left&#x27; &amp;&amp; overflowsLeft || placement === &#x27;right&#x27; &amp;&amp; overflowsRight || placement === &#x27;top&#x27; &amp;&amp; overflowsTop || placement === &#x27;bottom&#x27; &amp;&amp; overflowsBottom;

	    // flip the variation if required
	    var isVertical = [&#x27;top&#x27;, &#x27;bottom&#x27;].indexOf(placement) !== -1;
	    var flippedVariation = !!options.flipVariations &amp;&amp; (isVertical &amp;&amp; variation === &#x27;start&#x27; &amp;&amp; overflowsLeft || isVertical &amp;&amp; variation === &#x27;end&#x27; &amp;&amp; overflowsRight || !isVertical &amp;&amp; variation === &#x27;start&#x27; &amp;&amp; overflowsTop || !isVertical &amp;&amp; variation === &#x27;end&#x27; &amp;&amp; overflowsBottom);

	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      // this boolean to detect any flip loop
	      data.flipped = true;

	      if (overlapsRef || overflowsBoundaries) {
	        placement = flipOrder[index + 1];
	      }

	      if (flippedVariation) {
	        variation = getOppositeVariation(variation);
	      }

	      data.placement = placement + (variation ? &#x27;-&#x27; + variation : &#x27;&#x27;);

	      // this object contains &#x60;position&#x60;, we want to preserve it along with
	      // any additional property we may add in the future
	      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

	      data = runModifiers(data.instance.modifiers, data, &#x27;flip&#x27;);
	    }
	  });
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function keepTogether(data) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var placement = data.placement.split(&#x27;-&#x27;)[0];
	  var floor = Math.floor;
	  var isVertical = [&#x27;top&#x27;, &#x27;bottom&#x27;].indexOf(placement) !== -1;
	  var side = isVertical ? &#x27;right&#x27; : &#x27;bottom&#x27;;
	  var opSide = isVertical ? &#x27;left&#x27; : &#x27;top&#x27;;
	  var measurement = isVertical ? &#x27;width&#x27; : &#x27;height&#x27;;

	  if (popper[side] &lt; floor(reference[opSide])) {
	    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] &gt; floor(reference[side])) {
	    data.offsets.popper[opSide] = floor(reference[side]);
	  }

	  return data;
	}

	/**
	 * Converts a string containing value + unit into a px value number
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} str - Value + unit string
	 * @argument {String} measurement - &#x60;height&#x60; or &#x60;width&#x60;
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @returns {Number|String}
	 * Value in pixels, or original string if no values were extracted
	 */
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  // separate value from unit
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];

	  // If it&#x27;s not a number it&#x27;s an operator, I guess
	  if (!value) {
	    return str;
	  }

	  if (unit.indexOf(&#x27;%&#x27;) === 0) {
	    var element = void 0;
	    switch (unit) {
	      case &#x27;%p&#x27;:
	        element = popperOffsets;
	        break;
	      case &#x27;%&#x27;:
	      case &#x27;%r&#x27;:
	      default:
	        element = referenceOffsets;
	    }

	    var rect = getClientRect(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit === &#x27;vh&#x27; || unit === &#x27;vw&#x27;) {
	    // if is a vh or vw, we calculate the size based on the viewport
	    var size = void 0;
	    if (unit === &#x27;vh&#x27;) {
	      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    // if is an explicit pixel unit, we get rid of the unit and keep the value
	    // if is an implicit unit, it&#x27;s px, and we return just the value
	    return value;
	  }
	}

	/**
	 * Parse an &#x60;offset&#x60; string to extrapolate &#x60;x&#x60; and &#x60;y&#x60; numeric offsets.
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} offset
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @argument {String} basePlacement
	 * @returns {Array} a two cells array with x and y offsets in numbers
	 */
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];

	  // Use height if placement is left or right and index is 0 otherwise use width
	  // in this way the first offset will use an axis and the second one
	  // will use the other one
	  var useHeight = [&#x27;right&#x27;, &#x27;left&#x27;].indexOf(basePlacement) !== -1;

	  // Split the offset string to obtain a list of values and operands
	  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });

	  // Detect if the offset string contains a pair of values or a single one
	  // they could be separated by comma or space
	  var divider = fragments.indexOf(find(fragments, function (frag) {
	    return frag.search(/,|\s/) !== -1;
	  }));

	  if (fragments[divider] &amp;&amp; fragments[divider].indexOf(&#x27;,&#x27;) === -1) {
	    console.warn(&#x27;Offsets separated by white space(s) are deprecated, use a comma (,) instead.&#x27;);
	  }

	  // If divider is found, we divide the list of values and operands to divide
	  // them by ofset X and Y.
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

	  // Convert the values with units to absolute pixels to allow our computations
	  ops = ops.map(function (op, index) {
	    // Most of the units rely on the orientation of the popper
	    var measurement = (index === 1 ? !useHeight : useHeight) ? &#x27;height&#x27; : &#x27;width&#x27;;
	    var mergeWithPrevious = false;
	    return op
	    // This aggregates any &#x60;+&#x60; or &#x60;-&#x60; sign that aren&#x27;t considered operators
	    // e.g.: 10 + +5 =&gt; [10, +, +5]
	    .reduce(function (a, b) {
	      if (a[a.length - 1] === &#x27;&#x27; &amp;&amp; [&#x27;+&#x27;, &#x27;-&#x27;].indexOf(b) !== -1) {
	        a[a.length - 1] = b;
	        mergeWithPrevious = true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] += b;
	        mergeWithPrevious = false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    // Here we convert the string values into number values (in px)
	    .map(function (str) {
	      return toValue(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });

	  // Loop trough the offsets arrays and execute the operations
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric(frag)) {
	        offsets[index] += frag * (op[index2 - 1] === &#x27;-&#x27; ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @argument {Number|String} options.offset=0
	 * The offset value as described in the modifier description
	 * @returns {Object} The data object, properly modified
	 */
	function offset(data, _ref) {
	  var offset = _ref.offset;
	  var placement = data.placement,
	      _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var basePlacement = placement.split(&#x27;-&#x27;)[0];

	  var offsets = void 0;
	  if (isNumeric(+offset)) {
	    offsets = [+offset, 0];
	  } else {
	    offsets = parseOffset(offset, popper, reference, basePlacement);
	  }

	  if (basePlacement === &#x27;left&#x27;) {
	    popper.top += offsets[0];
	    popper.left -= offsets[1];
	  } else if (basePlacement === &#x27;right&#x27;) {
	    popper.top += offsets[0];
	    popper.left += offsets[1];
	  } else if (basePlacement === &#x27;top&#x27;) {
	    popper.left += offsets[0];
	    popper.top -= offsets[1];
	  } else if (basePlacement === &#x27;bottom&#x27;) {
	    popper.left += offsets[0];
	    popper.top += offsets[1];
	  }

	  data.popper = popper;
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function preventOverflow(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

	  // If offsetParent is the reference element, we really want to
	  // go one step up and use the next offsetParent as reference to
	  // avoid to make this modifier completely useless and look like broken
	  if (data.instance.reference === boundariesElement) {
	    boundariesElement = getOffsetParent(boundariesElement);
	  }

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
	  options.boundaries = boundaries;

	  var order = options.priority;
	  var popper = data.offsets.popper;

	  var check = {
	    primary: function primary(placement) {
	      var value = popper[placement];
	      if (popper[placement] &lt; boundaries[placement] &amp;&amp; !options.escapeWithReference) {
	        value = Math.max(popper[placement], boundaries[placement]);
	      }
	      return defineProperty({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide = placement === &#x27;right&#x27; ? &#x27;left&#x27; : &#x27;top&#x27;;
	      var value = popper[mainSide];
	      if (popper[placement] &gt; boundaries[placement] &amp;&amp; !options.escapeWithReference) {
	        value = Math.min(popper[mainSide], boundaries[placement] - (placement === &#x27;right&#x27; ? popper.width : popper.height));
	      }
	      return defineProperty({}, mainSide, value);
	    }
	  };

	  order.forEach(function (placement) {
	    var side = [&#x27;left&#x27;, &#x27;top&#x27;].indexOf(placement) !== -1 ? &#x27;primary&#x27; : &#x27;secondary&#x27;;
	    popper = _extends({}, popper, check[side](placement));
	  });

	  data.offsets.popper = popper;

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function shift(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split(&#x27;-&#x27;)[0];
	  var shiftvariation = placement.split(&#x27;-&#x27;)[1];

	  // if shift shiftvariation is specified, run the modifier
	  if (shiftvariation) {
	    var _data$offsets = data.offsets,
	        reference = _data$offsets.reference,
	        popper = _data$offsets.popper;

	    var isVertical = [&#x27;bottom&#x27;, &#x27;top&#x27;].indexOf(basePlacement) !== -1;
	    var side = isVertical ? &#x27;left&#x27; : &#x27;top&#x27;;
	    var measurement = isVertical ? &#x27;width&#x27; : &#x27;height&#x27;;

	    var shiftOffsets = {
	      start: defineProperty({}, side, reference[side]),
	      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };

	    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, &#x27;hide&#x27;, &#x27;preventOverflow&#x27;)) {
	    return data;
	  }

	  var refRect = data.offsets.reference;
	  var bound = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === &#x27;preventOverflow&#x27;;
	  }).boundaries;

	  if (refRect.bottom &lt; bound.top || refRect.left &gt; bound.right || refRect.top &gt; bound.bottom || refRect.right &lt; bound.left) {
	    // Avoid unnecessary DOM access if visibility hasn&#x27;t changed
	    if (data.hide === true) {
	      return data;
	    }

	    data.hide = true;
	    data.attributes[&#x27;x-out-of-boundaries&#x27;] = &#x27;&#x27;;
	  } else {
	    // Avoid unnecessary DOM access if visibility hasn&#x27;t changed
	    if (data.hide === false) {
	      return data;
	    }

	    data.hide = false;
	    data.attributes[&#x27;x-out-of-boundaries&#x27;] = false;
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function inner(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split(&#x27;-&#x27;)[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isHoriz = [&#x27;left&#x27;, &#x27;right&#x27;].indexOf(basePlacement) !== -1;

	  var subtractLength = [&#x27;top&#x27;, &#x27;left&#x27;].indexOf(basePlacement) === -1;

	  popper[isHoriz ? &#x27;left&#x27; : &#x27;top&#x27;] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? &#x27;width&#x27; : &#x27;height&#x27;] : 0);

	  data.placement = getOppositePlacement(placement);
	  data.offsets.popper = getClientRect(popper);

	  return data;
	}

	/**
	 * Modifier function, each modifier can have a function of this type assigned
	 * to its &#x60;fn&#x60; property.&lt;br /&gt;
	 * These functions will be called on each update, this means that you must
	 * make sure they are performant enough to avoid performance bottlenecks.
	 *
	 * @function ModifierFn
	 * @argument {dataObject} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {dataObject} The data object, properly modified
	 */

	/**
	 * Modifiers are plugins used to alter the behavior of your poppers.&lt;br /&gt;
	 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
	 * needed by the library.
	 *
	 * Usually you don&#x27;t want to override the &#x60;order&#x60;, &#x60;fn&#x60; and &#x60;onLoad&#x60; props.
	 * All the other properties are configurations that could be tweaked.
	 * @namespace modifiers
	 */
	var modifiers = {
	  /**
	   * Modifier used to shift the popper on the start or end of its reference
	   * element.&lt;br /&gt;
	   * It will read the variation of the &#x60;placement&#x60; property.&lt;br /&gt;
	   * It can be one either &#x60;-end&#x60; or &#x60;-start&#x60;.
	   * @memberof modifiers
	   * @inner
	   */
	  shift: {
	    /** @prop {number} order=100 - Index used to define the order of execution */
	    order: 100,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: shift
	  },

	  /**
	   * The &#x60;offset&#x60; modifier can shift your popper on both its axis.
	   *
	   * It accepts the following units:
	   * - &#x60;px&#x60; or unitless, interpreted as pixels
	   * - &#x60;%&#x60; or &#x60;%r&#x60;, percentage relative to the length of the reference element
	   * - &#x60;%p&#x60;, percentage relative to the length of the popper element
	   * - &#x60;vw&#x60;, CSS viewport width unit
	   * - &#x60;vh&#x60;, CSS viewport height unit
	   *
	   * For length is intended the main axis relative to the placement of the popper.&lt;br /&gt;
	   * This means that if the placement is &#x60;top&#x60; or &#x60;bottom&#x60;, the length will be the
	   * &#x60;width&#x60;. In case of &#x60;left&#x60; or &#x60;right&#x60;, it will be the height.
	   *
	   * You can provide a single value (as &#x60;Number&#x60; or &#x60;String&#x60;), or a pair of values
	   * as &#x60;String&#x60; divided by a comma or one (or more) white spaces.&lt;br /&gt;
	   * The latter is a deprecated method because it leads to confusion and will be
	   * removed in v2.&lt;br /&gt;
	   * Additionally, it accepts additions and subtractions between different units.
	   * Note that multiplications and divisions aren&#x27;t supported.
	   *
	   * Valid examples are:
	   * &#x60;&#x60;&#x60;
	   * 10
	   * &#x27;10%&#x27;
	   * &#x27;10, 10&#x27;
	   * &#x27;10%, 10&#x27;
	   * &#x27;10 + 10%&#x27;
	   * &#x27;10 - 5vh + 3%&#x27;
	   * &#x27;-10px + 5vh, 5px - 6%&#x27;
	   * &#x60;&#x60;&#x60;
	   * &gt; **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
	   * &gt; with their reference element, unfortunately, you will have to disable the &#x60;flip&#x60; modifier.
	   * &gt; More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  offset: {
	    /** @prop {number} order=200 - Index used to define the order of execution */
	    order: 200,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: offset,
	    /** @prop {Number|String} offset=0
	     * The offset value as described in the modifier description
	     */
	    offset: 0
	  },

	  /**
	   * Modifier used to prevent the popper from being positioned outside the boundary.
	   *
	   * An scenario exists where the reference itself is not within the boundaries.&lt;br /&gt;
	   * We can say it has &quot;escaped the boundaries&quot; — or just &quot;escaped&quot;.&lt;br /&gt;
	   * In this case we need to decide whether the popper should either:
	   *
	   * - detach from the reference and remain &quot;trapped&quot; in the boundaries, or
	   * - if it should ignore the boundary and &quot;escape with its reference&quot;
	   *
	   * When &#x60;escapeWithReference&#x60; is set to&#x60;true&#x60; and reference is completely
	   * outside its boundaries, the popper will overflow (or completely leave)
	   * the boundaries in order to remain attached to the edge of the reference.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  preventOverflow: {
	    /** @prop {number} order=300 - Index used to define the order of execution */
	    order: 300,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: preventOverflow,
	    /**
	     * @prop {Array} [priority=[&#x27;left&#x27;,&#x27;right&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;]]
	     * Popper will try to prevent overflow following these priorities by default,
	     * then, it could overflow on the left and on top of the &#x60;boundariesElement&#x60;
	     */
	    priority: [&#x27;left&#x27;, &#x27;right&#x27;, &#x27;top&#x27;, &#x27;bottom&#x27;],
	    /**
	     * @prop {number} padding=5
	     * Amount of pixel used to define a minimum distance between the boundaries
	     * and the popper this makes sure the popper has always a little padding
	     * between the edges of its container
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement=&#x27;scrollParent&#x27;
	     * Boundaries used by the modifier, can be &#x60;scrollParent&#x60;, &#x60;window&#x60;,
	     * &#x60;viewport&#x60; or any DOM element.
	     */
	    boundariesElement: &#x27;scrollParent&#x27;
	  },

	  /**
	   * Modifier used to make sure the reference and its popper stay near eachothers
	   * without leaving any gap between the two. Expecially useful when the arrow is
	   * enabled and you want to assure it to point to its reference element.
	   * It cares only about the first axis, you can still have poppers with margin
	   * between the popper and its reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  keepTogether: {
	    /** @prop {number} order=400 - Index used to define the order of execution */
	    order: 400,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: keepTogether
	  },

	  /**
	   * This modifier is used to move the &#x60;arrowElement&#x60; of the popper to make
	   * sure it is positioned between the reference element and its popper element.
	   * It will read the outer size of the &#x60;arrowElement&#x60; node to detect how many
	   * pixels of conjuction are needed.
	   *
	   * It has no effect if no &#x60;arrowElement&#x60; is provided.
	   * @memberof modifiers
	   * @inner
	   */
	  arrow: {
	    /** @prop {number} order=500 - Index used to define the order of execution */
	    order: 500,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: arrow,
	    /** @prop {String|HTMLElement} element=&#x27;[x-arrow]&#x27; - Selector or node used as arrow */
	    element: &#x27;[x-arrow]&#x27;
	  },

	  /**
	   * Modifier used to flip the popper&#x27;s placement when it starts to overlap its
	   * reference element.
	   *
	   * Requires the &#x60;preventOverflow&#x60; modifier before it in order to work.
	   *
	   * **NOTE:** this modifier will interrupt the current update cycle and will
	   * restart it if it detects the need to flip the placement.
	   * @memberof modifiers
	   * @inner
	   */
	  flip: {
	    /** @prop {number} order=600 - Index used to define the order of execution */
	    order: 600,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: flip,
	    /**
	     * @prop {String|Array} behavior=&#x27;flip&#x27;
	     * The behavior used to change the popper&#x27;s placement. It can be one of
	     * &#x60;flip&#x60;, &#x60;clockwise&#x60;, &#x60;counterclockwise&#x60; or an array with a list of valid
	     * placements (with optional variations).
	     */
	    behavior: &#x27;flip&#x27;,
	    /**
	     * @prop {number} padding=5
	     * The popper will flip if it hits the edges of the &#x60;boundariesElement&#x60;
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement=&#x27;viewport&#x27;
	     * The element which will define the boundaries of the popper position,
	     * the popper will never be placed outside of the defined boundaries
	     * (except if keepTogether is enabled)
	     */
	    boundariesElement: &#x27;viewport&#x27;
	  },

	  /**
	   * Modifier used to make the popper flow toward the inner of the reference element.
	   * By default, when this modifier is disabled, the popper will be placed outside
	   * the reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  inner: {
	    /** @prop {number} order=700 - Index used to define the order of execution */
	    order: 700,
	    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
	    enabled: false,
	    /** @prop {ModifierFn} */
	    fn: inner
	  },

	  /**
	   * Modifier used to hide the popper when its reference element is outside of the
	   * popper boundaries. It will set a &#x60;x-out-of-boundaries&#x60; attribute which can
	   * be used to hide with a CSS selector the popper when its reference is
	   * out of boundaries.
	   *
	   * Requires the &#x60;preventOverflow&#x60; modifier before it in order to work.
	   * @memberof modifiers
	   * @inner
	   */
	  hide: {
	    /** @prop {number} order=800 - Index used to define the order of execution */
	    order: 800,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: hide
	  },

	  /**
	   * Computes the style that will be applied to the popper element to gets
	   * properly positioned.
	   *
	   * Note that this modifier will not touch the DOM, it just prepares the styles
	   * so that &#x60;applyStyle&#x60; modifier can apply it. This separation is useful
	   * in case you need to replace &#x60;applyStyle&#x60; with a custom implementation.
	   *
	   * This modifier has &#x60;850&#x60; as &#x60;order&#x60; value to maintain backward compatibility
	   * with previous versions of Popper.js. Expect the modifiers ordering method
	   * to change in future major versions of the library.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  computeStyle: {
	    /** @prop {number} order=850 - Index used to define the order of execution */
	    order: 850,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: computeStyle,
	    /**
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3d transformation to position the popper.
	     * Otherwise, it will use the &#x60;top&#x60; and &#x60;left&#x60; properties.
	     */
	    gpuAcceleration: true,
	    /**
	     * @prop {string} [x=&#x27;bottom&#x27;]
	     * Where to anchor the X axis (&#x60;bottom&#x60; or &#x60;top&#x60;). AKA X offset origin.
	     * Change this if your popper should grow in a direction different from &#x60;bottom&#x60;
	     */
	    x: &#x27;bottom&#x27;,
	    /**
	     * @prop {string} [x=&#x27;left&#x27;]
	     * Where to anchor the Y axis (&#x60;left&#x60; or &#x60;right&#x60;). AKA Y offset origin.
	     * Change this if your popper should grow in a direction different from &#x60;right&#x60;
	     */
	    y: &#x27;right&#x27;
	  },

	  /**
	   * Applies the computed styles to the popper element.
	   *
	   * All the DOM manipulations are limited to this modifier. This is useful in case
	   * you want to integrate Popper.js inside a framework or view library and you
	   * want to delegate all the DOM manipulations to it.
	   *
	   * Note that if you disable this modifier, you must make sure the popper element
	   * has its position set to &#x60;absolute&#x60; before Popper.js can do its work!
	   *
	   * Just disable this modifier and define you own to achieve the desired effect.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  applyStyle: {
	    /** @prop {number} order=900 - Index used to define the order of execution */
	    order: 900,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: applyStyle,
	    /** @prop {Function} */
	    onLoad: applyStyleOnLoad,
	    /**
	     * @deprecated since version 1.10.0, the property moved to &#x60;computeStyle&#x60; modifier
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3d transformation to position the popper.
	     * Otherwise, it will use the &#x60;top&#x60; and &#x60;left&#x60; properties.
	     */
	    gpuAcceleration: undefined
	  }
	};

	/**
	 * The &#x60;dataObject&#x60; is an object containing all the informations used by Popper.js
	 * this object get passed to modifiers and to the &#x60;onCreate&#x60; and &#x60;onUpdate&#x60; callbacks.
	 * @name dataObject
	 * @property {Object} data.instance The Popper.js instance
	 * @property {String} data.placement Placement applied to popper
	 * @property {String} data.originalPlacement Placement originally defined on init
	 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
	 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
	 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
	 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. &#x60;marginBottom&#x60;)
	 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. &#x60;marginBottom&#x60;)
	 * @property {Object} data.boundaries Offsets of the popper boundaries
	 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
	 * @property {Object} data.offsets.popper &#x60;top&#x60;, &#x60;left&#x60;, &#x60;width&#x60;, &#x60;height&#x60; values
	 * @property {Object} data.offsets.reference &#x60;top&#x60;, &#x60;left&#x60;, &#x60;width&#x60;, &#x60;height&#x60; values
	 * @property {Object} data.offsets.arrow] &#x60;top&#x60; and &#x60;left&#x60; offsets, only one of them will be different from 0
	 */

	/**
	 * Default options provided to Popper.js constructor.&lt;br /&gt;
	 * These can be overriden using the &#x60;options&#x60; argument of Popper.js.&lt;br /&gt;
	 * To override an option, simply pass as 3rd argument an object with the same
	 * structure of this object, example:
	 * &#x60;&#x60;&#x60;
	 * new Popper(ref, pop, {
	 *   modifiers: {
	 *     preventOverflow: { enabled: false }
	 *   }
	 * })
	 * &#x60;&#x60;&#x60;
	 * @type {Object}
	 * @static
	 * @memberof Popper
	 */
	var Defaults = {
	  /**
	   * Popper&#x27;s placement
	   * @prop {Popper.placements} placement=&#x27;bottom&#x27;
	   */
	  placement: &#x27;bottom&#x27;,

	  /**
	   * Set this to true if you want popper to position it self in &#x27;fixed&#x27; mode
	   * @prop {Boolean} positionFixed=false
	   */
	  positionFixed: false,

	  /**
	   * Whether events (resize, scroll) are initially enabled
	   * @prop {Boolean} eventsEnabled=true
	   */
	  eventsEnabled: true,

	  /**
	   * Set to true if you want to automatically remove the popper when
	   * you call the &#x60;destroy&#x60; method.
	   * @prop {Boolean} removeOnDestroy=false
	   */
	  removeOnDestroy: false,

	  /**
	   * Callback called when the popper is created.&lt;br /&gt;
	   * By default, is set to no-op.&lt;br /&gt;
	   * Access Popper.js instance with &#x60;data.instance&#x60;.
	   * @prop {onCreate}
	   */
	  onCreate: function onCreate() {},

	  /**
	   * Callback called when the popper is updated, this callback is not called
	   * on the initialization/creation of the popper, but only on subsequent
	   * updates.&lt;br /&gt;
	   * By default, is set to no-op.&lt;br /&gt;
	   * Access Popper.js instance with &#x60;data.instance&#x60;.
	   * @prop {onUpdate}
	   */
	  onUpdate: function onUpdate() {},

	  /**
	   * List of modifiers used to modify the offsets before they are applied to the popper.
	   * They provide most of the functionalities of Popper.js
	   * @prop {modifiers}
	   */
	  modifiers: modifiers
	};

	/**
	 * @callback onCreate
	 * @param {dataObject} data
	 */

	/**
	 * @callback onUpdate
	 * @param {dataObject} data
	 */

	// Utils
	// Methods
	var Popper = function () {
	  /**
	   * Create a new Popper.js instance
	   * @class Popper
	   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
	   * @param {HTMLElement} popper - The HTML element used as popper.
	   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
	   * @return {Object} instance - The generated Popper.js instance
	   */
	  function Popper(reference, popper) {
	    var _this = this;

	    var options = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : {};
	    classCallCheck(this, Popper);

	    this.scheduleUpdate = function () {
	      return requestAnimationFrame(_this.update);
	    };

	    // make update() debounced, so that it only runs at most once-per-tick
	    this.update = debounce(this.update.bind(this));

	    // with {} we create a new object with the options inside it
	    this.options = _extends({}, Popper.Defaults, options);

	    // init state
	    this.state = {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };

	    // get reference and popper elements (allow jQuery wrappers)
	    this.reference = reference &amp;&amp; reference.jquery ? reference[0] : reference;
	    this.popper = popper &amp;&amp; popper.jquery ? popper[0] : popper;

	    // Deep merge modifiers options
	    this.options.modifiers = {};
	    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });

	    // Refactoring modifiers&#x27; list (Object =&gt; Array)
	    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
	      return _extends({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    // sort the modifiers by order
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });

	    // modifiers have the ability to execute arbitrary code when Popper.js get inited
	    // such code is executed in the same order of its modifier
	    // they could add new properties to their options configuration
	    // BE AWARE: don&#x27;t add options to &#x60;options.modifiers.name&#x60; but to &#x60;modifierOptions&#x60;!
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled &amp;&amp; isFunction(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });

	    // fire the first update to position the popper in the right place
	    this.update();

	    var eventsEnabled = this.options.eventsEnabled;
	    if (eventsEnabled) {
	      // setup event listeners, they will take care of update the position in specific situations
	      this.enableEventListeners();
	    }

	    this.state.eventsEnabled = eventsEnabled;
	  }

	  // We can&#x27;t use class properties because they don&#x27;t get listed in the
	  // class prototype and break stuff like Sinon stubs


	  createClass(Popper, [{
	    key: &#x27;update&#x27;,
	    value: function update$$1() {
	      return update.call(this);
	    }
	  }, {
	    key: &#x27;destroy&#x27;,
	    value: function destroy$$1() {
	      return destroy.call(this);
	    }
	  }, {
	    key: &#x27;enableEventListeners&#x27;,
	    value: function enableEventListeners$$1() {
	      return enableEventListeners.call(this);
	    }
	  }, {
	    key: &#x27;disableEventListeners&#x27;,
	    value: function disableEventListeners$$1() {
	      return disableEventListeners.call(this);
	    }

	    /**
	     * Schedule an update, it will run on the next UI update available
	     * @method scheduleUpdate
	     * @memberof Popper
	     */


	    /**
	     * Collection of utilities useful when writing custom modifiers.
	     * Starting from version 1.7, this method is available only if you
	     * include &#x60;popper-utils.js&#x60; before &#x60;popper.js&#x60;.
	     *
	     * **DEPRECATION**: This way to access PopperUtils is deprecated
	     * and will be removed in v2! Use the PopperUtils module directly instead.
	     * Due to the high instability of the methods contained in Utils, we can&#x27;t
	     * guarantee them to follow semver. Use them at your own risk!
	     * @static
	     * @private
	     * @type {Object}
	     * @deprecated since version 1.8
	     * @member Utils
	     * @memberof Popper
	     */

	  }]);
	  return Popper;
	}();

	/**
	 * The &#x60;referenceObject&#x60; is an object that provides an interface compatible with Popper.js
	 * and lets you use it as replacement of a real DOM node.&lt;br /&gt;
	 * You can use this method to position a popper relatively to a set of coordinates
	 * in case you don&#x27;t have a DOM node to use as reference.
	 *
	 * &#x60;&#x60;&#x60;
	 * new Popper(referenceObject, popperNode);
	 * &#x60;&#x60;&#x60;
	 *
	 * NB: This feature isn&#x27;t supported in Internet Explorer 10
	 * @name referenceObject
	 * @property {Function} data.getBoundingClientRect
	 * A function that returns a set of coordinates compatible with the native &#x60;getBoundingClientRect&#x60; method.
	 * @property {number} data.clientWidth
	 * An ES6 getter that will return the width of the virtual reference element.
	 * @property {number} data.clientHeight
	 * An ES6 getter that will return the height of the virtual reference element.
	 */


	Popper.Utils = (typeof window !== &#x27;undefined&#x27; ? window : global).PopperUtils;
	Popper.placements = placements;
	Popper.Defaults = Defaults;

	return Popper;

	})));
	//# sourceMappingURL=popper.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	  * Bootstrap v4.0.0 (https://getbootstrap.com)
	  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	  */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(5), __webpack_require__(8)) :
		typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;exports&#x27;, &#x27;jquery&#x27;, &#x27;popper.js&#x27;], factory) :
		(factory((global.bootstrap = {}),global.jQuery,global.Popper));
	}(this, (function (exports,$,Popper) { &#x27;use strict&#x27;;

	$ = $ &amp;&amp; $.hasOwnProperty(&#x27;default&#x27;) ? $[&#x27;default&#x27;] : $;
	Popper = Popper &amp;&amp; Popper.hasOwnProperty(&#x27;default&#x27;) ? Popper[&#x27;default&#x27;] : Popper;

	function _defineProperties(target, props) {
	  for (var i = 0; i &lt; props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if (&quot;value&quot; in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i &lt; arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): util.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Util = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Private TransitionEnd Helpers
	   * ------------------------------------------------------------------------
	   */
	  var transition = false;
	  var MAX_UID = 1000000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

	  function toType(obj) {
	    return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
	  }

	  function getSpecialTransitionEndEvent() {
	    return {
	      bindType: transition.end,
	      delegateType: transition.end,
	      handle: function handle(event) {
	        if ($$$1(event.target).is(this)) {
	          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
	        }

	        return undefined; // eslint-disable-line no-undefined
	      }
	    };
	  }

	  function transitionEndTest() {
	    if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window.QUnit) {
	      return false;
	    }

	    return {
	      end: &#x27;transitionend&#x27;
	    };
	  }

	  function transitionEndEmulator(duration) {
	    var _this = this;

	    var called = false;
	    $$$1(this).one(Util.TRANSITION_END, function () {
	      called = true;
	    });
	    setTimeout(function () {
	      if (!called) {
	        Util.triggerTransitionEnd(_this);
	      }
	    }, duration);
	    return this;
	  }

	  function setTransitionEndSupport() {
	    transition = transitionEndTest();
	    $$$1.fn.emulateTransitionEnd = transitionEndEmulator;

	    if (Util.supportsTransitionEnd()) {
	      $$$1.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
	    }
	  }

	  function escapeId(selector) {
	    // We escape IDs in case of special selectors (selector = &#x27;#myId:something&#x27;)
	    // $.escapeSelector does not exist in jQuery &lt; 3
	    selector = typeof $$$1.escapeSelector === &#x27;function&#x27; ? $$$1.escapeSelector(selector).substr(1) : selector.replace(/(:|\.|\[|\]|,|=|@)/g, &#x27;\\$1&#x27;);
	    return selector;
	  }
	  /**
	   * --------------------------------------------------------------------------
	   * Public Util Api
	   * --------------------------------------------------------------------------
	   */


	  var Util = {
	    TRANSITION_END: &#x27;bsTransitionEnd&#x27;,
	    getUID: function getUID(prefix) {
	      do {
	        // eslint-disable-next-line no-bitwise
	        prefix += ~~(Math.random() * MAX_UID); // &quot;~~&quot; acts like a faster Math.floor() here
	      } while (document.getElementById(prefix));

	      return prefix;
	    },
	    getSelectorFromElement: function getSelectorFromElement(element) {
	      var selector = element.getAttribute(&#x27;data-target&#x27;);

	      if (!selector || selector === &#x27;#&#x27;) {
	        selector = element.getAttribute(&#x27;href&#x27;) || &#x27;&#x27;;
	      } // If it&#x27;s an ID


	      if (selector.charAt(0) === &#x27;#&#x27;) {
	        selector = escapeId(selector);
	      }

	      try {
	        var $selector = $$$1(document).find(selector);
	        return $selector.length &gt; 0 ? selector : null;
	      } catch (err) {
	        return null;
	      }
	    },
	    reflow: function reflow(element) {
	      return element.offsetHeight;
	    },
	    triggerTransitionEnd: function triggerTransitionEnd(element) {
	      $$$1(element).trigger(transition.end);
	    },
	    supportsTransitionEnd: function supportsTransitionEnd() {
	      return Boolean(transition);
	    },
	    isElement: function isElement(obj) {
	      return (obj[0] || obj).nodeType;
	    },
	    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
	      for (var property in configTypes) {
	        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
	          var expectedTypes = configTypes[property];
	          var value = config[property];
	          var valueType = value &amp;&amp; Util.isElement(value) ? &#x27;element&#x27; : toType(value);

	          if (!new RegExp(expectedTypes).test(valueType)) {
	            throw new Error(componentName.toUpperCase() + &quot;: &quot; + (&quot;Option \&quot;&quot; + property + &quot;\&quot; provided type \&quot;&quot; + valueType + &quot;\&quot; &quot;) + (&quot;but expected type \&quot;&quot; + expectedTypes + &quot;\&quot;.&quot;));
	          }
	        }
	      }
	    }
	  };
	  setTransitionEndSupport();
	  return Util;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): alert.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Alert = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;alert&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.alert&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var TRANSITION_DURATION = 150;
	  var Selector = {
	    DISMISS: &#x27;[data-dismiss=&quot;alert&quot;]&#x27;
	  };
	  var Event = {
	    CLOSE: &quot;close&quot; + EVENT_KEY,
	    CLOSED: &quot;closed&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    ALERT: &#x27;alert&#x27;,
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Alert =
	  /*#__PURE__*/
	  function () {
	    function Alert(element) {
	      this._element = element;
	    } // Getters


	    var _proto = Alert.prototype;

	    // Public
	    _proto.close = function close(element) {
	      element = element || this._element;

	      var rootElement = this._getRootElement(element);

	      var customEvent = this._triggerCloseEvent(rootElement);

	      if (customEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._removeElement(rootElement);
	    };

	    _proto.dispose = function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._element = null;
	    }; // Private


	    _proto._getRootElement = function _getRootElement(element) {
	      var selector = Util.getSelectorFromElement(element);
	      var parent = false;

	      if (selector) {
	        parent = $$$1(selector)[0];
	      }

	      if (!parent) {
	        parent = $$$1(element).closest(&quot;.&quot; + ClassName.ALERT)[0];
	      }

	      return parent;
	    };

	    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
	      var closeEvent = $$$1.Event(Event.CLOSE);
	      $$$1(element).trigger(closeEvent);
	      return closeEvent;
	    };

	    _proto._removeElement = function _removeElement(element) {
	      var _this = this;

	      $$$1(element).removeClass(ClassName.SHOW);

	      if (!Util.supportsTransitionEnd() || !$$$1(element).hasClass(ClassName.FADE)) {
	        this._destroyElement(element);

	        return;
	      }

	      $$$1(element).one(Util.TRANSITION_END, function (event) {
	        return _this._destroyElement(element, event);
	      }).emulateTransitionEnd(TRANSITION_DURATION);
	    };

	    _proto._destroyElement = function _destroyElement(element) {
	      $$$1(element).detach().trigger(Event.CLOSED).remove();
	    }; // Static


	    Alert._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var $element = $$$1(this);
	        var data = $element.data(DATA_KEY);

	        if (!data) {
	          data = new Alert(this);
	          $element.data(DATA_KEY, data);
	        }

	        if (config === &#x27;close&#x27;) {
	          data[config](this);
	        }
	      });
	    };

	    Alert._handleDismiss = function _handleDismiss(alertInstance) {
	      return function (event) {
	        if (event) {
	          event.preventDefault();
	        }

	        alertInstance.close(this);
	      };
	    };

	    _createClass(Alert, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Alert;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = Alert._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Alert;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Alert._jQueryInterface;
	  };

	  return Alert;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): button.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Button = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;button&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.button&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var ClassName = {
	    ACTIVE: &#x27;active&#x27;,
	    BUTTON: &#x27;btn&#x27;,
	    FOCUS: &#x27;focus&#x27;
	  };
	  var Selector = {
	    DATA_TOGGLE_CARROT: &#x27;[data-toggle^=&quot;button&quot;]&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle=&quot;buttons&quot;]&#x27;,
	    INPUT: &#x27;input&#x27;,
	    ACTIVE: &#x27;.active&#x27;,
	    BUTTON: &#x27;.btn&#x27;
	  };
	  var Event = {
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
	    FOCUS_BLUR_DATA_API: &quot;focus&quot; + EVENT_KEY + DATA_API_KEY + &quot; &quot; + (&quot;blur&quot; + EVENT_KEY + DATA_API_KEY)
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Button =
	  /*#__PURE__*/
	  function () {
	    function Button(element) {
	      this._element = element;
	    } // Getters


	    var _proto = Button.prototype;

	    // Public
	    _proto.toggle = function toggle() {
	      var triggerChangeEvent = true;
	      var addAriaPressed = true;
	      var rootElement = $$$1(this._element).closest(Selector.DATA_TOGGLE)[0];

	      if (rootElement) {
	        var input = $$$1(this._element).find(Selector.INPUT)[0];

	        if (input) {
	          if (input.type === &#x27;radio&#x27;) {
	            if (input.checked &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE)) {
	              triggerChangeEvent = false;
	            } else {
	              var activeElement = $$$1(rootElement).find(Selector.ACTIVE)[0];

	              if (activeElement) {
	                $$$1(activeElement).removeClass(ClassName.ACTIVE);
	              }
	            }
	          }

	          if (triggerChangeEvent) {
	            if (input.hasAttribute(&#x27;disabled&#x27;) || rootElement.hasAttribute(&#x27;disabled&#x27;) || input.classList.contains(&#x27;disabled&#x27;) || rootElement.classList.contains(&#x27;disabled&#x27;)) {
	              return;
	            }

	            input.checked = !$$$1(this._element).hasClass(ClassName.ACTIVE);
	            $$$1(input).trigger(&#x27;change&#x27;);
	          }

	          input.focus();
	          addAriaPressed = false;
	        }
	      }

	      if (addAriaPressed) {
	        this._element.setAttribute(&#x27;aria-pressed&#x27;, !$$$1(this._element).hasClass(ClassName.ACTIVE));
	      }

	      if (triggerChangeEvent) {
	        $$$1(this._element).toggleClass(ClassName.ACTIVE);
	      }
	    };

	    _proto.dispose = function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._element = null;
	    }; // Static


	    Button._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $$$1(this).data(DATA_KEY);

	        if (!data) {
	          data = new Button(this);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (config === &#x27;toggle&#x27;) {
	          data[config]();
	        }
	      });
	    };

	    _createClass(Button, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Button;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
	    event.preventDefault();
	    var button = event.target;

	    if (!$$$1(button).hasClass(ClassName.BUTTON)) {
	      button = $$$1(button).closest(Selector.BUTTON);
	    }

	    Button._jQueryInterface.call($$$1(button), &#x27;toggle&#x27;);
	  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
	    var button = $$$1(event.target).closest(Selector.BUTTON)[0];
	    $$$1(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = Button._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Button;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Button._jQueryInterface;
	  };

	  return Button;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): carousel.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Carousel = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;carousel&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.carousel&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var TRANSITION_DURATION = 600;
	  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

	  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

	  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

	  var Default = {
	    interval: 5000,
	    keyboard: true,
	    slide: false,
	    pause: &#x27;hover&#x27;,
	    wrap: true
	  };
	  var DefaultType = {
	    interval: &#x27;(number|boolean)&#x27;,
	    keyboard: &#x27;boolean&#x27;,
	    slide: &#x27;(boolean|string)&#x27;,
	    pause: &#x27;(string|boolean)&#x27;,
	    wrap: &#x27;boolean&#x27;
	  };
	  var Direction = {
	    NEXT: &#x27;next&#x27;,
	    PREV: &#x27;prev&#x27;,
	    LEFT: &#x27;left&#x27;,
	    RIGHT: &#x27;right&#x27;
	  };
	  var Event = {
	    SLIDE: &quot;slide&quot; + EVENT_KEY,
	    SLID: &quot;slid&quot; + EVENT_KEY,
	    KEYDOWN: &quot;keydown&quot; + EVENT_KEY,
	    MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
	    MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY,
	    TOUCHEND: &quot;touchend&quot; + EVENT_KEY,
	    LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    CAROUSEL: &#x27;carousel&#x27;,
	    ACTIVE: &#x27;active&#x27;,
	    SLIDE: &#x27;slide&#x27;,
	    RIGHT: &#x27;carousel-item-right&#x27;,
	    LEFT: &#x27;carousel-item-left&#x27;,
	    NEXT: &#x27;carousel-item-next&#x27;,
	    PREV: &#x27;carousel-item-prev&#x27;,
	    ITEM: &#x27;carousel-item&#x27;
	  };
	  var Selector = {
	    ACTIVE: &#x27;.active&#x27;,
	    ACTIVE_ITEM: &#x27;.active.carousel-item&#x27;,
	    ITEM: &#x27;.carousel-item&#x27;,
	    NEXT_PREV: &#x27;.carousel-item-next, .carousel-item-prev&#x27;,
	    INDICATORS: &#x27;.carousel-indicators&#x27;,
	    DATA_SLIDE: &#x27;[data-slide], [data-slide-to]&#x27;,
	    DATA_RIDE: &#x27;[data-ride=&quot;carousel&quot;]&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Carousel =
	  /*#__PURE__*/
	  function () {
	    function Carousel(element, config) {
	      this._items = null;
	      this._interval = null;
	      this._activeElement = null;
	      this._isPaused = false;
	      this._isSliding = false;
	      this.touchTimeout = null;
	      this._config = this._getConfig(config);
	      this._element = $$$1(element)[0];
	      this._indicatorsElement = $$$1(this._element).find(Selector.INDICATORS)[0];

	      this._addEventListeners();
	    } // Getters


	    var _proto = Carousel.prototype;

	    // Public
	    _proto.next = function next() {
	      if (!this._isSliding) {
	        this._slide(Direction.NEXT);
	      }
	    };

	    _proto.nextWhenVisible = function nextWhenVisible() {
	      // Don&#x27;t call next when the page isn&#x27;t visible
	      // or the carousel or its parent isn&#x27;t visible
	      if (!document.hidden &amp;&amp; $$$1(this._element).is(&#x27;:visible&#x27;) &amp;&amp; $$$1(this._element).css(&#x27;visibility&#x27;) !== &#x27;hidden&#x27;) {
	        this.next();
	      }
	    };

	    _proto.prev = function prev() {
	      if (!this._isSliding) {
	        this._slide(Direction.PREV);
	      }
	    };

	    _proto.pause = function pause(event) {
	      if (!event) {
	        this._isPaused = true;
	      }

	      if ($$$1(this._element).find(Selector.NEXT_PREV)[0] &amp;&amp; Util.supportsTransitionEnd()) {
	        Util.triggerTransitionEnd(this._element);
	        this.cycle(true);
	      }

	      clearInterval(this._interval);
	      this._interval = null;
	    };

	    _proto.cycle = function cycle(event) {
	      if (!event) {
	        this._isPaused = false;
	      }

	      if (this._interval) {
	        clearInterval(this._interval);
	        this._interval = null;
	      }

	      if (this._config.interval &amp;&amp; !this._isPaused) {
	        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
	      }
	    };

	    _proto.to = function to(index) {
	      var _this = this;

	      this._activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];

	      var activeIndex = this._getItemIndex(this._activeElement);

	      if (index &gt; this._items.length - 1 || index &lt; 0) {
	        return;
	      }

	      if (this._isSliding) {
	        $$$1(this._element).one(Event.SLID, function () {
	          return _this.to(index);
	        });
	        return;
	      }

	      if (activeIndex === index) {
	        this.pause();
	        this.cycle();
	        return;
	      }

	      var direction = index &gt; activeIndex ? Direction.NEXT : Direction.PREV;

	      this._slide(direction, this._items[index]);
	    };

	    _proto.dispose = function dispose() {
	      $$$1(this._element).off(EVENT_KEY);
	      $$$1.removeData(this._element, DATA_KEY);
	      this._items = null;
	      this._config = null;
	      this._element = null;
	      this._interval = null;
	      this._isPaused = null;
	      this._isSliding = null;
	      this._activeElement = null;
	      this._indicatorsElement = null;
	    }; // Private


	    _proto._getConfig = function _getConfig(config) {
	      config = _extends({}, Default, config);
	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._addEventListeners = function _addEventListeners() {
	      var _this2 = this;

	      if (this._config.keyboard) {
	        $$$1(this._element).on(Event.KEYDOWN, function (event) {
	          return _this2._keydown(event);
	        });
	      }

	      if (this._config.pause === &#x27;hover&#x27;) {
	        $$$1(this._element).on(Event.MOUSEENTER, function (event) {
	          return _this2.pause(event);
	        }).on(Event.MOUSELEAVE, function (event) {
	          return _this2.cycle(event);
	        });

	        if (&#x27;ontouchstart&#x27; in document.documentElement) {
	          // If it&#x27;s a touch-enabled device, mouseenter/leave are fired as
	          // part of the mouse compatibility events on first tap - the carousel
	          // would stop cycling until user tapped out of it;
	          // here, we listen for touchend, explicitly pause the carousel
	          // (as if it&#x27;s the second time we tap on it, mouseenter compat event
	          // is NOT fired) and after a timeout (to allow for mouse compatibility
	          // events to fire) we explicitly restart cycling
	          $$$1(this._element).on(Event.TOUCHEND, function () {
	            _this2.pause();

	            if (_this2.touchTimeout) {
	              clearTimeout(_this2.touchTimeout);
	            }

	            _this2.touchTimeout = setTimeout(function (event) {
	              return _this2.cycle(event);
	            }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
	          });
	        }
	      }
	    };

	    _proto._keydown = function _keydown(event) {
	      if (/input|textarea/i.test(event.target.tagName)) {
	        return;
	      }

	      switch (event.which) {
	        case ARROW_LEFT_KEYCODE:
	          event.preventDefault();
	          this.prev();
	          break;

	        case ARROW_RIGHT_KEYCODE:
	          event.preventDefault();
	          this.next();
	          break;

	        default:
	      }
	    };

	    _proto._getItemIndex = function _getItemIndex(element) {
	      this._items = $$$1.makeArray($$$1(element).parent().find(Selector.ITEM));
	      return this._items.indexOf(element);
	    };

	    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
	      var isNextDirection = direction === Direction.NEXT;
	      var isPrevDirection = direction === Direction.PREV;

	      var activeIndex = this._getItemIndex(activeElement);

	      var lastItemIndex = this._items.length - 1;
	      var isGoingToWrap = isPrevDirection &amp;&amp; activeIndex === 0 || isNextDirection &amp;&amp; activeIndex === lastItemIndex;

	      if (isGoingToWrap &amp;&amp; !this._config.wrap) {
	        return activeElement;
	      }

	      var delta = direction === Direction.PREV ? -1 : 1;
	      var itemIndex = (activeIndex + delta) % this._items.length;
	      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
	    };

	    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
	      var targetIndex = this._getItemIndex(relatedTarget);

	      var fromIndex = this._getItemIndex($$$1(this._element).find(Selector.ACTIVE_ITEM)[0]);

	      var slideEvent = $$$1.Event(Event.SLIDE, {
	        relatedTarget: relatedTarget,
	        direction: eventDirectionName,
	        from: fromIndex,
	        to: targetIndex
	      });
	      $$$1(this._element).trigger(slideEvent);
	      return slideEvent;
	    };

	    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
	      if (this._indicatorsElement) {
	        $$$1(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);

	        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

	        if (nextIndicator) {
	          $$$1(nextIndicator).addClass(ClassName.ACTIVE);
	        }
	      }
	    };

	    _proto._slide = function _slide(direction, element) {
	      var _this3 = this;

	      var activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];

	      var activeElementIndex = this._getItemIndex(activeElement);

	      var nextElement = element || activeElement &amp;&amp; this._getItemByDirection(direction, activeElement);

	      var nextElementIndex = this._getItemIndex(nextElement);

	      var isCycling = Boolean(this._interval);
	      var directionalClassName;
	      var orderClassName;
	      var eventDirectionName;

	      if (direction === Direction.NEXT) {
	        directionalClassName = ClassName.LEFT;
	        orderClassName = ClassName.NEXT;
	        eventDirectionName = Direction.LEFT;
	      } else {
	        directionalClassName = ClassName.RIGHT;
	        orderClassName = ClassName.PREV;
	        eventDirectionName = Direction.RIGHT;
	      }

	      if (nextElement &amp;&amp; $$$1(nextElement).hasClass(ClassName.ACTIVE)) {
	        this._isSliding = false;
	        return;
	      }

	      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

	      if (slideEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (!activeElement || !nextElement) {
	        // Some weirdness is happening, so we bail
	        return;
	      }

	      this._isSliding = true;

	      if (isCycling) {
	        this.pause();
	      }

	      this._setActiveIndicatorElement(nextElement);

	      var slidEvent = $$$1.Event(Event.SLID, {
	        relatedTarget: nextElement,
	        direction: eventDirectionName,
	        from: activeElementIndex,
	        to: nextElementIndex
	      });

	      if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.SLIDE)) {
	        $$$1(nextElement).addClass(orderClassName);
	        Util.reflow(nextElement);
	        $$$1(activeElement).addClass(directionalClassName);
	        $$$1(nextElement).addClass(directionalClassName);
	        $$$1(activeElement).one(Util.TRANSITION_END, function () {
	          $$$1(nextElement).removeClass(directionalClassName + &quot; &quot; + orderClassName).addClass(ClassName.ACTIVE);
	          $$$1(activeElement).removeClass(ClassName.ACTIVE + &quot; &quot; + orderClassName + &quot; &quot; + directionalClassName);
	          _this3._isSliding = false;
	          setTimeout(function () {
	            return $$$1(_this3._element).trigger(slidEvent);
	          }, 0);
	        }).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        $$$1(activeElement).removeClass(ClassName.ACTIVE);
	        $$$1(nextElement).addClass(ClassName.ACTIVE);
	        this._isSliding = false;
	        $$$1(this._element).trigger(slidEvent);
	      }

	      if (isCycling) {
	        this.cycle();
	      }
	    }; // Static


	    Carousel._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $$$1(this).data(DATA_KEY);

	        var _config = _extends({}, Default, $$$1(this).data());

	        if (typeof config === &#x27;object&#x27;) {
	          _config = _extends({}, _config, config);
	        }

	        var action = typeof config === &#x27;string&#x27; ? config : _config.slide;

	        if (!data) {
	          data = new Carousel(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;number&#x27;) {
	          data.to(config);
	        } else if (typeof action === &#x27;string&#x27;) {
	          if (typeof data[action] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + action + &quot;\&quot;&quot;);
	          }

	          data[action]();
	        } else if (_config.interval) {
	          data.pause();
	          data.cycle();
	        }
	      });
	    };

	    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
	      var selector = Util.getSelectorFromElement(this);

	      if (!selector) {
	        return;
	      }

	      var target = $$$1(selector)[0];

	      if (!target || !$$$1(target).hasClass(ClassName.CAROUSEL)) {
	        return;
	      }

	      var config = _extends({}, $$$1(target).data(), $$$1(this).data());
	      var slideIndex = this.getAttribute(&#x27;data-slide-to&#x27;);

	      if (slideIndex) {
	        config.interval = false;
	      }

	      Carousel._jQueryInterface.call($$$1(target), config);

	      if (slideIndex) {
	        $$$1(target).data(DATA_KEY).to(slideIndex);
	      }

	      event.preventDefault();
	    };

	    _createClass(Carousel, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Carousel;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
	  $$$1(window).on(Event.LOAD_DATA_API, function () {
	    $$$1(Selector.DATA_RIDE).each(function () {
	      var $carousel = $$$1(this);

	      Carousel._jQueryInterface.call($carousel, $carousel.data());
	    });
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = Carousel._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Carousel;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Carousel._jQueryInterface;
	  };

	  return Carousel;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): collapse.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Collapse = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;collapse&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.collapse&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var TRANSITION_DURATION = 600;
	  var Default = {
	    toggle: true,
	    parent: &#x27;&#x27;
	  };
	  var DefaultType = {
	    toggle: &#x27;boolean&#x27;,
	    parent: &#x27;(string|element)&#x27;
	  };
	  var Event = {
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    SHOW: &#x27;show&#x27;,
	    COLLAPSE: &#x27;collapse&#x27;,
	    COLLAPSING: &#x27;collapsing&#x27;,
	    COLLAPSED: &#x27;collapsed&#x27;
	  };
	  var Dimension = {
	    WIDTH: &#x27;width&#x27;,
	    HEIGHT: &#x27;height&#x27;
	  };
	  var Selector = {
	    ACTIVES: &#x27;.show, .collapsing&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle=&quot;collapse&quot;]&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Collapse =
	  /*#__PURE__*/
	  function () {
	    function Collapse(element, config) {
	      this._isTransitioning = false;
	      this._element = element;
	      this._config = this._getConfig(config);
	      this._triggerArray = $$$1.makeArray($$$1(&quot;[data-toggle=\&quot;collapse\&quot;][href=\&quot;#&quot; + element.id + &quot;\&quot;],&quot; + (&quot;[data-toggle=\&quot;collapse\&quot;][data-target=\&quot;#&quot; + element.id + &quot;\&quot;]&quot;)));
	      var tabToggles = $$$1(Selector.DATA_TOGGLE);

	      for (var i = 0; i &lt; tabToggles.length; i++) {
	        var elem = tabToggles[i];
	        var selector = Util.getSelectorFromElement(elem);

	        if (selector !== null &amp;&amp; $$$1(selector).filter(element).length &gt; 0) {
	          this._selector = selector;

	          this._triggerArray.push(elem);
	        }
	      }

	      this._parent = this._config.parent ? this._getParent() : null;

	      if (!this._config.parent) {
	        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
	      }

	      if (this._config.toggle) {
	        this.toggle();
	      }
	    } // Getters


	    var _proto = Collapse.prototype;

	    // Public
	    _proto.toggle = function toggle() {
	      if ($$$1(this._element).hasClass(ClassName.SHOW)) {
	        this.hide();
	      } else {
	        this.show();
	      }
	    };

	    _proto.show = function show() {
	      var _this = this;

	      if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {
	        return;
	      }

	      var actives;
	      var activesData;

	      if (this._parent) {
	        actives = $$$1.makeArray($$$1(this._parent).find(Selector.ACTIVES).filter(&quot;[data-parent=\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;));

	        if (actives.length === 0) {
	          actives = null;
	        }
	      }

	      if (actives) {
	        activesData = $$$1(actives).not(this._selector).data(DATA_KEY);

	        if (activesData &amp;&amp; activesData._isTransitioning) {
	          return;
	        }
	      }

	      var startEvent = $$$1.Event(Event.SHOW);
	      $$$1(this._element).trigger(startEvent);

	      if (startEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (actives) {
	        Collapse._jQueryInterface.call($$$1(actives).not(this._selector), &#x27;hide&#x27;);

	        if (!activesData) {
	          $$$1(actives).data(DATA_KEY, null);
	        }
	      }

	      var dimension = this._getDimension();

	      $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
	      this._element.style[dimension] = 0;

	      if (this._triggerArray.length &gt; 0) {
	        $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr(&#x27;aria-expanded&#x27;, true);
	      }

	      this.setTransitioning(true);

	      var complete = function complete() {
	        $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
	        _this._element.style[dimension] = &#x27;&#x27;;

	        _this.setTransitioning(false);

	        $$$1(_this._element).trigger(Event.SHOWN);
	      };

	      if (!Util.supportsTransitionEnd()) {
	        complete();
	        return;
	      }

	      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
	      var scrollSize = &quot;scroll&quot; + capitalizedDimension;
	      $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      this._element.style[dimension] = this._element[scrollSize] + &quot;px&quot;;
	    };

	    _proto.hide = function hide() {
	      var _this2 = this;

	      if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {
	        return;
	      }

	      var startEvent = $$$1.Event(Event.HIDE);
	      $$$1(this._element).trigger(startEvent);

	      if (startEvent.isDefaultPrevented()) {
	        return;
	      }

	      var dimension = this._getDimension();

	      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + &quot;px&quot;;
	      Util.reflow(this._element);
	      $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

	      if (this._triggerArray.length &gt; 0) {
	        for (var i = 0; i &lt; this._triggerArray.length; i++) {
	          var trigger = this._triggerArray[i];
	          var selector = Util.getSelectorFromElement(trigger);

	          if (selector !== null) {
	            var $elem = $$$1(selector);

	            if (!$elem.hasClass(ClassName.SHOW)) {
	              $$$1(trigger).addClass(ClassName.COLLAPSED).attr(&#x27;aria-expanded&#x27;, false);
	            }
	          }
	        }
	      }

	      this.setTransitioning(true);

	      var complete = function complete() {
	        _this2.setTransitioning(false);

	        $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
	      };

	      this._element.style[dimension] = &#x27;&#x27;;

	      if (!Util.supportsTransitionEnd()) {
	        complete();
	        return;
	      }

	      $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	    };

	    _proto.setTransitioning = function setTransitioning(isTransitioning) {
	      this._isTransitioning = isTransitioning;
	    };

	    _proto.dispose = function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._config = null;
	      this._parent = null;
	      this._element = null;
	      this._triggerArray = null;
	      this._isTransitioning = null;
	    }; // Private


	    _proto._getConfig = function _getConfig(config) {
	      config = _extends({}, Default, config);
	      config.toggle = Boolean(config.toggle); // Coerce string values

	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._getDimension = function _getDimension() {
	      var hasWidth = $$$1(this._element).hasClass(Dimension.WIDTH);
	      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
	    };

	    _proto._getParent = function _getParent() {
	      var _this3 = this;

	      var parent = null;

	      if (Util.isElement(this._config.parent)) {
	        parent = this._config.parent; // It&#x27;s a jQuery object

	        if (typeof this._config.parent.jquery !== &#x27;undefined&#x27;) {
	          parent = this._config.parent[0];
	        }
	      } else {
	        parent = $$$1(this._config.parent)[0];
	      }

	      var selector = &quot;[data-toggle=\&quot;collapse\&quot;][data-parent=\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;;
	      $$$1(parent).find(selector).each(function (i, element) {
	        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
	      });
	      return parent;
	    };

	    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
	      if (element) {
	        var isOpen = $$$1(element).hasClass(ClassName.SHOW);

	        if (triggerArray.length &gt; 0) {
	          $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr(&#x27;aria-expanded&#x27;, isOpen);
	        }
	      }
	    }; // Static


	    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
	      var selector = Util.getSelectorFromElement(element);
	      return selector ? $$$1(selector)[0] : null;
	    };

	    Collapse._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var $this = $$$1(this);
	        var data = $this.data(DATA_KEY);

	        var _config = _extends({}, Default, $this.data(), typeof config === &#x27;object&#x27; &amp;&amp; config);

	        if (!data &amp;&amp; _config.toggle &amp;&amp; /show|hide/.test(config)) {
	          _config.toggle = false;
	        }

	        if (!data) {
	          data = new Collapse(this, _config);
	          $this.data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;string&#x27;) {
	          if (typeof data[config] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Collapse, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Collapse;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    // preventDefault only for &lt;a&gt; elements (which change the URL) not inside the collapsible element
	    if (event.currentTarget.tagName === &#x27;A&#x27;) {
	      event.preventDefault();
	    }

	    var $trigger = $$$1(this);
	    var selector = Util.getSelectorFromElement(this);
	    $$$1(selector).each(function () {
	      var $target = $$$1(this);
	      var data = $target.data(DATA_KEY);
	      var config = data ? &#x27;toggle&#x27; : $trigger.data();

	      Collapse._jQueryInterface.call($target, config);
	    });
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = Collapse._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Collapse;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Collapse._jQueryInterface;
	  };

	  return Collapse;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): dropdown.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Dropdown = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;dropdown&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.dropdown&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

	  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

	  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

	  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

	  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

	  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

	  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + &quot;|&quot; + ARROW_DOWN_KEYCODE + &quot;|&quot; + ESCAPE_KEYCODE);
	  var Event = {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    CLICK: &quot;click&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
	    KEYDOWN_DATA_API: &quot;keydown&quot; + EVENT_KEY + DATA_API_KEY,
	    KEYUP_DATA_API: &quot;keyup&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    DISABLED: &#x27;disabled&#x27;,
	    SHOW: &#x27;show&#x27;,
	    DROPUP: &#x27;dropup&#x27;,
	    DROPRIGHT: &#x27;dropright&#x27;,
	    DROPLEFT: &#x27;dropleft&#x27;,
	    MENURIGHT: &#x27;dropdown-menu-right&#x27;,
	    MENULEFT: &#x27;dropdown-menu-left&#x27;,
	    POSITION_STATIC: &#x27;position-static&#x27;
	  };
	  var Selector = {
	    DATA_TOGGLE: &#x27;[data-toggle=&quot;dropdown&quot;]&#x27;,
	    FORM_CHILD: &#x27;.dropdown form&#x27;,
	    MENU: &#x27;.dropdown-menu&#x27;,
	    NAVBAR_NAV: &#x27;.navbar-nav&#x27;,
	    VISIBLE_ITEMS: &#x27;.dropdown-menu .dropdown-item:not(.disabled)&#x27;
	  };
	  var AttachmentMap = {
	    TOP: &#x27;top-start&#x27;,
	    TOPEND: &#x27;top-end&#x27;,
	    BOTTOM: &#x27;bottom-start&#x27;,
	    BOTTOMEND: &#x27;bottom-end&#x27;,
	    RIGHT: &#x27;right-start&#x27;,
	    RIGHTEND: &#x27;right-end&#x27;,
	    LEFT: &#x27;left-start&#x27;,
	    LEFTEND: &#x27;left-end&#x27;
	  };
	  var Default = {
	    offset: 0,
	    flip: true,
	    boundary: &#x27;scrollParent&#x27;
	  };
	  var DefaultType = {
	    offset: &#x27;(number|string|function)&#x27;,
	    flip: &#x27;boolean&#x27;,
	    boundary: &#x27;(string|element)&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Dropdown =
	  /*#__PURE__*/
	  function () {
	    function Dropdown(element, config) {
	      this._element = element;
	      this._popper = null;
	      this._config = this._getConfig(config);
	      this._menu = this._getMenuElement();
	      this._inNavbar = this._detectNavbar();

	      this._addEventListeners();
	    } // Getters


	    var _proto = Dropdown.prototype;

	    // Public
	    _proto.toggle = function toggle() {
	      if (this._element.disabled || $$$1(this._element).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var parent = Dropdown._getParentFromElement(this._element);

	      var isActive = $$$1(this._menu).hasClass(ClassName.SHOW);

	      Dropdown._clearMenus();

	      if (isActive) {
	        return;
	      }

	      var relatedTarget = {
	        relatedTarget: this._element
	      };
	      var showEvent = $$$1.Event(Event.SHOW, relatedTarget);
	      $$$1(parent).trigger(showEvent);

	      if (showEvent.isDefaultPrevented()) {
	        return;
	      } // Disable totally Popper.js for Dropdown in Navbar


	      if (!this._inNavbar) {
	        /**
	         * Check for Popper dependency
	         * Popper - https://popper.js.org
	         */
	        if (typeof Popper === &#x27;undefined&#x27;) {
	          throw new TypeError(&#x27;Bootstrap dropdown require Popper.js (https://popper.js.org)&#x27;);
	        }

	        var element = this._element; // For dropup with alignment we use the parent as popper container

	        if ($$$1(parent).hasClass(ClassName.DROPUP)) {
	          if ($$$1(this._menu).hasClass(ClassName.MENULEFT) || $$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
	            element = parent;
	          }
	        } // If boundary is not &#x60;scrollParent&#x60;, then set position to &#x60;static&#x60;
	        // to allow the menu to &quot;escape&quot; the scroll parent&#x27;s boundaries
	        // https://github.com/twbs/bootstrap/issues/24251


	        if (this._config.boundary !== &#x27;scrollParent&#x27;) {
	          $$$1(parent).addClass(ClassName.POSITION_STATIC);
	        }

	        this._popper = new Popper(element, this._menu, this._getPopperConfig());
	      } // If this is a touch-enabled device we add extra
	      // empty mouseover listeners to the body&#x27;s immediate children;
	      // only needed because of broken event delegation on iOS
	      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


	      if (&#x27;ontouchstart&#x27; in document.documentElement &amp;&amp; $$$1(parent).closest(Selector.NAVBAR_NAV).length === 0) {
	        $$$1(&#x27;body&#x27;).children().on(&#x27;mouseover&#x27;, null, $$$1.noop);
	      }

	      this._element.focus();

	      this._element.setAttribute(&#x27;aria-expanded&#x27;, true);

	      $$$1(this._menu).toggleClass(ClassName.SHOW);
	      $$$1(parent).toggleClass(ClassName.SHOW).trigger($$$1.Event(Event.SHOWN, relatedTarget));
	    };

	    _proto.dispose = function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      $$$1(this._element).off(EVENT_KEY);
	      this._element = null;
	      this._menu = null;

	      if (this._popper !== null) {
	        this._popper.destroy();

	        this._popper = null;
	      }
	    };

	    _proto.update = function update() {
	      this._inNavbar = this._detectNavbar();

	      if (this._popper !== null) {
	        this._popper.scheduleUpdate();
	      }
	    }; // Private


	    _proto._addEventListeners = function _addEventListeners() {
	      var _this = this;

	      $$$1(this._element).on(Event.CLICK, function (event) {
	        event.preventDefault();
	        event.stopPropagation();

	        _this.toggle();
	      });
	    };

	    _proto._getConfig = function _getConfig(config) {
	      config = _extends({}, this.constructor.Default, $$$1(this._element).data(), config);
	      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
	      return config;
	    };

	    _proto._getMenuElement = function _getMenuElement() {
	      if (!this._menu) {
	        var parent = Dropdown._getParentFromElement(this._element);

	        this._menu = $$$1(parent).find(Selector.MENU)[0];
	      }

	      return this._menu;
	    };

	    _proto._getPlacement = function _getPlacement() {
	      var $parentDropdown = $$$1(this._element).parent();
	      var placement = AttachmentMap.BOTTOM; // Handle dropup

	      if ($parentDropdown.hasClass(ClassName.DROPUP)) {
	        placement = AttachmentMap.TOP;

	        if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
	          placement = AttachmentMap.TOPEND;
	        }
	      } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {
	        placement = AttachmentMap.RIGHT;
	      } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {
	        placement = AttachmentMap.LEFT;
	      } else if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
	        placement = AttachmentMap.BOTTOMEND;
	      }

	      return placement;
	    };

	    _proto._detectNavbar = function _detectNavbar() {
	      return $$$1(this._element).closest(&#x27;.navbar&#x27;).length &gt; 0;
	    };

	    _proto._getPopperConfig = function _getPopperConfig() {
	      var _this2 = this;

	      var offsetConf = {};

	      if (typeof this._config.offset === &#x27;function&#x27;) {
	        offsetConf.fn = function (data) {
	          data.offsets = _extends({}, data.offsets, _this2._config.offset(data.offsets) || {});
	          return data;
	        };
	      } else {
	        offsetConf.offset = this._config.offset;
	      }

	      var popperConfig = {
	        placement: this._getPlacement(),
	        modifiers: {
	          offset: offsetConf,
	          flip: {
	            enabled: this._config.flip
	          },
	          preventOverflow: {
	            boundariesElement: this._config.boundary
	          }
	        }
	      };
	      return popperConfig;
	    }; // Static


	    Dropdown._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $$$1(this).data(DATA_KEY);

	        var _config = typeof config === &#x27;object&#x27; ? config : null;

	        if (!data) {
	          data = new Dropdown(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;string&#x27;) {
	          if (typeof data[config] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    Dropdown._clearMenus = function _clearMenus(event) {
	      if (event &amp;&amp; (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === &#x27;keyup&#x27; &amp;&amp; event.which !== TAB_KEYCODE)) {
	        return;
	      }

	      var toggles = $$$1.makeArray($$$1(Selector.DATA_TOGGLE));

	      for (var i = 0; i &lt; toggles.length; i++) {
	        var parent = Dropdown._getParentFromElement(toggles[i]);

	        var context = $$$1(toggles[i]).data(DATA_KEY);
	        var relatedTarget = {
	          relatedTarget: toggles[i]
	        };

	        if (!context) {
	          continue;
	        }

	        var dropdownMenu = context._menu;

	        if (!$$$1(parent).hasClass(ClassName.SHOW)) {
	          continue;
	        }

	        if (event &amp;&amp; (event.type === &#x27;click&#x27; &amp;&amp; /input|textarea/i.test(event.target.tagName) || event.type === &#x27;keyup&#x27; &amp;&amp; event.which === TAB_KEYCODE) &amp;&amp; $$$1.contains(parent, event.target)) {
	          continue;
	        }

	        var hideEvent = $$$1.Event(Event.HIDE, relatedTarget);
	        $$$1(parent).trigger(hideEvent);

	        if (hideEvent.isDefaultPrevented()) {
	          continue;
	        } // If this is a touch-enabled device we remove the extra
	        // empty mouseover listeners we added for iOS support


	        if (&#x27;ontouchstart&#x27; in document.documentElement) {
	          $$$1(&#x27;body&#x27;).children().off(&#x27;mouseover&#x27;, null, $$$1.noop);
	        }

	        toggles[i].setAttribute(&#x27;aria-expanded&#x27;, &#x27;false&#x27;);
	        $$$1(dropdownMenu).removeClass(ClassName.SHOW);
	        $$$1(parent).removeClass(ClassName.SHOW).trigger($$$1.Event(Event.HIDDEN, relatedTarget));
	      }
	    };

	    Dropdown._getParentFromElement = function _getParentFromElement(element) {
	      var parent;
	      var selector = Util.getSelectorFromElement(element);

	      if (selector) {
	        parent = $$$1(selector)[0];
	      }

	      return parent || element.parentNode;
	    }; // eslint-disable-next-line complexity


	    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
	      // If not input/textarea:
	      //  - And not a key in REGEXP_KEYDOWN =&gt; not a dropdown command
	      // If input/textarea:
	      //  - If space key =&gt; not a dropdown command
	      //  - If key is other than escape
	      //    - If key is not up or down =&gt; not a dropdown command
	      //    - If trigger inside the menu =&gt; not a dropdown command
	      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE &amp;&amp; (event.which !== ARROW_DOWN_KEYCODE &amp;&amp; event.which !== ARROW_UP_KEYCODE || $$$1(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
	        return;
	      }

	      event.preventDefault();
	      event.stopPropagation();

	      if (this.disabled || $$$1(this).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var parent = Dropdown._getParentFromElement(this);

	      var isActive = $$$1(parent).hasClass(ClassName.SHOW);

	      if (!isActive &amp;&amp; (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive &amp;&amp; (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
	        if (event.which === ESCAPE_KEYCODE) {
	          var toggle = $$$1(parent).find(Selector.DATA_TOGGLE)[0];
	          $$$1(toggle).trigger(&#x27;focus&#x27;);
	        }

	        $$$1(this).trigger(&#x27;click&#x27;);
	        return;
	      }

	      var items = $$$1(parent).find(Selector.VISIBLE_ITEMS).get();

	      if (items.length === 0) {
	        return;
	      }

	      var index = items.indexOf(event.target);

	      if (event.which === ARROW_UP_KEYCODE &amp;&amp; index &gt; 0) {
	        // Up
	        index--;
	      }

	      if (event.which === ARROW_DOWN_KEYCODE &amp;&amp; index &lt; items.length - 1) {
	        // Down
	        index++;
	      }

	      if (index &lt; 0) {
	        index = 0;
	      }

	      items[index].focus();
	    };

	    _createClass(Dropdown, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: &quot;DefaultType&quot;,
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Dropdown;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + &quot; &quot; + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    event.preventDefault();
	    event.stopPropagation();

	    Dropdown._jQueryInterface.call($$$1(this), &#x27;toggle&#x27;);
	  }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
	    e.stopPropagation();
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = Dropdown._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Dropdown;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Dropdown._jQueryInterface;
	  };

	  return Dropdown;
	}($, Popper);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): modal.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Modal = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;modal&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.modal&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var TRANSITION_DURATION = 300;
	  var BACKDROP_TRANSITION_DURATION = 150;
	  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

	  var Default = {
	    backdrop: true,
	    keyboard: true,
	    focus: true,
	    show: true
	  };
	  var DefaultType = {
	    backdrop: &#x27;(boolean|string)&#x27;,
	    keyboard: &#x27;boolean&#x27;,
	    focus: &#x27;boolean&#x27;,
	    show: &#x27;boolean&#x27;
	  };
	  var Event = {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
	    RESIZE: &quot;resize&quot; + EVENT_KEY,
	    CLICK_DISMISS: &quot;click.dismiss&quot; + EVENT_KEY,
	    KEYDOWN_DISMISS: &quot;keydown.dismiss&quot; + EVENT_KEY,
	    MOUSEUP_DISMISS: &quot;mouseup.dismiss&quot; + EVENT_KEY,
	    MOUSEDOWN_DISMISS: &quot;mousedown.dismiss&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    SCROLLBAR_MEASURER: &#x27;modal-scrollbar-measure&#x27;,
	    BACKDROP: &#x27;modal-backdrop&#x27;,
	    OPEN: &#x27;modal-open&#x27;,
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector = {
	    DIALOG: &#x27;.modal-dialog&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle=&quot;modal&quot;]&#x27;,
	    DATA_DISMISS: &#x27;[data-dismiss=&quot;modal&quot;]&#x27;,
	    FIXED_CONTENT: &#x27;.fixed-top, .fixed-bottom, .is-fixed, .sticky-top&#x27;,
	    STICKY_CONTENT: &#x27;.sticky-top&#x27;,
	    NAVBAR_TOGGLER: &#x27;.navbar-toggler&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Modal =
	  /*#__PURE__*/
	  function () {
	    function Modal(element, config) {
	      this._config = this._getConfig(config);
	      this._element = element;
	      this._dialog = $$$1(element).find(Selector.DIALOG)[0];
	      this._backdrop = null;
	      this._isShown = false;
	      this._isBodyOverflowing = false;
	      this._ignoreBackdropClick = false;
	      this._originalBodyPadding = 0;
	      this._scrollbarWidth = 0;
	    } // Getters


	    var _proto = Modal.prototype;

	    // Public
	    _proto.toggle = function toggle(relatedTarget) {
	      return this._isShown ? this.hide() : this.show(relatedTarget);
	    };

	    _proto.show = function show(relatedTarget) {
	      var _this = this;

	      if (this._isTransitioning || this._isShown) {
	        return;
	      }

	      if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE)) {
	        this._isTransitioning = true;
	      }

	      var showEvent = $$$1.Event(Event.SHOW, {
	        relatedTarget: relatedTarget
	      });
	      $$$1(this._element).trigger(showEvent);

	      if (this._isShown || showEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._isShown = true;

	      this._checkScrollbar();

	      this._setScrollbar();

	      this._adjustDialog();

	      $$$1(document.body).addClass(ClassName.OPEN);

	      this._setEscapeEvent();

	      this._setResizeEvent();

	      $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
	        return _this.hide(event);
	      });
	      $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
	        $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
	          if ($$$1(event.target).is(_this._element)) {
	            _this._ignoreBackdropClick = true;
	          }
	        });
	      });

	      this._showBackdrop(function () {
	        return _this._showElement(relatedTarget);
	      });
	    };

	    _proto.hide = function hide(event) {
	      var _this2 = this;

	      if (event) {
	        event.preventDefault();
	      }

	      if (this._isTransitioning || !this._isShown) {
	        return;
	      }

	      var hideEvent = $$$1.Event(Event.HIDE);
	      $$$1(this._element).trigger(hideEvent);

	      if (!this._isShown || hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._isShown = false;
	      var transition = Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE);

	      if (transition) {
	        this._isTransitioning = true;
	      }

	      this._setEscapeEvent();

	      this._setResizeEvent();

	      $$$1(document).off(Event.FOCUSIN);
	      $$$1(this._element).removeClass(ClassName.SHOW);
	      $$$1(this._element).off(Event.CLICK_DISMISS);
	      $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);

	      if (transition) {
	        $$$1(this._element).one(Util.TRANSITION_END, function (event) {
	          return _this2._hideModal(event);
	        }).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        this._hideModal();
	      }
	    };

	    _proto.dispose = function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);
	      this._config = null;
	      this._element = null;
	      this._dialog = null;
	      this._backdrop = null;
	      this._isShown = null;
	      this._isBodyOverflowing = null;
	      this._ignoreBackdropClick = null;
	      this._scrollbarWidth = null;
	    };

	    _proto.handleUpdate = function handleUpdate() {
	      this._adjustDialog();
	    }; // Private


	    _proto._getConfig = function _getConfig(config) {
	      config = _extends({}, Default, config);
	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._showElement = function _showElement(relatedTarget) {
	      var _this3 = this;

	      var transition = Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE);

	      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
	        // Don&#x27;t move modal&#x27;s DOM position
	        document.body.appendChild(this._element);
	      }

	      this._element.style.display = &#x27;block&#x27;;

	      this._element.removeAttribute(&#x27;aria-hidden&#x27;);

	      this._element.scrollTop = 0;

	      if (transition) {
	        Util.reflow(this._element);
	      }

	      $$$1(this._element).addClass(ClassName.SHOW);

	      if (this._config.focus) {
	        this._enforceFocus();
	      }

	      var shownEvent = $$$1.Event(Event.SHOWN, {
	        relatedTarget: relatedTarget
	      });

	      var transitionComplete = function transitionComplete() {
	        if (_this3._config.focus) {
	          _this3._element.focus();
	        }

	        _this3._isTransitioning = false;
	        $$$1(_this3._element).trigger(shownEvent);
	      };

	      if (transition) {
	        $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        transitionComplete();
	      }
	    };

	    _proto._enforceFocus = function _enforceFocus() {
	      var _this4 = this;

	      $$$1(document).off(Event.FOCUSIN) // Guard against infinite focus loop
	      .on(Event.FOCUSIN, function (event) {
	        if (document !== event.target &amp;&amp; _this4._element !== event.target &amp;&amp; $$$1(_this4._element).has(event.target).length === 0) {
	          _this4._element.focus();
	        }
	      });
	    };

	    _proto._setEscapeEvent = function _setEscapeEvent() {
	      var _this5 = this;

	      if (this._isShown &amp;&amp; this._config.keyboard) {
	        $$$1(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
	          if (event.which === ESCAPE_KEYCODE) {
	            event.preventDefault();

	            _this5.hide();
	          }
	        });
	      } else if (!this._isShown) {
	        $$$1(this._element).off(Event.KEYDOWN_DISMISS);
	      }
	    };

	    _proto._setResizeEvent = function _setResizeEvent() {
	      var _this6 = this;

	      if (this._isShown) {
	        $$$1(window).on(Event.RESIZE, function (event) {
	          return _this6.handleUpdate(event);
	        });
	      } else {
	        $$$1(window).off(Event.RESIZE);
	      }
	    };

	    _proto._hideModal = function _hideModal() {
	      var _this7 = this;

	      this._element.style.display = &#x27;none&#x27;;

	      this._element.setAttribute(&#x27;aria-hidden&#x27;, true);

	      this._isTransitioning = false;

	      this._showBackdrop(function () {
	        $$$1(document.body).removeClass(ClassName.OPEN);

	        _this7._resetAdjustments();

	        _this7._resetScrollbar();

	        $$$1(_this7._element).trigger(Event.HIDDEN);
	      });
	    };

	    _proto._removeBackdrop = function _removeBackdrop() {
	      if (this._backdrop) {
	        $$$1(this._backdrop).remove();
	        this._backdrop = null;
	      }
	    };

	    _proto._showBackdrop = function _showBackdrop(callback) {
	      var _this8 = this;

	      var animate = $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : &#x27;&#x27;;

	      if (this._isShown &amp;&amp; this._config.backdrop) {
	        var doAnimate = Util.supportsTransitionEnd() &amp;&amp; animate;
	        this._backdrop = document.createElement(&#x27;div&#x27;);
	        this._backdrop.className = ClassName.BACKDROP;

	        if (animate) {
	          $$$1(this._backdrop).addClass(animate);
	        }

	        $$$1(this._backdrop).appendTo(document.body);
	        $$$1(this._element).on(Event.CLICK_DISMISS, function (event) {
	          if (_this8._ignoreBackdropClick) {
	            _this8._ignoreBackdropClick = false;
	            return;
	          }

	          if (event.target !== event.currentTarget) {
	            return;
	          }

	          if (_this8._config.backdrop === &#x27;static&#x27;) {
	            _this8._element.focus();
	          } else {
	            _this8.hide();
	          }
	        });

	        if (doAnimate) {
	          Util.reflow(this._backdrop);
	        }

	        $$$1(this._backdrop).addClass(ClassName.SHOW);

	        if (!callback) {
	          return;
	        }

	        if (!doAnimate) {
	          callback();
	          return;
	        }

	        $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
	      } else if (!this._isShown &amp;&amp; this._backdrop) {
	        $$$1(this._backdrop).removeClass(ClassName.SHOW);

	        var callbackRemove = function callbackRemove() {
	          _this8._removeBackdrop();

	          if (callback) {
	            callback();
	          }
	        };

	        if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE)) {
	          $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
	        } else {
	          callbackRemove();
	        }
	      } else if (callback) {
	        callback();
	      }
	    }; // ----------------------------------------------------------------------
	    // the following methods are used to handle overflowing modals
	    // todo (fat): these should probably be refactored out of modal.js
	    // ----------------------------------------------------------------------


	    _proto._adjustDialog = function _adjustDialog() {
	      var isModalOverflowing = this._element.scrollHeight &gt; document.documentElement.clientHeight;

	      if (!this._isBodyOverflowing &amp;&amp; isModalOverflowing) {
	        this._element.style.paddingLeft = this._scrollbarWidth + &quot;px&quot;;
	      }

	      if (this._isBodyOverflowing &amp;&amp; !isModalOverflowing) {
	        this._element.style.paddingRight = this._scrollbarWidth + &quot;px&quot;;
	      }
	    };

	    _proto._resetAdjustments = function _resetAdjustments() {
	      this._element.style.paddingLeft = &#x27;&#x27;;
	      this._element.style.paddingRight = &#x27;&#x27;;
	    };

	    _proto._checkScrollbar = function _checkScrollbar() {
	      var rect = document.body.getBoundingClientRect();
	      this._isBodyOverflowing = rect.left + rect.right &lt; window.innerWidth;
	      this._scrollbarWidth = this._getScrollbarWidth();
	    };

	    _proto._setScrollbar = function _setScrollbar() {
	      var _this9 = this;

	      if (this._isBodyOverflowing) {
	        // Note: DOMNode.style.paddingRight returns the actual value or &#x27;&#x27; if not set
	        //   while $(DOMNode).css(&#x27;padding-right&#x27;) returns the calculated value or 0 if not set
	        // Adjust fixed content padding
	        $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
	          var actualPadding = $$$1(element)[0].style.paddingRight;
	          var calculatedPadding = $$$1(element).css(&#x27;padding-right&#x27;);
	          $$$1(element).data(&#x27;padding-right&#x27;, actualPadding).css(&#x27;padding-right&#x27;, parseFloat(calculatedPadding) + _this9._scrollbarWidth + &quot;px&quot;);
	        }); // Adjust sticky content margin

	        $$$1(Selector.STICKY_CONTENT).each(function (index, element) {
	          var actualMargin = $$$1(element)[0].style.marginRight;
	          var calculatedMargin = $$$1(element).css(&#x27;margin-right&#x27;);
	          $$$1(element).data(&#x27;margin-right&#x27;, actualMargin).css(&#x27;margin-right&#x27;, parseFloat(calculatedMargin) - _this9._scrollbarWidth + &quot;px&quot;);
	        }); // Adjust navbar-toggler margin

	        $$$1(Selector.NAVBAR_TOGGLER).each(function (index, element) {
	          var actualMargin = $$$1(element)[0].style.marginRight;
	          var calculatedMargin = $$$1(element).css(&#x27;margin-right&#x27;);
	          $$$1(element).data(&#x27;margin-right&#x27;, actualMargin).css(&#x27;margin-right&#x27;, parseFloat(calculatedMargin) + _this9._scrollbarWidth + &quot;px&quot;);
	        }); // Adjust body padding

	        var actualPadding = document.body.style.paddingRight;
	        var calculatedPadding = $$$1(&#x27;body&#x27;).css(&#x27;padding-right&#x27;);
	        $$$1(&#x27;body&#x27;).data(&#x27;padding-right&#x27;, actualPadding).css(&#x27;padding-right&#x27;, parseFloat(calculatedPadding) + this._scrollbarWidth + &quot;px&quot;);
	      }
	    };

	    _proto._resetScrollbar = function _resetScrollbar() {
	      // Restore fixed content padding
	      $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
	        var padding = $$$1(element).data(&#x27;padding-right&#x27;);

	        if (typeof padding !== &#x27;undefined&#x27;) {
	          $$$1(element).css(&#x27;padding-right&#x27;, padding).removeData(&#x27;padding-right&#x27;);
	        }
	      }); // Restore sticky content and navbar-toggler margin

	      $$$1(Selector.STICKY_CONTENT + &quot;, &quot; + Selector.NAVBAR_TOGGLER).each(function (index, element) {
	        var margin = $$$1(element).data(&#x27;margin-right&#x27;);

	        if (typeof margin !== &#x27;undefined&#x27;) {
	          $$$1(element).css(&#x27;margin-right&#x27;, margin).removeData(&#x27;margin-right&#x27;);
	        }
	      }); // Restore body padding

	      var padding = $$$1(&#x27;body&#x27;).data(&#x27;padding-right&#x27;);

	      if (typeof padding !== &#x27;undefined&#x27;) {
	        $$$1(&#x27;body&#x27;).css(&#x27;padding-right&#x27;, padding).removeData(&#x27;padding-right&#x27;);
	      }
	    };

	    _proto._getScrollbarWidth = function _getScrollbarWidth() {
	      // thx d.walsh
	      var scrollDiv = document.createElement(&#x27;div&#x27;);
	      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
	      document.body.appendChild(scrollDiv);
	      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
	      document.body.removeChild(scrollDiv);
	      return scrollbarWidth;
	    }; // Static


	    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
	      return this.each(function () {
	        var data = $$$1(this).data(DATA_KEY);

	        var _config = _extends({}, Modal.Default, $$$1(this).data(), typeof config === &#x27;object&#x27; &amp;&amp; config);

	        if (!data) {
	          data = new Modal(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;string&#x27;) {
	          if (typeof data[config] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config](relatedTarget);
	        } else if (_config.show) {
	          data.show(relatedTarget);
	        }
	      });
	    };

	    _createClass(Modal, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Modal;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    var _this10 = this;

	    var target;
	    var selector = Util.getSelectorFromElement(this);

	    if (selector) {
	      target = $$$1(selector)[0];
	    }

	    var config = $$$1(target).data(DATA_KEY) ? &#x27;toggle&#x27; : _extends({}, $$$1(target).data(), $$$1(this).data());

	    if (this.tagName === &#x27;A&#x27; || this.tagName === &#x27;AREA&#x27;) {
	      event.preventDefault();
	    }

	    var $target = $$$1(target).one(Event.SHOW, function (showEvent) {
	      if (showEvent.isDefaultPrevented()) {
	        // Only register focus restorer if modal will actually get shown
	        return;
	      }

	      $target.one(Event.HIDDEN, function () {
	        if ($$$1(_this10).is(&#x27;:visible&#x27;)) {
	          _this10.focus();
	        }
	      });
	    });

	    Modal._jQueryInterface.call($$$1(target), config, this);
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = Modal._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Modal;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Modal._jQueryInterface;
	  };

	  return Modal;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): tooltip.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Tooltip = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;tooltip&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.tooltip&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var TRANSITION_DURATION = 150;
	  var CLASS_PREFIX = &#x27;bs-tooltip&#x27;;
	  var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, &#x27;g&#x27;);
	  var DefaultType = {
	    animation: &#x27;boolean&#x27;,
	    template: &#x27;string&#x27;,
	    title: &#x27;(string|element|function)&#x27;,
	    trigger: &#x27;string&#x27;,
	    delay: &#x27;(number|object)&#x27;,
	    html: &#x27;boolean&#x27;,
	    selector: &#x27;(string|boolean)&#x27;,
	    placement: &#x27;(string|function)&#x27;,
	    offset: &#x27;(number|string)&#x27;,
	    container: &#x27;(string|element|boolean)&#x27;,
	    fallbackPlacement: &#x27;(string|array)&#x27;,
	    boundary: &#x27;(string|element)&#x27;
	  };
	  var AttachmentMap = {
	    AUTO: &#x27;auto&#x27;,
	    TOP: &#x27;top&#x27;,
	    RIGHT: &#x27;right&#x27;,
	    BOTTOM: &#x27;bottom&#x27;,
	    LEFT: &#x27;left&#x27;
	  };
	  var Default = {
	    animation: true,
	    template: &#x27;&lt;div class=&quot;tooltip&quot; role=&quot;tooltip&quot;&gt;&#x27; + &#x27;&lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;&#x27; + &#x27;&lt;div class=&quot;tooltip-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;,
	    trigger: &#x27;hover focus&#x27;,
	    title: &#x27;&#x27;,
	    delay: 0,
	    html: false,
	    selector: false,
	    placement: &#x27;top&#x27;,
	    offset: 0,
	    container: false,
	    fallbackPlacement: &#x27;flip&#x27;,
	    boundary: &#x27;scrollParent&#x27;
	  };
	  var HoverState = {
	    SHOW: &#x27;show&#x27;,
	    OUT: &#x27;out&#x27;
	  };
	  var Event = {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    INSERTED: &quot;inserted&quot; + EVENT_KEY,
	    CLICK: &quot;click&quot; + EVENT_KEY,
	    FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
	    FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
	    MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
	    MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
	  };
	  var ClassName = {
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector = {
	    TOOLTIP: &#x27;.tooltip&#x27;,
	    TOOLTIP_INNER: &#x27;.tooltip-inner&#x27;,
	    ARROW: &#x27;.arrow&#x27;
	  };
	  var Trigger = {
	    HOVER: &#x27;hover&#x27;,
	    FOCUS: &#x27;focus&#x27;,
	    CLICK: &#x27;click&#x27;,
	    MANUAL: &#x27;manual&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Tooltip =
	  /*#__PURE__*/
	  function () {
	    function Tooltip(element, config) {
	      /**
	       * Check for Popper dependency
	       * Popper - https://popper.js.org
	       */
	      if (typeof Popper === &#x27;undefined&#x27;) {
	        throw new TypeError(&#x27;Bootstrap tooltips require Popper.js (https://popper.js.org)&#x27;);
	      } // private


	      this._isEnabled = true;
	      this._timeout = 0;
	      this._hoverState = &#x27;&#x27;;
	      this._activeTrigger = {};
	      this._popper = null; // Protected

	      this.element = element;
	      this.config = this._getConfig(config);
	      this.tip = null;

	      this._setListeners();
	    } // Getters


	    var _proto = Tooltip.prototype;

	    // Public
	    _proto.enable = function enable() {
	      this._isEnabled = true;
	    };

	    _proto.disable = function disable() {
	      this._isEnabled = false;
	    };

	    _proto.toggleEnabled = function toggleEnabled() {
	      this._isEnabled = !this._isEnabled;
	    };

	    _proto.toggle = function toggle(event) {
	      if (!this._isEnabled) {
	        return;
	      }

	      if (event) {
	        var dataKey = this.constructor.DATA_KEY;
	        var context = $$$1(event.currentTarget).data(dataKey);

	        if (!context) {
	          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
	          $$$1(event.currentTarget).data(dataKey, context);
	        }

	        context._activeTrigger.click = !context._activeTrigger.click;

	        if (context._isWithActiveTrigger()) {
	          context._enter(null, context);
	        } else {
	          context._leave(null, context);
	        }
	      } else {
	        if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {
	          this._leave(null, this);

	          return;
	        }

	        this._enter(null, this);
	      }
	    };

	    _proto.dispose = function dispose() {
	      clearTimeout(this._timeout);
	      $$$1.removeData(this.element, this.constructor.DATA_KEY);
	      $$$1(this.element).off(this.constructor.EVENT_KEY);
	      $$$1(this.element).closest(&#x27;.modal&#x27;).off(&#x27;hide.bs.modal&#x27;);

	      if (this.tip) {
	        $$$1(this.tip).remove();
	      }

	      this._isEnabled = null;
	      this._timeout = null;
	      this._hoverState = null;
	      this._activeTrigger = null;

	      if (this._popper !== null) {
	        this._popper.destroy();
	      }

	      this._popper = null;
	      this.element = null;
	      this.config = null;
	      this.tip = null;
	    };

	    _proto.show = function show() {
	      var _this = this;

	      if ($$$1(this.element).css(&#x27;display&#x27;) === &#x27;none&#x27;) {
	        throw new Error(&#x27;Please use show on visible elements&#x27;);
	      }

	      var showEvent = $$$1.Event(this.constructor.Event.SHOW);

	      if (this.isWithContent() &amp;&amp; this._isEnabled) {
	        $$$1(this.element).trigger(showEvent);
	        var isInTheDom = $$$1.contains(this.element.ownerDocument.documentElement, this.element);

	        if (showEvent.isDefaultPrevented() || !isInTheDom) {
	          return;
	        }

	        var tip = this.getTipElement();
	        var tipId = Util.getUID(this.constructor.NAME);
	        tip.setAttribute(&#x27;id&#x27;, tipId);
	        this.element.setAttribute(&#x27;aria-describedby&#x27;, tipId);
	        this.setContent();

	        if (this.config.animation) {
	          $$$1(tip).addClass(ClassName.FADE);
	        }

	        var placement = typeof this.config.placement === &#x27;function&#x27; ? this.config.placement.call(this, tip, this.element) : this.config.placement;

	        var attachment = this._getAttachment(placement);

	        this.addAttachmentClass(attachment);
	        var container = this.config.container === false ? document.body : $$$1(this.config.container);
	        $$$1(tip).data(this.constructor.DATA_KEY, this);

	        if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {
	          $$$1(tip).appendTo(container);
	        }

	        $$$1(this.element).trigger(this.constructor.Event.INSERTED);
	        this._popper = new Popper(this.element, tip, {
	          placement: attachment,
	          modifiers: {
	            offset: {
	              offset: this.config.offset
	            },
	            flip: {
	              behavior: this.config.fallbackPlacement
	            },
	            arrow: {
	              element: Selector.ARROW
	            },
	            preventOverflow: {
	              boundariesElement: this.config.boundary
	            }
	          },
	          onCreate: function onCreate(data) {
	            if (data.originalPlacement !== data.placement) {
	              _this._handlePopperPlacementChange(data);
	            }
	          },
	          onUpdate: function onUpdate(data) {
	            _this._handlePopperPlacementChange(data);
	          }
	        });
	        $$$1(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra
	        // empty mouseover listeners to the body&#x27;s immediate children;
	        // only needed because of broken event delegation on iOS
	        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

	        if (&#x27;ontouchstart&#x27; in document.documentElement) {
	          $$$1(&#x27;body&#x27;).children().on(&#x27;mouseover&#x27;, null, $$$1.noop);
	        }

	        var complete = function complete() {
	          if (_this.config.animation) {
	            _this._fixTransition();
	          }

	          var prevHoverState = _this._hoverState;
	          _this._hoverState = null;
	          $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);

	          if (prevHoverState === HoverState.OUT) {
	            _this._leave(null, _this);
	          }
	        };

	        if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this.tip).hasClass(ClassName.FADE)) {
	          $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
	        } else {
	          complete();
	        }
	      }
	    };

	    _proto.hide = function hide(callback) {
	      var _this2 = this;

	      var tip = this.getTipElement();
	      var hideEvent = $$$1.Event(this.constructor.Event.HIDE);

	      var complete = function complete() {
	        if (_this2._hoverState !== HoverState.SHOW &amp;&amp; tip.parentNode) {
	          tip.parentNode.removeChild(tip);
	        }

	        _this2._cleanTipClass();

	        _this2.element.removeAttribute(&#x27;aria-describedby&#x27;);

	        $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

	        if (_this2._popper !== null) {
	          _this2._popper.destroy();
	        }

	        if (callback) {
	          callback();
	        }
	      };

	      $$$1(this.element).trigger(hideEvent);

	      if (hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      $$$1(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra
	      // empty mouseover listeners we added for iOS support

	      if (&#x27;ontouchstart&#x27; in document.documentElement) {
	        $$$1(&#x27;body&#x27;).children().off(&#x27;mouseover&#x27;, null, $$$1.noop);
	      }

	      this._activeTrigger[Trigger.CLICK] = false;
	      this._activeTrigger[Trigger.FOCUS] = false;
	      this._activeTrigger[Trigger.HOVER] = false;

	      if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this.tip).hasClass(ClassName.FADE)) {
	        $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        complete();
	      }

	      this._hoverState = &#x27;&#x27;;
	    };

	    _proto.update = function update() {
	      if (this._popper !== null) {
	        this._popper.scheduleUpdate();
	      }
	    }; // Protected


	    _proto.isWithContent = function isWithContent() {
	      return Boolean(this.getTitle());
	    };

	    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
	      $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
	    };

	    _proto.getTipElement = function getTipElement() {
	      this.tip = this.tip || $$$1(this.config.template)[0];
	      return this.tip;
	    };

	    _proto.setContent = function setContent() {
	      var $tip = $$$1(this.getTipElement());
	      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
	      $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
	    };

	    _proto.setElementContent = function setElementContent($element, content) {
	      var html = this.config.html;

	      if (typeof content === &#x27;object&#x27; &amp;&amp; (content.nodeType || content.jquery)) {
	        // Content is a DOM node or a jQuery
	        if (html) {
	          if (!$$$1(content).parent().is($element)) {
	            $element.empty().append(content);
	          }
	        } else {
	          $element.text($$$1(content).text());
	        }
	      } else {
	        $element[html ? &#x27;html&#x27; : &#x27;text&#x27;](content);
	      }
	    };

	    _proto.getTitle = function getTitle() {
	      var title = this.element.getAttribute(&#x27;data-original-title&#x27;);

	      if (!title) {
	        title = typeof this.config.title === &#x27;function&#x27; ? this.config.title.call(this.element) : this.config.title;
	      }

	      return title;
	    }; // Private


	    _proto._getAttachment = function _getAttachment(placement) {
	      return AttachmentMap[placement.toUpperCase()];
	    };

	    _proto._setListeners = function _setListeners() {
	      var _this3 = this;

	      var triggers = this.config.trigger.split(&#x27; &#x27;);
	      triggers.forEach(function (trigger) {
	        if (trigger === &#x27;click&#x27;) {
	          $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
	            return _this3.toggle(event);
	          });
	        } else if (trigger !== Trigger.MANUAL) {
	          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
	          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
	          $$$1(_this3.element).on(eventIn, _this3.config.selector, function (event) {
	            return _this3._enter(event);
	          }).on(eventOut, _this3.config.selector, function (event) {
	            return _this3._leave(event);
	          });
	        }

	        $$$1(_this3.element).closest(&#x27;.modal&#x27;).on(&#x27;hide.bs.modal&#x27;, function () {
	          return _this3.hide();
	        });
	      });

	      if (this.config.selector) {
	        this.config = _extends({}, this.config, {
	          trigger: &#x27;manual&#x27;,
	          selector: &#x27;&#x27;
	        });
	      } else {
	        this._fixTitle();
	      }
	    };

	    _proto._fixTitle = function _fixTitle() {
	      var titleType = typeof this.element.getAttribute(&#x27;data-original-title&#x27;);

	      if (this.element.getAttribute(&#x27;title&#x27;) || titleType !== &#x27;string&#x27;) {
	        this.element.setAttribute(&#x27;data-original-title&#x27;, this.element.getAttribute(&#x27;title&#x27;) || &#x27;&#x27;);
	        this.element.setAttribute(&#x27;title&#x27;, &#x27;&#x27;);
	      }
	    };

	    _proto._enter = function _enter(event, context) {
	      var dataKey = this.constructor.DATA_KEY;
	      context = context || $$$1(event.currentTarget).data(dataKey);

	      if (!context) {
	        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
	        $$$1(event.currentTarget).data(dataKey, context);
	      }

	      if (event) {
	        context._activeTrigger[event.type === &#x27;focusin&#x27; ? Trigger.FOCUS : Trigger.HOVER] = true;
	      }

	      if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
	        context._hoverState = HoverState.SHOW;
	        return;
	      }

	      clearTimeout(context._timeout);
	      context._hoverState = HoverState.SHOW;

	      if (!context.config.delay || !context.config.delay.show) {
	        context.show();
	        return;
	      }

	      context._timeout = setTimeout(function () {
	        if (context._hoverState === HoverState.SHOW) {
	          context.show();
	        }
	      }, context.config.delay.show);
	    };

	    _proto._leave = function _leave(event, context) {
	      var dataKey = this.constructor.DATA_KEY;
	      context = context || $$$1(event.currentTarget).data(dataKey);

	      if (!context) {
	        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
	        $$$1(event.currentTarget).data(dataKey, context);
	      }

	      if (event) {
	        context._activeTrigger[event.type === &#x27;focusout&#x27; ? Trigger.FOCUS : Trigger.HOVER] = false;
	      }

	      if (context._isWithActiveTrigger()) {
	        return;
	      }

	      clearTimeout(context._timeout);
	      context._hoverState = HoverState.OUT;

	      if (!context.config.delay || !context.config.delay.hide) {
	        context.hide();
	        return;
	      }

	      context._timeout = setTimeout(function () {
	        if (context._hoverState === HoverState.OUT) {
	          context.hide();
	        }
	      }, context.config.delay.hide);
	    };

	    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
	      for (var trigger in this._activeTrigger) {
	        if (this._activeTrigger[trigger]) {
	          return true;
	        }
	      }

	      return false;
	    };

	    _proto._getConfig = function _getConfig(config) {
	      config = _extends({}, this.constructor.Default, $$$1(this.element).data(), config);

	      if (typeof config.delay === &#x27;number&#x27;) {
	        config.delay = {
	          show: config.delay,
	          hide: config.delay
	        };
	      }

	      if (typeof config.title === &#x27;number&#x27;) {
	        config.title = config.title.toString();
	      }

	      if (typeof config.content === &#x27;number&#x27;) {
	        config.content = config.content.toString();
	      }

	      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
	      return config;
	    };

	    _proto._getDelegateConfig = function _getDelegateConfig() {
	      var config = {};

	      if (this.config) {
	        for (var key in this.config) {
	          if (this.constructor.Default[key] !== this.config[key]) {
	            config[key] = this.config[key];
	          }
	        }
	      }

	      return config;
	    };

	    _proto._cleanTipClass = function _cleanTipClass() {
	      var $tip = $$$1(this.getTipElement());
	      var tabClass = $tip.attr(&#x27;class&#x27;).match(BSCLS_PREFIX_REGEX);

	      if (tabClass !== null &amp;&amp; tabClass.length &gt; 0) {
	        $tip.removeClass(tabClass.join(&#x27;&#x27;));
	      }
	    };

	    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
	      this._cleanTipClass();

	      this.addAttachmentClass(this._getAttachment(data.placement));
	    };

	    _proto._fixTransition = function _fixTransition() {
	      var tip = this.getTipElement();
	      var initConfigAnimation = this.config.animation;

	      if (tip.getAttribute(&#x27;x-placement&#x27;) !== null) {
	        return;
	      }

	      $$$1(tip).removeClass(ClassName.FADE);
	      this.config.animation = false;
	      this.hide();
	      this.show();
	      this.config.animation = initConfigAnimation;
	    }; // Static


	    Tooltip._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $$$1(this).data(DATA_KEY);

	        var _config = typeof config === &#x27;object&#x27; &amp;&amp; config;

	        if (!data &amp;&amp; /dispose|hide/.test(config)) {
	          return;
	        }

	        if (!data) {
	          data = new Tooltip(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;string&#x27;) {
	          if (typeof data[config] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Tooltip, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: &quot;NAME&quot;,
	      get: function get() {
	        return NAME;
	      }
	    }, {
	      key: &quot;DATA_KEY&quot;,
	      get: function get() {
	        return DATA_KEY;
	      }
	    }, {
	      key: &quot;Event&quot;,
	      get: function get() {
	        return Event;
	      }
	    }, {
	      key: &quot;EVENT_KEY&quot;,
	      get: function get() {
	        return EVENT_KEY;
	      }
	    }, {
	      key: &quot;DefaultType&quot;,
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Tooltip;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */


	  $$$1.fn[NAME] = Tooltip._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Tooltip;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Tooltip._jQueryInterface;
	  };

	  return Tooltip;
	}($, Popper);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): popover.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Popover = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;popover&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.popover&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var CLASS_PREFIX = &#x27;bs-popover&#x27;;
	  var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, &#x27;g&#x27;);
	  var Default = _extends({}, Tooltip.Default, {
	    placement: &#x27;right&#x27;,
	    trigger: &#x27;click&#x27;,
	    content: &#x27;&#x27;,
	    template: &#x27;&lt;div class=&quot;popover&quot; role=&quot;tooltip&quot;&gt;&#x27; + &#x27;&lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;&#x27; + &#x27;&lt;h3 class=&quot;popover-header&quot;&gt;&lt;/h3&gt;&#x27; + &#x27;&lt;div class=&quot;popover-body&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;
	  });
	  var DefaultType = _extends({}, Tooltip.DefaultType, {
	    content: &#x27;(string|element|function)&#x27;
	  });
	  var ClassName = {
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector = {
	    TITLE: &#x27;.popover-header&#x27;,
	    CONTENT: &#x27;.popover-body&#x27;
	  };
	  var Event = {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    INSERTED: &quot;inserted&quot; + EVENT_KEY,
	    CLICK: &quot;click&quot; + EVENT_KEY,
	    FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
	    FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
	    MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
	    MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Popover =
	  /*#__PURE__*/
	  function (_Tooltip) {
	    _inheritsLoose(Popover, _Tooltip);

	    function Popover() {
	      return _Tooltip.apply(this, arguments) || this;
	    }

	    var _proto = Popover.prototype;

	    // Overrides
	    _proto.isWithContent = function isWithContent() {
	      return this.getTitle() || this._getContent();
	    };

	    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
	      $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
	    };

	    _proto.getTipElement = function getTipElement() {
	      this.tip = this.tip || $$$1(this.config.template)[0];
	      return this.tip;
	    };

	    _proto.setContent = function setContent() {
	      var $tip = $$$1(this.getTipElement()); // We use append for html objects to maintain js events

	      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());

	      var content = this._getContent();

	      if (typeof content === &#x27;function&#x27;) {
	        content = content.call(this.element);
	      }

	      this.setElementContent($tip.find(Selector.CONTENT), content);
	      $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
	    }; // Private


	    _proto._getContent = function _getContent() {
	      return this.element.getAttribute(&#x27;data-content&#x27;) || this.config.content;
	    };

	    _proto._cleanTipClass = function _cleanTipClass() {
	      var $tip = $$$1(this.getTipElement());
	      var tabClass = $tip.attr(&#x27;class&#x27;).match(BSCLS_PREFIX_REGEX);

	      if (tabClass !== null &amp;&amp; tabClass.length &gt; 0) {
	        $tip.removeClass(tabClass.join(&#x27;&#x27;));
	      }
	    }; // Static


	    Popover._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $$$1(this).data(DATA_KEY);

	        var _config = typeof config === &#x27;object&#x27; ? config : null;

	        if (!data &amp;&amp; /destroy|hide/.test(config)) {
	          return;
	        }

	        if (!data) {
	          data = new Popover(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;string&#x27;) {
	          if (typeof data[config] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Popover, null, [{
	      key: &quot;VERSION&quot;,
	      // Getters
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: &quot;NAME&quot;,
	      get: function get() {
	        return NAME;
	      }
	    }, {
	      key: &quot;DATA_KEY&quot;,
	      get: function get() {
	        return DATA_KEY;
	      }
	    }, {
	      key: &quot;Event&quot;,
	      get: function get() {
	        return Event;
	      }
	    }, {
	      key: &quot;EVENT_KEY&quot;,
	      get: function get() {
	        return EVENT_KEY;
	      }
	    }, {
	      key: &quot;DefaultType&quot;,
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Popover;
	  }(Tooltip);
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */


	  $$$1.fn[NAME] = Popover._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Popover;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Popover._jQueryInterface;
	  };

	  return Popover;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): scrollspy.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var ScrollSpy = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;scrollspy&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.scrollspy&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var Default = {
	    offset: 10,
	    method: &#x27;auto&#x27;,
	    target: &#x27;&#x27;
	  };
	  var DefaultType = {
	    offset: &#x27;number&#x27;,
	    method: &#x27;string&#x27;,
	    target: &#x27;(string|element)&#x27;
	  };
	  var Event = {
	    ACTIVATE: &quot;activate&quot; + EVENT_KEY,
	    SCROLL: &quot;scroll&quot; + EVENT_KEY,
	    LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    DROPDOWN_ITEM: &#x27;dropdown-item&#x27;,
	    DROPDOWN_MENU: &#x27;dropdown-menu&#x27;,
	    ACTIVE: &#x27;active&#x27;
	  };
	  var Selector = {
	    DATA_SPY: &#x27;[data-spy=&quot;scroll&quot;]&#x27;,
	    ACTIVE: &#x27;.active&#x27;,
	    NAV_LIST_GROUP: &#x27;.nav, .list-group&#x27;,
	    NAV_LINKS: &#x27;.nav-link&#x27;,
	    NAV_ITEMS: &#x27;.nav-item&#x27;,
	    LIST_ITEMS: &#x27;.list-group-item&#x27;,
	    DROPDOWN: &#x27;.dropdown&#x27;,
	    DROPDOWN_ITEMS: &#x27;.dropdown-item&#x27;,
	    DROPDOWN_TOGGLE: &#x27;.dropdown-toggle&#x27;
	  };
	  var OffsetMethod = {
	    OFFSET: &#x27;offset&#x27;,
	    POSITION: &#x27;position&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var ScrollSpy =
	  /*#__PURE__*/
	  function () {
	    function ScrollSpy(element, config) {
	      var _this = this;

	      this._element = element;
	      this._scrollElement = element.tagName === &#x27;BODY&#x27; ? window : element;
	      this._config = this._getConfig(config);
	      this._selector = this._config.target + &quot; &quot; + Selector.NAV_LINKS + &quot;,&quot; + (this._config.target + &quot; &quot; + Selector.LIST_ITEMS + &quot;,&quot;) + (this._config.target + &quot; &quot; + Selector.DROPDOWN_ITEMS);
	      this._offsets = [];
	      this._targets = [];
	      this._activeTarget = null;
	      this._scrollHeight = 0;
	      $$$1(this._scrollElement).on(Event.SCROLL, function (event) {
	        return _this._process(event);
	      });
	      this.refresh();

	      this._process();
	    } // Getters


	    var _proto = ScrollSpy.prototype;

	    // Public
	    _proto.refresh = function refresh() {
	      var _this2 = this;

	      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
	      var offsetMethod = this._config.method === &#x27;auto&#x27; ? autoMethod : this._config.method;
	      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
	      this._offsets = [];
	      this._targets = [];
	      this._scrollHeight = this._getScrollHeight();
	      var targets = $$$1.makeArray($$$1(this._selector));
	      targets.map(function (element) {
	        var target;
	        var targetSelector = Util.getSelectorFromElement(element);

	        if (targetSelector) {
	          target = $$$1(targetSelector)[0];
	        }

	        if (target) {
	          var targetBCR = target.getBoundingClientRect();

	          if (targetBCR.width || targetBCR.height) {
	            // TODO (fat): remove sketch reliance on jQuery position/offset
	            return [$$$1(target)[offsetMethod]().top + offsetBase, targetSelector];
	          }
	        }

	        return null;
	      }).filter(function (item) {
	        return item;
	      }).sort(function (a, b) {
	        return a[0] - b[0];
	      }).forEach(function (item) {
	        _this2._offsets.push(item[0]);

	        _this2._targets.push(item[1]);
	      });
	    };

	    _proto.dispose = function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      $$$1(this._scrollElement).off(EVENT_KEY);
	      this._element = null;
	      this._scrollElement = null;
	      this._config = null;
	      this._selector = null;
	      this._offsets = null;
	      this._targets = null;
	      this._activeTarget = null;
	      this._scrollHeight = null;
	    }; // Private


	    _proto._getConfig = function _getConfig(config) {
	      config = _extends({}, Default, config);

	      if (typeof config.target !== &#x27;string&#x27;) {
	        var id = $$$1(config.target).attr(&#x27;id&#x27;);

	        if (!id) {
	          id = Util.getUID(NAME);
	          $$$1(config.target).attr(&#x27;id&#x27;, id);
	        }

	        config.target = &quot;#&quot; + id;
	      }

	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._getScrollTop = function _getScrollTop() {
	      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
	    };

	    _proto._getScrollHeight = function _getScrollHeight() {
	      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
	    };

	    _proto._getOffsetHeight = function _getOffsetHeight() {
	      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
	    };

	    _proto._process = function _process() {
	      var scrollTop = this._getScrollTop() + this._config.offset;

	      var scrollHeight = this._getScrollHeight();

	      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

	      if (this._scrollHeight !== scrollHeight) {
	        this.refresh();
	      }

	      if (scrollTop &gt;= maxScroll) {
	        var target = this._targets[this._targets.length - 1];

	        if (this._activeTarget !== target) {
	          this._activate(target);
	        }

	        return;
	      }

	      if (this._activeTarget &amp;&amp; scrollTop &lt; this._offsets[0] &amp;&amp; this._offsets[0] &gt; 0) {
	        this._activeTarget = null;

	        this._clear();

	        return;
	      }

	      for (var i = this._offsets.length; i--;) {
	        var isActiveTarget = this._activeTarget !== this._targets[i] &amp;&amp; scrollTop &gt;= this._offsets[i] &amp;&amp; (typeof this._offsets[i + 1] === &#x27;undefined&#x27; || scrollTop &lt; this._offsets[i + 1]);

	        if (isActiveTarget) {
	          this._activate(this._targets[i]);
	        }
	      }
	    };

	    _proto._activate = function _activate(target) {
	      this._activeTarget = target;

	      this._clear();

	      var queries = this._selector.split(&#x27;,&#x27;); // eslint-disable-next-line arrow-body-style


	      queries = queries.map(function (selector) {
	        return selector + &quot;[data-target=\&quot;&quot; + target + &quot;\&quot;],&quot; + (selector + &quot;[href=\&quot;&quot; + target + &quot;\&quot;]&quot;);
	      });
	      var $link = $$$1(queries.join(&#x27;,&#x27;));

	      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
	        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
	        $link.addClass(ClassName.ACTIVE);
	      } else {
	        // Set triggered link as active
	        $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
	        // With both &lt;ul&gt; and &lt;nav&gt; markup a parent is the previous sibling of any nav ancestor

	        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + &quot;, &quot; + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

	        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
	      }

	      $$$1(this._scrollElement).trigger(Event.ACTIVATE, {
	        relatedTarget: target
	      });
	    };

	    _proto._clear = function _clear() {
	      $$$1(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
	    }; // Static


	    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $$$1(this).data(DATA_KEY);

	        var _config = typeof config === &#x27;object&#x27; &amp;&amp; config;

	        if (!data) {
	          data = new ScrollSpy(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;string&#x27;) {
	          if (typeof data[config] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(ScrollSpy, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return ScrollSpy;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(window).on(Event.LOAD_DATA_API, function () {
	    var scrollSpys = $$$1.makeArray($$$1(Selector.DATA_SPY));

	    for (var i = scrollSpys.length; i--;) {
	      var $spy = $$$1(scrollSpys[i]);

	      ScrollSpy._jQueryInterface.call($spy, $spy.data());
	    }
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = ScrollSpy._jQueryInterface;
	  $$$1.fn[NAME].Constructor = ScrollSpy;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return ScrollSpy._jQueryInterface;
	  };

	  return ScrollSpy;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): tab.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Tab = function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = &#x27;tab&#x27;;
	  var VERSION = &#x27;4.0.0&#x27;;
	  var DATA_KEY = &#x27;bs.tab&#x27;;
	  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY = &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
	  var TRANSITION_DURATION = 150;
	  var Event = {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    DROPDOWN_MENU: &#x27;dropdown-menu&#x27;,
	    ACTIVE: &#x27;active&#x27;,
	    DISABLED: &#x27;disabled&#x27;,
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector = {
	    DROPDOWN: &#x27;.dropdown&#x27;,
	    NAV_LIST_GROUP: &#x27;.nav, .list-group&#x27;,
	    ACTIVE: &#x27;.active&#x27;,
	    ACTIVE_UL: &#x27;&gt; li &gt; .active&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle=&quot;tab&quot;], [data-toggle=&quot;pill&quot;], [data-toggle=&quot;list&quot;]&#x27;,
	    DROPDOWN_TOGGLE: &#x27;.dropdown-toggle&#x27;,
	    DROPDOWN_ACTIVE_CHILD: &#x27;&gt; .dropdown-menu .active&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Tab =
	  /*#__PURE__*/
	  function () {
	    function Tab(element) {
	      this._element = element;
	    } // Getters


	    var _proto = Tab.prototype;

	    // Public
	    _proto.show = function show() {
	      var _this = this;

	      if (this._element.parentNode &amp;&amp; this._element.parentNode.nodeType === Node.ELEMENT_NODE &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var target;
	      var previous;
	      var listElement = $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];
	      var selector = Util.getSelectorFromElement(this._element);

	      if (listElement) {
	        var itemSelector = listElement.nodeName === &#x27;UL&#x27; ? Selector.ACTIVE_UL : Selector.ACTIVE;
	        previous = $$$1.makeArray($$$1(listElement).find(itemSelector));
	        previous = previous[previous.length - 1];
	      }

	      var hideEvent = $$$1.Event(Event.HIDE, {
	        relatedTarget: this._element
	      });
	      var showEvent = $$$1.Event(Event.SHOW, {
	        relatedTarget: previous
	      });

	      if (previous) {
	        $$$1(previous).trigger(hideEvent);
	      }

	      $$$1(this._element).trigger(showEvent);

	      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (selector) {
	        target = $$$1(selector)[0];
	      }

	      this._activate(this._element, listElement);

	      var complete = function complete() {
	        var hiddenEvent = $$$1.Event(Event.HIDDEN, {
	          relatedTarget: _this._element
	        });
	        var shownEvent = $$$1.Event(Event.SHOWN, {
	          relatedTarget: previous
	        });
	        $$$1(previous).trigger(hiddenEvent);
	        $$$1(_this._element).trigger(shownEvent);
	      };

	      if (target) {
	        this._activate(target, target.parentNode, complete);
	      } else {
	        complete();
	      }
	    };

	    _proto.dispose = function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._element = null;
	    }; // Private


	    _proto._activate = function _activate(element, container, callback) {
	      var _this2 = this;

	      var activeElements;

	      if (container.nodeName === &#x27;UL&#x27;) {
	        activeElements = $$$1(container).find(Selector.ACTIVE_UL);
	      } else {
	        activeElements = $$$1(container).children(Selector.ACTIVE);
	      }

	      var active = activeElements[0];
	      var isTransitioning = callback &amp;&amp; Util.supportsTransitionEnd() &amp;&amp; active &amp;&amp; $$$1(active).hasClass(ClassName.FADE);

	      var complete = function complete() {
	        return _this2._transitionComplete(element, active, callback);
	      };

	      if (active &amp;&amp; isTransitioning) {
	        $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        complete();
	      }
	    };

	    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
	      if (active) {
	        $$$1(active).removeClass(ClassName.SHOW + &quot; &quot; + ClassName.ACTIVE);
	        var dropdownChild = $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

	        if (dropdownChild) {
	          $$$1(dropdownChild).removeClass(ClassName.ACTIVE);
	        }

	        if (active.getAttribute(&#x27;role&#x27;) === &#x27;tab&#x27;) {
	          active.setAttribute(&#x27;aria-selected&#x27;, false);
	        }
	      }

	      $$$1(element).addClass(ClassName.ACTIVE);

	      if (element.getAttribute(&#x27;role&#x27;) === &#x27;tab&#x27;) {
	        element.setAttribute(&#x27;aria-selected&#x27;, true);
	      }

	      Util.reflow(element);
	      $$$1(element).addClass(ClassName.SHOW);

	      if (element.parentNode &amp;&amp; $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
	        var dropdownElement = $$$1(element).closest(Selector.DROPDOWN)[0];

	        if (dropdownElement) {
	          $$$1(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
	        }

	        element.setAttribute(&#x27;aria-expanded&#x27;, true);
	      }

	      if (callback) {
	        callback();
	      }
	    }; // Static


	    Tab._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var $this = $$$1(this);
	        var data = $this.data(DATA_KEY);

	        if (!data) {
	          data = new Tab(this);
	          $this.data(DATA_KEY, data);
	        }

	        if (typeof config === &#x27;string&#x27;) {
	          if (typeof data[config] === &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Tab, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Tab;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    event.preventDefault();

	    Tab._jQueryInterface.call($$$1(this), &#x27;show&#x27;);
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] = Tab._jQueryInterface;
	  $$$1.fn[NAME].Constructor = Tab;

	  $$$1.fn[NAME].noConflict = function () {
	    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Tab._jQueryInterface;
	  };

	  return Tab;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-alpha.6): index.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	(function ($$$1) {
	  if (typeof $$$1 === &#x27;undefined&#x27;) {
	    throw new TypeError(&#x27;Bootstrap\&#x27;s JavaScript requires jQuery. jQuery must be included before Bootstrap\&#x27;s JavaScript.&#x27;);
	  }

	  var version = $$$1.fn.jquery.split(&#x27; &#x27;)[0].split(&#x27;.&#x27;);
	  var minMajor = 1;
	  var ltMajor = 2;
	  var minMinor = 9;
	  var minPatch = 1;
	  var maxMajor = 4;

	  if (version[0] &lt; ltMajor &amp;&amp; version[1] &lt; minMinor || version[0] === minMajor &amp;&amp; version[1] === minMinor &amp;&amp; version[2] &lt; minPatch || version[0] &gt;= maxMajor) {
	    throw new Error(&#x27;Bootstrap\&#x27;s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0&#x27;);
	  }
	})($);

	exports.Util = Util;
	exports.Alert = Alert;
	exports.Button = Button;
	exports.Carousel = Carousel;
	exports.Collapse = Collapse;
	exports.Dropdown = Dropdown;
	exports.Modal = Modal;
	exports.Popover = Popover;
	exports.Scrollspy = ScrollSpy;
	exports.Tab = Tab;
	exports.Tooltip = Tooltip;

	Object.defineProperty(exports, &#x27;__esModule&#x27;, { value: true });

	})));
	//# sourceMappingURL=bootstrap.js.map


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/*! waitForImages jQuery Plugin 2013-07-20 */
	!function(a){var b=&quot;waitForImages&quot;;a.waitForImages={hasImageProperties:[&quot;backgroundImage&quot;,&quot;listStyleImage&quot;,&quot;borderImage&quot;,&quot;borderCornerImage&quot;,&quot;cursor&quot;]},a.expr[&quot;:&quot;].uncached=function(b){if(!a(b).is(&#x27;img[src!=&quot;&quot;]&#x27;))return!1;var c=new Image;return c.src=b.src,!c.complete},a.fn.waitForImages=function(c,d,e){var f=0,g=0;if(a.isPlainObject(arguments[0])&amp;&amp;(e=arguments[0].waitForAll,d=arguments[0].each,c=arguments[0].finished),c=c||a.noop,d=d||a.noop,e=!!e,!a.isFunction(c)||!a.isFunction(d))throw new TypeError(&quot;An invalid callback was supplied.&quot;);return this.each(function(){var h=a(this),i=[],j=a.waitForImages.hasImageProperties||[],k=/url\(\s*([&#x27;&quot;]?)(.*?)\1\s*\)/g;e?h.find(&quot;*&quot;).addBack().each(function(){var b=a(this);b.is(&quot;img:uncached&quot;)&amp;&amp;i.push({src:b.attr(&quot;src&quot;),element:b[0]}),a.each(j,function(a,c){var d,e=b.css(c);if(!e)return!0;for(;d=k.exec(e);)i.push({src:d[2],element:b[0]})})}):h.find(&quot;img:uncached&quot;).each(function(){i.push({src:this.src,element:this})}),f=i.length,g=0,0===f&amp;&amp;c.call(h[0]),a.each(i,function(e,i){var j=new Image;a(j).on(&quot;load.&quot;+b+&quot; error.&quot;+b,function(a){return g++,d.call(i.element,g,f,&quot;load&quot;==a.type),g==f?(c.call(h[0]),!1):void 0}),j.src=i.src})})}}(jQuery);

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/*
	 * CSS3 Animate it
	 * Copyright (c) 2014 Jack McCourt
	 * https://github.com/kriegar/css3-animate-it
	 * Version: 0.1.0
	 * 
	 * I utilise the jQuery.appear plugin within this javascript file so here is a link to that too
	 * https://github.com/morr/jquery.appear
	 *
	 * I also utilise the jQuery.doTimeout plugin for the data-sequence functionality so here is a link back to them.
	 * http://benalman.com/projects/jquery-dotimeout-plugin/
	 */
	(function ($) {
	    var selectors = [];

	    var check_binded = false;
	    var check_lock = false;
	    var defaults = {
	        interval: 250,
	        force_process: false
	    };
	    var $window = $(window);

	    var $prior_appeared;

	    function process() {
	        check_lock = false;
	        for (var index = 0; index &lt; selectors.length; index++) {
	            var $appeared = $(selectors[index]).filter(function () {
	                return $(this).is(&#x27;:appeared&#x27;);
	            });

	            $appeared.trigger(&#x27;appear&#x27;, [$appeared]);

	            if ($prior_appeared) {

	                var $disappeared = $prior_appeared.not($appeared);
	                $disappeared.trigger(&#x27;disappear&#x27;, [$disappeared]);
	            }
	            $prior_appeared = $appeared;
	        }
	    }

	    // &quot;appeared&quot; custom filter
	    $.expr[&#x27;:&#x27;][&#x27;appeared&#x27;] = function (element) {
	        var $element = $(element);
	        if (!$element.is(&#x27;:visible&#x27;)) {
	            return false;
	        }

	        var window_left = $window.scrollLeft();
	        var window_top = $window.scrollTop();
	        var offset = $element.offset();
	        var left = offset.left;
	        var top = offset.top;

	        if (top + $element.height() &gt;= window_top &amp;&amp;
	            top - ($element.data(&#x27;appear-top-offset&#x27;) || 0) &lt;= window_top + $window.height() &amp;&amp;
	            left + $element.width() &gt;= window_left &amp;&amp;
	            left - ($element.data(&#x27;appear-left-offset&#x27;) || 0) &lt;= window_left + $window.width()) {
	            return true;
	        } else {
	            return false;
	        }
	    };

	    $.fn.extend({
	        // watching for element&#x27;s appearance in browser viewport
	        appear: function (options) {
	            var opts = $.extend({}, defaults, options || {});
	            var selector = this.selector || this;
	            if (!check_binded) {
	                var on_check = function () {
	                    if (check_lock) {
	                        return;
	                    }
	                    check_lock = true;

	                    setTimeout(process, opts.interval);
	                };

	                $(window).scroll(on_check).resize(on_check);
	                check_binded = true;
	            }

	            if (opts.force_process) {
	                setTimeout(process, opts.interval);
	            }
	            selectors.push(selector);
	            return $(selector);
	        }
	    });

	    $.extend({
	        // force elements&#x27;s appearance check
	        force_appear: function () {
	            if (check_binded) {
	                process();
	                return true;
	            }
	            return false;
	        }
	    });
	})(jQuery);


	/*!
	 * jQuery doTimeout: Like setTimeout, but better! - v1.0 - 3/3/2010
	 * http://benalman.com/projects/jquery-dotimeout-plugin/
	 * 
	 * Copyright (c) 2010 &quot;Cowboy&quot; Ben Alman
	 * Dual licensed under the MIT and GPL licenses.
	 * http://benalman.com/about/license/
	 */

	// Script: jQuery doTimeout: Like setTimeout, but better!
	//
	// *Version: 1.0, Last updated: 3/3/2010*
	// 
	// Project Home - http://benalman.com/projects/jquery-dotimeout-plugin/
	// GitHub       - http://github.com/cowboy/jquery-dotimeout/
	// Source       - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.js
	// (Minified)   - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.min.js (1.0kb)
	// 
	// About: License
	// 
	// Copyright (c) 2010 &quot;Cowboy&quot; Ben Alman,
	// Dual licensed under the MIT and GPL licenses.
	// http://benalman.com/about/license/
	// 
	// About: Examples
	// 
	// These working examples, complete with fully commented code, illustrate a few
	// ways in which this plugin can be used.
	// 
	// Debouncing      - http://benalman.com/code/projects/jquery-dotimeout/examples/debouncing/
	// Delays, Polling - http://benalman.com/code/projects/jquery-dotimeout/examples/delay-poll/
	// Hover Intent    - http://benalman.com/code/projects/jquery-dotimeout/examples/hoverintent/
	// 
	// About: Support and Testing
	// 
	// Information about what version or versions of jQuery this plugin has been
	// tested with, what browsers it has been tested in, and where the unit tests
	// reside (so you can test it yourself).
	// 
	// jQuery Versions - 1.3.2, 1.4.2
	// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
	// Unit Tests      - http://benalman.com/code/projects/jquery-dotimeout/unit/
	// 
	// About: Release History
	// 
	// 1.0 - (3/3/2010) Callback can now be a string, in which case it will call
	//       the appropriate $.method or $.fn.method, depending on where .doTimeout
	//       was called. Callback must now return &#x60;true&#x60; (not just a truthy value)
	//       to poll.
	// 0.4 - (7/15/2009) Made the &quot;id&quot; argument optional, some other minor tweaks
	// 0.3 - (6/25/2009) Initial release

	(function ($) {
	    &#x27;$:nomunge&#x27;; // Used by YUI compressor.

	    var cache = {},

	        // Reused internal string.
	        doTimeout = &#x27;doTimeout&#x27;,

	        // A convenient shortcut.
	        aps = Array.prototype.slice;

	    // Method: jQuery.doTimeout
	    // 
	    // Initialize, cancel, or force execution of a callback after a delay.
	    // 
	    // If delay and callback are specified, a doTimeout is initialized. The
	    // callback will execute, asynchronously, after the delay. If an id is
	    // specified, this doTimeout will override and cancel any existing doTimeout
	    // with the same id. Any additional arguments will be passed into callback
	    // when it is executed.
	    // 
	    // If the callback returns true, the doTimeout loop will execute again, after
	    // the delay, creating a polling loop until the callback returns a non-true
	    // value.
	    // 
	    // Note that if an id is not passed as the first argument, this doTimeout will
	    // NOT be able to be manually canceled or forced. (for debouncing, be sure to
	    // specify an id).
	    // 
	    // If id is specified, but delay and callback are not, the doTimeout will be
	    // canceled without executing the callback. If force_mode is specified, the
	    // callback will be executed, synchronously, but will only be allowed to
	    // continue a polling loop if force_mode is true (provided the callback
	    // returns true, of course). If force_mode is false, no polling loop will
	    // continue, even if the callback returns true.
	    // 
	    // Usage:
	    // 
	    // &gt; jQuery.doTimeout( [ id, ] delay, callback [, arg ... ] );
	    // &gt; jQuery.doTimeout( id [, force_mode ] );
	    // 
	    // Arguments:
	    // 
	    //  id - (String) An optional unique identifier for this doTimeout. If id is
	    //    not specified, the doTimeout will NOT be able to be manually canceled or
	    //    forced.
	    //  delay - (Number) A zero-or-greater delay in milliseconds after which
	    //    callback will be executed. 
	    //  callback - (Function) A function to be executed after delay milliseconds.
	    //  callback - (String) A jQuery method to be executed after delay
	    //    milliseconds. This method will only poll if it explicitly returns
	    //    true.
	    //  force_mode - (Boolean) If true, execute that id&#x27;s doTimeout callback
	    //    immediately and synchronously, continuing any callback return-true
	    //    polling loop. If false, execute the callback immediately and
	    //    synchronously but do NOT continue a callback return-true polling loop.
	    //    If omitted, cancel that id&#x27;s doTimeout.
	    // 
	    // Returns:
	    // 
	    //  If force_mode is true, false or undefined and there is a
	    //  yet-to-be-executed callback to cancel, true is returned, but if no
	    //  callback remains to be executed, undefined is returned.

	    $[doTimeout] = function () {
	        return p_doTimeout.apply(window, [0].concat(aps.call(arguments)));
	    };

	    // Method: jQuery.fn.doTimeout
	    // 
	    // Initialize, cancel, or force execution of a callback after a delay.
	    // Operates like &lt;jQuery.doTimeout&gt;, but the passed callback executes in the
	    // context of the jQuery collection of elements, and the id is stored as data
	    // on the first element in that collection.
	    // 
	    // If delay and callback are specified, a doTimeout is initialized. The
	    // callback will execute, asynchronously, after the delay. If an id is
	    // specified, this doTimeout will override and cancel any existing doTimeout
	    // with the same id. Any additional arguments will be passed into callback
	    // when it is executed.
	    // 
	    // If the callback returns true, the doTimeout loop will execute again, after
	    // the delay, creating a polling loop until the callback returns a non-true
	    // value.
	    // 
	    // Note that if an id is not passed as the first argument, this doTimeout will
	    // NOT be able to be manually canceled or forced (for debouncing, be sure to
	    // specify an id).
	    // 
	    // If id is specified, but delay and callback are not, the doTimeout will be
	    // canceled without executing the callback. If force_mode is specified, the
	    // callback will be executed, synchronously, but will only be allowed to
	    // continue a polling loop if force_mode is true (provided the callback
	    // returns true, of course). If force_mode is false, no polling loop will
	    // continue, even if the callback returns true.
	    // 
	    // Usage:
	    // 
	    // &gt; jQuery(&#x27;selector&#x27;).doTimeout( [ id, ] delay, callback [, arg ... ] );
	    // &gt; jQuery(&#x27;selector&#x27;).doTimeout( id [, force_mode ] );
	    // 
	    // Arguments:
	    // 
	    //  id - (String) An optional unique identifier for this doTimeout, stored as
	    //    jQuery data on the element. If id is not specified, the doTimeout will
	    //    NOT be able to be manually canceled or forced.
	    //  delay - (Number) A zero-or-greater delay in milliseconds after which
	    //    callback will be executed. 
	    //  callback - (Function) A function to be executed after delay milliseconds.
	    //  callback - (String) A jQuery.fn method to be executed after delay
	    //    milliseconds. This method will only poll if it explicitly returns
	    //    true (most jQuery.fn methods return a jQuery object, and not &#x60;true&#x60;,
	    //    which allows them to be chained and prevents polling).
	    //  force_mode - (Boolean) If true, execute that id&#x27;s doTimeout callback
	    //    immediately and synchronously, continuing any callback return-true
	    //    polling loop. If false, execute the callback immediately and
	    //    synchronously but do NOT continue a callback return-true polling loop.
	    //    If omitted, cancel that id&#x27;s doTimeout.
	    // 
	    // Returns:
	    // 
	    //  When creating a &lt;jQuery.fn.doTimeout&gt;, the initial jQuery collection of
	    //  elements is returned. Otherwise, if force_mode is true, false or undefined
	    //  and there is a yet-to-be-executed callback to cancel, true is returned,
	    //  but if no callback remains to be executed, undefined is returned.

	    $.fn[doTimeout] = function () {
	        var args = aps.call(arguments),
	            result = p_doTimeout.apply(this, [doTimeout + args[0]].concat(args));

	        return typeof args[0] === &#x27;number&#x27; || typeof args[1] === &#x27;number&#x27; ?
	            this :
	            result;
	    };

	    function p_doTimeout(jquery_data_key) {
	        var that = this,
	            elem,
	            data = {},

	            // Allows the plugin to call a string callback method.
	            method_base = jquery_data_key ? $.fn : $,

	            // Any additional arguments will be passed to the callback.
	            args = arguments,
	            slice_args = 4,

	            id = args[1],
	            delay = args[2],
	            callback = args[3];

	        if (typeof id !== &#x27;string&#x27;) {
	            slice_args--;

	            id = jquery_data_key = 0;
	            delay = args[1];
	            callback = args[2];
	        }

	        // If id is passed, store a data reference either as .data on the first
	        // element in a jQuery collection, or in the internal cache.
	        if (jquery_data_key) { // Note: key is &#x27;doTimeout&#x27; + id

	            // Get id-object from the first element&#x27;s data, otherwise initialize it to {}.
	            elem = that.eq(0);
	            elem.data(jquery_data_key, data = elem.data(jquery_data_key) || {});

	        } else if (id) {
	            // Get id-object from the cache, otherwise initialize it to {}.
	            data = cache[id] || (cache[id] = {});
	        }

	        // Clear any existing timeout for this id.
	        data.id &amp;&amp; clearTimeout(data.id);
	        delete data.id;

	        // Clean up when necessary.
	        function cleanup() {
	            if (jquery_data_key) {
	                elem.removeData(jquery_data_key);
	            } else if (id) {
	                delete cache[id];
	            }
	        }
	        // Yes, there actually is a setTimeout call in here!
	        function actually_setTimeout() {
	            data.id = setTimeout(function () {
	                data.fn();
	            }, delay);
	        }
	        if (callback) {
	            // A callback (and delay) were specified. Store the callback reference for
	            // possible later use, and then setTimeout.
	            data.fn = function (no_polling_loop) {

	                // If the callback value is a string, it is assumed to be the name of a
	                // method on $ or $.fn depending on where doTimeout was executed.
	                if (typeof callback === &#x27;string&#x27;) {
	                    callback = method_base[callback];
	                }

	                callback.apply(that, aps.call(args, slice_args)) === true &amp;&amp; !no_polling_loop

	                    // Since the callback returned true, and we&#x27;re not specifically
	                    // canceling a polling loop, do it again!
	                    ?
	                    actually_setTimeout()

	                    // Otherwise, clean up and quit.
	                    : cleanup();
	            };

	            // Set that timeout!
	            actually_setTimeout();

	        } else if (data.fn) {
	            // No callback passed. If force_mode (delay) is true, execute the data.fn
	            // callback immediately, continuing any callback return-true polling loop.
	            // If force_mode is false, execute the data.fn callback immediately but do
	            // NOT continue a callback return-true polling loop. If force_mode is
	            // undefined, simply clean up. Since data.fn was still defined, whatever
	            // was supposed to happen hadn&#x27;t yet, so return true.
	            delay === undefined ? cleanup() : data.fn(delay === false);
	            return true;

	        } else {
	            // Since no callback was passed, and data.fn isn&#x27;t defined, it looks like
	            // whatever was supposed to happen already did. Clean up and quit!
	            cleanup();
	        }

	    }
	})(jQuery);


	//CSS3 Animate-it
	$(&#x27;.animatedParent&#x27;).appear();
	$(&#x27;.animatedClick&#x27;).click(function () {
	    var target = $(this).attr(&#x27;data-target&#x27;);


	    if ($(this).attr(&#x27;data-sequence&#x27;) != undefined) {
	        var firstId = $(&quot;.&quot; + target + &quot;:first&quot;).attr(&#x27;data-id&#x27;);
	        var lastId = $(&quot;.&quot; + target + &quot;:last&quot;).attr(&#x27;data-id&#x27;);
	        var number = firstId;

	        //Add or remove the class
	        if ($(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).hasClass(&#x27;go&#x27;)) {
	            $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).addClass(&#x27;goAway&#x27;);
	            $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).removeClass(&#x27;go&#x27;);
	        } else {
	            $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	            $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).removeClass(&#x27;goAway&#x27;);
	        }
	        number++;
	        delay = Number($(this).attr(&#x27;data-sequence&#x27;));
	        $.doTimeout(delay, function () {
	            console.log(lastId);

	            //Add or remove the class
	            if ($(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).hasClass(&#x27;go&#x27;)) {
	                $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).addClass(&#x27;goAway&#x27;);
	                $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).removeClass(&#x27;go&#x27;);
	            } else {
	                $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	                $(&quot;.&quot; + target + &quot;[data-id=&quot; + number + &quot;]&quot;).removeClass(&#x27;goAway&#x27;);
	            }

	            //increment
	            ++number;

	            //continute looping till reached last ID
	            if (number &lt;= lastId) {
	                return true;
	            }
	        });
	    } else {
	        if ($(&#x27;.&#x27; + target).hasClass(&#x27;go&#x27;)) {
	            $(&#x27;.&#x27; + target).addClass(&#x27;goAway&#x27;);
	            $(&#x27;.&#x27; + target).removeClass(&#x27;go&#x27;);
	        } else {
	            $(&#x27;.&#x27; + target).addClass(&#x27;go&#x27;);
	            $(&#x27;.&#x27; + target).removeClass(&#x27;goAway&#x27;);
	        }
	    }
	});

	$(document.body).on(&#x27;appear&#x27;, &#x27;.animatedParent&#x27;, function (e, $affected) {
	    var ele = $(this).find(&#x27;.animated&#x27;);
	    var parent = $(this);


	    if (parent.attr(&#x27;data-sequence&#x27;) != undefined) {

	        var firstId = $(this).find(&#x27;.animated:first&#x27;).attr(&#x27;data-id&#x27;);
	        var number = firstId;
	        var lastId = $(this).find(&#x27;.animated:last&#x27;).attr(&#x27;data-id&#x27;);

	        $(parent).find(&quot;.animated[data-id=&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	        number++;
	        delay = Number(parent.attr(&#x27;data-sequence&#x27;));

	        $.doTimeout(delay, function () {
	            $(parent).find(&quot;.animated[data-id=&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	            ++number;
	            if (number &lt;= lastId) {
	                return true;
	            }
	        });
	    } else {
	        ele.addClass(&#x27;go&#x27;);
	    }

	});

	$(document.body).on(&#x27;disappear&#x27;, &#x27;.animatedParent&#x27;, function (e, $affected) {
	    if (!$(this).hasClass(&#x27;animateOnce&#x27;)) {
	        $(this).find(&#x27;.animated&#x27;).removeClass(&#x27;go&#x27;);
	    }
	});

	$(window).on(&#x27;load&#x27;, function () {
	    $.force_appear();
	});

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(13);

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ($(&#x27;.sticky&#x27;).length) {
	        $(&#x27;.sticky&#x27;).Stickyfill();
	    }
	});



/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/*!
	 * Stickyfill -- &#x60;position: sticky&#x60; polyfill
	 * v. 1.1.4 | https://github.com/wilddeer/stickyfill
	 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
	 *
	 * MIT License
	 */
	!function(a,b){function c(){y=D=z=A=B=C=K}function d(a,b){for(var c in b)b.hasOwnProperty(c)&amp;&amp;(a[c]=b[c])}function e(a){return parseFloat(a)||0}function f(){F={top:b.pageYOffset,left:b.pageXOffset}}function g(){return b.pageXOffset!=F.left?(f(),void z()):void(b.pageYOffset!=F.top&amp;&amp;(f(),i()))}function h(a){setTimeout(function(){b.pageYOffset!=F.top&amp;&amp;(F.top=b.pageYOffset,i())},0)}function i(){for(var a=H.length-1;a&gt;=0;a--)j(H[a])}function j(a){if(a.inited){var b=F.top&lt;=a.limit.start?0:F.top&gt;=a.limit.end?2:1;a.mode!=b&amp;&amp;p(a,b)}}function k(){for(var a=H.length-1;a&gt;=0;a--)if(H[a].inited){var b=Math.abs(t(H[a].clone)-H[a].docOffsetTop),c=Math.abs(H[a].parent.node.offsetHeight-H[a].parent.height);if(b&gt;=2||c&gt;=2)return!1}return!0}function l(a){isNaN(parseFloat(a.computed.top))||a.isCell||&quot;none&quot;==a.computed.display||(a.inited=!0,a.clone||q(a),&quot;absolute&quot;!=a.parent.computed.position&amp;&amp;&quot;relative&quot;!=a.parent.computed.position&amp;&amp;(a.parent.node.style.position=&quot;relative&quot;),j(a),a.parent.height=a.parent.node.offsetHeight,a.docOffsetTop=t(a.clone))}function m(a){var b=!0;a.clone&amp;&amp;r(a),d(a.node.style,a.css);for(var c=H.length-1;c&gt;=0;c--)if(H[c].node!==a.node&amp;&amp;H[c].parent.node===a.parent.node){b=!1;break}b&amp;&amp;(a.parent.node.style.position=a.parent.css.position),a.mode=-1}function n(){for(var a=H.length-1;a&gt;=0;a--)l(H[a])}function o(){for(var a=H.length-1;a&gt;=0;a--)m(H[a])}function p(a,b){var c=a.node.style;switch(b){case 0:c.position=&quot;absolute&quot;,c.left=a.offset.left+&quot;px&quot;,c.right=a.offset.right+&quot;px&quot;,c.top=a.offset.top+&quot;px&quot;,c.bottom=&quot;auto&quot;,c.width=&quot;auto&quot;,c.marginLeft=0,c.marginRight=0,c.marginTop=0;break;case 1:c.position=&quot;fixed&quot;,c.left=a.box.left+&quot;px&quot;,c.right=a.box.right+&quot;px&quot;,c.top=a.css.top,c.bottom=&quot;auto&quot;,c.width=&quot;auto&quot;,c.marginLeft=0,c.marginRight=0,c.marginTop=0;break;case 2:c.position=&quot;absolute&quot;,c.left=a.offset.left+&quot;px&quot;,c.right=a.offset.right+&quot;px&quot;,c.top=&quot;auto&quot;,c.bottom=0,c.width=&quot;auto&quot;,c.marginLeft=0,c.marginRight=0}a.mode=b}function q(a){a.clone=document.createElement(&quot;div&quot;);var b=a.node.nextSibling||a.node,c=a.clone.style;c.height=a.height+&quot;px&quot;,c.width=a.width+&quot;px&quot;,c.marginTop=a.computed.marginTop,c.marginBottom=a.computed.marginBottom,c.marginLeft=a.computed.marginLeft,c.marginRight=a.computed.marginRight,c.padding=c.border=c.borderSpacing=0,c.fontSize=&quot;1em&quot;,c.position=&quot;static&quot;,c.cssFloat=a.computed.cssFloat,a.node.parentNode.insertBefore(a.clone,b)}function r(a){a.clone.parentNode.removeChild(a.clone),a.clone=void 0}function s(a){var b=getComputedStyle(a),c=a.parentNode,d=getComputedStyle(c),f=a.style.position;a.style.position=&quot;relative&quot;;var g={top:b.top,marginTop:b.marginTop,marginBottom:b.marginBottom,marginLeft:b.marginLeft,marginRight:b.marginRight,cssFloat:b.cssFloat,display:b.display},h={top:e(b.top),marginBottom:e(b.marginBottom),paddingLeft:e(b.paddingLeft),paddingRight:e(b.paddingRight),borderLeftWidth:e(b.borderLeftWidth),borderRightWidth:e(b.borderRightWidth)};a.style.position=f;var i={position:a.style.position,top:a.style.top,bottom:a.style.bottom,left:a.style.left,right:a.style.right,width:a.style.width,marginTop:a.style.marginTop,marginLeft:a.style.marginLeft,marginRight:a.style.marginRight},j=u(a),k=u(c),l={node:c,css:{position:c.style.position},computed:{position:d.position},numeric:{borderLeftWidth:e(d.borderLeftWidth),borderRightWidth:e(d.borderRightWidth),borderTopWidth:e(d.borderTopWidth),borderBottomWidth:e(d.borderBottomWidth)}},m={node:a,box:{left:j.win.left,right:J.clientWidth-j.win.right},offset:{top:j.win.top-k.win.top-l.numeric.borderTopWidth,left:j.win.left-k.win.left-l.numeric.borderLeftWidth,right:-j.win.right+k.win.right-l.numeric.borderRightWidth},css:i,isCell:&quot;table-cell&quot;==b.display,computed:g,numeric:h,width:j.win.right-j.win.left,height:j.win.bottom-j.win.top,mode:-1,inited:!1,parent:l,limit:{start:j.doc.top-h.top,end:k.doc.top+c.offsetHeight-l.numeric.borderBottomWidth-a.offsetHeight-h.top-h.marginBottom}};return m}function t(a){for(var b=0;a;)b+=a.offsetTop,a=a.offsetParent;return b}function u(a){var c=a.getBoundingClientRect();return{doc:{top:c.top+b.pageYOffset,left:c.left+b.pageXOffset},win:c}}function v(){G=setInterval(function(){!k()&amp;&amp;z()},500)}function w(){clearInterval(G)}function x(){I&amp;&amp;(document[L]?w():v())}function y(){I||(f(),n(),b.addEventListener(&quot;scroll&quot;,g),b.addEventListener(&quot;wheel&quot;,h),b.addEventListener(&quot;resize&quot;,z),b.addEventListener(&quot;orientationchange&quot;,z),a.addEventListener(M,x),v(),I=!0)}function z(){if(I){o();for(var a=H.length-1;a&gt;=0;a--)H[a]=s(H[a].node);n()}}function A(){b.removeEventListener(&quot;scroll&quot;,g),b.removeEventListener(&quot;wheel&quot;,h),b.removeEventListener(&quot;resize&quot;,z),b.removeEventListener(&quot;orientationchange&quot;,z),a.removeEventListener(M,x),w(),I=!1}function B(){A(),o()}function C(){for(B();H.length;)H.pop()}function D(a){for(var b=H.length-1;b&gt;=0;b--)if(H[b].node===a)return;var c=s(a);H.push(c),I?l(c):y()}function E(a){for(var b=H.length-1;b&gt;=0;b--)H[b].node===a&amp;&amp;(m(H[b]),H.splice(b,1))}var F,G,H=[],I=!1,J=a.documentElement,K=function(){},L=&quot;hidden&quot;,M=&quot;visibilitychange&quot;;void 0!==a.webkitHidden&amp;&amp;(L=&quot;webkitHidden&quot;,M=&quot;webkitvisibilitychange&quot;),b.getComputedStyle||c();for(var N=[&quot;&quot;,&quot;-webkit-&quot;,&quot;-moz-&quot;,&quot;-ms-&quot;],O=document.createElement(&quot;div&quot;),P=N.length-1;P&gt;=0;P--){try{O.style.position=N[P]+&quot;sticky&quot;}catch(Q){}&quot;&quot;!=O.style.position&amp;&amp;c()}f(),b.Stickyfill={stickies:H,add:D,remove:E,init:y,rebuild:z,pause:A,stop:B,kill:C}}(document,window),window.jQuery&amp;&amp;!function($){$.fn.Stickyfill=function(a){return this.each(function(){Stickyfill.add(this)}),this}}(window.jQuery);

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	// Format Number With Commas
	getNumberWithCommas = function (x) {
	    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &quot;,&quot;);
	};

	isElementInViewport = function isElementInViewport(el) {

	    //special bonus for those using jQuery
	    if (typeof jQuery === &quot;function&quot; &amp;&amp; el instanceof jQuery) {
	        el = el[0];
	    }

	    var rect = el.getBoundingClientRect();

	    return (
	        rect.top &gt;= 0 &amp;&amp;
	        rect.left &gt;= 0 &amp;&amp;
	        rect.bottom &lt;= (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; /*or $(window).height() */
	        rect.right &lt;= (window.innerWidth || document.documentElement.clientWidth) /*or $(window).width() */
	    );
	};


	goToTop = function () {
	    if($(&#x27;.js-gotop&#x27;).length) {
	        $(&#x27;.js-gotop&#x27;).on(&#x27;click&#x27;, function (event) {
	            event.preventDefault();
	            $(&#x27;html, body&#x27;).animate({
	                scrollTop: $(&#x27;html&#x27;).offset().top
	            }, 500, &#x27;easeInOutExpo&#x27;);
	            return false;
	        });

	        $(window).scroll(function () {
	            var $win = $(window);
	            if ($win.scrollTop() &gt; 200) {
	                $(&#x27;.js-top&#x27;).addClass(&#x27;active&#x27;);
	            } else {
	                $(&#x27;.js-top&#x27;).removeClass(&#x27;active&#x27;);
	            }
	        });
	    }
	};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	(function () {

	    &#x27;use strict&#x27;;

	    /*-------------------------------------
	     window...
	     --------------------------------------*/

	    var window_w = $(window).width(); // Window Width
	    var window_h = $(window).height(); // Window Height
	    var window_s = $(window).scrollTop(); // Window Scroll Top

	    var $html = $(&#x27;html&#x27;); // HTML
	    var $body = $(&#x27;body&#x27;); // Body


	    if ($(&quot;#docs&quot;).length) {
	        $(&#x27;#docs&#x27;).popover(&#x27;show&#x27;);
	    }

	    /*-------------------------------------
	     Smooth Scroll
	     --------------------------------------*/

	    if ($(&quot;.scroll&quot;).length &gt; 0 || $(&quot;.scroll a[href^=&#x27;#&#x27;]&quot;).length &gt; 0) {
	        $(&#x27;.scroll, .scroll a[href^=&quot;#&quot;]&#x27;).on(&#x27;click&#x27;, function () {
	            $(&#x27;html, body&#x27;).animate({
	                scrollTop: $($.attr(this, &#x27;href&#x27;)).offset().top - 30
	            }, 1500, function () {
	            });
	            return false;
	        });
	    }

	    /*-------------------------------------
	     Woo-Quantity
	     --------------------------------------*/

	    $(&quot;body&quot;).on(&quot;click&quot;, &quot;.xv-qyt&quot;, function (e) {
	        e.preventDefault();
	        var $add = parseInt($(this).attr(&quot;data-value&quot;)),
	            $input = $(this).siblings(&quot;input.qty&quot;),
	            cVal = parseInt($input.val());
	        if (cVal &gt;= 1) {
	            if ($add === -1 &amp;&amp; cVal === 1)
	                return false;
	            $input.val(cVal + $add);
	        }
	    });

	    /*-------------------------------------
	     Custom Select
	     --------------------------------------*/
	    $(&#x27;.custome-select select&#x27;).on(&#x27;change&#x27;, function () {
	        var p = $(this).parent(&quot;.custome-select&quot;);
	        p.find(&#x27;span&#x27;).html($(this).val());
	    });


	    goToTop();

	}());

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(17);
	jQuery(function ($) {
	    &quot;use strict&quot;;
	    lightSlider();
	});
	var lightSlider = function () {
	    var clientSlider = $(&#x27;#clientSlider&#x27;).lightSlider({
	        adaptiveHeight: true,
	        item: 5,
	        slideMargin: 0,
	        auto: true,
	        loop: false,
	        pauseOnHover: true,
	    });

	    var light = $(&quot;.lightSlider&quot;);
	    light.each(function () {
	        var $this = $(this);
	        $this.lightSlider({
	            verticalHeight: $this.data(&#x27;vertical-height&#x27;),
	            autoWidth: $this.data(&#x27;auto-width&#x27;),
	            slideWidth: $this.data(&#x27;slide-width&#x27;),
	            centerSlide: $this.data(&#x27;center-slide&#x27;),
	            gallery: $this.data(&#x27;gallery&#x27;),
	            thumbItem: $this.data(&#x27;thumbs&#x27;),
	            thumbMargin: $this.data(&#x27;margin&#x27;),
	            item: $this.data(&#x27;item&#x27;),
	            loop: $this.data(&#x27;loop&#x27;),
	            mode: $this.data(&#x27;mode&#x27;),
	            adaptiveHeight: $this.data(&#x27;adaptive-height&#x27;),
	            speed: $this.data(&#x27;speed&#x27;),
	            auto: $this.data(&#x27;auto&#x27;),
	            pause: $this.data(&#x27;pause&#x27;),
	            pauseOnHover: $this.data(&#x27;pause-on-hover&#x27;),
	            pager: $this.data(&#x27;pager&#x27;),
	            slideMargin: $this.data(&#x27;slide-margin&#x27;),
	            vThumbWidth: 80,
	            currentPagerPosition: $this.data(&#x27;position&#x27;),
	            controls: $this.data(&#x27;controls&#x27;),
	            prevHtml: &#x27;&lt;span class=&quot;icon-left-arrow&quot;&gt;&lt;/span&gt;&#x27;,
	            nextHtml: &#x27;&lt;span class=&quot;icon-right-arrow&quot;&gt;&lt;/span&gt;&#x27;,
	            responsive: [
	                {
	                    breakpoint: 1024,
	                    settings: {
	                        item: $this.data(&#x27;item-lg&#x27;),
	                        slideMove: 1,
	                        slideMargin: 6,
	                    }
	                },
	                {
	                    breakpoint: 768,
	                    settings: {
	                        item: $this.data(&#x27;item-md&#x27;),
	                        slideMove: 1,
	                        slideMargin: 6,
	                    }
	                },
	                {
	                    breakpoint: 480,
	                    settings: {
	                        item: $this.data(&#x27;item-sm&#x27;),
	                        slideMove: 1
	                    }
	                }
	            ],
	            onSliderLoad: function (el) {
	                if ($this.data(&#x27;start&#x27;)) {
	                    $this.goToSlide($this.data(&#x27;start&#x27;));
	                }
	                $this.addClass(&#x27;showSlider&#x27;);


	                el.find(&#x27;.lslide .animated&#x27;).addClass(&quot;go&quot;);
	            },

	            onBeforeNextSlide: function (el) {
	                el.find(&#x27;.lslide .animated&#x27;).removeClass(&quot;go&quot;);
	            },
	            onAfterSlide: function (el) {
	                el.find(&#x27;.lslide .animated&#x27;).addClass(&quot;go&quot;);
	            }
	        });
	    });

	};

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/*! lightslider - v1.1.6 - 2016-10-25
	* https://github.com/sachinchoolur/lightslider
	* Copyright (c) 2016 Sachin N; Licensed MIT */
	(function ($, undefined) {
	    &#x27;use strict&#x27;;
	    var defaults = {
	        item: 3,
	        autoWidth: false,
	        slideMove: 1,
	        slideMargin: 10,
	        addClass: &#x27;&#x27;,
	        mode: &#x27;slide&#x27;,
	        useCSS: true,
	        cssEasing: &#x27;ease&#x27;, //&#x27;cubic-bezier(0.25, 0, 0.25, 1)&#x27;,
	        easing: &#x27;linear&#x27;, //&#x27;for jquery animation&#x27;,//
	        speed: 400, //ms&#x27;
	        auto: false,
	        pauseOnHover: false,
	        loop: false,
	        slideEndAnimation: true,
	        pause: 2000,
	        keyPress: false,
	        controls: true,
	        prevHtml: &#x27;&#x27;,
	        nextHtml: &#x27;&#x27;,
	        rtl: false,
	        adaptiveHeight: false,
	        vertical: false,
	        verticalHeight: 500,
	        vThumbWidth: 100,
	        thumbItem: 10,
	        pager: true,
	        gallery: false,
	        galleryMargin: 5,
	        thumbMargin: 5,
	        currentPagerPosition: &#x27;middle&#x27;,
	        enableTouch: true,
	        enableDrag: true,
	        freeMove: true,
	        swipeThreshold: 40,
	        responsive: [],
	        /* jshint ignore:start */
	        onBeforeStart: function ($el) {},
	        onSliderLoad: function ($el) {},
	        onBeforeSlide: function ($el, scene) {},
	        onAfterSlide: function ($el, scene) {},
	        onBeforeNextSlide: function ($el, scene) {},
	        onBeforePrevSlide: function ($el, scene) {}
	        /* jshint ignore:end */
	    };
	    $.fn.lightSlider = function (options) {
	        if (this.length === 0) {
	            return this;
	        }

	        if (this.length &gt; 1) {
	            this.each(function () {
	                $(this).lightSlider(options);
	            });
	            return this;
	        }

	        var plugin = {},
	            settings = $.extend(true, {}, defaults, options),
	            settingsTemp = {},
	            $el = this;
	        plugin.$el = this;

	        if (settings.mode === &#x27;fade&#x27;) {
	            settings.vertical = false;
	        }
	        var $children = $el.children(),
	            windowW = $(window).width(),
	            breakpoint = null,
	            resposiveObj = null,
	            length = 0,
	            w = 0,
	            on = false,
	            elSize = 0,
	            $slide = &#x27;&#x27;,
	            scene = 0,
	            property = (settings.vertical === true) ? &#x27;height&#x27; : &#x27;width&#x27;,
	            gutter = (settings.vertical === true) ? &#x27;margin-bottom&#x27; : &#x27;margin-right&#x27;,
	            slideValue = 0,
	            pagerWidth = 0,
	            slideWidth = 0,
	            thumbWidth = 0,
	            interval = null,
	            isTouch = (&#x27;ontouchstart&#x27; in document.documentElement);
	        var refresh = {};

	        refresh.chbreakpoint = function () {
	            windowW = $(window).width();
	            if (settings.responsive.length) {
	                var item;
	                if (settings.autoWidth === false) {
	                    item = settings.item;
	                }
	                if (windowW &lt; settings.responsive[0].breakpoint) {
	                    for (var i = 0; i &lt; settings.responsive.length; i++) {
	                        if (windowW &lt; settings.responsive[i].breakpoint) {
	                            breakpoint = settings.responsive[i].breakpoint;
	                            resposiveObj = settings.responsive[i];
	                        }
	                    }
	                }
	                if (typeof resposiveObj !== &#x27;undefined&#x27; &amp;&amp; resposiveObj !== null) {
	                    for (var j in resposiveObj.settings) {
	                        if (resposiveObj.settings.hasOwnProperty(j)) {
	                            if (typeof settingsTemp[j] === &#x27;undefined&#x27; || settingsTemp[j] === null) {
	                                settingsTemp[j] = settings[j];
	                            }
	                            settings[j] = resposiveObj.settings[j];
	                        }
	                    }
	                }
	                if (!$.isEmptyObject(settingsTemp) &amp;&amp; windowW &gt; settings.responsive[0].breakpoint) {
	                    for (var k in settingsTemp) {
	                        if (settingsTemp.hasOwnProperty(k)) {
	                            settings[k] = settingsTemp[k];
	                        }
	                    }
	                }
	                if (settings.autoWidth === false) {
	                    if (slideValue &gt; 0 &amp;&amp; slideWidth &gt; 0) {
	                        if (item !== settings.item) {
	                            scene = Math.round(slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove));
	                        }
	                    }
	                }
	            }
	        };

	        refresh.calSW = function () {
	            if (settings.autoWidth === false) {
	                slideWidth = (elSize - ((settings.item * (settings.slideMargin)) - settings.slideMargin)) / settings.item;
	            }
	        };

	        refresh.calWidth = function (cln) {
	            var ln = cln === true ? $slide.find(&#x27;.lslide&#x27;).length : $children.length;
	            if (settings.autoWidth === false) {
	                w = ln * (slideWidth + settings.slideMargin);
	            } else {
	                w = 0;
	                for (var i = 0; i &lt; ln; i++) {
	                    w += (parseInt($children.eq(i).width()) + settings.slideMargin);
	                }
	            }
	            return w;
	        };
	        plugin = {
	            doCss: function () {
	                var support = function () {
	                    var transition = [&#x27;transition&#x27;, &#x27;MozTransition&#x27;, &#x27;WebkitTransition&#x27;, &#x27;OTransition&#x27;, &#x27;msTransition&#x27;, &#x27;KhtmlTransition&#x27;];
	                    var root = document.documentElement;
	                    for (var i = 0; i &lt; transition.length; i++) {
	                        if (transition[i] in root.style) {
	                            return true;
	                        }
	                    }
	                };
	                if (settings.useCSS &amp;&amp; support()) {
	                    return true;
	                }
	                return false;
	            },
	            keyPress: function () {
	                if (settings.keyPress) {
	                    $(document).on(&#x27;keyup.lightslider&#x27;, function (e) {
	                        if (!$(&#x27;:focus&#x27;).is(&#x27;input, textarea&#x27;)) {
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            } else {
	                                e.returnValue = false;
	                            }
	                            if (e.keyCode === 37) {
	                                $el.goToPrevSlide();
	                            } else if (e.keyCode === 39) {
	                                $el.goToNextSlide();
	                            }
	                        }
	                    });
	                }
	            },
	            controls: function () {
	                if (settings.controls) {
	                    $el.after(&#x27;&lt;div class=&quot;lSAction&quot;&gt;&lt;a class=&quot;lSPrev&quot;&gt;&#x27; + settings.prevHtml + &#x27;&lt;/a&gt;&lt;a class=&quot;lSNext&quot;&gt;&#x27; + settings.nextHtml + &#x27;&lt;/a&gt;&lt;/div&gt;&#x27;);
	                    if (!settings.autoWidth) {
	                        if (length &lt;= settings.item) {
	                            $slide.find(&#x27;.lSAction&#x27;).hide();
	                        }
	                    } else {
	                        if (refresh.calWidth(false) &lt; elSize) {
	                            $slide.find(&#x27;.lSAction&#x27;).hide();
	                        }
	                    }
	                    $slide.find(&#x27;.lSAction a&#x27;).on(&#x27;click&#x27;, function (e) {
	                        if (e.preventDefault) {
	                            e.preventDefault();
	                        } else {
	                            e.returnValue = false;
	                        }
	                        if ($(this).attr(&#x27;class&#x27;) === &#x27;lSPrev&#x27;) {
	                            $el.goToPrevSlide();
	                        } else {
	                            $el.goToNextSlide();
	                        }
	                        return false;
	                    });
	                }
	            },
	            initialStyle: function () {
	                var $this = this;
	                if (settings.mode === &#x27;fade&#x27;) {
	                    settings.autoWidth = false;
	                    settings.slideEndAnimation = false;
	                }
	                if (settings.auto) {
	                    settings.slideEndAnimation = false;
	                }
	                if (settings.autoWidth) {
	                    settings.slideMove = 1;
	                    settings.item = 1;
	                }
	                if (settings.loop) {
	                    settings.slideMove = 1;
	                    settings.freeMove = false;
	                }
	                settings.onBeforeStart.call(this, $el);
	                refresh.chbreakpoint();
	                $el.addClass(&#x27;lightSlider&#x27;).wrap(&#x27;&lt;div class=&quot;lSSlideOuter &#x27; + settings.addClass + &#x27;&quot;&gt;&lt;div class=&quot;lSSlideWrapper&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;);
	                $slide = $el.parent(&#x27;.lSSlideWrapper&#x27;);
	                if (settings.rtl === true) {
	                    $slide.parent().addClass(&#x27;lSrtl&#x27;);
	                }
	                if (settings.vertical) {
	                    $slide.parent().addClass(&#x27;vertical&#x27;);
	                    elSize = settings.verticalHeight;
	                    $slide.css(&#x27;height&#x27;, elSize + &#x27;px&#x27;);
	                } else {
	                    elSize = $el.outerWidth();
	                }
	                $children.addClass(&#x27;lslide&#x27;);
	                if (settings.loop === true &amp;&amp; settings.mode === &#x27;slide&#x27;) {
	                    refresh.calSW();
	                    refresh.clone = function () {
	                        if (refresh.calWidth(true) &gt; elSize) {
	                            /**/
	                            var tWr = 0,
	                                tI = 0;
	                            for (var k = 0; k &lt; $children.length; k++) {
	                                tWr += (parseInt($el.find(&#x27;.lslide&#x27;).eq(k).width()) + settings.slideMargin);
	                                tI++;
	                                if (tWr &gt;= (elSize + settings.slideMargin)) {
	                                    break;
	                                }
	                            }
	                            var tItem = settings.autoWidth === true ? tI : settings.item;

	                            /**/
	                            if (tItem &lt; $el.find(&#x27;.clone.left&#x27;).length) {
	                                for (var i = 0; i &lt; $el.find(&#x27;.clone.left&#x27;).length - tItem; i++) {
	                                    $children.eq(i).remove();
	                                }
	                            }
	                            if (tItem &lt; $el.find(&#x27;.clone.right&#x27;).length) {
	                                for (var j = $children.length - 1; j &gt; ($children.length - 1 - $el.find(&#x27;.clone.right&#x27;).length); j--) {
	                                    scene--;
	                                    $children.eq(j).remove();
	                                }
	                            }
	                            /**/
	                            for (var n = $el.find(&#x27;.clone.right&#x27;).length; n &lt; tItem; n++) {
	                                $el.find(&#x27;.lslide&#x27;).eq(n).clone().removeClass(&#x27;lslide&#x27;).addClass(&#x27;clone right&#x27;).appendTo($el);
	                                scene++;
	                            }
	                            for (var m = $el.find(&#x27;.lslide&#x27;).length - $el.find(&#x27;.clone.left&#x27;).length; m &gt; ($el.find(&#x27;.lslide&#x27;).length - tItem); m--) {
	                                $el.find(&#x27;.lslide&#x27;).eq(m - 1).clone().removeClass(&#x27;lslide&#x27;).addClass(&#x27;clone left&#x27;).prependTo($el);
	                            }
	                            $children = $el.children();
	                        } else {
	                            if ($children.hasClass(&#x27;clone&#x27;)) {
	                                $el.find(&#x27;.clone&#x27;).remove();
	                                $this.move($el, 0);
	                            }
	                        }
	                    };
	                    refresh.clone();
	                }
	                refresh.sSW = function () {
	                    length = $children.length;
	                    if (settings.rtl === true &amp;&amp; settings.vertical === false) {
	                        gutter = &#x27;margin-left&#x27;;
	                    }
	                    if (settings.autoWidth === false) {
	                        $children.css(property, slideWidth + &#x27;px&#x27;);
	                    }
	                    $children.css(gutter, settings.slideMargin + &#x27;px&#x27;);
	                    w = refresh.calWidth(false);
	                    $el.css(property, w + &#x27;px&#x27;);
	                    if (settings.loop === true &amp;&amp; settings.mode === &#x27;slide&#x27;) {
	                        if (on === false) {
	                            scene = $el.find(&#x27;.clone.left&#x27;).length;
	                        }
	                    }
	                };
	                refresh.calL = function () {
	                    $children = $el.children();
	                    length = $children.length;
	                };
	                if (this.doCss()) {
	                    $slide.addClass(&#x27;usingCss&#x27;);
	                }
	                refresh.calL();
	                if (settings.mode === &#x27;slide&#x27;) {
	                    refresh.calSW();
	                    refresh.sSW();
	                    if (settings.loop === true) {
	                        slideValue = $this.slideValue();
	                        this.move($el, slideValue);
	                    }
	                    if (settings.vertical === false) {
	                        this.setHeight($el, false);
	                    }

	                } else {
	                    this.setHeight($el, true);
	                    $el.addClass(&#x27;lSFade&#x27;);
	                    if (!this.doCss()) {
	                        $children.fadeOut(0);
	                        $children.eq(scene).fadeIn(0);
	                    }
	                }
	                if (settings.loop === true &amp;&amp; settings.mode === &#x27;slide&#x27;) {
	                    $children.eq(scene).addClass(&#x27;active&#x27;);
	                } else {
	                    $children.first().addClass(&#x27;active&#x27;);
	                }
	            },
	            pager: function () {
	                var $this = this;
	                refresh.createPager = function () {
	                    thumbWidth = (elSize - ((settings.thumbItem * (settings.thumbMargin)) - settings.thumbMargin)) / settings.thumbItem;
	                    var $children = $slide.find(&#x27;.lslide&#x27;);
	                    var length = $slide.find(&#x27;.lslide&#x27;).length;
	                    var i = 0,
	                        pagers = &#x27;&#x27;,
	                        v = 0;
	                    for (i = 0; i &lt; length; i++) {
	                        if (settings.mode === &#x27;slide&#x27;) {
	                            // calculate scene * slide value
	                            if (!settings.autoWidth) {
	                                v = i * ((slideWidth + settings.slideMargin) * settings.slideMove);
	                            } else {
	                                v += ((parseInt($children.eq(i).width()) + settings.slideMargin) * settings.slideMove);
	                            }
	                        }
	                        var thumb = $children.eq(i * settings.slideMove).attr(&#x27;data-thumb&#x27;);
	                        if (settings.gallery === true) {
	                            pagers += &#x27;&lt;li style=&quot;width:100%;&#x27; + property + &#x27;:&#x27; + thumbWidth + &#x27;px;&#x27; + gutter + &#x27;:&#x27; + settings.thumbMargin + &#x27;px&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;&#x27; + thumb + &#x27;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;&#x27;;
	                        } else {
	                            pagers += &#x27;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&#x27; + (i + 1) + &#x27;&lt;/a&gt;&lt;/li&gt;&#x27;;
	                        }
	                        if (settings.mode === &#x27;slide&#x27;) {
	                            if ((v) &gt;= w - elSize - settings.slideMargin) {
	                                i = i + 1;
	                                var minPgr = 2;
	                                if (settings.autoWidth) {
	                                    pagers += &#x27;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&#x27; + (i + 1) + &#x27;&lt;/a&gt;&lt;/li&gt;&#x27;;
	                                    minPgr = 1;
	                                }
	                                if (i &lt; minPgr) {
	                                    pagers = null;
	                                    $slide.parent().addClass(&#x27;noPager&#x27;);
	                                } else {
	                                    $slide.parent().removeClass(&#x27;noPager&#x27;);
	                                }
	                                break;
	                            }
	                        }
	                    }
	                    var $cSouter = $slide.parent();
	                    $cSouter.find(&#x27;.lSPager&#x27;).html(pagers); 
	                    if (settings.gallery === true) {
	                        if (settings.vertical === true) {
	                            // set Gallery thumbnail width
	                            $cSouter.find(&#x27;.lSPager&#x27;).css(&#x27;width&#x27;, settings.vThumbWidth + &#x27;px&#x27;);
	                        }
	                        pagerWidth = (i * (settings.thumbMargin + thumbWidth)) + 0.5;
	                        $cSouter.find(&#x27;.lSPager&#x27;).css({
	                            property: pagerWidth + &#x27;px&#x27;,
	                            &#x27;transition-duration&#x27;: settings.speed + &#x27;ms&#x27;
	                        });
	                        if (settings.vertical === true) {
	                            $slide.parent().css(&#x27;padding-right&#x27;, (settings.vThumbWidth + settings.galleryMargin) + &#x27;px&#x27;);
	                        }
	                        $cSouter.find(&#x27;.lSPager&#x27;).css(property, pagerWidth + &#x27;px&#x27;);
	                    }
	                    var $pager = $cSouter.find(&#x27;.lSPager&#x27;).find(&#x27;li&#x27;);
	                    $pager.first().addClass(&#x27;active&#x27;);
	                    $pager.on(&#x27;click&#x27;, function () {
	                        if (settings.loop === true &amp;&amp; settings.mode === &#x27;slide&#x27;) {
	                            scene = scene + ($pager.index(this) - $cSouter.find(&#x27;.lSPager&#x27;).find(&#x27;li.active&#x27;).index());
	                        } else {
	                            scene = $pager.index(this);
	                        }
	                        $el.mode(false);
	                        if (settings.gallery === true) {
	                            $this.slideThumb();
	                        }
	                        return false;
	                    });
	                };
	                if (settings.pager) {
	                    var cl = &#x27;lSpg&#x27;;
	                    if (settings.gallery) {
	                        cl = &#x27;lSGallery&#x27;;
	                    }
	                    $slide.after(&#x27;&lt;ul class=&quot;lSPager &#x27; + cl + &#x27;&quot;&gt;&lt;/ul&gt;&#x27;);
	                    var gMargin = (settings.vertical) ? &#x27;margin-left&#x27; : &#x27;margin-top&#x27;;
	                    $slide.parent().find(&#x27;.lSPager&#x27;).css(gMargin, settings.galleryMargin + &#x27;px&#x27;);
	                    refresh.createPager();
	                }

	                setTimeout(function () {
	                    refresh.init();
	                }, 0);
	            },
	            setHeight: function (ob, fade) {
	                var obj = null,
	                    $this = this;
	                if (settings.loop) {
	                    obj = ob.children(&#x27;.lslide &#x27;).first();
	                } else {
	                    obj = ob.children().first();
	                }
	                var setCss = function () {
	                    var tH = obj.outerHeight(),
	                        tP = 0,
	                        tHT = tH;
	                    if (fade) {
	                        tH = 0;
	                        tP = ((tHT) * 100) / elSize;
	                    }
	                    ob.css({
	                        &#x27;height&#x27;: tH + &#x27;px&#x27;,
	                        &#x27;padding-bottom&#x27;: tP + &#x27;%&#x27;
	                    });
	                };
	                setCss();
	                if (obj.find(&#x27;img&#x27;).length) {
	                    if ( obj.find(&#x27;img&#x27;)[0].complete) {
	                        setCss();
	                        if (!interval) {
	                            $this.auto();
	                        }   
	                    }else{
	                        obj.find(&#x27;img&#x27;).on(&#x27;load&#x27;, function () {
	                            setTimeout(function () {
	                                setCss();
	                                if (!interval) {
	                                    $this.auto();
	                                }
	                            }, 100);
	                        });
	                    }
	                }else{
	                    if (!interval) {
	                        $this.auto();
	                    }
	                }
	            },
	            active: function (ob, t) {
	                if (this.doCss() &amp;&amp; settings.mode === &#x27;fade&#x27;) {
	                    $slide.addClass(&#x27;on&#x27;);
	                }
	                var sc = 0;
	                if (scene * settings.slideMove &lt; length) {
	                    ob.removeClass(&#x27;active&#x27;);
	                    if (!this.doCss() &amp;&amp; settings.mode === &#x27;fade&#x27; &amp;&amp; t === false) {
	                        ob.fadeOut(settings.speed);
	                    }
	                    if (t === true) {
	                        sc = scene;
	                    } else {
	                        sc = scene * settings.slideMove;
	                    }
	                    //t === true ? sc = scene : sc = scene * settings.slideMove;
	                    var l, nl;
	                    if (t === true) {
	                        l = ob.length;
	                        nl = l - 1;
	                        if (sc + 1 &gt;= l) {
	                            sc = nl;
	                        }
	                    }
	                    if (settings.loop === true &amp;&amp; settings.mode === &#x27;slide&#x27;) {
	                        //t === true ? sc = scene - $el.find(&#x27;.clone.left&#x27;).length : sc = scene * settings.slideMove;
	                        if (t === true) {
	                            sc = scene - $el.find(&#x27;.clone.left&#x27;).length;
	                        } else {
	                            sc = scene * settings.slideMove;
	                        }
	                        if (t === true) {
	                            l = ob.length;
	                            nl = l - 1;
	                            if (sc + 1 === l) {
	                                sc = nl;
	                            } else if (sc + 1 &gt; l) {
	                                sc = 0;
	                            }
	                        }
	                    }

	                    if (!this.doCss() &amp;&amp; settings.mode === &#x27;fade&#x27; &amp;&amp; t === false) {
	                        ob.eq(sc).fadeIn(settings.speed);
	                    }
	                    ob.eq(sc).addClass(&#x27;active&#x27;);
	                } else {
	                    ob.removeClass(&#x27;active&#x27;);
	                    ob.eq(ob.length - 1).addClass(&#x27;active&#x27;);
	                    if (!this.doCss() &amp;&amp; settings.mode === &#x27;fade&#x27; &amp;&amp; t === false) {
	                        ob.fadeOut(settings.speed);
	                        ob.eq(sc).fadeIn(settings.speed);
	                    }
	                }
	            },
	            move: function (ob, v) {
	                if (settings.rtl === true) {
	                    v = -v;
	                }
	                if (this.doCss()) {
	                    if (settings.vertical === true) {
	                        ob.css({
	                            &#x27;transform&#x27;: &#x27;translate3d(0px, &#x27; + (-v) + &#x27;px, 0px)&#x27;,
	                            &#x27;-webkit-transform&#x27;: &#x27;translate3d(0px, &#x27; + (-v) + &#x27;px, 0px)&#x27;
	                        });
	                    } else {
	                        ob.css({
	                            &#x27;transform&#x27;: &#x27;translate3d(&#x27; + (-v) + &#x27;px, 0px, 0px)&#x27;,
	                            &#x27;-webkit-transform&#x27;: &#x27;translate3d(&#x27; + (-v) + &#x27;px, 0px, 0px)&#x27;,
	                        });
	                    }
	                } else {
	                    if (settings.vertical === true) {
	                        ob.css(&#x27;position&#x27;, &#x27;relative&#x27;).animate({
	                            top: -v + &#x27;px&#x27;
	                        }, settings.speed, settings.easing);
	                    } else {
	                        ob.css(&#x27;position&#x27;, &#x27;relative&#x27;).animate({
	                            left: -v + &#x27;px&#x27;
	                        }, settings.speed, settings.easing);
	                    }
	                }
	                var $thumb = $slide.parent().find(&#x27;.lSPager&#x27;).find(&#x27;li&#x27;);
	                this.active($thumb, true);
	            },
	            fade: function () {
	                this.active($children, false);
	                var $thumb = $slide.parent().find(&#x27;.lSPager&#x27;).find(&#x27;li&#x27;);
	                this.active($thumb, true);
	            },
	            slide: function () {
	                var $this = this;
	                refresh.calSlide = function () {
	                    if (w &gt; elSize) {
	                        slideValue = $this.slideValue();
	                        $this.active($children, false);
	                        if ((slideValue) &gt; w - elSize - settings.slideMargin) {
	                            slideValue = w - elSize - settings.slideMargin;
	                        } else if (slideValue &lt; 0) {
	                            slideValue = 0;
	                        }
	                        $this.move($el, slideValue);
	                        if (settings.loop === true &amp;&amp; settings.mode === &#x27;slide&#x27;) {
	                            if (scene &gt;= (length - ($el.find(&#x27;.clone.left&#x27;).length / settings.slideMove))) {
	                                $this.resetSlide($el.find(&#x27;.clone.left&#x27;).length);
	                            }
	                            if (scene === 0) {
	                                $this.resetSlide($slide.find(&#x27;.lslide&#x27;).length);
	                            }
	                        }
	                    }
	                };
	                refresh.calSlide();
	            },
	            resetSlide: function (s) {
	                var $this = this;
	                $slide.find(&#x27;.lSAction a&#x27;).addClass(&#x27;disabled&#x27;);
	                setTimeout(function () {
	                    scene = s;
	                    $slide.css(&#x27;transition-duration&#x27;, &#x27;0ms&#x27;);
	                    slideValue = $this.slideValue();
	                    $this.active($children, false);
	                    plugin.move($el, slideValue);
	                    setTimeout(function () {
	                        $slide.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                        $slide.find(&#x27;.lSAction a&#x27;).removeClass(&#x27;disabled&#x27;);
	                    }, 50);
	                }, settings.speed + 100);
	            },
	            slideValue: function () {
	                var _sV = 0;
	                if (settings.autoWidth === false) {
	                    _sV = scene * ((slideWidth + settings.slideMargin) * settings.slideMove);
	                } else {
	                    _sV = 0;
	                    for (var i = 0; i &lt; scene; i++) {
	                        _sV += (parseInt($children.eq(i).width()) + settings.slideMargin);
	                    }
	                }
	                return _sV;
	            },
	            slideThumb: function () {
	                var position;
	                switch (settings.currentPagerPosition) {
	                case &#x27;left&#x27;:
	                    position = 0;
	                    break;
	                case &#x27;middle&#x27;:
	                    position = (elSize / 2) - (thumbWidth / 2);
	                    break;
	                case &#x27;right&#x27;:
	                    position = elSize - thumbWidth;
	                }
	                var sc = scene - $el.find(&#x27;.clone.left&#x27;).length;
	                var $pager = $slide.parent().find(&#x27;.lSPager&#x27;);
	                if (settings.mode === &#x27;slide&#x27; &amp;&amp; settings.loop === true) {
	                    if (sc &gt;= $pager.children().length) {
	                        sc = 0;
	                    } else if (sc &lt; 0) {
	                        sc = $pager.children().length;
	                    }
	                }
	                var thumbSlide = sc * ((thumbWidth + settings.thumbMargin)) - (position);
	                if ((thumbSlide + elSize) &gt; pagerWidth) {
	                    thumbSlide = pagerWidth - elSize - settings.thumbMargin;
	                }
	                if (thumbSlide &lt; 0) {
	                    thumbSlide = 0;
	                }
	                this.move($pager, thumbSlide);
	            },
	            auto: function () {
	                if (settings.auto) {
	                    clearInterval(interval);
	                    interval = setInterval(function () {
	                        $el.goToNextSlide();
	                    }, settings.pause);
	                }
	            },
	            pauseOnHover: function(){
	                var $this = this;
	                if (settings.auto &amp;&amp; settings.pauseOnHover) {
	                    $slide.on(&#x27;mouseenter&#x27;, function(){
	                        $(this).addClass(&#x27;ls-hover&#x27;);
	                        $el.pause();
	                        settings.auto = true;
	                    });
	                    $slide.on(&#x27;mouseleave&#x27;,function(){
	                        $(this).removeClass(&#x27;ls-hover&#x27;);
	                        if (!$slide.find(&#x27;.lightSlider&#x27;).hasClass(&#x27;lsGrabbing&#x27;)) {
	                            $this.auto();
	                        }
	                    });
	                }
	            },
	            touchMove: function (endCoords, startCoords) {
	                $slide.css(&#x27;transition-duration&#x27;, &#x27;0ms&#x27;);
	                if (settings.mode === &#x27;slide&#x27;) {
	                    var distance = endCoords - startCoords;
	                    var swipeVal = slideValue - distance;
	                    if ((swipeVal) &gt;= w - elSize - settings.slideMargin) {
	                        if (settings.freeMove === false) {
	                            swipeVal = w - elSize - settings.slideMargin;
	                        } else {
	                            var swipeValT = w - elSize - settings.slideMargin;
	                            swipeVal = swipeValT + ((swipeVal - swipeValT) / 5);

	                        }
	                    } else if (swipeVal &lt; 0) {
	                        if (settings.freeMove === false) {
	                            swipeVal = 0;
	                        } else {
	                            swipeVal = swipeVal / 5;
	                        }
	                    }
	                    this.move($el, swipeVal);
	                }
	            },

	            touchEnd: function (distance) {
	                $slide.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                if (settings.mode === &#x27;slide&#x27;) {
	                    var mxVal = false;
	                    var _next = true;
	                    slideValue = slideValue - distance;
	                    if ((slideValue) &gt; w - elSize - settings.slideMargin) {
	                        slideValue = w - elSize - settings.slideMargin;
	                        if (settings.autoWidth === false) {
	                            mxVal = true;
	                        }
	                    } else if (slideValue &lt; 0) {
	                        slideValue = 0;
	                    }
	                    var gC = function (next) {
	                        var ad = 0;
	                        if (!mxVal) {
	                            if (next) {
	                                ad = 1;
	                            }
	                        }
	                        if (!settings.autoWidth) {
	                            var num = slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove);
	                            scene = parseInt(num) + ad;
	                            if (slideValue &gt;= (w - elSize - settings.slideMargin)) {
	                                if (num % 1 !== 0) {
	                                    scene++;
	                                }
	                            }
	                        } else {
	                            var tW = 0;
	                            for (var i = 0; i &lt; $children.length; i++) {
	                                tW += (parseInt($children.eq(i).width()) + settings.slideMargin);
	                                scene = i + ad;
	                                if (tW &gt;= slideValue) {
	                                    break;
	                                }
	                            }
	                        }
	                    };
	                    if (distance &gt;= settings.swipeThreshold) {
	                        gC(false);
	                        _next = false;
	                    } else if (distance &lt;= -settings.swipeThreshold) {
	                        gC(true);
	                        _next = false;
	                    }
	                    $el.mode(_next);
	                    this.slideThumb();
	                } else {
	                    if (distance &gt;= settings.swipeThreshold) {
	                        $el.goToPrevSlide();
	                    } else if (distance &lt;= -settings.swipeThreshold) {
	                        $el.goToNextSlide();
	                    }
	                }
	            },



	            enableDrag: function () {
	                var $this = this;
	                if (!isTouch) {
	                    var startCoords = 0,
	                        endCoords = 0,
	                        isDraging = false;
	                    $slide.find(&#x27;.lightSlider&#x27;).addClass(&#x27;lsGrab&#x27;);
	                    $slide.on(&#x27;mousedown&#x27;, function (e) {
	                        if (w &lt; elSize) {
	                            if (w !== 0) {
	                                return false;
	                            }
	                        }
	                        if ($(e.target).attr(&#x27;class&#x27;) !== (&#x27;lSPrev&#x27;) &amp;&amp; $(e.target).attr(&#x27;class&#x27;) !== (&#x27;lSNext&#x27;)) {
	                            startCoords = (settings.vertical === true) ? e.pageY : e.pageX;
	                            isDraging = true;
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            } else {
	                                e.returnValue = false;
	                            }
	                            // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
	                            $slide.scrollLeft += 1;
	                            $slide.scrollLeft -= 1;
	                            // *
	                            $slide.find(&#x27;.lightSlider&#x27;).removeClass(&#x27;lsGrab&#x27;).addClass(&#x27;lsGrabbing&#x27;);
	                            clearInterval(interval);
	                        }
	                    });
	                    $(window).on(&#x27;mousemove&#x27;, function (e) {
	                        if (isDraging) {
	                            endCoords = (settings.vertical === true) ? e.pageY : e.pageX;
	                            $this.touchMove(endCoords, startCoords);
	                        }
	                    });
	                    $(window).on(&#x27;mouseup&#x27;, function (e) {
	                        if (isDraging) {
	                            $slide.find(&#x27;.lightSlider&#x27;).removeClass(&#x27;lsGrabbing&#x27;).addClass(&#x27;lsGrab&#x27;);
	                            isDraging = false;
	                            endCoords = (settings.vertical === true) ? e.pageY : e.pageX;
	                            var distance = endCoords - startCoords;
	                            if (Math.abs(distance) &gt;= settings.swipeThreshold) {
	                                $(window).on(&#x27;click.ls&#x27;, function (e) {
	                                    if (e.preventDefault) {
	                                        e.preventDefault();
	                                    } else {
	                                        e.returnValue = false;
	                                    }
	                                    e.stopImmediatePropagation();
	                                    e.stopPropagation();
	                                    $(window).off(&#x27;click.ls&#x27;);
	                                });
	                            }

	                            $this.touchEnd(distance);

	                        }
	                    });
	                }
	            },




	            enableTouch: function () {
	                var $this = this;
	                if (isTouch) {
	                    var startCoords = {},
	                        endCoords = {};
	                    $slide.on(&#x27;touchstart&#x27;, function (e) {
	                        endCoords = e.originalEvent.targetTouches[0];
	                        startCoords.pageX = e.originalEvent.targetTouches[0].pageX;
	                        startCoords.pageY = e.originalEvent.targetTouches[0].pageY;
	                        clearInterval(interval);
	                    });
	                    $slide.on(&#x27;touchmove&#x27;, function (e) {
	                        if (w &lt; elSize) {
	                            if (w !== 0) {
	                                return false;
	                            }
	                        }
	                        var orig = e.originalEvent;
	                        endCoords = orig.targetTouches[0];
	                        var xMovement = Math.abs(endCoords.pageX - startCoords.pageX);
	                        var yMovement = Math.abs(endCoords.pageY - startCoords.pageY);
	                        if (settings.vertical === true) {
	                            if ((yMovement * 3) &gt; xMovement) {
	                                e.preventDefault();
	                            }
	                            $this.touchMove(endCoords.pageY, startCoords.pageY);
	                        } else {
	                            if ((xMovement * 3) &gt; yMovement) {
	                                e.preventDefault();
	                            }
	                            $this.touchMove(endCoords.pageX, startCoords.pageX);
	                        }

	                    });
	                    $slide.on(&#x27;touchend&#x27;, function () {
	                        if (w &lt; elSize) {
	                            if (w !== 0) {
	                                return false;
	                            }
	                        }
	                        var distance;
	                        if (settings.vertical === true) {
	                            distance = endCoords.pageY - startCoords.pageY;
	                        } else {
	                            distance = endCoords.pageX - startCoords.pageX;
	                        }
	                        $this.touchEnd(distance);
	                    });
	                }
	            },
	            build: function () {
	                var $this = this;
	                $this.initialStyle();
	                if (this.doCss()) {

	                    if (settings.enableTouch === true) {
	                        $this.enableTouch();
	                    }
	                    if (settings.enableDrag === true) {
	                        $this.enableDrag();
	                    }
	                }

	                $(window).on(&#x27;focus&#x27;, function(){
	                    $this.auto();
	                });
	                
	                $(window).on(&#x27;blur&#x27;, function(){
	                    clearInterval(interval);
	                });

	                $this.pager();
	                $this.pauseOnHover();
	                $this.controls();
	                $this.keyPress();
	            }
	        };
	        plugin.build();
	        refresh.init = function () {
	            refresh.chbreakpoint();
	            if (settings.vertical === true) {
	                if (settings.item &gt; 1) {
	                    elSize = settings.verticalHeight;
	                } else {
	                    elSize = $children.outerHeight();
	                }
	                $slide.css(&#x27;height&#x27;, elSize + &#x27;px&#x27;);
	            } else {
	                elSize = $slide.outerWidth();
	            }
	            if (settings.loop === true &amp;&amp; settings.mode === &#x27;slide&#x27;) {
	                refresh.clone();
	            }
	            refresh.calL();
	            if (settings.mode === &#x27;slide&#x27;) {
	                $el.removeClass(&#x27;lSSlide&#x27;);
	            }
	            if (settings.mode === &#x27;slide&#x27;) {
	                refresh.calSW();
	                refresh.sSW();
	            }
	            setTimeout(function () {
	                if (settings.mode === &#x27;slide&#x27;) {
	                    $el.addClass(&#x27;lSSlide&#x27;);
	                }
	            }, 1000);
	            if (settings.pager) {
	                refresh.createPager();
	            }
	            if (settings.adaptiveHeight === true &amp;&amp; settings.vertical === false) {
	                $el.css(&#x27;height&#x27;, $children.eq(scene).outerHeight(true));
	            }
	            if (settings.adaptiveHeight === false) {
	                if (settings.mode === &#x27;slide&#x27;) {
	                    if (settings.vertical === false) {
	                        plugin.setHeight($el, false);
	                    }else{
	                        plugin.auto();
	                    }
	                } else {
	                    plugin.setHeight($el, true);
	                }
	            }
	            if (settings.gallery === true) {
	                plugin.slideThumb();
	            }
	            if (settings.mode === &#x27;slide&#x27;) {
	                plugin.slide();
	            }
	            if (settings.autoWidth === false) {
	                if ($children.length &lt;= settings.item) {
	                    $slide.find(&#x27;.lSAction&#x27;).hide();
	                } else {
	                    $slide.find(&#x27;.lSAction&#x27;).show();
	                }
	            } else {
	                if ((refresh.calWidth(false) &lt; elSize) &amp;&amp; (w !== 0)) {
	                    $slide.find(&#x27;.lSAction&#x27;).hide();
	                } else {
	                    $slide.find(&#x27;.lSAction&#x27;).show();
	                }
	            }
	        };
	        $el.goToPrevSlide = function () {
	            if (scene &gt; 0) {
	                settings.onBeforePrevSlide.call(this, $el, scene);
	                scene--;
	                $el.mode(false);
	                if (settings.gallery === true) {
	                    plugin.slideThumb();
	                }
	            } else {
	                if (settings.loop === true) {
	                    settings.onBeforePrevSlide.call(this, $el, scene);
	                    if (settings.mode === &#x27;fade&#x27;) {
	                        var l = (length - 1);
	                        scene = parseInt(l / settings.slideMove);
	                    }
	                    $el.mode(false);
	                    if (settings.gallery === true) {
	                        plugin.slideThumb();
	                    }
	                } else if (settings.slideEndAnimation === true) {
	                    $el.addClass(&#x27;leftEnd&#x27;);
	                    setTimeout(function () {
	                        $el.removeClass(&#x27;leftEnd&#x27;);
	                    }, 400);
	                }
	            }
	        };
	        $el.goToNextSlide = function () {
	            var nextI = true;
	            if (settings.mode === &#x27;slide&#x27;) {
	                var _slideValue = plugin.slideValue();
	                nextI = _slideValue &lt; w - elSize - settings.slideMargin;
	            }
	            if (((scene * settings.slideMove) &lt; length - settings.slideMove) &amp;&amp; nextI) {
	                settings.onBeforeNextSlide.call(this, $el, scene);
	                scene++;
	                $el.mode(false);
	                if (settings.gallery === true) {
	                    plugin.slideThumb();
	                }
	            } else {
	                if (settings.loop === true) {
	                    settings.onBeforeNextSlide.call(this, $el, scene);
	                    scene = 0;
	                    $el.mode(false);
	                    if (settings.gallery === true) {
	                        plugin.slideThumb();
	                    }
	                } else if (settings.slideEndAnimation === true) {
	                    $el.addClass(&#x27;rightEnd&#x27;);
	                    setTimeout(function () {
	                        $el.removeClass(&#x27;rightEnd&#x27;);
	                    }, 400);
	                }
	            }
	        };
	        $el.mode = function (_touch) {
	            if (settings.adaptiveHeight === true &amp;&amp; settings.vertical === false) {
	                $el.css(&#x27;height&#x27;, $children.eq(scene).outerHeight(true));
	            }
	            if (on === false) {
	                if (settings.mode === &#x27;slide&#x27;) {
	                    if (plugin.doCss()) {
	                        $el.addClass(&#x27;lSSlide&#x27;);
	                        if (settings.speed !== &#x27;&#x27;) {
	                            $slide.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                        }
	                        if (settings.cssEasing !== &#x27;&#x27;) {
	                            $slide.css(&#x27;transition-timing-function&#x27;, settings.cssEasing);
	                        }
	                    }
	                } else {
	                    if (plugin.doCss()) {
	                        if (settings.speed !== &#x27;&#x27;) {
	                            $el.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                        }
	                        if (settings.cssEasing !== &#x27;&#x27;) {
	                            $el.css(&#x27;transition-timing-function&#x27;, settings.cssEasing);
	                        }
	                    }
	                }
	            }
	            if (!_touch) {
	                settings.onBeforeSlide.call(this, $el, scene);
	            }
	            if (settings.mode === &#x27;slide&#x27;) {
	                plugin.slide();
	            } else {
	                plugin.fade();
	            }
	            if (!$slide.hasClass(&#x27;ls-hover&#x27;)) {
	                plugin.auto();
	            }
	            setTimeout(function () {
	                if (!_touch) {
	                    settings.onAfterSlide.call(this, $el, scene);
	                }
	            }, settings.speed);
	            on = true;
	        };
	        $el.play = function () {
	            $el.goToNextSlide();
	            settings.auto = true;
	            plugin.auto();
	        };
	        $el.pause = function () {
	            settings.auto = false;
	            clearInterval(interval);
	        };
	        $el.refresh = function () {
	            refresh.init();
	        };
	        $el.getCurrentSlideCount = function () {
	            var sc = scene;
	            if (settings.loop) {
	                var ln = $slide.find(&#x27;.lslide&#x27;).length,
	                    cl = $el.find(&#x27;.clone.left&#x27;).length;
	                if (scene &lt;= cl - 1) {
	                    sc = ln + (scene - cl);
	                } else if (scene &gt;= (ln + cl)) {
	                    sc = scene - ln - cl;
	                } else {
	                    sc = scene - cl;
	                }
	            }
	            return sc + 1;
	        }; 
	        $el.getTotalSlideCount = function () {
	            return $slide.find(&#x27;.lslide&#x27;).length;
	        };
	        $el.goToSlide = function (s) {
	            if (settings.loop) {
	                scene = (s + $el.find(&#x27;.clone.left&#x27;).length - 1);
	            } else {
	                scene = s;
	            }
	            $el.mode(false);
	            if (settings.gallery === true) {
	                plugin.slideThumb();
	            }
	        };
	        $el.destroy = function () {
	            if ($el.lightSlider) {
	                $el.goToPrevSlide = function(){};
	                $el.goToNextSlide = function(){};
	                $el.mode = function(){};
	                $el.play = function(){};
	                $el.pause = function(){};
	                $el.refresh = function(){};
	                $el.getCurrentSlideCount = function(){};
	                $el.getTotalSlideCount = function(){};
	                $el.goToSlide = function(){}; 
	                $el.lightSlider = null;
	                refresh = {
	                    init : function(){}
	                };
	                $el.parent().parent().find(&#x27;.lSAction, .lSPager&#x27;).remove();
	                $el.removeClass(&#x27;lightSlider lSFade lSSlide lsGrab lsGrabbing leftEnd right&#x27;).removeAttr(&#x27;style&#x27;).unwrap().unwrap();
	                $el.children().removeAttr(&#x27;style&#x27;);
	                $children.removeClass(&#x27;lslide active&#x27;);
	                $el.find(&#x27;.clone&#x27;).remove();
	                $children = null;
	                interval = null;
	                on = false;
	                scene = 0;
	            }

	        };
	        setTimeout(function () {
	            settings.onSliderLoad.call(this, $el);
	        }, 10);
	        $(window).on(&#x27;resize orientationchange&#x27;, function (e) {
	            setTimeout(function () {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                } else {
	                    e.returnValue = false;
	                }
	                refresh.init();
	            }, 200);
	        });
	        return this;
	    };
	}(jQuery));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(19);
	__webpack_require__(26);

	jQuery(function ($) {
	    &quot;use strict&quot;;

	    initMasonary();


	});


	var initfilter = function ($masonryContainer, $ele) {
	    var $filterElement = $(&#x27;.project-filter li, .filter li&#x27;);
	    $filterElement.removeClass(&quot;active&quot;);
	    $ele.addClass(&quot;active&quot;);

	    if ($(&#x27;.masonry-container .animated&#x27;).length &gt; 0) {
	        $(&#x27;.masonry-container .animated&#x27;).addClass(&quot;go&quot;);
	    }

	    var selector = $ele.attr(&#x27;data-filter&#x27;);
	    $masonryContainer.isotope({
	        filter: selector,
	        animationOptions: {
	            duration: 750,
	            easing: &#x27;linear&#x27;,
	            queue: false
	        }
	    });
	    return false;

	};
	function initMasonary() {

	    var $masonryContainer = $(&#x27;.masonry-container&#x27;);
	    var $filterElement = $(&#x27;.project-filter li, .filter li&#x27;);

	    if ($(&#x27;#filter-items&#x27;).length) {
	        $(&#x27;.filter li&#x27;).on(&#x27;click&#x27;, function () {
	            console.log(&#x27;scroll now&#x27;);
	            $(&#x27;html, body&#x27;).animate({
	                scrollTop: $(&#x27;#filter-items&#x27;).offset().top - 0
	            }, 1500, function () {
	            });
	            return false;
	        });
	    }


	    $masonryContainer.waitForImages(function () {
	        $(&#x27;.masonry-container&#x27;).show();
	        $(&#x27;.masonry-container&#x27;).masonry({
	            itemSelector: &#x27;.masonry-post&#x27;
	        });

	    });

	    $(window).on(&#x27;load&#x27;, function () {
	        var $ele = $(&#x27;.project-filter .active&#x27;);
	        initfilter($masonryContainer, $ele);
	    });


	    $filterElement.click(function () {
	        $filterElement.removeClass(&quot;active&quot;);
	        var $ele = $(this).addClass(&quot;active&quot;);

	        initfilter($masonryContainer, $ele, $filterElement);
	    });
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Masonry v4.2.1
	 * Cascading grid layout library
	 * https://masonry.desandro.com
	 * MIT License
	 * by David DeSandro
	 */

	( function( window, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /*globals define, module, require */
	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(20),
	        __webpack_require__(22)
	      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports = factory(
	      require(&#x27;outlayer&#x27;),
	      require(&#x27;get-size&#x27;)
	    );
	  } else {
	    // browser global
	    window.Masonry = factory(
	      window.Outlayer,
	      window.getSize
	    );
	  }

	}( window, function factory( Outlayer, getSize ) {

	&#x27;use strict&#x27;;

	// -------------------------- masonryDefinition -------------------------- //

	  // create an Outlayer layout class
	  var Masonry = Outlayer.create(&#x27;masonry&#x27;);
	  // isFitWidth -&gt; fitWidth
	  Masonry.compatOptions.fitWidth = &#x27;isFitWidth&#x27;;

	  var proto = Masonry.prototype;

	  proto._resetLayout = function() {
	    this.getSize();
	    this._getMeasurement( &#x27;columnWidth&#x27;, &#x27;outerWidth&#x27; );
	    this._getMeasurement( &#x27;gutter&#x27;, &#x27;outerWidth&#x27; );
	    this.measureColumns();

	    // reset column Y
	    this.colYs = [];
	    for ( var i=0; i &lt; this.cols; i++ ) {
	      this.colYs.push( 0 );
	    }

	    this.maxY = 0;
	    this.horizontalColIndex = 0;
	  };

	  proto.measureColumns = function() {
	    this.getContainerWidth();
	    // if columnWidth is 0, default to outerWidth of first item
	    if ( !this.columnWidth ) {
	      var firstItem = this.items[0];
	      var firstItemElem = firstItem &amp;&amp; firstItem.element;
	      // columnWidth fall back to item of first element
	      this.columnWidth = firstItemElem &amp;&amp; getSize( firstItemElem ).outerWidth ||
	        // if first elem has no width, default to size of container
	        this.containerWidth;
	    }

	    var columnWidth = this.columnWidth += this.gutter;

	    // calculate columns
	    var containerWidth = this.containerWidth + this.gutter;
	    var cols = containerWidth / columnWidth;
	    // fix rounding errors, typically with gutters
	    var excess = columnWidth - containerWidth % columnWidth;
	    // if overshoot is less than a pixel, round up, otherwise floor it
	    var mathMethod = excess &amp;&amp; excess &lt; 1 ? &#x27;round&#x27; : &#x27;floor&#x27;;
	    cols = Math[ mathMethod ]( cols );
	    this.cols = Math.max( cols, 1 );
	  };

	  proto.getContainerWidth = function() {
	    // container is parent if fit width
	    var isFitWidth = this._getOption(&#x27;fitWidth&#x27;);
	    var container = isFitWidth ? this.element.parentNode : this.element;
	    // check that this.size and size are there
	    // IE8 triggers resize on body size change, so they might not be
	    var size = getSize( container );
	    this.containerWidth = size &amp;&amp; size.innerWidth;
	  };

	  proto._getItemLayoutPosition = function( item ) {
	    item.getSize();
	    // how many columns does this brick span
	    var remainder = item.size.outerWidth % this.columnWidth;
	    var mathMethod = remainder &amp;&amp; remainder &lt; 1 ? &#x27;round&#x27; : &#x27;ceil&#x27;;
	    // round if off by 1 pixel, otherwise use ceil
	    var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );
	    colSpan = Math.min( colSpan, this.cols );
	    // use horizontal or top column position
	    var colPosMethod = this.options.horizontalOrder ?
	      &#x27;_getHorizontalColPosition&#x27; : &#x27;_getTopColPosition&#x27;;
	    var colPosition = this[ colPosMethod ]( colSpan, item );
	    // position the brick
	    var position = {
	      x: this.columnWidth * colPosition.col,
	      y: colPosition.y
	    };
	    // apply setHeight to necessary columns
	    var setHeight = colPosition.y + item.size.outerHeight;
	    var setMax = colSpan + colPosition.col;
	    for ( var i = colPosition.col; i &lt; setMax; i++ ) {
	      this.colYs[i] = setHeight;
	    }

	    return position;
	  };

	  proto._getTopColPosition = function( colSpan ) {
	    var colGroup = this._getTopColGroup( colSpan );
	    // get the minimum Y value from the columns
	    var minimumY = Math.min.apply( Math, colGroup );

	    return {
	      col: colGroup.indexOf( minimumY ),
	      y: minimumY,
	    };
	  };

	  /**
	   * @param {Number} colSpan - number of columns the element spans
	   * @returns {Array} colGroup
	   */
	  proto._getTopColGroup = function( colSpan ) {
	    if ( colSpan &lt; 2 ) {
	      // if brick spans only one column, use all the column Ys
	      return this.colYs;
	    }

	    var colGroup = [];
	    // how many different places could this brick fit horizontally
	    var groupCount = this.cols + 1 - colSpan;
	    // for each group potential horizontal position
	    for ( var i = 0; i &lt; groupCount; i++ ) {
	      colGroup[i] = this._getColGroupY( i, colSpan );
	    }
	    return colGroup;
	  };

	  proto._getColGroupY = function( col, colSpan ) {
	    if ( colSpan &lt; 2 ) {
	      return this.colYs[ col ];
	    }
	    // make an array of colY values for that one group
	    var groupColYs = this.colYs.slice( col, col + colSpan );
	    // and get the max value of the array
	    return Math.max.apply( Math, groupColYs );
	  };

	  // get column position based on horizontal index. #873
	  proto._getHorizontalColPosition = function( colSpan, item ) {
	    var col = this.horizontalColIndex % this.cols;
	    var isOver = colSpan &gt; 1 &amp;&amp; col + colSpan &gt; this.cols;
	    // shift to next row if item can&#x27;t fit on current row
	    col = isOver ? 0 : col;
	    // don&#x27;t let zero-size items take up space
	    var hasSize = item.size.outerWidth &amp;&amp; item.size.outerHeight;
	    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;

	    return {
	      col: col,
	      y: this._getColGroupY( col, colSpan ),
	    };
	  };

	  proto._manageStamp = function( stamp ) {
	    var stampSize = getSize( stamp );
	    var offset = this._getElementOffset( stamp );
	    // get the columns that this stamp affects
	    var isOriginLeft = this._getOption(&#x27;originLeft&#x27;);
	    var firstX = isOriginLeft ? offset.left : offset.right;
	    var lastX = firstX + stampSize.outerWidth;
	    var firstCol = Math.floor( firstX / this.columnWidth );
	    firstCol = Math.max( 0, firstCol );
	    var lastCol = Math.floor( lastX / this.columnWidth );
	    // lastCol should not go over if multiple of columnWidth #425
	    lastCol -= lastX % this.columnWidth ? 0 : 1;
	    lastCol = Math.min( this.cols - 1, lastCol );
	    // set colYs to bottom of the stamp

	    var isOriginTop = this._getOption(&#x27;originTop&#x27;);
	    var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +
	      stampSize.outerHeight;
	    for ( var i = firstCol; i &lt;= lastCol; i++ ) {
	      this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );
	    }
	  };

	  proto._getContainerSize = function() {
	    this.maxY = Math.max.apply( Math, this.colYs );
	    var size = {
	      height: this.maxY
	    };

	    if ( this._getOption(&#x27;fitWidth&#x27;) ) {
	      size.width = this._getContainerFitWidth();
	    }

	    return size;
	  };

	  proto._getContainerFitWidth = function() {
	    var unusedCols = 0;
	    // count unused columns
	    var i = this.cols;
	    while ( --i ) {
	      if ( this.colYs[i] !== 0 ) {
	        break;
	      }
	      unusedCols++;
	    }
	    // fit container to columns that have been used
	    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;
	  };

	  proto.needsResizeLayout = function() {
	    var previousWidth = this.containerWidth;
	    this.getContainerWidth();
	    return previousWidth != this.containerWidth;
	  };

	  return Masonry;

	}));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Outlayer v2.1.1
	 * the brains and guts of a layout library
	 * MIT license
	 */

	( function( window, factory ) {
	  &#x27;use strict&#x27;;
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, require */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(21),
	        __webpack_require__(22),
	        __webpack_require__(23),
	        __webpack_require__(25)
	      ], __WEBPACK_AMD_DEFINE_RESULT__ = function( EvEmitter, getSize, utils, Item ) {
	        return factory( window, EvEmitter, getSize, utils, Item);
	      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports = factory(
	      window,
	      require(&#x27;ev-emitter&#x27;),
	      require(&#x27;get-size&#x27;),
	      require(&#x27;fizzy-ui-utils&#x27;),
	      require(&#x27;./item&#x27;)
	    );
	  } else {
	    // browser global
	    window.Outlayer = factory(
	      window,
	      window.EvEmitter,
	      window.getSize,
	      window.fizzyUIUtils,
	      window.Outlayer.Item
	    );
	  }

	}( window, function factory( window, EvEmitter, getSize, utils, Item ) {
	&#x27;use strict&#x27;;

	// ----- vars ----- //

	var console = window.console;
	var jQuery = window.jQuery;
	var noop = function() {};

	// -------------------------- Outlayer -------------------------- //

	// globally unique identifiers
	var GUID = 0;
	// internal store of all Outlayer intances
	var instances = {};


	/**
	 * @param {Element, String} element
	 * @param {Object} options
	 * @constructor
	 */
	function Outlayer( element, options ) {
	  var queryElement = utils.getQueryElement( element );
	  if ( !queryElement ) {
	    if ( console ) {
	      console.error( &#x27;Bad element for &#x27; + this.constructor.namespace +
	        &#x27;: &#x27; + ( queryElement || element ) );
	    }
	    return;
	  }
	  this.element = queryElement;
	  // add jQuery
	  if ( jQuery ) {
	    this.$element = jQuery( this.element );
	  }

	  // options
	  this.options = utils.extend( {}, this.constructor.defaults );
	  this.option( options );

	  // add id for Outlayer.getFromElement
	  var id = ++GUID;
	  this.element.outlayerGUID = id; // expando
	  instances[ id ] = this; // associate via id

	  // kick it off
	  this._create();

	  var isInitLayout = this._getOption(&#x27;initLayout&#x27;);
	  if ( isInitLayout ) {
	    this.layout();
	  }
	}

	// settings are for internal use only
	Outlayer.namespace = &#x27;outlayer&#x27;;
	Outlayer.Item = Item;

	// default options
	Outlayer.defaults = {
	  containerStyle: {
	    position: &#x27;relative&#x27;
	  },
	  initLayout: true,
	  originLeft: true,
	  originTop: true,
	  resize: true,
	  resizeContainer: true,
	  // item options
	  transitionDuration: &#x27;0.4s&#x27;,
	  hiddenStyle: {
	    opacity: 0,
	    transform: &#x27;scale(0.001)&#x27;
	  },
	  visibleStyle: {
	    opacity: 1,
	    transform: &#x27;scale(1)&#x27;
	  }
	};

	var proto = Outlayer.prototype;
	// inherit EvEmitter
	utils.extend( proto, EvEmitter.prototype );

	/**
	 * set options
	 * @param {Object} opts
	 */
	proto.option = function( opts ) {
	  utils.extend( this.options, opts );
	};

	/**
	 * get backwards compatible option value, check old name
	 */
	proto._getOption = function( option ) {
	  var oldOption = this.constructor.compatOptions[ option ];
	  return oldOption &amp;&amp; this.options[ oldOption ] !== undefined ?
	    this.options[ oldOption ] : this.options[ option ];
	};

	Outlayer.compatOptions = {
	  // currentName: oldName
	  initLayout: &#x27;isInitLayout&#x27;,
	  horizontal: &#x27;isHorizontal&#x27;,
	  layoutInstant: &#x27;isLayoutInstant&#x27;,
	  originLeft: &#x27;isOriginLeft&#x27;,
	  originTop: &#x27;isOriginTop&#x27;,
	  resize: &#x27;isResizeBound&#x27;,
	  resizeContainer: &#x27;isResizingContainer&#x27;
	};

	proto._create = function() {
	  // get items from children
	  this.reloadItems();
	  // elements that affect layout, but are not laid out
	  this.stamps = [];
	  this.stamp( this.options.stamp );
	  // set container style
	  utils.extend( this.element.style, this.options.containerStyle );

	  // bind resize method
	  var canBindResize = this._getOption(&#x27;resize&#x27;);
	  if ( canBindResize ) {
	    this.bindResize();
	  }
	};

	// goes through all children again and gets bricks in proper order
	proto.reloadItems = function() {
	  // collection of item elements
	  this.items = this._itemize( this.element.children );
	};


	/**
	 * turn elements into Outlayer.Items to be used in layout
	 * @param {Array or NodeList or HTMLElement} elems
	 * @returns {Array} items - collection of new Outlayer Items
	 */
	proto._itemize = function( elems ) {

	  var itemElems = this._filterFindItemElements( elems );
	  var Item = this.constructor.Item;

	  // create new Outlayer Items for collection
	  var items = [];
	  for ( var i=0; i &lt; itemElems.length; i++ ) {
	    var elem = itemElems[i];
	    var item = new Item( elem, this );
	    items.push( item );
	  }

	  return items;
	};

	/**
	 * get item elements to be used in layout
	 * @param {Array or NodeList or HTMLElement} elems
	 * @returns {Array} items - item elements
	 */
	proto._filterFindItemElements = function( elems ) {
	  return utils.filterFindElements( elems, this.options.itemSelector );
	};

	/**
	 * getter method for getting item elements
	 * @returns {Array} elems - collection of item elements
	 */
	proto.getItemElements = function() {
	  return this.items.map( function( item ) {
	    return item.element;
	  });
	};

	// ----- init &amp; layout ----- //

	/**
	 * lays out all items
	 */
	proto.layout = function() {
	  this._resetLayout();
	  this._manageStamps();

	  // don&#x27;t animate first layout
	  var layoutInstant = this._getOption(&#x27;layoutInstant&#x27;);
	  var isInstant = layoutInstant !== undefined ?
	    layoutInstant : !this._isLayoutInited;
	  this.layoutItems( this.items, isInstant );

	  // flag for initalized
	  this._isLayoutInited = true;
	};

	// _init is alias for layout
	proto._init = proto.layout;

	/**
	 * logic before any new layout
	 */
	proto._resetLayout = function() {
	  this.getSize();
	};


	proto.getSize = function() {
	  this.size = getSize( this.element );
	};

	/**
	 * get measurement from option, for columnWidth, rowHeight, gutter
	 * if option is String -&gt; get element from selector string, &amp; get size of element
	 * if option is Element -&gt; get size of element
	 * else use option as a number
	 *
	 * @param {String} measurement
	 * @param {String} size - width or height
	 * @private
	 */
	proto._getMeasurement = function( measurement, size ) {
	  var option = this.options[ measurement ];
	  var elem;
	  if ( !option ) {
	    // default to 0
	    this[ measurement ] = 0;
	  } else {
	    // use option as an element
	    if ( typeof option == &#x27;string&#x27; ) {
	      elem = this.element.querySelector( option );
	    } else if ( option instanceof HTMLElement ) {
	      elem = option;
	    }
	    // use size of element, if element
	    this[ measurement ] = elem ? getSize( elem )[ size ] : option;
	  }
	};

	/**
	 * layout a collection of item elements
	 * @api public
	 */
	proto.layoutItems = function( items, isInstant ) {
	  items = this._getItemsForLayout( items );

	  this._layoutItems( items, isInstant );

	  this._postLayout();
	};

	/**
	 * get the items to be laid out
	 * you may want to skip over some items
	 * @param {Array} items
	 * @returns {Array} items
	 */
	proto._getItemsForLayout = function( items ) {
	  return items.filter( function( item ) {
	    return !item.isIgnored;
	  });
	};

	/**
	 * layout items
	 * @param {Array} items
	 * @param {Boolean} isInstant
	 */
	proto._layoutItems = function( items, isInstant ) {
	  this._emitCompleteOnItems( &#x27;layout&#x27;, items );

	  if ( !items || !items.length ) {
	    // no items, emit event with empty array
	    return;
	  }

	  var queue = [];

	  items.forEach( function( item ) {
	    // get x/y object from method
	    var position = this._getItemLayoutPosition( item );
	    // enqueue
	    position.item = item;
	    position.isInstant = isInstant || item.isLayoutInstant;
	    queue.push( position );
	  }, this );

	  this._processLayoutQueue( queue );
	};

	/**
	 * get item layout position
	 * @param {Outlayer.Item} item
	 * @returns {Object} x and y position
	 */
	proto._getItemLayoutPosition = function( /* item */ ) {
	  return {
	    x: 0,
	    y: 0
	  };
	};

	/**
	 * iterate over array and position each item
	 * Reason being - separating this logic prevents &#x27;layout invalidation&#x27;
	 * thx @paul_irish
	 * @param {Array} queue
	 */
	proto._processLayoutQueue = function( queue ) {
	  this.updateStagger();
	  queue.forEach( function( obj, i ) {
	    this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );
	  }, this );
	};

	// set stagger from option in milliseconds number
	proto.updateStagger = function() {
	  var stagger = this.options.stagger;
	  if ( stagger === null || stagger === undefined ) {
	    this.stagger = 0;
	    return;
	  }
	  this.stagger = getMilliseconds( stagger );
	  return this.stagger;
	};

	/**
	 * Sets position of item in DOM
	 * @param {Outlayer.Item} item
	 * @param {Number} x - horizontal position
	 * @param {Number} y - vertical position
	 * @param {Boolean} isInstant - disables transitions
	 */
	proto._positionItem = function( item, x, y, isInstant, i ) {
	  if ( isInstant ) {
	    // if not transition, just set CSS
	    item.goTo( x, y );
	  } else {
	    item.stagger( i * this.stagger );
	    item.moveTo( x, y );
	  }
	};

	/**
	 * Any logic you want to do after each layout,
	 * i.e. size the container
	 */
	proto._postLayout = function() {
	  this.resizeContainer();
	};

	proto.resizeContainer = function() {
	  var isResizingContainer = this._getOption(&#x27;resizeContainer&#x27;);
	  if ( !isResizingContainer ) {
	    return;
	  }
	  var size = this._getContainerSize();
	  if ( size ) {
	    this._setContainerMeasure( size.width, true );
	    this._setContainerMeasure( size.height, false );
	  }
	};

	/**
	 * Sets width or height of container if returned
	 * @returns {Object} size
	 *   @param {Number} width
	 *   @param {Number} height
	 */
	proto._getContainerSize = noop;

	/**
	 * @param {Number} measure - size of width or height
	 * @param {Boolean} isWidth
	 */
	proto._setContainerMeasure = function( measure, isWidth ) {
	  if ( measure === undefined ) {
	    return;
	  }

	  var elemSize = this.size;
	  // add padding and border width if border box
	  if ( elemSize.isBorderBox ) {
	    measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
	      elemSize.borderLeftWidth + elemSize.borderRightWidth :
	      elemSize.paddingBottom + elemSize.paddingTop +
	      elemSize.borderTopWidth + elemSize.borderBottomWidth;
	  }

	  measure = Math.max( measure, 0 );
	  this.element.style[ isWidth ? &#x27;width&#x27; : &#x27;height&#x27; ] = measure + &#x27;px&#x27;;
	};

	/**
	 * emit eventComplete on a collection of items events
	 * @param {String} eventName
	 * @param {Array} items - Outlayer.Items
	 */
	proto._emitCompleteOnItems = function( eventName, items ) {
	  var _this = this;
	  function onComplete() {
	    _this.dispatchEvent( eventName + &#x27;Complete&#x27;, null, [ items ] );
	  }

	  var count = items.length;
	  if ( !items || !count ) {
	    onComplete();
	    return;
	  }

	  var doneCount = 0;
	  function tick() {
	    doneCount++;
	    if ( doneCount == count ) {
	      onComplete();
	    }
	  }

	  // bind callback
	  items.forEach( function( item ) {
	    item.once( eventName, tick );
	  });
	};

	/**
	 * emits events via EvEmitter and jQuery events
	 * @param {String} type - name of event
	 * @param {Event} event - original event
	 * @param {Array} args - extra arguments
	 */
	proto.dispatchEvent = function( type, event, args ) {
	  // add original event to arguments
	  var emitArgs = event ? [ event ].concat( args ) : args;
	  this.emitEvent( type, emitArgs );

	  if ( jQuery ) {
	    // set this.$element
	    this.$element = this.$element || jQuery( this.element );
	    if ( event ) {
	      // create jQuery event
	      var $event = jQuery.Event( event );
	      $event.type = type;
	      this.$element.trigger( $event, args );
	    } else {
	      // just trigger with type if no event available
	      this.$element.trigger( type, args );
	    }
	  }
	};

	// -------------------------- ignore &amp; stamps -------------------------- //


	/**
	 * keep item in collection, but do not lay it out
	 * ignored items do not get skipped in layout
	 * @param {Element} elem
	 */
	proto.ignore = function( elem ) {
	  var item = this.getItem( elem );
	  if ( item ) {
	    item.isIgnored = true;
	  }
	};

	/**
	 * return item to layout collection
	 * @param {Element} elem
	 */
	proto.unignore = function( elem ) {
	  var item = this.getItem( elem );
	  if ( item ) {
	    delete item.isIgnored;
	  }
	};

	/**
	 * adds elements to stamps
	 * @param {NodeList, Array, Element, or String} elems
	 */
	proto.stamp = function( elems ) {
	  elems = this._find( elems );
	  if ( !elems ) {
	    return;
	  }

	  this.stamps = this.stamps.concat( elems );
	  // ignore
	  elems.forEach( this.ignore, this );
	};

	/**
	 * removes elements to stamps
	 * @param {NodeList, Array, or Element} elems
	 */
	proto.unstamp = function( elems ) {
	  elems = this._find( elems );
	  if ( !elems ){
	    return;
	  }

	  elems.forEach( function( elem ) {
	    // filter out removed stamp elements
	    utils.removeFrom( this.stamps, elem );
	    this.unignore( elem );
	  }, this );
	};

	/**
	 * finds child elements
	 * @param {NodeList, Array, Element, or String} elems
	 * @returns {Array} elems
	 */
	proto._find = function( elems ) {
	  if ( !elems ) {
	    return;
	  }
	  // if string, use argument as selector string
	  if ( typeof elems == &#x27;string&#x27; ) {
	    elems = this.element.querySelectorAll( elems );
	  }
	  elems = utils.makeArray( elems );
	  return elems;
	};

	proto._manageStamps = function() {
	  if ( !this.stamps || !this.stamps.length ) {
	    return;
	  }

	  this._getBoundingRect();

	  this.stamps.forEach( this._manageStamp, this );
	};

	// update boundingLeft / Top
	proto._getBoundingRect = function() {
	  // get bounding rect for container element
	  var boundingRect = this.element.getBoundingClientRect();
	  var size = this.size;
	  this._boundingRect = {
	    left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
	    top: boundingRect.top + size.paddingTop + size.borderTopWidth,
	    right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
	    bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
	  };
	};

	/**
	 * @param {Element} stamp
	**/
	proto._manageStamp = noop;

	/**
	 * get x/y position of element relative to container element
	 * @param {Element} elem
	 * @returns {Object} offset - has left, top, right, bottom
	 */
	proto._getElementOffset = function( elem ) {
	  var boundingRect = elem.getBoundingClientRect();
	  var thisRect = this._boundingRect;
	  var size = getSize( elem );
	  var offset = {
	    left: boundingRect.left - thisRect.left - size.marginLeft,
	    top: boundingRect.top - thisRect.top - size.marginTop,
	    right: thisRect.right - boundingRect.right - size.marginRight,
	    bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
	  };
	  return offset;
	};

	// -------------------------- resize -------------------------- //

	// enable event handlers for listeners
	// i.e. resize -&gt; onresize
	proto.handleEvent = utils.handleEvent;

	/**
	 * Bind layout to window resizing
	 */
	proto.bindResize = function() {
	  window.addEventListener( &#x27;resize&#x27;, this );
	  this.isResizeBound = true;
	};

	/**
	 * Unbind layout to window resizing
	 */
	proto.unbindResize = function() {
	  window.removeEventListener( &#x27;resize&#x27;, this );
	  this.isResizeBound = false;
	};

	proto.onresize = function() {
	  this.resize();
	};

	utils.debounceMethod( Outlayer, &#x27;onresize&#x27;, 100 );

	proto.resize = function() {
	  // don&#x27;t trigger if size did not change
	  // or if resize was unbound. See #9
	  if ( !this.isResizeBound || !this.needsResizeLayout() ) {
	    return;
	  }

	  this.layout();
	};

	/**
	 * check if layout is needed post layout
	 * @returns Boolean
	 */
	proto.needsResizeLayout = function() {
	  var size = getSize( this.element );
	  // check that this.size and size are there
	  // IE8 triggers resize on body size change, so they might not be
	  var hasSizes = this.size &amp;&amp; size;
	  return hasSizes &amp;&amp; size.innerWidth !== this.size.innerWidth;
	};

	// -------------------------- methods -------------------------- //

	/**
	 * add items to Outlayer instance
	 * @param {Array or NodeList or Element} elems
	 * @returns {Array} items - Outlayer.Items
	**/
	proto.addItems = function( elems ) {
	  var items = this._itemize( elems );
	  // add items to collection
	  if ( items.length ) {
	    this.items = this.items.concat( items );
	  }
	  return items;
	};

	/**
	 * Layout newly-appended item elements
	 * @param {Array or NodeList or Element} elems
	 */
	proto.appended = function( elems ) {
	  var items = this.addItems( elems );
	  if ( !items.length ) {
	    return;
	  }
	  // layout and reveal just the new items
	  this.layoutItems( items, true );
	  this.reveal( items );
	};

	/**
	 * Layout prepended elements
	 * @param {Array or NodeList or Element} elems
	 */
	proto.prepended = function( elems ) {
	  var items = this._itemize( elems );
	  if ( !items.length ) {
	    return;
	  }
	  // add items to beginning of collection
	  var previousItems = this.items.slice(0);
	  this.items = items.concat( previousItems );
	  // start new layout
	  this._resetLayout();
	  this._manageStamps();
	  // layout new stuff without transition
	  this.layoutItems( items, true );
	  this.reveal( items );
	  // layout previous items
	  this.layoutItems( previousItems );
	};

	/**
	 * reveal a collection of items
	 * @param {Array of Outlayer.Items} items
	 */
	proto.reveal = function( items ) {
	  this._emitCompleteOnItems( &#x27;reveal&#x27;, items );
	  if ( !items || !items.length ) {
	    return;
	  }
	  var stagger = this.updateStagger();
	  items.forEach( function( item, i ) {
	    item.stagger( i * stagger );
	    item.reveal();
	  });
	};

	/**
	 * hide a collection of items
	 * @param {Array of Outlayer.Items} items
	 */
	proto.hide = function( items ) {
	  this._emitCompleteOnItems( &#x27;hide&#x27;, items );
	  if ( !items || !items.length ) {
	    return;
	  }
	  var stagger = this.updateStagger();
	  items.forEach( function( item, i ) {
	    item.stagger( i * stagger );
	    item.hide();
	  });
	};

	/**
	 * reveal item elements
	 * @param {Array}, {Element}, {NodeList} items
	 */
	proto.revealItemElements = function( elems ) {
	  var items = this.getItems( elems );
	  this.reveal( items );
	};

	/**
	 * hide item elements
	 * @param {Array}, {Element}, {NodeList} items
	 */
	proto.hideItemElements = function( elems ) {
	  var items = this.getItems( elems );
	  this.hide( items );
	};

	/**
	 * get Outlayer.Item, given an Element
	 * @param {Element} elem
	 * @param {Function} callback
	 * @returns {Outlayer.Item} item
	 */
	proto.getItem = function( elem ) {
	  // loop through items to get the one that matches
	  for ( var i=0; i &lt; this.items.length; i++ ) {
	    var item = this.items[i];
	    if ( item.element == elem ) {
	      // return item
	      return item;
	    }
	  }
	};

	/**
	 * get collection of Outlayer.Items, given Elements
	 * @param {Array} elems
	 * @returns {Array} items - Outlayer.Items
	 */
	proto.getItems = function( elems ) {
	  elems = utils.makeArray( elems );
	  var items = [];
	  elems.forEach( function( elem ) {
	    var item = this.getItem( elem );
	    if ( item ) {
	      items.push( item );
	    }
	  }, this );

	  return items;
	};

	/**
	 * remove element(s) from instance and DOM
	 * @param {Array or NodeList or Element} elems
	 */
	proto.remove = function( elems ) {
	  var removeItems = this.getItems( elems );

	  this._emitCompleteOnItems( &#x27;remove&#x27;, removeItems );

	  // bail if no items to remove
	  if ( !removeItems || !removeItems.length ) {
	    return;
	  }

	  removeItems.forEach( function( item ) {
	    item.remove();
	    // remove item from collection
	    utils.removeFrom( this.items, item );
	  }, this );
	};

	// ----- destroy ----- //

	// remove and disable Outlayer instance
	proto.destroy = function() {
	  // clean up dynamic styles
	  var style = this.element.style;
	  style.height = &#x27;&#x27;;
	  style.position = &#x27;&#x27;;
	  style.width = &#x27;&#x27;;
	  // destroy items
	  this.items.forEach( function( item ) {
	    item.destroy();
	  });

	  this.unbindResize();

	  var id = this.element.outlayerGUID;
	  delete instances[ id ]; // remove reference to instance by id
	  delete this.element.outlayerGUID;
	  // remove data for jQuery
	  if ( jQuery ) {
	    jQuery.removeData( this.element, this.constructor.namespace );
	  }

	};

	// -------------------------- data -------------------------- //

	/**
	 * get Outlayer instance from element
	 * @param {Element} elem
	 * @returns {Outlayer}
	 */
	Outlayer.data = function( elem ) {
	  elem = utils.getQueryElement( elem );
	  var id = elem &amp;&amp; elem.outlayerGUID;
	  return id &amp;&amp; instances[ id ];
	};


	// -------------------------- create Outlayer class -------------------------- //

	/**
	 * create a layout class
	 * @param {String} namespace
	 */
	Outlayer.create = function( namespace, options ) {
	  // sub-class Outlayer
	  var Layout = subclass( Outlayer );
	  // apply new options and compatOptions
	  Layout.defaults = utils.extend( {}, Outlayer.defaults );
	  utils.extend( Layout.defaults, options );
	  Layout.compatOptions = utils.extend( {}, Outlayer.compatOptions  );

	  Layout.namespace = namespace;

	  Layout.data = Outlayer.data;

	  // sub-class Item
	  Layout.Item = subclass( Item );

	  // -------------------------- declarative -------------------------- //

	  utils.htmlInit( Layout, namespace );

	  // -------------------------- jQuery bridge -------------------------- //

	  // make into jQuery plugin
	  if ( jQuery &amp;&amp; jQuery.bridget ) {
	    jQuery.bridget( namespace, Layout );
	  }

	  return Layout;
	};

	function subclass( Parent ) {
	  function SubClass() {
	    Parent.apply( this, arguments );
	  }

	  SubClass.prototype = Object.create( Parent.prototype );
	  SubClass.prototype.constructor = SubClass;

	  return SubClass;
	}

	// ----- helpers ----- //

	// how many milliseconds are in each unit
	var msUnits = {
	  ms: 1,
	  s: 1000
	};

	// munge time-like parameter into millisecond number
	// &#x27;0.4s&#x27; -&gt; 40
	function getMilliseconds( time ) {
	  if ( typeof time == &#x27;number&#x27; ) {
	    return time;
	  }
	  var matches = time.match( /(^\d*\.?\d*)(\w*)/ );
	  var num = matches &amp;&amp; matches[1];
	  var unit = matches &amp;&amp; matches[2];
	  if ( !num.length ) {
	    return 0;
	  }
	  num = parseFloat( num );
	  var mult = msUnits[ unit ] || 1;
	  return num * mult;
	}

	// ----- fin ----- //

	// back in global
	Outlayer.Item = Item;

	return Outlayer;

	}));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * EvEmitter v1.1.0
	 * Lil&#x27; event emitter
	 * MIT License
	 */

	/* jshint unused: true, undef: true, strict: true */

	( function( global, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, window */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports = factory();
	  } else {
	    // Browser globals
	    global.EvEmitter = factory();
	  }

	}( typeof window != &#x27;undefined&#x27; ? window : this, function() {

	&quot;use strict&quot;;

	function EvEmitter() {}

	var proto = EvEmitter.prototype;

	proto.on = function( eventName, listener ) {
	  if ( !eventName || !listener ) {
	    return;
	  }
	  // set events hash
	  var events = this._events = this._events || {};
	  // set listeners array
	  var listeners = events[ eventName ] = events[ eventName ] || [];
	  // only add once
	  if ( listeners.indexOf( listener ) == -1 ) {
	    listeners.push( listener );
	  }

	  return this;
	};

	proto.once = function( eventName, listener ) {
	  if ( !eventName || !listener ) {
	    return;
	  }
	  // add event
	  this.on( eventName, listener );
	  // set once flag
	  // set onceEvents hash
	  var onceEvents = this._onceEvents = this._onceEvents || {};
	  // set onceListeners object
	  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
	  // set flag
	  onceListeners[ listener ] = true;

	  return this;
	};

	proto.off = function( eventName, listener ) {
	  var listeners = this._events &amp;&amp; this._events[ eventName ];
	  if ( !listeners || !listeners.length ) {
	    return;
	  }
	  var index = listeners.indexOf( listener );
	  if ( index != -1 ) {
	    listeners.splice( index, 1 );
	  }

	  return this;
	};

	proto.emitEvent = function( eventName, args ) {
	  var listeners = this._events &amp;&amp; this._events[ eventName ];
	  if ( !listeners || !listeners.length ) {
	    return;
	  }
	  // copy over to avoid interference if .off() in listener
	  listeners = listeners.slice(0);
	  args = args || [];
	  // once stuff
	  var onceListeners = this._onceEvents &amp;&amp; this._onceEvents[ eventName ];

	  for ( var i=0; i &lt; listeners.length; i++ ) {
	    var listener = listeners[i]
	    var isOnce = onceListeners &amp;&amp; onceListeners[ listener ];
	    if ( isOnce ) {
	      // remove listener
	      // remove before trigger to prevent recursion
	      this.off( eventName, listener );
	      // unset once flag
	      delete onceListeners[ listener ];
	    }
	    // trigger listener
	    listener.apply( this, args );
	  }

	  return this;
	};

	proto.allOff = function() {
	  delete this._events;
	  delete this._onceEvents;
	};

	return EvEmitter;

	}));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * getSize v2.0.2
	 * measure size of elements
	 * MIT license
	 */

	/*jshint browser: true, strict: true, undef: true, unused: true */
	/*global define: false, module: false, console: false */

	( function( window, factory ) {
	  &#x27;use strict&#x27;;

	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return factory();
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports = factory();
	  } else {
	    // browser global
	    window.getSize = factory();
	  }

	})( window, function factory() {
	&#x27;use strict&#x27;;

	// -------------------------- helpers -------------------------- //

	// get a number from a string, not a percentage
	function getStyleSize( value ) {
	  var num = parseFloat( value );
	  // not a percent like &#x27;100%&#x27;, and a number
	  var isValid = value.indexOf(&#x27;%&#x27;) == -1 &amp;&amp; !isNaN( num );
	  return isValid &amp;&amp; num;
	}

	function noop() {}

	var logError = typeof console == &#x27;undefined&#x27; ? noop :
	  function( message ) {
	    console.error( message );
	  };

	// -------------------------- measurements -------------------------- //

	var measurements = [
	  &#x27;paddingLeft&#x27;,
	  &#x27;paddingRight&#x27;,
	  &#x27;paddingTop&#x27;,
	  &#x27;paddingBottom&#x27;,
	  &#x27;marginLeft&#x27;,
	  &#x27;marginRight&#x27;,
	  &#x27;marginTop&#x27;,
	  &#x27;marginBottom&#x27;,
	  &#x27;borderLeftWidth&#x27;,
	  &#x27;borderRightWidth&#x27;,
	  &#x27;borderTopWidth&#x27;,
	  &#x27;borderBottomWidth&#x27;
	];

	var measurementsLength = measurements.length;

	function getZeroSize() {
	  var size = {
	    width: 0,
	    height: 0,
	    innerWidth: 0,
	    innerHeight: 0,
	    outerWidth: 0,
	    outerHeight: 0
	  };
	  for ( var i=0; i &lt; measurementsLength; i++ ) {
	    var measurement = measurements[i];
	    size[ measurement ] = 0;
	  }
	  return size;
	}

	// -------------------------- getStyle -------------------------- //

	/**
	 * getStyle, get style of element, check for Firefox bug
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
	 */
	function getStyle( elem ) {
	  var style = getComputedStyle( elem );
	  if ( !style ) {
	    logError( &#x27;Style returned &#x27; + style +
	      &#x27;. Are you running this code in a hidden iframe on Firefox? &#x27; +
	      &#x27;See http://bit.ly/getsizebug1&#x27; );
	  }
	  return style;
	}

	// -------------------------- setup -------------------------- //

	var isSetup = false;

	var isBoxSizeOuter;

	/**
	 * setup
	 * check isBoxSizerOuter
	 * do on first getSize() rather than on page load for Firefox bug
	 */
	function setup() {
	  // setup once
	  if ( isSetup ) {
	    return;
	  }
	  isSetup = true;

	  // -------------------------- box sizing -------------------------- //

	  /**
	   * WebKit measures the outer-width on style.width on border-box elems
	   * IE &amp; Firefox&lt;29 measures the inner-width
	   */
	  var div = document.createElement(&#x27;div&#x27;);
	  div.style.width = &#x27;200px&#x27;;
	  div.style.padding = &#x27;1px 2px 3px 4px&#x27;;
	  div.style.borderStyle = &#x27;solid&#x27;;
	  div.style.borderWidth = &#x27;1px 2px 3px 4px&#x27;;
	  div.style.boxSizing = &#x27;border-box&#x27;;

	  var body = document.body || document.documentElement;
	  body.appendChild( div );
	  var style = getStyle( div );

	  getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize( style.width ) == 200;
	  body.removeChild( div );

	}

	// -------------------------- getSize -------------------------- //

	function getSize( elem ) {
	  setup();

	  // use querySeletor if elem is string
	  if ( typeof elem == &#x27;string&#x27; ) {
	    elem = document.querySelector( elem );
	  }

	  // do not proceed on non-objects
	  if ( !elem || typeof elem != &#x27;object&#x27; || !elem.nodeType ) {
	    return;
	  }

	  var style = getStyle( elem );

	  // if hidden, everything is 0
	  if ( style.display == &#x27;none&#x27; ) {
	    return getZeroSize();
	  }

	  var size = {};
	  size.width = elem.offsetWidth;
	  size.height = elem.offsetHeight;

	  var isBorderBox = size.isBorderBox = style.boxSizing == &#x27;border-box&#x27;;

	  // get all measurements
	  for ( var i=0; i &lt; measurementsLength; i++ ) {
	    var measurement = measurements[i];
	    var value = style[ measurement ];
	    var num = parseFloat( value );
	    // any &#x27;auto&#x27;, &#x27;medium&#x27; value will be 0
	    size[ measurement ] = !isNaN( num ) ? num : 0;
	  }

	  var paddingWidth = size.paddingLeft + size.paddingRight;
	  var paddingHeight = size.paddingTop + size.paddingBottom;
	  var marginWidth = size.marginLeft + size.marginRight;
	  var marginHeight = size.marginTop + size.marginBottom;
	  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
	  var borderHeight = size.borderTopWidth + size.borderBottomWidth;

	  var isBorderBoxSizeOuter = isBorderBox &amp;&amp; isBoxSizeOuter;

	  // overwrite width and height if we can get it from style
	  var styleWidth = getStyleSize( style.width );
	  if ( styleWidth !== false ) {
	    size.width = styleWidth +
	      // add padding and border unless it&#x27;s already including it
	      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
	  }

	  var styleHeight = getStyleSize( style.height );
	  if ( styleHeight !== false ) {
	    size.height = styleHeight +
	      // add padding and border unless it&#x27;s already including it
	      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
	  }

	  size.innerWidth = size.width - ( paddingWidth + borderWidth );
	  size.innerHeight = size.height - ( paddingHeight + borderHeight );

	  size.outerWidth = size.width + marginWidth;
	  size.outerHeight = size.height + marginHeight;

	  return size;
	}

	return getSize;

	});


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Fizzy UI utils v2.0.7
	 * MIT license
	 */

	/*jshint browser: true, undef: true, unused: true, strict: true */

	( function( window, factory ) {
	  // universal module definition
	  /*jshint strict: false */ /*globals define, module, require */

	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	      __webpack_require__(24)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function( matchesSelector ) {
	      return factory( window, matchesSelector );
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports = factory(
	      window,
	      require(&#x27;desandro-matches-selector&#x27;)
	    );
	  } else {
	    // browser global
	    window.fizzyUIUtils = factory(
	      window,
	      window.matchesSelector
	    );
	  }

	}( window, function factory( window, matchesSelector ) {

	&#x27;use strict&#x27;;

	var utils = {};

	// ----- extend ----- //

	// extends objects
	utils.extend = function( a, b ) {
	  for ( var prop in b ) {
	    a[ prop ] = b[ prop ];
	  }
	  return a;
	};

	// ----- modulo ----- //

	utils.modulo = function( num, div ) {
	  return ( ( num % div ) + div ) % div;
	};

	// ----- makeArray ----- //

	var arraySlice = Array.prototype.slice;

	// turn element or nodeList into an array
	utils.makeArray = function( obj ) {
	  if ( Array.isArray( obj ) ) {
	    // use object if already an array
	    return obj;
	  }
	  // return empty array if undefined or null. #6
	  if ( obj === null || obj === undefined ) {
	    return [];
	  }

	  var isArrayLike = typeof obj == &#x27;object&#x27; &amp;&amp; typeof obj.length == &#x27;number&#x27;;
	  if ( isArrayLike ) {
	    // convert nodeList to array
	    return arraySlice.call( obj );
	  }

	  // array of single index
	  return [ obj ];
	};

	// ----- removeFrom ----- //

	utils.removeFrom = function( ary, obj ) {
	  var index = ary.indexOf( obj );
	  if ( index != -1 ) {
	    ary.splice( index, 1 );
	  }
	};

	// ----- getParent ----- //

	utils.getParent = function( elem, selector ) {
	  while ( elem.parentNode &amp;&amp; elem != document.body ) {
	    elem = elem.parentNode;
	    if ( matchesSelector( elem, selector ) ) {
	      return elem;
	    }
	  }
	};

	// ----- getQueryElement ----- //

	// use element as selector string
	utils.getQueryElement = function( elem ) {
	  if ( typeof elem == &#x27;string&#x27; ) {
	    return document.querySelector( elem );
	  }
	  return elem;
	};

	// ----- handleEvent ----- //

	// enable .ontype to trigger from .addEventListener( elem, &#x27;type&#x27; )
	utils.handleEvent = function( event ) {
	  var method = &#x27;on&#x27; + event.type;
	  if ( this[ method ] ) {
	    this[ method ]( event );
	  }
	};

	// ----- filterFindElements ----- //

	utils.filterFindElements = function( elems, selector ) {
	  // make array of elems
	  elems = utils.makeArray( elems );
	  var ffElems = [];

	  elems.forEach( function( elem ) {
	    // check that elem is an actual element
	    if ( !( elem instanceof HTMLElement ) ) {
	      return;
	    }
	    // add elem if no selector
	    if ( !selector ) {
	      ffElems.push( elem );
	      return;
	    }
	    // filter &amp; find items if we have a selector
	    // filter
	    if ( matchesSelector( elem, selector ) ) {
	      ffElems.push( elem );
	    }
	    // find children
	    var childElems = elem.querySelectorAll( selector );
	    // concat childElems to filterFound array
	    for ( var i=0; i &lt; childElems.length; i++ ) {
	      ffElems.push( childElems[i] );
	    }
	  });

	  return ffElems;
	};

	// ----- debounceMethod ----- //

	utils.debounceMethod = function( _class, methodName, threshold ) {
	  threshold = threshold || 100;
	  // original method
	  var method = _class.prototype[ methodName ];
	  var timeoutName = methodName + &#x27;Timeout&#x27;;

	  _class.prototype[ methodName ] = function() {
	    var timeout = this[ timeoutName ];
	    clearTimeout( timeout );

	    var args = arguments;
	    var _this = this;
	    this[ timeoutName ] = setTimeout( function() {
	      method.apply( _this, args );
	      delete _this[ timeoutName ];
	    }, threshold );
	  };
	};

	// ----- docReady ----- //

	utils.docReady = function( callback ) {
	  var readyState = document.readyState;
	  if ( readyState == &#x27;complete&#x27; || readyState == &#x27;interactive&#x27; ) {
	    // do async to allow for other scripts to run. metafizzy/flickity#441
	    setTimeout( callback );
	  } else {
	    document.addEventListener( &#x27;DOMContentLoaded&#x27;, callback );
	  }
	};

	// ----- htmlInit ----- //

	// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
	utils.toDashed = function( str ) {
	  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
	    return $1 + &#x27;-&#x27; + $2;
	  }).toLowerCase();
	};

	var console = window.console;
	/**
	 * allow user to initialize classes via [data-namespace] or .js-namespace class
	 * htmlInit( Widget, &#x27;widgetName&#x27; )
	 * options are parsed from data-namespace-options
	 */
	utils.htmlInit = function( WidgetClass, namespace ) {
	  utils.docReady( function() {
	    var dashedNamespace = utils.toDashed( namespace );
	    var dataAttr = &#x27;data-&#x27; + dashedNamespace;
	    var dataAttrElems = document.querySelectorAll( &#x27;[&#x27; + dataAttr + &#x27;]&#x27; );
	    var jsDashElems = document.querySelectorAll( &#x27;.js-&#x27; + dashedNamespace );
	    var elems = utils.makeArray( dataAttrElems )
	      .concat( utils.makeArray( jsDashElems ) );
	    var dataOptionsAttr = dataAttr + &#x27;-options&#x27;;
	    var jQuery = window.jQuery;

	    elems.forEach( function( elem ) {
	      var attr = elem.getAttribute( dataAttr ) ||
	        elem.getAttribute( dataOptionsAttr );
	      var options;
	      try {
	        options = attr &amp;&amp; JSON.parse( attr );
	      } catch ( error ) {
	        // log error, do not initialize
	        if ( console ) {
	          console.error( &#x27;Error parsing &#x27; + dataAttr + &#x27; on &#x27; + elem.className +
	          &#x27;: &#x27; + error );
	        }
	        return;
	      }
	      // initialize
	      var instance = new WidgetClass( elem, options );
	      // make available via $().data(&#x27;namespace&#x27;)
	      if ( jQuery ) {
	        jQuery.data( elem, namespace, instance );
	      }
	    });

	  });
	};

	// -----  ----- //

	return utils;

	}));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * matchesSelector v2.0.2
	 * matchesSelector( element, &#x27;.selector&#x27; )
	 * MIT license
	 */

	/*jshint browser: true, strict: true, undef: true, unused: true */

	( function( window, factory ) {
	  /*global define: false, module: false */
	  &#x27;use strict&#x27;;
	  // universal module definition
	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports = factory();
	  } else {
	    // browser global
	    window.matchesSelector = factory();
	  }

	}( window, function factory() {
	  &#x27;use strict&#x27;;

	  var matchesMethod = ( function() {
	    var ElemProto = window.Element.prototype;
	    // check for the standard method name first
	    if ( ElemProto.matches ) {
	      return &#x27;matches&#x27;;
	    }
	    // check un-prefixed
	    if ( ElemProto.matchesSelector ) {
	      return &#x27;matchesSelector&#x27;;
	    }
	    // check vendor prefixes
	    var prefixes = [ &#x27;webkit&#x27;, &#x27;moz&#x27;, &#x27;ms&#x27;, &#x27;o&#x27; ];

	    for ( var i=0; i &lt; prefixes.length; i++ ) {
	      var prefix = prefixes[i];
	      var method = prefix + &#x27;MatchesSelector&#x27;;
	      if ( ElemProto[ method ] ) {
	        return method;
	      }
	    }
	  })();

	  return function matchesSelector( elem, selector ) {
	    return elem[ matchesMethod ]( selector );
	  };

	}));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Outlayer Item
	 */

	( function( window, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, require */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(21),
	        __webpack_require__(22)
	      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports = factory(
	      require(&#x27;ev-emitter&#x27;),
	      require(&#x27;get-size&#x27;)
	    );
	  } else {
	    // browser global
	    window.Outlayer = {};
	    window.Outlayer.Item = factory(
	      window.EvEmitter,
	      window.getSize
	    );
	  }

	}( window, function factory( EvEmitter, getSize ) {
	&#x27;use strict&#x27;;

	// ----- helpers ----- //

	function isEmptyObj( obj ) {
	  for ( var prop in obj ) {
	    return false;
	  }
	  prop = null;
	  return true;
	}

	// -------------------------- CSS3 support -------------------------- //


	var docElemStyle = document.documentElement.style;

	var transitionProperty = typeof docElemStyle.transition == &#x27;string&#x27; ?
	  &#x27;transition&#x27; : &#x27;WebkitTransition&#x27;;
	var transformProperty = typeof docElemStyle.transform == &#x27;string&#x27; ?
	  &#x27;transform&#x27; : &#x27;WebkitTransform&#x27;;

	var transitionEndEvent = {
	  WebkitTransition: &#x27;webkitTransitionEnd&#x27;,
	  transition: &#x27;transitionend&#x27;
	}[ transitionProperty ];

	// cache all vendor properties that could have vendor prefix
	var vendorProperties = {
	  transform: transformProperty,
	  transition: transitionProperty,
	  transitionDuration: transitionProperty + &#x27;Duration&#x27;,
	  transitionProperty: transitionProperty + &#x27;Property&#x27;,
	  transitionDelay: transitionProperty + &#x27;Delay&#x27;
	};

	// -------------------------- Item -------------------------- //

	function Item( element, layout ) {
	  if ( !element ) {
	    return;
	  }

	  this.element = element;
	  // parent layout class, i.e. Masonry, Isotope, or Packery
	  this.layout = layout;
	  this.position = {
	    x: 0,
	    y: 0
	  };

	  this._create();
	}

	// inherit EvEmitter
	var proto = Item.prototype = Object.create( EvEmitter.prototype );
	proto.constructor = Item;

	proto._create = function() {
	  // transition objects
	  this._transn = {
	    ingProperties: {},
	    clean: {},
	    onEnd: {}
	  };

	  this.css({
	    position: &#x27;absolute&#x27;
	  });
	};

	// trigger specified handler for event type
	proto.handleEvent = function( event ) {
	  var method = &#x27;on&#x27; + event.type;
	  if ( this[ method ] ) {
	    this[ method ]( event );
	  }
	};

	proto.getSize = function() {
	  this.size = getSize( this.element );
	};

	/**
	 * apply CSS styles to element
	 * @param {Object} style
	 */
	proto.css = function( style ) {
	  var elemStyle = this.element.style;

	  for ( var prop in style ) {
	    // use vendor property if available
	    var supportedProp = vendorProperties[ prop ] || prop;
	    elemStyle[ supportedProp ] = style[ prop ];
	  }
	};

	 // measure position, and sets it
	proto.getPosition = function() {
	  var style = getComputedStyle( this.element );
	  var isOriginLeft = this.layout._getOption(&#x27;originLeft&#x27;);
	  var isOriginTop = this.layout._getOption(&#x27;originTop&#x27;);
	  var xValue = style[ isOriginLeft ? &#x27;left&#x27; : &#x27;right&#x27; ];
	  var yValue = style[ isOriginTop ? &#x27;top&#x27; : &#x27;bottom&#x27; ];
	  var x = parseFloat( xValue );
	  var y = parseFloat( yValue );
	  // convert percent to pixels
	  var layoutSize = this.layout.size;
	  if ( xValue.indexOf(&#x27;%&#x27;) != -1 ) {
	    x = ( x / 100 ) * layoutSize.width;
	  }
	  if ( yValue.indexOf(&#x27;%&#x27;) != -1 ) {
	    y = ( y / 100 ) * layoutSize.height;
	  }
	  // clean up &#x27;auto&#x27; or other non-integer values
	  x = isNaN( x ) ? 0 : x;
	  y = isNaN( y ) ? 0 : y;
	  // remove padding from measurement
	  x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
	  y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

	  this.position.x = x;
	  this.position.y = y;
	};

	// set settled position, apply padding
	proto.layoutPosition = function() {
	  var layoutSize = this.layout.size;
	  var style = {};
	  var isOriginLeft = this.layout._getOption(&#x27;originLeft&#x27;);
	  var isOriginTop = this.layout._getOption(&#x27;originTop&#x27;);

	  // x
	  var xPadding = isOriginLeft ? &#x27;paddingLeft&#x27; : &#x27;paddingRight&#x27;;
	  var xProperty = isOriginLeft ? &#x27;left&#x27; : &#x27;right&#x27;;
	  var xResetProperty = isOriginLeft ? &#x27;right&#x27; : &#x27;left&#x27;;

	  var x = this.position.x + layoutSize[ xPadding ];
	  // set in percentage or pixels
	  style[ xProperty ] = this.getXValue( x );
	  // reset other property
	  style[ xResetProperty ] = &#x27;&#x27;;

	  // y
	  var yPadding = isOriginTop ? &#x27;paddingTop&#x27; : &#x27;paddingBottom&#x27;;
	  var yProperty = isOriginTop ? &#x27;top&#x27; : &#x27;bottom&#x27;;
	  var yResetProperty = isOriginTop ? &#x27;bottom&#x27; : &#x27;top&#x27;;

	  var y = this.position.y + layoutSize[ yPadding ];
	  // set in percentage or pixels
	  style[ yProperty ] = this.getYValue( y );
	  // reset other property
	  style[ yResetProperty ] = &#x27;&#x27;;

	  this.css( style );
	  this.emitEvent( &#x27;layout&#x27;, [ this ] );
	};

	proto.getXValue = function( x ) {
	  var isHorizontal = this.layout._getOption(&#x27;horizontal&#x27;);
	  return this.layout.options.percentPosition &amp;&amp; !isHorizontal ?
	    ( ( x / this.layout.size.width ) * 100 ) + &#x27;%&#x27; : x + &#x27;px&#x27;;
	};

	proto.getYValue = function( y ) {
	  var isHorizontal = this.layout._getOption(&#x27;horizontal&#x27;);
	  return this.layout.options.percentPosition &amp;&amp; isHorizontal ?
	    ( ( y / this.layout.size.height ) * 100 ) + &#x27;%&#x27; : y + &#x27;px&#x27;;
	};

	proto._transitionTo = function( x, y ) {
	  this.getPosition();
	  // get current x &amp; y from top/left
	  var curX = this.position.x;
	  var curY = this.position.y;

	  var didNotMove = x == this.position.x &amp;&amp; y == this.position.y;

	  // save end position
	  this.setPosition( x, y );

	  // if did not move and not transitioning, just go to layout
	  if ( didNotMove &amp;&amp; !this.isTransitioning ) {
	    this.layoutPosition();
	    return;
	  }

	  var transX = x - curX;
	  var transY = y - curY;
	  var transitionStyle = {};
	  transitionStyle.transform = this.getTranslate( transX, transY );

	  this.transition({
	    to: transitionStyle,
	    onTransitionEnd: {
	      transform: this.layoutPosition
	    },
	    isCleaning: true
	  });
	};

	proto.getTranslate = function( x, y ) {
	  // flip cooridinates if origin on right or bottom
	  var isOriginLeft = this.layout._getOption(&#x27;originLeft&#x27;);
	  var isOriginTop = this.layout._getOption(&#x27;originTop&#x27;);
	  x = isOriginLeft ? x : -x;
	  y = isOriginTop ? y : -y;
	  return &#x27;translate3d(&#x27; + x + &#x27;px, &#x27; + y + &#x27;px, 0)&#x27;;
	};

	// non transition + transform support
	proto.goTo = function( x, y ) {
	  this.setPosition( x, y );
	  this.layoutPosition();
	};

	proto.moveTo = proto._transitionTo;

	proto.setPosition = function( x, y ) {
	  this.position.x = parseFloat( x );
	  this.position.y = parseFloat( y );
	};

	// ----- transition ----- //

	/**
	 * @param {Object} style - CSS
	 * @param {Function} onTransitionEnd
	 */

	// non transition, just trigger callback
	proto._nonTransition = function( args ) {
	  this.css( args.to );
	  if ( args.isCleaning ) {
	    this._removeStyles( args.to );
	  }
	  for ( var prop in args.onTransitionEnd ) {
	    args.onTransitionEnd[ prop ].call( this );
	  }
	};

	/**
	 * proper transition
	 * @param {Object} args - arguments
	 *   @param {Object} to - style to transition to
	 *   @param {Object} from - style to start transition from
	 *   @param {Boolean} isCleaning - removes transition styles after transition
	 *   @param {Function} onTransitionEnd - callback
	 */
	proto.transition = function( args ) {
	  // redirect to nonTransition if no transition duration
	  if ( !parseFloat( this.layout.options.transitionDuration ) ) {
	    this._nonTransition( args );
	    return;
	  }

	  var _transition = this._transn;
	  // keep track of onTransitionEnd callback by css property
	  for ( var prop in args.onTransitionEnd ) {
	    _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];
	  }
	  // keep track of properties that are transitioning
	  for ( prop in args.to ) {
	    _transition.ingProperties[ prop ] = true;
	    // keep track of properties to clean up when transition is done
	    if ( args.isCleaning ) {
	      _transition.clean[ prop ] = true;
	    }
	  }

	  // set from styles
	  if ( args.from ) {
	    this.css( args.from );
	    // force redraw. http://blog.alexmaccaw.com/css-transitions
	    var h = this.element.offsetHeight;
	    // hack for JSHint to hush about unused var
	    h = null;
	  }
	  // enable transition
	  this.enableTransition( args.to );
	  // set styles that are transitioning
	  this.css( args.to );

	  this.isTransitioning = true;

	};

	// dash before all cap letters, including first for
	// WebkitTransform =&gt; -webkit-transform
	function toDashedAll( str ) {
	  return str.replace( /([A-Z])/g, function( $1 ) {
	    return &#x27;-&#x27; + $1.toLowerCase();
	  });
	}

	var transitionProps = &#x27;opacity,&#x27; + toDashedAll( transformProperty );

	proto.enableTransition = function(/* style */) {
	  // HACK changing transitionProperty during a transition
	  // will cause transition to jump
	  if ( this.isTransitioning ) {
	    return;
	  }

	  // make &#x60;transition: foo, bar, baz&#x60; from style object
	  // HACK un-comment this when enableTransition can work
	  // while a transition is happening
	  // var transitionValues = [];
	  // for ( var prop in style ) {
	  //   // dash-ify camelCased properties like WebkitTransition
	  //   prop = vendorProperties[ prop ] || prop;
	  //   transitionValues.push( toDashedAll( prop ) );
	  // }
	  // munge number to millisecond, to match stagger
	  var duration = this.layout.options.transitionDuration;
	  duration = typeof duration == &#x27;number&#x27; ? duration + &#x27;ms&#x27; : duration;
	  // enable transition styles
	  this.css({
	    transitionProperty: transitionProps,
	    transitionDuration: duration,
	    transitionDelay: this.staggerDelay || 0
	  });
	  // listen for transition end event
	  this.element.addEventListener( transitionEndEvent, this, false );
	};

	// ----- events ----- //

	proto.onwebkitTransitionEnd = function( event ) {
	  this.ontransitionend( event );
	};

	proto.onotransitionend = function( event ) {
	  this.ontransitionend( event );
	};

	// properties that I munge to make my life easier
	var dashedVendorProperties = {
	  &#x27;-webkit-transform&#x27;: &#x27;transform&#x27;
	};

	proto.ontransitionend = function( event ) {
	  // disregard bubbled events from children
	  if ( event.target !== this.element ) {
	    return;
	  }
	  var _transition = this._transn;
	  // get property name of transitioned property, convert to prefix-free
	  var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;

	  // remove property that has completed transitioning
	  delete _transition.ingProperties[ propertyName ];
	  // check if any properties are still transitioning
	  if ( isEmptyObj( _transition.ingProperties ) ) {
	    // all properties have completed transitioning
	    this.disableTransition();
	  }
	  // clean style
	  if ( propertyName in _transition.clean ) {
	    // clean up style
	    this.element.style[ event.propertyName ] = &#x27;&#x27;;
	    delete _transition.clean[ propertyName ];
	  }
	  // trigger onTransitionEnd callback
	  if ( propertyName in _transition.onEnd ) {
	    var onTransitionEnd = _transition.onEnd[ propertyName ];
	    onTransitionEnd.call( this );
	    delete _transition.onEnd[ propertyName ];
	  }

	  this.emitEvent( &#x27;transitionEnd&#x27;, [ this ] );
	};

	proto.disableTransition = function() {
	  this.removeTransitionStyles();
	  this.element.removeEventListener( transitionEndEvent, this, false );
	  this.isTransitioning = false;
	};

	/**
	 * removes style property from element
	 * @param {Object} style
	**/
	proto._removeStyles = function( style ) {
	  // clean up transition styles
	  var cleanStyle = {};
	  for ( var prop in style ) {
	    cleanStyle[ prop ] = &#x27;&#x27;;
	  }
	  this.css( cleanStyle );
	};

	var cleanTransitionStyle = {
	  transitionProperty: &#x27;&#x27;,
	  transitionDuration: &#x27;&#x27;,
	  transitionDelay: &#x27;&#x27;
	};

	proto.removeTransitionStyles = function() {
	  // remove transition
	  this.css( cleanTransitionStyle );
	};

	// ----- stagger ----- //

	proto.stagger = function( delay ) {
	  delay = isNaN( delay ) ? 0 : delay;
	  this.staggerDelay = delay + &#x27;ms&#x27;;
	};

	// ----- show/hide/remove ----- //

	// remove element from DOM
	proto.removeElem = function() {
	  this.element.parentNode.removeChild( this.element );
	  // remove display: none
	  this.css({ display: &#x27;&#x27; });
	  this.emitEvent( &#x27;remove&#x27;, [ this ] );
	};

	proto.remove = function() {
	  // just remove element if no transition support or no transition
	  if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
	    this.removeElem();
	    return;
	  }

	  // start transition
	  this.once( &#x27;transitionEnd&#x27;, function() {
	    this.removeElem();
	  });
	  this.hide();
	};

	proto.reveal = function() {
	  delete this.isHidden;
	  // remove display: none
	  this.css({ display: &#x27;&#x27; });

	  var options = this.layout.options;

	  var onTransitionEnd = {};
	  var transitionEndProperty = this.getHideRevealTransitionEndProperty(&#x27;visibleStyle&#x27;);
	  onTransitionEnd[ transitionEndProperty ] = this.onRevealTransitionEnd;

	  this.transition({
	    from: options.hiddenStyle,
	    to: options.visibleStyle,
	    isCleaning: true,
	    onTransitionEnd: onTransitionEnd
	  });
	};

	proto.onRevealTransitionEnd = function() {
	  // check if still visible
	  // during transition, item may have been hidden
	  if ( !this.isHidden ) {
	    this.emitEvent(&#x27;reveal&#x27;);
	  }
	};

	/**
	 * get style property use for hide/reveal transition end
	 * @param {String} styleProperty - hiddenStyle/visibleStyle
	 * @returns {String}
	 */
	proto.getHideRevealTransitionEndProperty = function( styleProperty ) {
	  var optionStyle = this.layout.options[ styleProperty ];
	  // use opacity
	  if ( optionStyle.opacity ) {
	    return &#x27;opacity&#x27;;
	  }
	  // get first property
	  for ( var prop in optionStyle ) {
	    return prop;
	  }
	};

	proto.hide = function() {
	  // set flag
	  this.isHidden = true;
	  // remove display: none
	  this.css({ display: &#x27;&#x27; });

	  var options = this.layout.options;

	  var onTransitionEnd = {};
	  var transitionEndProperty = this.getHideRevealTransitionEndProperty(&#x27;hiddenStyle&#x27;);
	  onTransitionEnd[ transitionEndProperty ] = this.onHideTransitionEnd;

	  this.transition({
	    from: options.visibleStyle,
	    to: options.hiddenStyle,
	    // keep hidden stuff hidden
	    isCleaning: true,
	    onTransitionEnd: onTransitionEnd
	  });
	};

	proto.onHideTransitionEnd = function() {
	  // check if still hidden
	  // during transition, item may have been un-hidden
	  if ( this.isHidden ) {
	    this.css({ display: &#x27;none&#x27; });
	    this.emitEvent(&#x27;hide&#x27;);
	  }
	};

	proto.destroy = function() {
	  this.css({
	    position: &#x27;&#x27;,
	    left: &#x27;&#x27;,
	    right: &#x27;&#x27;,
	    top: &#x27;&#x27;,
	    bottom: &#x27;&#x27;,
	    transition: &#x27;&#x27;,
	    transform: &#x27;&#x27;
	  });
	};

	return Item;

	}));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_1__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_2__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_3__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_8__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_9__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_10__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_11__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_12__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Isotope PACKAGED v3.0.3
	 *
	 * Licensed GPLv3 for open source use
	 * or Isotope Commercial License for commercial use
	 *
	 * http://isotope.metafizzy.co
	 * Copyright 2017 Metafizzy
	 */

	!function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function(i){return e(t,i)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(t,require(&quot;jquery&quot;)):t.jQueryBridget=e(t,t.jQuery)}(window,function(t,e){&quot;use strict&quot;;function i(i,s,a){function u(t,e,n){var o,s=&quot;$().&quot;+i+&#x27;(&quot;&#x27;+e+&#x27;&quot;)&#x27;;return t.each(function(t,u){var h=a.data(u,i);if(!h)return void r(i+&quot; not initialized. Cannot call methods, i.e. &quot;+s);var d=h[e];if(!d||&quot;_&quot;==e.charAt(0))return void r(s+&quot; is not a valid method&quot;);var l=d.apply(h,n);o=void 0===o?l:o}),void 0!==o?o:t}function h(t,e){t.each(function(t,n){var o=a.data(n,i);o?(o.option(e),o._init()):(o=new s(n,e),a.data(n,i,o))})}a=a||e||t.jQuery,a&amp;&amp;(s.prototype.option||(s.prototype.option=function(t){a.isPlainObject(t)&amp;&amp;(this.options=a.extend(!0,this.options,t))}),a.fn[i]=function(t){if(&quot;string&quot;==typeof t){var e=o.call(arguments,1);return u(this,t,e)}return h(this,t),this},n(a))}function n(t){!t||t&amp;&amp;t.bridget||(t.bridget=i)}var o=Array.prototype.slice,s=t.console,r=&quot;undefined&quot;==typeof s?function(){}:function(t){s.error(t)};return n(e||t.jQuery),i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_1__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e():t.EvEmitter=e()}(&quot;undefined&quot;!=typeof window?window:this,function(){function t(){}var e=t.prototype;return e.on=function(t,e){if(t&amp;&amp;e){var i=this._events=this._events||{},n=i[t]=i[t]||[];return n.indexOf(e)==-1&amp;&amp;n.push(e),this}},e.once=function(t,e){if(t&amp;&amp;e){this.on(t,e);var i=this._onceEvents=this._onceEvents||{},n=i[t]=i[t]||{};return n[e]=!0,this}},e.off=function(t,e){var i=this._events&amp;&amp;this._events[t];if(i&amp;&amp;i.length){var n=i.indexOf(e);return n!=-1&amp;&amp;i.splice(n,1),this}},e.emitEvent=function(t,e){var i=this._events&amp;&amp;this._events[t];if(i&amp;&amp;i.length){var n=0,o=i[n];e=e||[];for(var s=this._onceEvents&amp;&amp;this._onceEvents[t];o;){var r=s&amp;&amp;s[o];r&amp;&amp;(this.off(t,o),delete s[o]),o.apply(this,e),n+=r?0:1,o=i[n]}return this}},t}),function(t,e){&quot;use strict&quot;; true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_2__ = (function(){return e()}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e():t.getSize=e()}(window,function(){&quot;use strict&quot;;function t(t){var e=parseFloat(t),i=t.indexOf(&quot;%&quot;)==-1&amp;&amp;!isNaN(e);return i&amp;&amp;e}function e(){}function i(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},e=0;e&lt;h;e++){var i=u[e];t[i]=0}return t}function n(t){var e=getComputedStyle(t);return e||a(&quot;Style returned &quot;+e+&quot;. Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1&quot;),e}function o(){if(!d){d=!0;var e=document.createElement(&quot;div&quot;);e.style.width=&quot;200px&quot;,e.style.padding=&quot;1px 2px 3px 4px&quot;,e.style.borderStyle=&quot;solid&quot;,e.style.borderWidth=&quot;1px 2px 3px 4px&quot;,e.style.boxSizing=&quot;border-box&quot;;var i=document.body||document.documentElement;i.appendChild(e);var o=n(e);s.isBoxSizeOuter=r=200==t(o.width),i.removeChild(e)}}function s(e){if(o(),&quot;string&quot;==typeof e&amp;&amp;(e=document.querySelector(e)),e&amp;&amp;&quot;object&quot;==typeof e&amp;&amp;e.nodeType){var s=n(e);if(&quot;none&quot;==s.display)return i();var a={};a.width=e.offsetWidth,a.height=e.offsetHeight;for(var d=a.isBorderBox=&quot;border-box&quot;==s.boxSizing,l=0;l&lt;h;l++){var f=u[l],m=s[f],c=parseFloat(m);a[f]=isNaN(c)?0:c}var p=a.paddingLeft+a.paddingRight,y=a.paddingTop+a.paddingBottom,g=a.marginLeft+a.marginRight,v=a.marginTop+a.marginBottom,_=a.borderLeftWidth+a.borderRightWidth,I=a.borderTopWidth+a.borderBottomWidth,z=d&amp;&amp;r,S=t(s.width);S!==!1&amp;&amp;(a.width=S+(z?0:p+_));var x=t(s.height);return x!==!1&amp;&amp;(a.height=x+(z?0:y+I)),a.innerWidth=a.width-(p+_),a.innerHeight=a.height-(y+I),a.outerWidth=a.width+g,a.outerHeight=a.height+v,a}}var r,a=&quot;undefined&quot;==typeof console?e:function(t){console.error(t)},u=[&quot;paddingLeft&quot;,&quot;paddingRight&quot;,&quot;paddingTop&quot;,&quot;paddingBottom&quot;,&quot;marginLeft&quot;,&quot;marginRight&quot;,&quot;marginTop&quot;,&quot;marginBottom&quot;,&quot;borderLeftWidth&quot;,&quot;borderRightWidth&quot;,&quot;borderTopWidth&quot;,&quot;borderBottomWidth&quot;],h=u.length,d=!1;return s}),function(t,e){&quot;use strict&quot;; true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_3__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e():t.matchesSelector=e()}(window,function(){&quot;use strict&quot;;var t=function(){var t=window.Element.prototype;if(t.matches)return&quot;matches&quot;;if(t.matchesSelector)return&quot;matchesSelector&quot;;for(var e=[&quot;webkit&quot;,&quot;moz&quot;,&quot;ms&quot;,&quot;o&quot;],i=0;i&lt;e.length;i++){var n=e[i],o=n+&quot;MatchesSelector&quot;;if(t[o])return o}}();return function(e,i){return e[t](i)}}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_3__], __WEBPACK_LOCAL_MODULE_4__ = (function(i){return e(t,i)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(t,require(&quot;desandro-matches-selector&quot;)):t.fizzyUIUtils=e(t,t.matchesSelector)}(window,function(t,e){var i={};i.extend=function(t,e){for(var i in e)t[i]=e[i];return t},i.modulo=function(t,e){return(t%e+e)%e},i.makeArray=function(t){var e=[];if(Array.isArray(t))e=t;else if(t&amp;&amp;&quot;object&quot;==typeof t&amp;&amp;&quot;number&quot;==typeof t.length)for(var i=0;i&lt;t.length;i++)e.push(t[i]);else e.push(t);return e},i.removeFrom=function(t,e){var i=t.indexOf(e);i!=-1&amp;&amp;t.splice(i,1)},i.getParent=function(t,i){for(;t!=document.body;)if(t=t.parentNode,e(t,i))return t},i.getQueryElement=function(t){return&quot;string&quot;==typeof t?document.querySelector(t):t},i.handleEvent=function(t){var e=&quot;on&quot;+t.type;this[e]&amp;&amp;this[e](t)},i.filterFindElements=function(t,n){t=i.makeArray(t);var o=[];return t.forEach(function(t){if(t instanceof HTMLElement){if(!n)return void o.push(t);e(t,n)&amp;&amp;o.push(t);for(var i=t.querySelectorAll(n),s=0;s&lt;i.length;s++)o.push(i[s])}}),o},i.debounceMethod=function(t,e,i){var n=t.prototype[e],o=e+&quot;Timeout&quot;;t.prototype[e]=function(){var t=this[o];t&amp;&amp;clearTimeout(t);var e=arguments,s=this;this[o]=setTimeout(function(){n.apply(s,e),delete s[o]},i||100)}},i.docReady=function(t){var e=document.readyState;&quot;complete&quot;==e||&quot;interactive&quot;==e?setTimeout(t):document.addEventListener(&quot;DOMContentLoaded&quot;,t)},i.toDashed=function(t){return t.replace(/(.)([A-Z])/g,function(t,e,i){return e+&quot;-&quot;+i}).toLowerCase()};var n=t.console;return i.htmlInit=function(e,o){i.docReady(function(){var s=i.toDashed(o),r=&quot;data-&quot;+s,a=document.querySelectorAll(&quot;[&quot;+r+&quot;]&quot;),u=document.querySelectorAll(&quot;.js-&quot;+s),h=i.makeArray(a).concat(i.makeArray(u)),d=r+&quot;-options&quot;,l=t.jQuery;h.forEach(function(t){var i,s=t.getAttribute(r)||t.getAttribute(d);try{i=s&amp;&amp;JSON.parse(s)}catch(a){return void(n&amp;&amp;n.error(&quot;Error parsing &quot;+r+&quot; on &quot;+t.className+&quot;: &quot;+a))}var u=new e(t,i);l&amp;&amp;l.data(t,o,u)})})},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__,__WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_5__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(require(&quot;ev-emitter&quot;),require(&quot;get-size&quot;)):(t.Outlayer={},t.Outlayer.Item=e(t.EvEmitter,t.getSize))}(window,function(t,e){&quot;use strict&quot;;function i(t){for(var e in t)return!1;return e=null,!0}function n(t,e){t&amp;&amp;(this.element=t,this.layout=e,this.position={x:0,y:0},this._create())}function o(t){return t.replace(/([A-Z])/g,function(t){return&quot;-&quot;+t.toLowerCase()})}var s=document.documentElement.style,r=&quot;string&quot;==typeof s.transition?&quot;transition&quot;:&quot;WebkitTransition&quot;,a=&quot;string&quot;==typeof s.transform?&quot;transform&quot;:&quot;WebkitTransform&quot;,u={WebkitTransition:&quot;webkitTransitionEnd&quot;,transition:&quot;transitionend&quot;}[r],h={transform:a,transition:r,transitionDuration:r+&quot;Duration&quot;,transitionProperty:r+&quot;Property&quot;,transitionDelay:r+&quot;Delay&quot;},d=n.prototype=Object.create(t.prototype);d.constructor=n,d._create=function(){this._transn={ingProperties:{},clean:{},onEnd:{}},this.css({position:&quot;absolute&quot;})},d.handleEvent=function(t){var e=&quot;on&quot;+t.type;this[e]&amp;&amp;this[e](t)},d.getSize=function(){this.size=e(this.element)},d.css=function(t){var e=this.element.style;for(var i in t){var n=h[i]||i;e[n]=t[i]}},d.getPosition=function(){var t=getComputedStyle(this.element),e=this.layout._getOption(&quot;originLeft&quot;),i=this.layout._getOption(&quot;originTop&quot;),n=t[e?&quot;left&quot;:&quot;right&quot;],o=t[i?&quot;top&quot;:&quot;bottom&quot;],s=this.layout.size,r=n.indexOf(&quot;%&quot;)!=-1?parseFloat(n)/100*s.width:parseInt(n,10),a=o.indexOf(&quot;%&quot;)!=-1?parseFloat(o)/100*s.height:parseInt(o,10);r=isNaN(r)?0:r,a=isNaN(a)?0:a,r-=e?s.paddingLeft:s.paddingRight,a-=i?s.paddingTop:s.paddingBottom,this.position.x=r,this.position.y=a},d.layoutPosition=function(){var t=this.layout.size,e={},i=this.layout._getOption(&quot;originLeft&quot;),n=this.layout._getOption(&quot;originTop&quot;),o=i?&quot;paddingLeft&quot;:&quot;paddingRight&quot;,s=i?&quot;left&quot;:&quot;right&quot;,r=i?&quot;right&quot;:&quot;left&quot;,a=this.position.x+t[o];e[s]=this.getXValue(a),e[r]=&quot;&quot;;var u=n?&quot;paddingTop&quot;:&quot;paddingBottom&quot;,h=n?&quot;top&quot;:&quot;bottom&quot;,d=n?&quot;bottom&quot;:&quot;top&quot;,l=this.position.y+t[u];e[h]=this.getYValue(l),e[d]=&quot;&quot;,this.css(e),this.emitEvent(&quot;layout&quot;,[this])},d.getXValue=function(t){var e=this.layout._getOption(&quot;horizontal&quot;);return this.layout.options.percentPosition&amp;&amp;!e?t/this.layout.size.width*100+&quot;%&quot;:t+&quot;px&quot;},d.getYValue=function(t){var e=this.layout._getOption(&quot;horizontal&quot;);return this.layout.options.percentPosition&amp;&amp;e?t/this.layout.size.height*100+&quot;%&quot;:t+&quot;px&quot;},d._transitionTo=function(t,e){this.getPosition();var i=this.position.x,n=this.position.y,o=parseInt(t,10),s=parseInt(e,10),r=o===this.position.x&amp;&amp;s===this.position.y;if(this.setPosition(t,e),r&amp;&amp;!this.isTransitioning)return void this.layoutPosition();var a=t-i,u=e-n,h={};h.transform=this.getTranslate(a,u),this.transition({to:h,onTransitionEnd:{transform:this.layoutPosition},isCleaning:!0})},d.getTranslate=function(t,e){var i=this.layout._getOption(&quot;originLeft&quot;),n=this.layout._getOption(&quot;originTop&quot;);return t=i?t:-t,e=n?e:-e,&quot;translate3d(&quot;+t+&quot;px, &quot;+e+&quot;px, 0)&quot;},d.goTo=function(t,e){this.setPosition(t,e),this.layoutPosition()},d.moveTo=d._transitionTo,d.setPosition=function(t,e){this.position.x=parseInt(t,10),this.position.y=parseInt(e,10)},d._nonTransition=function(t){this.css(t.to),t.isCleaning&amp;&amp;this._removeStyles(t.to);for(var e in t.onTransitionEnd)t.onTransitionEnd[e].call(this)},d.transition=function(t){if(!parseFloat(this.layout.options.transitionDuration))return void this._nonTransition(t);var e=this._transn;for(var i in t.onTransitionEnd)e.onEnd[i]=t.onTransitionEnd[i];for(i in t.to)e.ingProperties[i]=!0,t.isCleaning&amp;&amp;(e.clean[i]=!0);if(t.from){this.css(t.from);var n=this.element.offsetHeight;n=null}this.enableTransition(t.to),this.css(t.to),this.isTransitioning=!0};var l=&quot;opacity,&quot;+o(a);d.enableTransition=function(){if(!this.isTransitioning){var t=this.layout.options.transitionDuration;t=&quot;number&quot;==typeof t?t+&quot;ms&quot;:t,this.css({transitionProperty:l,transitionDuration:t,transitionDelay:this.staggerDelay||0}),this.element.addEventListener(u,this,!1)}},d.onwebkitTransitionEnd=function(t){this.ontransitionend(t)},d.onotransitionend=function(t){this.ontransitionend(t)};var f={&quot;-webkit-transform&quot;:&quot;transform&quot;};d.ontransitionend=function(t){if(t.target===this.element){var e=this._transn,n=f[t.propertyName]||t.propertyName;if(delete e.ingProperties[n],i(e.ingProperties)&amp;&amp;this.disableTransition(),n in e.clean&amp;&amp;(this.element.style[t.propertyName]=&quot;&quot;,delete e.clean[n]),n in e.onEnd){var o=e.onEnd[n];o.call(this),delete e.onEnd[n]}this.emitEvent(&quot;transitionEnd&quot;,[this])}},d.disableTransition=function(){this.removeTransitionStyles(),this.element.removeEventListener(u,this,!1),this.isTransitioning=!1},d._removeStyles=function(t){var e={};for(var i in t)e[i]=&quot;&quot;;this.css(e)};var m={transitionProperty:&quot;&quot;,transitionDuration:&quot;&quot;,transitionDelay:&quot;&quot;};return d.removeTransitionStyles=function(){this.css(m)},d.stagger=function(t){t=isNaN(t)?0:t,this.staggerDelay=t+&quot;ms&quot;},d.removeElem=function(){this.element.parentNode.removeChild(this.element),this.css({display:&quot;&quot;}),this.emitEvent(&quot;remove&quot;,[this])},d.remove=function(){return r&amp;&amp;parseFloat(this.layout.options.transitionDuration)?(this.once(&quot;transitionEnd&quot;,function(){this.removeElem()}),void this.hide()):void this.removeElem()},d.reveal=function(){delete this.isHidden,this.css({display:&quot;&quot;});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty(&quot;visibleStyle&quot;);e[i]=this.onRevealTransitionEnd,this.transition({from:t.hiddenStyle,to:t.visibleStyle,isCleaning:!0,onTransitionEnd:e})},d.onRevealTransitionEnd=function(){this.isHidden||this.emitEvent(&quot;reveal&quot;)},d.getHideRevealTransitionEndProperty=function(t){var e=this.layout.options[t];if(e.opacity)return&quot;opacity&quot;;for(var i in e)return i},d.hide=function(){this.isHidden=!0,this.css({display:&quot;&quot;});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty(&quot;hiddenStyle&quot;);e[i]=this.onHideTransitionEnd,this.transition({from:t.visibleStyle,to:t.hiddenStyle,isCleaning:!0,onTransitionEnd:e})},d.onHideTransitionEnd=function(){this.isHidden&amp;&amp;(this.css({display:&quot;none&quot;}),this.emitEvent(&quot;hide&quot;))},d.destroy=function(){this.css({position:&quot;&quot;,left:&quot;&quot;,right:&quot;&quot;,top:&quot;&quot;,bottom:&quot;&quot;,transition:&quot;&quot;,transform:&quot;&quot;})},n}),function(t,e){&quot;use strict&quot;; true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__,__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_4__,__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ = (function(i,n,o,s){return e(t,i,n,o,s)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(t,require(&quot;ev-emitter&quot;),require(&quot;get-size&quot;),require(&quot;fizzy-ui-utils&quot;),require(&quot;./item&quot;)):t.Outlayer=e(t,t.EvEmitter,t.getSize,t.fizzyUIUtils,t.Outlayer.Item)}(window,function(t,e,i,n,o){&quot;use strict&quot;;function s(t,e){var i=n.getQueryElement(t);if(!i)return void(u&amp;&amp;u.error(&quot;Bad element for &quot;+this.constructor.namespace+&quot;: &quot;+(i||t)));this.element=i,h&amp;&amp;(this.$element=h(this.element)),this.options=n.extend({},this.constructor.defaults),this.option(e);var o=++l;this.element.outlayerGUID=o,f[o]=this,this._create();var s=this._getOption(&quot;initLayout&quot;);s&amp;&amp;this.layout()}function r(t){function e(){t.apply(this,arguments)}return e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e}function a(t){if(&quot;number&quot;==typeof t)return t;var e=t.match(/(^\d*\.?\d*)(\w*)/),i=e&amp;&amp;e[1],n=e&amp;&amp;e[2];if(!i.length)return 0;i=parseFloat(i);var o=c[n]||1;return i*o}var u=t.console,h=t.jQuery,d=function(){},l=0,f={};s.namespace=&quot;outlayer&quot;,s.Item=o,s.defaults={containerStyle:{position:&quot;relative&quot;},initLayout:!0,originLeft:!0,originTop:!0,resize:!0,resizeContainer:!0,transitionDuration:&quot;0.4s&quot;,hiddenStyle:{opacity:0,transform:&quot;scale(0.001)&quot;},visibleStyle:{opacity:1,transform:&quot;scale(1)&quot;}};var m=s.prototype;n.extend(m,e.prototype),m.option=function(t){n.extend(this.options,t)},m._getOption=function(t){var e=this.constructor.compatOptions[t];return e&amp;&amp;void 0!==this.options[e]?this.options[e]:this.options[t]},s.compatOptions={initLayout:&quot;isInitLayout&quot;,horizontal:&quot;isHorizontal&quot;,layoutInstant:&quot;isLayoutInstant&quot;,originLeft:&quot;isOriginLeft&quot;,originTop:&quot;isOriginTop&quot;,resize:&quot;isResizeBound&quot;,resizeContainer:&quot;isResizingContainer&quot;},m._create=function(){this.reloadItems(),this.stamps=[],this.stamp(this.options.stamp),n.extend(this.element.style,this.options.containerStyle);var t=this._getOption(&quot;resize&quot;);t&amp;&amp;this.bindResize()},m.reloadItems=function(){this.items=this._itemize(this.element.children)},m._itemize=function(t){for(var e=this._filterFindItemElements(t),i=this.constructor.Item,n=[],o=0;o&lt;e.length;o++){var s=e[o],r=new i(s,this);n.push(r)}return n},m._filterFindItemElements=function(t){return n.filterFindElements(t,this.options.itemSelector)},m.getItemElements=function(){return this.items.map(function(t){return t.element})},m.layout=function(){this._resetLayout(),this._manageStamps();var t=this._getOption(&quot;layoutInstant&quot;),e=void 0!==t?t:!this._isLayoutInited;this.layoutItems(this.items,e),this._isLayoutInited=!0},m._init=m.layout,m._resetLayout=function(){this.getSize()},m.getSize=function(){this.size=i(this.element)},m._getMeasurement=function(t,e){var n,o=this.options[t];o?(&quot;string&quot;==typeof o?n=this.element.querySelector(o):o instanceof HTMLElement&amp;&amp;(n=o),this[t]=n?i(n)[e]:o):this[t]=0},m.layoutItems=function(t,e){t=this._getItemsForLayout(t),this._layoutItems(t,e),this._postLayout()},m._getItemsForLayout=function(t){return t.filter(function(t){return!t.isIgnored})},m._layoutItems=function(t,e){if(this._emitCompleteOnItems(&quot;layout&quot;,t),t&amp;&amp;t.length){var i=[];t.forEach(function(t){var n=this._getItemLayoutPosition(t);n.item=t,n.isInstant=e||t.isLayoutInstant,i.push(n)},this),this._processLayoutQueue(i)}},m._getItemLayoutPosition=function(){return{x:0,y:0}},m._processLayoutQueue=function(t){this.updateStagger(),t.forEach(function(t,e){this._positionItem(t.item,t.x,t.y,t.isInstant,e)},this)},m.updateStagger=function(){var t=this.options.stagger;return null===t||void 0===t?void(this.stagger=0):(this.stagger=a(t),this.stagger)},m._positionItem=function(t,e,i,n,o){n?t.goTo(e,i):(t.stagger(o*this.stagger),t.moveTo(e,i))},m._postLayout=function(){this.resizeContainer()},m.resizeContainer=function(){var t=this._getOption(&quot;resizeContainer&quot;);if(t){var e=this._getContainerSize();e&amp;&amp;(this._setContainerMeasure(e.width,!0),this._setContainerMeasure(e.height,!1))}},m._getContainerSize=d,m._setContainerMeasure=function(t,e){if(void 0!==t){var i=this.size;i.isBorderBox&amp;&amp;(t+=e?i.paddingLeft+i.paddingRight+i.borderLeftWidth+i.borderRightWidth:i.paddingBottom+i.paddingTop+i.borderTopWidth+i.borderBottomWidth),t=Math.max(t,0),this.element.style[e?&quot;width&quot;:&quot;height&quot;]=t+&quot;px&quot;}},m._emitCompleteOnItems=function(t,e){function i(){o.dispatchEvent(t+&quot;Complete&quot;,null,[e])}function n(){r++,r==s&amp;&amp;i()}var o=this,s=e.length;if(!e||!s)return void i();var r=0;e.forEach(function(e){e.once(t,n)})},m.dispatchEvent=function(t,e,i){var n=e?[e].concat(i):i;if(this.emitEvent(t,n),h)if(this.$element=this.$element||h(this.element),e){var o=h.Event(e);o.type=t,this.$element.trigger(o,i)}else this.$element.trigger(t,i)},m.ignore=function(t){var e=this.getItem(t);e&amp;&amp;(e.isIgnored=!0)},m.unignore=function(t){var e=this.getItem(t);e&amp;&amp;delete e.isIgnored},m.stamp=function(t){t=this._find(t),t&amp;&amp;(this.stamps=this.stamps.concat(t),t.forEach(this.ignore,this))},m.unstamp=function(t){t=this._find(t),t&amp;&amp;t.forEach(function(t){n.removeFrom(this.stamps,t),this.unignore(t)},this)},m._find=function(t){if(t)return&quot;string&quot;==typeof t&amp;&amp;(t=this.element.querySelectorAll(t)),t=n.makeArray(t)},m._manageStamps=function(){this.stamps&amp;&amp;this.stamps.length&amp;&amp;(this._getBoundingRect(),this.stamps.forEach(this._manageStamp,this))},m._getBoundingRect=function(){var t=this.element.getBoundingClientRect(),e=this.size;this._boundingRect={left:t.left+e.paddingLeft+e.borderLeftWidth,top:t.top+e.paddingTop+e.borderTopWidth,right:t.right-(e.paddingRight+e.borderRightWidth),bottom:t.bottom-(e.paddingBottom+e.borderBottomWidth)}},m._manageStamp=d,m._getElementOffset=function(t){var e=t.getBoundingClientRect(),n=this._boundingRect,o=i(t),s={left:e.left-n.left-o.marginLeft,top:e.top-n.top-o.marginTop,right:n.right-e.right-o.marginRight,bottom:n.bottom-e.bottom-o.marginBottom};return s},m.handleEvent=n.handleEvent,m.bindResize=function(){t.addEventListener(&quot;resize&quot;,this),this.isResizeBound=!0},m.unbindResize=function(){t.removeEventListener(&quot;resize&quot;,this),this.isResizeBound=!1},m.onresize=function(){this.resize()},n.debounceMethod(s,&quot;onresize&quot;,100),m.resize=function(){this.isResizeBound&amp;&amp;this.needsResizeLayout()&amp;&amp;this.layout()},m.needsResizeLayout=function(){var t=i(this.element),e=this.size&amp;&amp;t;return e&amp;&amp;t.innerWidth!==this.size.innerWidth},m.addItems=function(t){var e=this._itemize(t);return e.length&amp;&amp;(this.items=this.items.concat(e)),e},m.appended=function(t){var e=this.addItems(t);e.length&amp;&amp;(this.layoutItems(e,!0),this.reveal(e))},m.prepended=function(t){var e=this._itemize(t);if(e.length){var i=this.items.slice(0);this.items=e.concat(i),this._resetLayout(),this._manageStamps(),this.layoutItems(e,!0),this.reveal(e),this.layoutItems(i)}},m.reveal=function(t){if(this._emitCompleteOnItems(&quot;reveal&quot;,t),t&amp;&amp;t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.reveal()})}},m.hide=function(t){if(this._emitCompleteOnItems(&quot;hide&quot;,t),t&amp;&amp;t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.hide()})}},m.revealItemElements=function(t){var e=this.getItems(t);this.reveal(e)},m.hideItemElements=function(t){var e=this.getItems(t);this.hide(e)},m.getItem=function(t){for(var e=0;e&lt;this.items.length;e++){var i=this.items[e];if(i.element==t)return i}},m.getItems=function(t){t=n.makeArray(t);var e=[];return t.forEach(function(t){var i=this.getItem(t);i&amp;&amp;e.push(i)},this),e},m.remove=function(t){var e=this.getItems(t);this._emitCompleteOnItems(&quot;remove&quot;,e),e&amp;&amp;e.length&amp;&amp;e.forEach(function(t){t.remove(),n.removeFrom(this.items,t)},this)},m.destroy=function(){var t=this.element.style;t.height=&quot;&quot;,t.position=&quot;&quot;,t.width=&quot;&quot;,this.items.forEach(function(t){t.destroy()}),this.unbindResize();var e=this.element.outlayerGUID;delete f[e],delete this.element.outlayerGUID,h&amp;&amp;h.removeData(this.element,this.constructor.namespace)},s.data=function(t){t=n.getQueryElement(t);var e=t&amp;&amp;t.outlayerGUID;return e&amp;&amp;f[e]},s.create=function(t,e){var i=r(s);return i.defaults=n.extend({},s.defaults),n.extend(i.defaults,e),i.compatOptions=n.extend({},s.compatOptions),i.namespace=t,i.data=s.data,i.Item=r(o),n.htmlInit(i,t),h&amp;&amp;h.bridget&amp;&amp;h.bridget(t,i),i};var c={ms:1,s:1e3};return s.Item=o,s}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_7__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(require(&quot;outlayer&quot;)):(t.Isotope=t.Isotope||{},t.Isotope.Item=e(t.Outlayer))}(window,function(t){&quot;use strict&quot;;function e(){t.Item.apply(this,arguments)}var i=e.prototype=Object.create(t.Item.prototype),n=i._create;i._create=function(){this.id=this.layout.itemGUID++,n.call(this),this.sortData={}},i.updateSortData=function(){if(!this.isIgnored){this.sortData.id=this.id,this.sortData[&quot;original-order&quot;]=this.id,this.sortData.random=Math.random();var t=this.layout.options.getSortData,e=this.layout._sorters;for(var i in t){var n=e[i];this.sortData[i]=n(this.element,this)}}};var o=i.destroy;return i.destroy=function(){o.apply(this,arguments),this.css({display:&quot;&quot;})},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_6__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_8__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(require(&quot;get-size&quot;),require(&quot;outlayer&quot;)):(t.Isotope=t.Isotope||{},t.Isotope.LayoutMode=e(t.getSize,t.Outlayer))}(window,function(t,e){&quot;use strict&quot;;function i(t){this.isotope=t,t&amp;&amp;(this.options=t.options[this.namespace],this.element=t.element,this.items=t.filteredItems,this.size=t.size)}var n=i.prototype,o=[&quot;_resetLayout&quot;,&quot;_getItemLayoutPosition&quot;,&quot;_manageStamp&quot;,&quot;_getContainerSize&quot;,&quot;_getElementOffset&quot;,&quot;needsResizeLayout&quot;,&quot;_getOption&quot;];return o.forEach(function(t){n[t]=function(){return e.prototype[t].apply(this.isotope,arguments)}}),n.needsVerticalResizeLayout=function(){var e=t(this.isotope.element),i=this.isotope.size&amp;&amp;e;return i&amp;&amp;e.innerHeight!=this.isotope.size.innerHeight},n._getMeasurement=function(){this.isotope._getMeasurement.apply(this,arguments)},n.getColumnWidth=function(){this.getSegmentSize(&quot;column&quot;,&quot;Width&quot;)},n.getRowHeight=function(){this.getSegmentSize(&quot;row&quot;,&quot;Height&quot;)},n.getSegmentSize=function(t,e){var i=t+e,n=&quot;outer&quot;+e;if(this._getMeasurement(i,n),!this[i]){var o=this.getFirstItemSize();this[i]=o&amp;&amp;o[n]||this.isotope.size[&quot;inner&quot;+e]}},n.getFirstItemSize=function(){var e=this.isotope.filteredItems[0];return e&amp;&amp;e.element&amp;&amp;t(e.element)},n.layout=function(){this.isotope.layout.apply(this.isotope,arguments)},n.getSize=function(){this.isotope.getSize(),this.size=this.isotope.size},i.modes={},i.create=function(t,e){function o(){i.apply(this,arguments)}return o.prototype=Object.create(n),o.prototype.constructor=o,e&amp;&amp;(o.options=e),o.prototype.namespace=t,i.modes[t]=o,o},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__,__WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_9__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(require(&quot;outlayer&quot;),require(&quot;get-size&quot;)):t.Masonry=e(t.Outlayer,t.getSize)}(window,function(t,e){var i=t.create(&quot;masonry&quot;);return i.compatOptions.fitWidth=&quot;isFitWidth&quot;,i.prototype._resetLayout=function(){this.getSize(),this._getMeasurement(&quot;columnWidth&quot;,&quot;outerWidth&quot;),this._getMeasurement(&quot;gutter&quot;,&quot;outerWidth&quot;),this.measureColumns(),this.colYs=[];for(var t=0;t&lt;this.cols;t++)this.colYs.push(0);this.maxY=0},i.prototype.measureColumns=function(){if(this.getContainerWidth(),!this.columnWidth){var t=this.items[0],i=t&amp;&amp;t.element;this.columnWidth=i&amp;&amp;e(i).outerWidth||this.containerWidth}var n=this.columnWidth+=this.gutter,o=this.containerWidth+this.gutter,s=o/n,r=n-o%n,a=r&amp;&amp;r&lt;1?&quot;round&quot;:&quot;floor&quot;;s=Math[a](s),this.cols=Math.max(s,1)},i.prototype.getContainerWidth=function(){var t=this._getOption(&quot;fitWidth&quot;),i=t?this.element.parentNode:this.element,n=e(i);this.containerWidth=n&amp;&amp;n.innerWidth},i.prototype._getItemLayoutPosition=function(t){t.getSize();var e=t.size.outerWidth%this.columnWidth,i=e&amp;&amp;e&lt;1?&quot;round&quot;:&quot;ceil&quot;,n=Math[i](t.size.outerWidth/this.columnWidth);n=Math.min(n,this.cols);for(var o=this._getColGroup(n),s=Math.min.apply(Math,o),r=o.indexOf(s),a={x:this.columnWidth*r,y:s},u=s+t.size.outerHeight,h=this.cols+1-o.length,d=0;d&lt;h;d++)this.colYs[r+d]=u;return a},i.prototype._getColGroup=function(t){if(t&lt;2)return this.colYs;for(var e=[],i=this.cols+1-t,n=0;n&lt;i;n++){var o=this.colYs.slice(n,n+t);e[n]=Math.max.apply(Math,o)}return e},i.prototype._manageStamp=function(t){var i=e(t),n=this._getElementOffset(t),o=this._getOption(&quot;originLeft&quot;),s=o?n.left:n.right,r=s+i.outerWidth,a=Math.floor(s/this.columnWidth);a=Math.max(0,a);var u=Math.floor(r/this.columnWidth);u-=r%this.columnWidth?0:1,u=Math.min(this.cols-1,u);for(var h=this._getOption(&quot;originTop&quot;),d=(h?n.top:n.bottom)+i.outerHeight,l=a;l&lt;=u;l++)this.colYs[l]=Math.max(d,this.colYs[l])},i.prototype._getContainerSize=function(){this.maxY=Math.max.apply(Math,this.colYs);var t={height:this.maxY};return this._getOption(&quot;fitWidth&quot;)&amp;&amp;(t.width=this._getContainerFitWidth()),t},i.prototype._getContainerFitWidth=function(){for(var t=0,e=this.cols;--e&amp;&amp;0===this.colYs[e];)t++;return(this.cols-t)*this.columnWidth-this.gutter},i.prototype.needsResizeLayout=function(){var t=this.containerWidth;return this.getContainerWidth(),t!=this.containerWidth},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_8__,__WEBPACK_LOCAL_MODULE_9__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_10__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(require(&quot;../layout-mode&quot;),require(&quot;masonry-layout&quot;)):e(t.Isotope.LayoutMode,t.Masonry)}(window,function(t,e){&quot;use strict&quot;;var i=t.create(&quot;masonry&quot;),n=i.prototype,o={_getElementOffset:!0,layout:!0,_getMeasurement:!0};for(var s in e.prototype)o[s]||(n[s]=e.prototype[s]);var r=n.measureColumns;n.measureColumns=function(){this.items=this.isotope.filteredItems,r.call(this)};var a=n._getOption;return n._getOption=function(t){return&quot;fitWidth&quot;==t?void 0!==this.options.isFitWidth?this.options.isFitWidth:this.options.fitWidth:a.apply(this.isotope,arguments)},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_11__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof exports?module.exports=e(require(&quot;../layout-mode&quot;)):e(t.Isotope.LayoutMode)}(window,function(t){&quot;use strict&quot;;var e=t.create(&quot;fitRows&quot;),i=e.prototype;return i._resetLayout=function(){this.x=0,this.y=0,this.maxY=0,this._getMeasurement(&quot;gutter&quot;,&quot;outerWidth&quot;)},i._getItemLayoutPosition=function(t){t.getSize();var e=t.size.outerWidth+this.gutter,i=this.isotope.size.innerWidth+this.gutter;0!==this.x&amp;&amp;e+this.x&gt;i&amp;&amp;(this.x=0,this.y=this.maxY);var n={x:this.x,y:this.y};return this.maxY=Math.max(this.maxY,this.y+t.size.outerHeight),this.x+=e,n},i._getContainerSize=function(){return{height:this.maxY}},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_12__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(require(&quot;../layout-mode&quot;)):e(t.Isotope.LayoutMode)}(window,function(t){&quot;use strict&quot;;var e=t.create(&quot;vertical&quot;,{horizontalAlignment:0}),i=e.prototype;return i._resetLayout=function(){this.y=0},i._getItemLayoutPosition=function(t){t.getSize();var e=(this.isotope.size.innerWidth-t.size.outerWidth)*this.options.horizontalAlignment,i=this.y;return this.y+=t.size.outerHeight,{x:e,y:i}},i._getContainerSize=function(){return{height:this.y}},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__,__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_3__,__WEBPACK_LOCAL_MODULE_4__,__WEBPACK_LOCAL_MODULE_7__,__WEBPACK_LOCAL_MODULE_8__,__WEBPACK_LOCAL_MODULE_10__,__WEBPACK_LOCAL_MODULE_11__,__WEBPACK_LOCAL_MODULE_12__], __WEBPACK_AMD_DEFINE_RESULT__ = function(i,n,o,s,r,a){return e(t,i,n,o,s,r,a)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):&quot;object&quot;==typeof module&amp;&amp;module.exports?module.exports=e(t,require(&quot;outlayer&quot;),require(&quot;get-size&quot;),require(&quot;desandro-matches-selector&quot;),require(&quot;fizzy-ui-utils&quot;),require(&quot;isotope/js/item&quot;),require(&quot;isotope/js/layout-mode&quot;),require(&quot;isotope/js/layout-modes/masonry&quot;),require(&quot;isotope/js/layout-modes/fit-rows&quot;),require(&quot;isotope/js/layout-modes/vertical&quot;)):t.Isotope=e(t,t.Outlayer,t.getSize,t.matchesSelector,t.fizzyUIUtils,t.Isotope.Item,t.Isotope.LayoutMode)}(window,function(t,e,i,n,o,s,r){function a(t,e){return function(i,n){for(var o=0;o&lt;t.length;o++){var s=t[o],r=i.sortData[s],a=n.sortData[s];if(r&gt;a||r&lt;a){var u=void 0!==e[s]?e[s]:e,h=u?1:-1;return(r&gt;a?1:-1)*h}}return 0}}var u=t.jQuery,h=String.prototype.trim?function(t){return t.trim()}:function(t){return t.replace(/^\s+|\s+$/g,&quot;&quot;)},d=e.create(&quot;isotope&quot;,{layoutMode:&quot;masonry&quot;,isJQueryFiltering:!0,sortAscending:!0});d.Item=s,d.LayoutMode=r;var l=d.prototype;l._create=function(){this.itemGUID=0,this._sorters={},this._getSorters(),e.prototype._create.call(this),this.modes={},this.filteredItems=this.items,this.sortHistory=[&quot;original-order&quot;];for(var t in r.modes)this._initLayoutMode(t)},l.reloadItems=function(){this.itemGUID=0,e.prototype.reloadItems.call(this)},l._itemize=function(){for(var t=e.prototype._itemize.apply(this,arguments),i=0;i&lt;t.length;i++){var n=t[i];n.id=this.itemGUID++}return this._updateItemsSortData(t),t},l._initLayoutMode=function(t){var e=r.modes[t],i=this.options[t]||{};this.options[t]=e.options?o.extend(e.options,i):i,this.modes[t]=new e(this)},l.layout=function(){return!this._isLayoutInited&amp;&amp;this._getOption(&quot;initLayout&quot;)?void this.arrange():void this._layout()},l._layout=function(){var t=this._getIsInstant();this._resetLayout(),this._manageStamps(),this.layoutItems(this.filteredItems,t),this._isLayoutInited=!0},l.arrange=function(t){this.option(t),this._getIsInstant();var e=this._filter(this.items);this.filteredItems=e.matches,this._bindArrangeComplete(),this._isInstant?this._noTransition(this._hideReveal,[e]):this._hideReveal(e),this._sort(),this._layout()},l._init=l.arrange,l._hideReveal=function(t){this.reveal(t.needReveal),this.hide(t.needHide)},l._getIsInstant=function(){var t=this._getOption(&quot;layoutInstant&quot;),e=void 0!==t?t:!this._isLayoutInited;return this._isInstant=e,e},l._bindArrangeComplete=function(){function t(){e&amp;&amp;i&amp;&amp;n&amp;&amp;o.dispatchEvent(&quot;arrangeComplete&quot;,null,[o.filteredItems])}var e,i,n,o=this;this.once(&quot;layoutComplete&quot;,function(){e=!0,t()}),this.once(&quot;hideComplete&quot;,function(){i=!0,t()}),this.once(&quot;revealComplete&quot;,function(){n=!0,t()})},l._filter=function(t){var e=this.options.filter;e=e||&quot;*&quot;;for(var i=[],n=[],o=[],s=this._getFilterTest(e),r=0;r&lt;t.length;r++){var a=t[r];if(!a.isIgnored){var u=s(a);u&amp;&amp;i.push(a),u&amp;&amp;a.isHidden?n.push(a):u||a.isHidden||o.push(a)}}return{matches:i,needReveal:n,needHide:o}},l._getFilterTest=function(t){return u&amp;&amp;this.options.isJQueryFiltering?function(e){return u(e.element).is(t)}:&quot;function&quot;==typeof t?function(e){return t(e.element)}:function(e){return n(e.element,t)}},l.updateSortData=function(t){var e;t?(t=o.makeArray(t),e=this.getItems(t)):e=this.items,this._getSorters(),this._updateItemsSortData(e)},l._getSorters=function(){var t=this.options.getSortData;for(var e in t){var i=t[e];this._sorters[e]=f(i)}},l._updateItemsSortData=function(t){for(var e=t&amp;&amp;t.length,i=0;e&amp;&amp;i&lt;e;i++){var n=t[i];n.updateSortData()}};var f=function(){function t(t){if(&quot;string&quot;!=typeof t)return t;var i=h(t).split(&quot; &quot;),n=i[0],o=n.match(/^\[(.+)\]$/),s=o&amp;&amp;o[1],r=e(s,n),a=d.sortDataParsers[i[1]];
	    return t=a?function(t){return t&amp;&amp;a(r(t))}:function(t){return t&amp;&amp;r(t)}}function e(t,e){return t?function(e){return e.getAttribute(t)}:function(t){var i=t.querySelector(e);return i&amp;&amp;i.textContent}}return t}();d.sortDataParsers={parseInt:function(t){return parseInt(t,10)},parseFloat:function(t){return parseFloat(t)}},l._sort=function(){if(this.options.sortBy){var t=o.makeArray(this.options.sortBy);this._getIsSameSortBy(t)||(this.sortHistory=t.concat(this.sortHistory));var e=a(this.sortHistory,this.options.sortAscending);this.filteredItems.sort(e)}},l._getIsSameSortBy=function(t){for(var e=0;e&lt;t.length;e++)if(t[e]!=this.sortHistory[e])return!1;return!0},l._mode=function(){var t=this.options.layoutMode,e=this.modes[t];if(!e)throw new Error(&quot;No layout mode: &quot;+t);return e.options=this.options[t],e},l._resetLayout=function(){e.prototype._resetLayout.call(this),this._mode()._resetLayout()},l._getItemLayoutPosition=function(t){return this._mode()._getItemLayoutPosition(t)},l._manageStamp=function(t){this._mode()._manageStamp(t)},l._getContainerSize=function(){return this._mode()._getContainerSize()},l.needsResizeLayout=function(){return this._mode().needsResizeLayout()},l.appended=function(t){var e=this.addItems(t);if(e.length){var i=this._filterRevealAdded(e);this.filteredItems=this.filteredItems.concat(i)}},l.prepended=function(t){var e=this._itemize(t);if(e.length){this._resetLayout(),this._manageStamps();var i=this._filterRevealAdded(e);this.layoutItems(this.filteredItems),this.filteredItems=i.concat(this.filteredItems),this.items=e.concat(this.items)}},l._filterRevealAdded=function(t){var e=this._filter(t);return this.hide(e.needHide),this.reveal(e.matches),this.layoutItems(e.matches,!0),e.matches},l.insert=function(t){var e=this.addItems(t);if(e.length){var i,n,o=e.length;for(i=0;i&lt;o;i++)n=e[i],this.element.appendChild(n.element);var s=this._filter(e).matches;for(i=0;i&lt;o;i++)e[i].isLayoutInstant=!0;for(this.arrange(),i=0;i&lt;o;i++)delete e[i].isLayoutInstant;this.reveal(s)}};var m=l.remove;return l.remove=function(t){t=o.makeArray(t);var e=this.getItems(t);m.call(this,t);for(var i=e&amp;&amp;e.length,n=0;i&amp;&amp;n&lt;i;n++){var s=e[n];o.removeFrom(this.filteredItems,s)}},l.shuffle=function(){for(var t=0;t&lt;this.items.length;t++){var e=this.items[t];e.sortData.random=Math.random()}this.options.sortBy=&quot;random&quot;,this._sort(),this._layout()},l._noTransition=function(t,e){var i=this.options.transitionDuration;this.options.transitionDuration=0;var n=t.apply(this,e);return this.options.transitionDuration=i,n},l.getFilteredItemElements=function(){return this.filteredItems.map(function(t){return t.element})},d});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/* PaperPanel
	 *
	 * @type Object
	 * @description $.PaperPanel is the main object for the template&#x27;s app.
	 *              It&#x27;s used for implementing functions and options related
	 *              to the template. Keeping everything wrapped in an object
	 *              prevents conflict with other plugins and is a better
	 *              way to organize our code.
	 */

	__webpack_require__(28);

	$.PaperPanel = {};

	/* --------------------
	 * - PaperPanel Options -
	 * --------------------
	 * Modify these options to suit your implementation
	 */
	$.PaperPanel.options = {

	    animationSpeed: 500,
	    //Sidebar push menu toggle button selector
	    sidebarToggleSelector: &quot;[data-toggle=&#x27;offcanvas&#x27;]&quot;,
	    //Activate sidebar push menu
	    sidebarPushMenu: true,
	    navbarMenuSlimscrollWidth: &quot;3px&quot;,
	    sidebarSlimScroll: true,
	    controlSidebarOptions: {
	        //Which button should trigger the open/close event
	        toggleBtnSelector: &quot;[data-toggle=&#x27;control-sidebar&#x27;]&quot;,
	        //The sidebar selector
	        selector: &quot;.control-sidebar&quot;,
	        //Enable slide over content
	        slide: true
	    },

	    //The standard screen sizes that bootstrap uses.
	    //If you change these in the variables.less file, change
	    //them here too.
	    screenSizes: {
	        xs: 480,
	        sm: 768,
	        md: 1025,
	        lg: 1200
	    }
	};

	/* ------------------
	 * - Implementation -
	 * ------------------
	 * The next block of code implements PaperPanel&#x27;s
	 * functions and plugins as specified by the
	 * options above.
	 */
	$(function () {
	    &quot;use strict&quot;;

	    //Fix for IE page transitions
	    $(&quot;body&quot;).removeClass(&quot;hold-transition&quot;);

	    //Extend options if external options exist
	    if (typeof PaperPanelOptions !== &quot;undefined&quot;) {
	        $.extend(true,
	            $.PaperPanel.options,
	            PaperPanelOptions);
	    }

	    //Easy access to options
	    var o = $.PaperPanel.options;

	    //Set up the object
	    _init();

	    //Activate the layout maker
	    $.PaperPanel.layout.activate();

	    //Enable sidebar tree view controls
	    $.PaperPanel.tree(&#x27;.sidebar&#x27;);

	    //Enable control sidebar
	    if (o.enableControlSidebar) {
	        $.PaperPanel.controlSidebar.activate();
	    }

	    //Activate sidebar push menu
	    if (o.sidebarPushMenu) {
	        $.PaperPanel.pushMenu.activate(o.sidebarToggleSelector);
	    }
	    /*
	     * INITIALIZE BUTTON TOGGLE
	     * ------------------------
	     */

	    $(&#x27;.btn-group[data-toggle=&quot;btn-toggle&quot;]&#x27;).each(function () {
	        var group = $(this);
	        $(this).find(&quot;.btn&quot;).on(&#x27;click&#x27;, function (e) {
	            group.find(&quot;.btn.active&quot;).removeClass(&quot;active&quot;);
	            $(this).addClass(&quot;active&quot;);
	            e.preventDefault();
	        });

	    });
	});

	/* ----------------------------------
	 * - Initialize the PaperPanel Object -
	 * ----------------------------------
	 * All PaperPanel functions are implemented below.
	 */
	function _init() {
	    &#x27;use strict&#x27;;
	    /* Layout
	     * ======
	     * Fixes the layout height in case min-height fails.
	     *
	     * @type Object
	     * @usage $.PaperPanel.layout.activate()
	     *        $.PaperPanel.layout.fix()
	     *        $.PaperPanel.layout.fixSidebar()
	     */

	    var slimScroll = $(&quot;.slimScroll&quot;);

	    if(slimScroll.length){
	        slimScroll.each(function () {
	            var $this = $(this);
	            var attrData =$this.data();
	            $this.slimscroll({
	                height: attrData.height ? attrData.height+&#x27;px&#x27; : ($(window).height()) + &quot;px&quot;,
	                color: attrData.color ? attrData.color : &quot;rgba(0,0,0,0.95)&quot;,
	                size:  attrData.size ? attrData.size +&#x27;px&#x27; : &quot;5px&quot;
	            });
	        });
	    }


	    $.PaperPanel.layout = {
	        activate: function () {
	            var _this = this;
	            _this.fix();
	            _this.fixSidebar();
	            $(window, &quot;.wrapper&quot;).resize(function () {
	                _this.fix();
	                _this.fixSidebar();
	            });
	        },
	        fix: function () {
	            //Get window height and the wrapper height
	            var neg = $(&#x27;.main-header&#x27;).outerHeight() + $(&#x27;.main-footer&#x27;).outerHeight();
	            var window_height = $(window).height();
	            var sidebar_height = $(&quot;.sidebar&quot;).height();
	            //Set the min-height of the content and sidebar based on the
	            //the height of the document.
	            if ($(&quot;body&quot;).hasClass(&quot;fixed&quot;)) {
	                $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, window_height - $(&#x27;.main-footer&#x27;).outerHeight());
	            } else {
	                var postSetWidth;
	                if (window_height &gt;= sidebar_height) {
	                    $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, window_height - neg);
	                    postSetWidth = window_height - neg;
	                } else {
	                    $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, sidebar_height);
	                    postSetWidth = sidebar_height;
	                }

	                //Fix for the control sidebar height
	                var controlSidebar = $($.PaperPanel.options.controlSidebarOptions.selector);
	                if (typeof controlSidebar !== &quot;undefined&quot;) {
	                    if (controlSidebar.height() &gt; postSetWidth)
	                        $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, controlSidebar.height());
	                }

	            }
	        },
	        fixSidebar: function () {
	            //Make sure the body tag has the .fixed class
	            if (!$(&quot;.main-sidebar&quot;).hasClass(&quot;fixed&quot;)) {
	                if (typeof $.fn.slimScroll != &#x27;undefined&#x27;) {
	                    $(&quot;.sidebar&quot;).slimScroll({destroy: true}).height(&quot;auto&quot;);

	                }
	                return;
	            } else if (typeof $.fn.slimScroll == &#x27;undefined&#x27; &amp;&amp; window.console) {
	                window.console.error(&quot;Error: the fixed layout requires the slimscroll plugin!&quot;);
	            }
	            //Enable slimscroll for fixed layout
	            if ($.PaperPanel.options.sidebarSlimScroll) {
	                if (typeof $.fn.slimScroll != &#x27;undefined&#x27;) {
	                    //Destroy if it exists
	                    $(&quot;.sidebar&quot;).slimScroll({destroy: true}).height(&quot;auto&quot;);
	                    //Add slimscroll

	                    $(&quot;.sidebar&quot;).slimscroll({
	                        height: ($(window).height()) + &quot;px&quot;,
	                        color: &quot;rgba(0,0,0,0.3)&quot;,
	                        size: &quot;5px&quot;
	                    });
	                }
	            }
	        }
	    };


	    /* PushMenu()
	     * ==========
	     * Adds the push menu functionality to the sidebar.
	     *
	     * @type Function
	     * @usage: $.PaperPanel.pushMenu(&quot;[data-toggle=&#x27;offcanvas&#x27;]&quot;)
	     */
	    $.PaperPanel.pushMenu = {
	        activate: function (toggleBtn) {
	            //Get the screen sizes
	            var screenSizes = $.PaperPanel.options.screenSizes;

	            //Enable sidebar toggle
	            $(document).on(&#x27;click&#x27;, toggleBtn, function (e) {
	                e.preventDefault();
	                e.stopPropagation();
	                //Enable sidebar push menu
	                if ($(window).width() &gt; (screenSizes.md - 1)) {
	                    if ($(&quot;body&quot;).hasClass(&#x27;sidebar-collapse&#x27;)) {
	                        $(&quot;body&quot;).removeClass(&#x27;sidebar-collapse&#x27;).trigger(&#x27;expanded.pushMenu&#x27;);
	                        if ($(&#x27;.nav-offcanvas-desktop&#x27;).length) {
	                            $(&quot;body&quot;).addClass(&#x27;sidebar-open&#x27;).trigger(&#x27;expanded.pushMenu&#x27;);
	                        }

	                    } else {
	                        $(&quot;body&quot;).addClass(&#x27;sidebar-collapse&#x27;).trigger(&#x27;collapsed.pushMenu&#x27;);
	                    }
	                }
	                //Handle sidebar push menu for small screens
	                else {
	                    if ($(&quot;body&quot;).hasClass(&#x27;sidebar-open&#x27;)) {
	                        $(&quot;body&quot;).removeClass(&#x27;sidebar-open&#x27;).removeClass(&#x27;sidebar-collapse&#x27;).trigger(&#x27;collapsed.pushMenu&#x27;);
	                    } else {
	                        $(&quot;body&quot;).addClass(&#x27;sidebar-open&#x27;).trigger(&#x27;expanded.pushMenu&#x27;);
	                    }
	                }
	            });

	            $(&quot;.content-wrapper&quot;).click(function () {
	                //Enable hide menu when clicking on the content-wrapper on small screens
	                if ($(window).width() &lt;= (screenSizes.md - 1) &amp;&amp; $(&quot;body&quot;).hasClass(&quot;sidebar-open&quot;)) {
	                    $(&quot;body&quot;).removeClass(&#x27;sidebar-open&#x27;);
	                }
	            });


	        },
	        expandOnHover: function () {
	            var _this = this;
	            var screenWidth = $.PaperPanel.options.screenSizes.sm - 1;
	            //Expand sidebar on hover
	            $(&#x27;.main-sidebar&#x27;).hover(function () {
	                if ($(&#x27;body&#x27;).hasClass(&#x27;sidebar-mini&#x27;) &amp;&amp;
	                    $(&quot;body&quot;).hasClass(&#x27;sidebar-collapse&#x27;) &amp;&amp;
	                    $(window).width() &gt; screenWidth) {
	                    _this.expand();
	                }
	            }, function () {
	                if ($(&#x27;body&#x27;).hasClass(&#x27;sidebar-mini&#x27;) &amp;&amp;
	                    $(&#x27;body&#x27;).hasClass(&#x27;sidebar-expanded-on-hover&#x27;) &amp;&amp;
	                    $(window).width() &gt; screenWidth) {
	                    _this.collapse();
	                }
	            });
	        },
	        expand: function () {
	            $(&quot;body&quot;).removeClass(&#x27;sidebar-collapse&#x27;).addClass(&#x27;sidebar-expanded-on-hover&#x27;);
	        },
	        collapse: function () {
	            if ($(&#x27;body&#x27;).hasClass(&#x27;sidebar-expanded-on-hover&#x27;)) {
	                $(&#x27;body&#x27;).removeClass(&#x27;sidebar-expanded-on-hover&#x27;).addClass(&#x27;sidebar-collapse&#x27;);
	            }
	        }
	    };

	    /* Tree()
	     * ======
	     * Converts the sidebar into a multilevel
	     * tree view menu.
	     *
	     * @type Function
	     * @Usage: $.PaperPanel.tree(&#x27;.sidebar&#x27;)
	     */
	    $.PaperPanel.tree = function (menu) {
	        var _this = this;
	        var animationSpeed = $.PaperPanel.options.animationSpeed;
	        $(document).on(&#x27;click&#x27;, menu + &#x27; li a&#x27;, function (e) {
	            //Get the clicked link and the next element
	            var $this = $(this);
	            var checkElement = $this.next();

	            //Check if the next element is a menu and is visible
	            if ((checkElement.is(&#x27;.treeview-menu&#x27;)) &amp;&amp; (checkElement.is(&#x27;:visible&#x27;)) &amp;&amp; (!$(&#x27;body&#x27;).hasClass(&#x27;sidebar-collapse&#x27;))) {
	                //Close the menu
	                checkElement.slideUp(animationSpeed, function () {
	                    checkElement.removeClass(&#x27;menu-open&#x27;);
	                    //Fix the layout in case the sidebar stretches over the height of the window
	                    //_this.layout.fix();
	                });
	                checkElement.parent(&quot;li&quot;).removeClass(&quot;active&quot;);
	            }
	            //If the menu is not visible
	            else if ((checkElement.is(&#x27;.treeview-menu&#x27;)) &amp;&amp; (!checkElement.is(&#x27;:visible&#x27;))) {
	                //Get the parent menu
	                var parent = $this.parents(&#x27;ul&#x27;).first();
	                //Close all open menus within the parent
	                var ul = parent.find(&#x27;ul:visible&#x27;).slideUp(animationSpeed);
	                //Remove the menu-open class from the parent
	                ul.removeClass(&#x27;menu-open&#x27;);
	                //Get the parent li
	                var parent_li = $this.parent(&quot;li&quot;);

	                //Open the target menu and add the menu-open class
	                checkElement.slideDown(animationSpeed, function () {
	                    //Add the class active to the parent li
	                    checkElement.addClass(&#x27;menu-open&#x27;);
	                    parent.find(&#x27;li.active&#x27;).removeClass(&#x27;active&#x27;);
	                    parent_li.addClass(&#x27;active&#x27;);
	                    //Fix the layout in case the sidebar stretches over the height of the window
	                    _this.layout.fix();
	                });
	            }
	            //if this isn&#x27;t a link, prevent the page from being redirected
	            if (checkElement.is(&#x27;.treeview-menu&#x27;)) {
	                e.preventDefault();
	            }
	        });
	    };
	}

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
	 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
	 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
	 *
	 * Version: 1.3.8
	 *
	 */
	(function ($) {

	    $.fn.extend({
	        slimScroll: function (options) {

	            var defaults = {

	                // width in pixels of the visible scroll area
	                width: &#x27;auto&#x27;,

	                // height in pixels of the visible scroll area
	                height: &#x27;250px&#x27;,

	                // width in pixels of the scrollbar and rail
	                size: &#x27;7px&#x27;,

	                // scrollbar color, accepts any hex/color value
	                color: &#x27;#000&#x27;,

	                // scrollbar position - left/right
	                position: &#x27;right&#x27;,

	                // distance in pixels between the side edge and the scrollbar
	                distance: &#x27;1px&#x27;,

	                // default scroll position on load - top / bottom / $(&#x27;selector&#x27;)
	                start: &#x27;top&#x27;,

	                // sets scrollbar opacity
	                opacity: .4,

	                // enables always-on mode for the scrollbar
	                alwaysVisible: false,

	                // check if we should hide the scrollbar when user is hovering over
	                disableFadeOut: false,

	                // sets visibility of the rail
	                railVisible: false,

	                // sets rail color
	                railColor: &#x27;#333&#x27;,

	                // sets rail opacity
	                railOpacity: .2,

	                // whether  we should use jQuery UI Draggable to enable bar dragging
	                railDraggable: true,

	                // defautlt CSS class of the slimscroll rail
	                railClass: &#x27;slimScrollRail&#x27;,

	                // defautlt CSS class of the slimscroll bar
	                barClass: &#x27;slimScrollBar&#x27;,

	                // defautlt CSS class of the slimscroll wrapper
	                wrapperClass: &#x27;slimScrollDiv&#x27;,

	                // check if mousewheel should scroll the window if we reach top/bottom
	                allowPageScroll: false,

	                // scroll amount applied to each mouse wheel step
	                wheelStep: 20,

	                // scroll amount applied when user is using gestures
	                touchScrollStep: 200,

	                // sets border radius
	                borderRadius: &#x27;7px&#x27;,

	                // sets border radius of the rail
	                railBorderRadius: &#x27;7px&#x27;
	            };

	            var o = $.extend(defaults, options);

	            // do it for every element that matches selector
	            this.each(function () {

	                var isOverPanel, isOverBar, isDragg, queueHide, touchDif,
	                    barHeight, percentScroll, lastScroll,
	                    divS = &#x27;&lt;div&gt;&lt;/div&gt;&#x27;,
	                    minBarHeight = 30,
	                    releaseScroll = false;

	                // used in event handlers and for better minification
	                var me = $(this);

	                // ensure we are not binding it again
	                if (me.parent().hasClass(o.wrapperClass)) {
	                    // start from last bar position
	                    var offset = me.scrollTop();

	                    // find bar and rail
	                    bar = me.siblings(&#x27;.&#x27; + o.barClass);
	                    rail = me.siblings(&#x27;.&#x27; + o.railClass);

	                    getBarHeight();

	                    // check if we should scroll existing instance
	                    if ($.isPlainObject(options)) {
	                        // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
	                        if (&#x27;height&#x27; in options &amp;&amp; options.height == &#x27;auto&#x27;) {
	                            me.parent().css(&#x27;height&#x27;, &#x27;auto&#x27;);
	                            me.css(&#x27;height&#x27;, &#x27;auto&#x27;);
	                            var height = me.parent().parent().height();
	                            me.parent().css(&#x27;height&#x27;, height);
	                            me.css(&#x27;height&#x27;, height);
	                        } else if (&#x27;height&#x27; in options) {
	                            var h = options.height;
	                            me.parent().css(&#x27;height&#x27;, h);
	                            me.css(&#x27;height&#x27;, h);
	                        }

	                        if (&#x27;scrollTo&#x27; in options) {
	                            // jump to a static point
	                            offset = parseInt(o.scrollTo);
	                        }
	                        else if (&#x27;scrollBy&#x27; in options) {
	                            // jump by value pixels
	                            offset += parseInt(o.scrollBy);
	                        }
	                        else if (&#x27;destroy&#x27; in options) {
	                            // remove slimscroll elements
	                            bar.remove();
	                            rail.remove();
	                            me.unwrap();
	                            return;
	                        }

	                        // scroll content by the given offset
	                        scrollContent(offset, false, true);
	                    }

	                    return;
	                }
	                else if ($.isPlainObject(options)) {
	                    if (&#x27;destroy&#x27; in options) {
	                        return;
	                    }
	                }

	                // optionally set height to the parent&#x27;s height
	                o.height = (o.height == &#x27;auto&#x27;) ? me.parent().height() : o.height;

	                // wrap content
	                var wrapper = $(divS)
	                    .addClass(o.wrapperClass)
	                    .css({
	                        position: &#x27;relative&#x27;,
	                        overflow: &#x27;hidden&#x27;,
	                        width: o.width,
	                        height: o.height
	                    });

	                // update style for the div
	                me.css({
	                    overflow: &#x27;hidden&#x27;,
	                    width: o.width,
	                    height: o.height
	                });

	                // create scrollbar rail
	                var rail = $(divS)
	                    .addClass(o.railClass)
	                    .css({
	                        width: o.size,
	                        height: &#x27;100%&#x27;,
	                        position: &#x27;absolute&#x27;,
	                        top: 0,
	                        display: (o.alwaysVisible &amp;&amp; o.railVisible) ? &#x27;block&#x27; : &#x27;none&#x27;,
	                        &#x27;border-radius&#x27;: o.railBorderRadius,
	                        background: o.railColor,
	                        opacity: o.railOpacity,
	                        zIndex: 90
	                    });

	                // create scrollbar
	                var bar = $(divS)
	                    .addClass(o.barClass)
	                    .css({
	                        background: o.color,
	                        width: o.size,
	                        position: &#x27;absolute&#x27;,
	                        top: 0,
	                        opacity: o.opacity,
	                        display: o.alwaysVisible ? &#x27;block&#x27; : &#x27;none&#x27;,
	                        &#x27;border-radius&#x27;: o.borderRadius,
	                        BorderRadius: o.borderRadius,
	                        MozBorderRadius: o.borderRadius,
	                        WebkitBorderRadius: o.borderRadius,
	                        zIndex: 99
	                    });

	                // set position
	                var posCss = (o.position == &#x27;right&#x27;) ? {right: o.distance} : {left: o.distance};
	                rail.css(posCss);
	                bar.css(posCss);

	                // wrap it
	                me.wrap(wrapper);

	                // append to parent div
	                me.parent().append(bar);
	                me.parent().append(rail);

	                // make it draggable and no longer dependent on the jqueryUI
	                if (o.railDraggable) {
	                    bar.bind(&quot;mousedown&quot;, function (e) {
	                        var $doc = $(document);
	                        isDragg = true;
	                        t = parseFloat(bar.css(&#x27;top&#x27;));
	                        pageY = e.pageY;

	                        $doc.bind(&quot;mousemove.slimscroll&quot;, function (e) {
	                            currTop = t + e.pageY - pageY;
	                            bar.css(&#x27;top&#x27;, currTop);
	                            scrollContent(0, bar.position().top, false);// scroll content
	                        });

	                        $doc.bind(&quot;mouseup.slimscroll&quot;, function (e) {
	                            isDragg = false;
	                            hideBar();
	                            $doc.unbind(&#x27;.slimscroll&#x27;);
	                        });
	                        return false;
	                    }).bind(&quot;selectstart.slimscroll&quot;, function (e) {
	                        e.stopPropagation();
	                        e.preventDefault();
	                        return false;
	                    });
	                }

	                // on rail over
	                rail.hover(function () {
	                    showBar();
	                }, function () {
	                    hideBar();
	                });

	                // on bar over
	                bar.hover(function () {
	                    isOverBar = true;
	                }, function () {
	                    isOverBar = false;
	                });

	                // show on parent mouseover
	                me.hover(function () {
	                    isOverPanel = true;
	                    showBar();
	                    hideBar();
	                }, function () {
	                    isOverPanel = false;
	                    hideBar();
	                });

	                // support for mobile
	                me.bind(&#x27;touchstart&#x27;, function (e, b) {
	                    if (e.originalEvent.touches.length) {
	                        // record where touch started
	                        touchDif = e.originalEvent.touches[0].pageY;
	                    }
	                });

	                me.bind(&#x27;touchmove&#x27;, function (e) {
	                    // prevent scrolling the page if necessary
	                    if (!releaseScroll) {
	                        e.originalEvent.preventDefault();
	                    }
	                    if (e.originalEvent.touches.length) {
	                        // see how far user swiped
	                        var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
	                        // scroll content
	                        scrollContent(diff, true);
	                        touchDif = e.originalEvent.touches[0].pageY;
	                    }
	                });

	                // set up initial height
	                getBarHeight();

	                // check start position
	                if (o.start === &#x27;bottom&#x27;) {
	                    // scroll content to bottom
	                    bar.css({top: me.outerHeight() - bar.outerHeight()});
	                    scrollContent(0, true);
	                }
	                else if (o.start !== &#x27;top&#x27;) {
	                    // assume jQuery selector
	                    scrollContent($(o.start).position().top, null, true);

	                    // make sure bar stays hidden
	                    if (!o.alwaysVisible) {
	                        bar.hide();
	                    }
	                }

	                // attach scroll events
	                attachWheel(this);

	                function _onWheel(e) {
	                    // use mouse wheel only when mouse is over
	                    if (!isOverPanel) {
	                        return;
	                    }

	                    var e = e || window.event;

	                    var delta = 0;
	                    if (e.wheelDelta) {
	                        delta = -e.wheelDelta / 120;
	                    }
	                    if (e.detail) {
	                        delta = e.detail / 3;
	                    }

	                    var target = e.target || e.srcTarget || e.srcElement;
	                    if ($(target).closest(&#x27;.&#x27; + o.wrapperClass).is(me.parent())) {
	                        // scroll content
	                        scrollContent(delta, true);
	                    }

	                    // stop window scroll
	                    if (e.preventDefault &amp;&amp; !releaseScroll) {
	                        e.preventDefault();
	                    }
	                    if (!releaseScroll) {
	                        e.returnValue = false;
	                    }
	                }

	                function scrollContent(y, isWheel, isJump) {
	                    releaseScroll = false;
	                    var delta = y;
	                    var maxTop = me.outerHeight() - bar.outerHeight();

	                    if (isWheel) {
	                        // move bar with mouse wheel
	                        delta = parseInt(bar.css(&#x27;top&#x27;)) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();

	                        // move bar, make sure it doesn&#x27;t go out
	                        delta = Math.min(Math.max(delta, 0), maxTop);

	                        // if scrolling down, make sure a fractional change to the
	                        // scroll position isn&#x27;t rounded away when the scrollbar&#x27;s CSS is set
	                        // this flooring of delta would happened automatically when
	                        // bar.css is set below, but we floor here for clarity
	                        delta = (y &gt; 0) ? Math.ceil(delta) : Math.floor(delta);

	                        // scroll the scrollbar
	                        bar.css({top: delta + &#x27;px&#x27;});
	                    }

	                    // calculate actual scroll amount
	                    percentScroll = parseInt(bar.css(&#x27;top&#x27;)) / (me.outerHeight() - bar.outerHeight());
	                    delta = percentScroll * (me[0].scrollHeight - me.outerHeight());

	                    if (isJump) {
	                        delta = y;
	                        var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
	                        offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
	                        bar.css({top: offsetTop + &#x27;px&#x27;});
	                    }

	                    // scroll content
	                    me.scrollTop(delta);

	                    // fire scrolling event
	                    me.trigger(&#x27;slimscrolling&#x27;, ~~delta);

	                    // ensure bar is visible
	                    showBar();

	                    // trigger hide when scroll is stopped
	                    hideBar();
	                }

	                function attachWheel(target) {
	                    if (window.addEventListener) {
	                        target.addEventListener(&#x27;DOMMouseScroll&#x27;, _onWheel, false);
	                        target.addEventListener(&#x27;mousewheel&#x27;, _onWheel, false);
	                    }
	                    else {
	                        document.attachEvent(&quot;onmousewheel&quot;, _onWheel)
	                    }
	                }

	                function getBarHeight() {
	                    // calculate scrollbar height and make sure it is not too small
	                    barHeight = Math.max((me.outerHeight() / me[0].scrollHeight) * me.outerHeight(), minBarHeight);
	                    bar.css({height: barHeight + &#x27;px&#x27;});

	                    // hide scrollbar if content is not long enough
	                    var display = barHeight == me.outerHeight() ? &#x27;none&#x27; : &#x27;block&#x27;;
	                    bar.css({display: display});
	                }

	                function showBar() {
	                    // recalculate bar height
	                    getBarHeight();
	                    clearTimeout(queueHide);

	                    // when bar reached top or bottom
	                    if (percentScroll == ~~percentScroll) {
	                        //release wheel
	                        releaseScroll = o.allowPageScroll;

	                        // publish approporiate event
	                        if (lastScroll != percentScroll) {
	                            var msg = (~~percentScroll == 0) ? &#x27;top&#x27; : &#x27;bottom&#x27;;
	                            me.trigger(&#x27;slimscroll&#x27;, msg);
	                        }
	                    }
	                    else {
	                        releaseScroll = false;
	                    }
	                    lastScroll = percentScroll;

	                    // show only when required
	                    if (barHeight &gt;= me.outerHeight()) {
	                        //allow window scroll
	                        releaseScroll = true;
	                        return;
	                    }
	                    bar.stop(true, true).fadeIn(&#x27;fast&#x27;);
	                    if (o.railVisible) {
	                        rail.stop(true, true).fadeIn(&#x27;fast&#x27;);
	                    }
	                }

	                function hideBar() {
	                    // only hide when options allow it
	                    if (!o.alwaysVisible) {
	                        queueHide = setTimeout(function () {
	                            if (!(o.disableFadeOut &amp;&amp; isOverPanel) &amp;&amp; !isOverBar &amp;&amp; !isDragg) {
	                                bar.fadeOut(&#x27;slow&#x27;);
	                                rail.fadeOut(&#x27;slow&#x27;);
	                            }
	                        }, 1000);
	                    }
	                }

	            });

	            // maintain chainability
	            return this;
	        }
	    });

	    $.fn.extend({
	        slimscroll: $.fn.slimScroll
	    });

	})(jQuery);


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30);

	jQuery(function ($) {
	    &quot;use strict&quot;;

	    var counter = $(&#x27;.counter&#x27;);

	    counter.each(function () {
	        var $this = $(this);
	        var eventDate = $this.data(&#x27;date&#x27;);
	        var targetDate = new Date(eventDate),
	            finished = false,
	            availiableExamples = {
	                set15daysFromNow: 15 * 24 * 60 * 60 * 1000,
	                set5minFromNow: 5 * 60 * 1000,
	                set1minFromNow: 1 * 60 * 1000
	            };

	        function callback(event) {
	            var $this = $(this);
	            switch (event.type) {
	                case &quot;seconds&quot;:
	                case &quot;minutes&quot;:
	                case &quot;hours&quot;:
	                case &quot;days&quot;:
	                case &quot;weeks&quot;:
	                case &quot;daysLeft&quot;:
	                    $this.find(&#x27;div span.&#x27; + event.type).html(event.value);
	                    if (finished) {
	                        $this.fadeTo(0, 1);
	                        finished = false;
	                    }

	                    break;
	                case &quot;finished&quot;:
	                    $this.fadeTo(&#x27;slow&#x27;, .5);
	                    finished = true;
	                    break;
	            }
	        }

	        $this.countdown(targetDate.valueOf(), callback);

	    });
	});

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	/*
	 * jQuery The Final Countdown plugin v1.0.0 beta
	 * http://github.com/hilios/jquery.countdown
	 *
	 * Copyright (c) 2011 Edson Hilios
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * &quot;Software&quot;), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	(function($) {
	  
	  $.fn.countdown = function(toDate, callback) {
	    var handlers = [&#x27;seconds&#x27;, &#x27;minutes&#x27;, &#x27;hours&#x27;, &#x27;days&#x27;, &#x27;weeks&#x27;, &#x27;daysLeft&#x27;];
	    
	    function delegate(scope, method) {
	      return function() { return method.call(scope) }
	    }
	    
	    return this.each(function() {
	      // Convert
	      if(!(toDate instanceof Date)) {
	        if(String(toDate).match(/^[0-9]*$/)) {
	          toDate = new Date(toDate);
	        } else if( toDate.match(/([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{2,4})\s([0-9]{1,2})\:([0-9]{2})\:([0-9]{2})/) ||
	            toDate.match(/([0-9]{2,4})\/([0-9]{1,2})\/([0-9]{1,2})\s([0-9]{1,2})\:([0-9]{2})\:([0-9]{2})/)
	            ) {
	          toDate = new Date(toDate);
	        } else if(toDate.match(/([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{2,4})/) || 
	                  toDate.match(/([0-9]{2,4})\/([0-9]{1,2})\/([0-9]{1,2})/)
	                  ) {
	          toDate = new Date(toDate)
	        } else {
	          throw new Error(&quot;Doesn&#x27;t seen to be a valid date object or string&quot;)
	        }
	      }
	      
	      var $this = $(this),
	          values = {},
	          lasting = {},
	          interval = $this.data(&#x27;countdownInterval&#x27;),
	          currentDate = new Date(),
	          secondsLeft = Math.floor((toDate.valueOf() - currentDate.valueOf()) / 1000);
	      
	      function triggerEvents() {
	        secondsLeft--;
	        if(secondsLeft &lt; 0) {
	          secondsLeft = 0;
	        }
	        lasting = {
	          seconds : secondsLeft % 60,
	          minutes : Math.floor(secondsLeft / 60) % 60,
	          hours   : Math.floor(secondsLeft / 60 / 60) % 24,
	          days    : Math.floor(secondsLeft / 60 / 60 / 24),
	          weeks   : Math.floor(secondsLeft / 60 / 60 / 24 / 7),
	          daysLeft: Math.floor(secondsLeft / 60 / 60 / 24) % 7
	        }
	        for(var i=0; i&lt;handlers.length; i++) {
	          var eventName = handlers[i];
	          if(values[eventName] != lasting[eventName]) {
	            values[eventName] = lasting[eventName];
	            dispatchEvent(eventName);
	          }
	        }
	        if(secondsLeft == 0) { 
	          stop();
	          dispatchEvent(&#x27;finished&#x27;);
	        }
	      }
	      triggerEvents();
	      
	      function dispatchEvent(eventName) {
	        var event = $.Event(eventName);
	        event.date  = new Date(new Date().valueOf() + secondsLeft);
	        event.value = values[eventName] || &quot;0&quot;;
	        event.toDate = toDate;
	        event.lasting = lasting;
	        switch(eventName) {
	          case &quot;seconds&quot;:
	          case &quot;minutes&quot;:
	          case &quot;hours&quot;:
	            event.value = event.value &lt; 10 ? &#x27;0&#x27;+event.value.toString() : event.value.toString();
	            break;
	          default:
	            if(event.value) {
	              event.value = event.value.toString();
	            }
	            break;
	        }
	        callback.call($this, event);
	      }
	      
	      $this.bind(&#x27;remove&#x27;, function() {
	        stop(); // If the selector is removed clear the interval for memory sake!
	        dispatchEvent(&#x27;removed&#x27;);
	      });
	      
	      function stop() {
	        clearInterval(interval);
	      }

	      function start() {
	        $this.data(&#x27;countdownInterval&#x27;, setInterval(delegate($this, triggerEvents), 1000));
	        interval = $this.data(&#x27;countdownInterval&#x27;);
	      }
	      
	      if(interval) stop();
	      start();
	    });
	  }
	  // Wrap the remove method to trigger an event when called
	  var removeEvent = new $.Event(&#x27;remove&#x27;),
	      removeFunction = $.fn.remove;
	  $.fn.remove = function() {
	    $(this).trigger(removeEvent);
	    return removeFunction.apply(this, arguments);
	  }
	})(jQuery);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30);

	jQuery(function ($) {
	    &quot;use strict&quot;;

	    // Initialize Counters
	    $(&#x27;.sc-counter&#x27;).each(function () {
	        $(this).data(&#x27;value&#x27;, $(this).text()).text(0);
	    });

	    counterStart();

	    // Check If Counter In Viewport
	    $(window).on(&#x27;load resize scroll&#x27;, function () {
	        counterStart();
	    });

	    function counterStart() {
	        $(&#x27;.sc-counter&#x27;).each(function () {

	            /* Counter Elements */
	            var counter = $(this);

	            /* Counter Variables */
	            var counter_value = counter.data(&#x27;value&#x27;);

	            var counter_animated = counter.hasClass(&#x27;counter-animated&#x27;);

	            /* Animate If In Viewport */
	            if (isElementInViewport(counter) &amp;&amp; !counter_animated) {

	                counter.addClass(&#x27;counter-animated&#x27;);
	                $({startVal: 0}).animate({startVal: counter_value},
	                    {
	                        duration: 3000,
	                        easing: &#x27;swing&#x27;,
	                        step: function () {
	                            counter.text(getNumberWithCommas(Math.ceil(this.startVal)));
	                        }
	                    }
	                );

	            }
	        });
	    }

	});


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(33);
	jQuery(function ($) {
	    &quot;use strict&quot;;
	    var Charts = {
	        _HYPHY_REGEX: /-([a-z])/g,
	        _cleanAttr: function (t) {
	            delete t.chart, delete t.datasets, delete t.datasetsOptions, delete t.labels, delete t.options
	        },
	         doughnut: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : {},
	                dataOptions = attrData.datasetOptions ? eval(&quot;(&quot; + attrData.datasetOptions + &quot;)&quot;) : {},
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {};

	            Charts._cleanAttr(attrData);
	            var datasets = $.extend({
	                    data: data,
	                    borderWidth: 2,
	                    hoverBorderColor: &quot;transparent&quot;
	                }, dataOptions),
	                options = $.extend({
	                    cutoutPercentage: 80,
	                    legend: {
	                        display: !1
	                    },
	                    animation: {
	                        animateRotate: !1,
	                        duration: 0
	                    }
	                }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;doughnut&quot;,
	                data: {
	                    datasets: [datasets],
	                    labels: labels
	                },
	                options: options
	            })
	        },
	        &quot;spark-line&quot;: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: &quot;rgba(255,255,255,.3)&quot;,
	                            borderColor: &quot;#fff&quot;,
	                            pointBorderColor: &quot;#fff&quot;,
	                            lineTension: .25,
	                            pointRadius: 0
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    xAxes: [{
	                        display: !1
	                    }],
	                    yAxes: [{
	                        display: !1
	                    }]
	                },
	                tooltips: {
	                    enabled: !1
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;bar&quot;,
	                data: data,
	                options: options
	            })
	        },
	         line: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: isDark ? &quot;rgba(28,168,221,.03)&quot; : &quot;rgba(66,165,245,.2)&quot;,
	                            borderColor: &quot;#42a5f5&quot;,
	                            pointBorderColor: &quot;#fff&quot;,
	                            lineTension: .25,
	                            pointRadius: 0,
	                            pointHoverRadius: 0,
	                            pointHitRadius: 20
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            beginAtZero: !1,
	                            fixedStepSize: 1e3,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14,
	                    callbacks: {
	                        title: function () {
	                            return &quot;&quot;
	                        },
	                        labelColor: function () {
	                            return {
	                                backgroundColor: &quot;#42a5f5&quot;,
	                                borderColor: &quot;#42a5f5&quot;
	                            }
	                        }
	                    }
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;line&quot;,
	                data: data,
	                options: options
	            })
	        },
	         bar: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? &quot;#42a5f5&quot; : &quot;#1bc98e&quot;,
	                            borderColor: &quot;transparent&quot;
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;bar&quot;,
	                data: data,
	                options: options
	            })
	        },
	         pie: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? &quot;#42a5f5&quot; : &quot;#1bc98e&quot;,
	                            borderColor: &quot;transparent&quot;
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;pie&quot;,
	                data: data,
	                options: options
	            })
	        },
	         radar: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? &quot;#42a5f5&quot; : &quot;#1bc98e&quot;,
	                            borderColor: &quot;transparent&quot;
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;radar&quot;,
	                data: data,
	                options: options
	            })
	        }
	    };

	    $(&quot;[data-chart]&quot;).each(function () {
	        $(this).is(&quot;:visible&quot;)
	        &amp;&amp; !$(this).hasClass(&quot;js-chart-drawn&quot;)
	        &amp;&amp; (Charts[$(this).attr(&quot;data-chart&quot;)](this), $(this).addClass(&quot;js-chart-drawn&quot;))
	    })

	});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @namespace Chart
	 */
	var Chart = __webpack_require__(34)();

	Chart.helpers = __webpack_require__(36);

	// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
	__webpack_require__(41)(Chart);

	Chart.defaults = __webpack_require__(35);
	Chart.Element = __webpack_require__(47);
	Chart.elements = __webpack_require__(48);
	Chart.Interaction = __webpack_require__(53);
	Chart.layouts = __webpack_require__(54);
	Chart.platform = __webpack_require__(55);
	Chart.plugins = __webpack_require__(58);
	Chart.Ticks = __webpack_require__(59);

	__webpack_require__(60)(Chart);
	__webpack_require__(61)(Chart);
	__webpack_require__(62)(Chart);
	__webpack_require__(63)(Chart);
	__webpack_require__(64)(Chart);
	__webpack_require__(65)(Chart);

	__webpack_require__(66)(Chart);
	__webpack_require__(67)(Chart);
	__webpack_require__(68)(Chart);
	__webpack_require__(69)(Chart);
	__webpack_require__(70)(Chart);
	__webpack_require__(71)(Chart);

	// Controllers must be loaded after elements
	// See Chart.core.datasetController.dataElementType
	__webpack_require__(197)(Chart);
	__webpack_require__(198)(Chart);
	__webpack_require__(199)(Chart);
	__webpack_require__(200)(Chart);
	__webpack_require__(201)(Chart);
	__webpack_require__(202)(Chart);
	__webpack_require__(203)(Chart);

	__webpack_require__(204)(Chart);
	__webpack_require__(205)(Chart);
	__webpack_require__(206)(Chart);
	__webpack_require__(207)(Chart);
	__webpack_require__(208)(Chart);
	__webpack_require__(209)(Chart);
	__webpack_require__(210)(Chart);

	// Loading built-it plugins
	var plugins = __webpack_require__(211);
	for (var k in plugins) {
		if (plugins.hasOwnProperty(k)) {
			Chart.plugins.register(plugins[k]);
		}
	}

	Chart.platform.initialize();

	module.exports = Chart;
	if (typeof window !== &#x27;undefined&#x27;) {
		window.Chart = Chart;
	}

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, not available anymore
	 * @namespace Chart.Legend
	 * @deprecated since version 2.1.5
	 * @todo remove at version 3
	 * @private
	 */
	Chart.Legend = plugins.legend._element;

	/**
	 * Provided for backward compatibility, not available anymore
	 * @namespace Chart.Title
	 * @deprecated since version 2.1.5
	 * @todo remove at version 3
	 * @private
	 */
	Chart.Title = plugins.title._element;

	/**
	 * Provided for backward compatibility, use Chart.plugins instead
	 * @namespace Chart.pluginService
	 * @deprecated since version 2.1.5
	 * @todo remove at version 3
	 * @private
	 */
	Chart.pluginService = Chart.plugins;

	/**
	 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
	 * effect, instead simply create/register plugins via plain JavaScript objects.
	 * @interface Chart.PluginBase
	 * @deprecated since version 2.5.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.PluginBase = Chart.Element.extend({});

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas instead.
	 * @namespace Chart.canvasHelpers
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.canvasHelpers = Chart.helpers.canvas;

	/**
	 * Provided for backward compatibility, use Chart.layouts instead.
	 * @namespace Chart.layoutService
	 * @deprecated since version 2.8.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.layoutService = Chart.layouts;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);

	defaults._set(&#x27;global&#x27;, {
		responsive: true,
		responsiveAnimationDuration: 0,
		maintainAspectRatio: true,
		events: [&#x27;mousemove&#x27;, &#x27;mouseout&#x27;, &#x27;click&#x27;, &#x27;touchstart&#x27;, &#x27;touchmove&#x27;],
		hover: {
			onHover: null,
			mode: &#x27;nearest&#x27;,
			intersect: true,
			animationDuration: 400
		},
		onClick: null,
		defaultColor: &#x27;rgba(0,0,0,0.1)&#x27;,
		defaultFontColor: &#x27;#666&#x27;,
		defaultFontFamily: &quot;&#x27;Helvetica Neue&#x27;, &#x27;Helvetica&#x27;, &#x27;Arial&#x27;, sans-serif&quot;,
		defaultFontSize: 12,
		defaultFontStyle: &#x27;normal&#x27;,
		showLines: true,

		// Element defaults defined in element extensions
		elements: {},

		// Layout options such as padding
		layout: {
			padding: {
				top: 0,
				right: 0,
				bottom: 0,
				left: 0
			}
		}
	});

	module.exports = function() {

		// Occupy the global variable of Chart, and create a simple base class
		var Chart = function(item, config) {
			this.construct(item, config);
			return this;
		};

		Chart.Chart = Chart;

		return Chart;
	};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);

	module.exports = {
		/**
		 * @private
		 */
		_set: function(scope, values) {
			return helpers.merge(this[scope] || (this[scope] = {}), values);
		}
	};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	module.exports = __webpack_require__(37);
	module.exports.easing = __webpack_require__(38);
	module.exports.canvas = __webpack_require__(39);
	module.exports.options = __webpack_require__(40);


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	/**
	 * @namespace Chart.helpers
	 */
	var helpers = {
		/**
		 * An empty function that can be used, for example, for optional callback.
		 */
		noop: function() {},

		/**
		 * Returns a unique id, sequentially generated from a global variable.
		 * @returns {Number}
		 * @function
		 */
		uid: (function() {
			var id = 0;
			return function() {
				return id++;
			};
		}()),

		/**
		 * Returns true if &#x60;value&#x60; is neither null nor undefined, else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @since 2.7.0
		 */
		isNullOrUndef: function(value) {
			return value === null || typeof value === &#x27;undefined&#x27;;
		},

		/**
		 * Returns true if &#x60;value&#x60; is an array, else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @function
		 */
		isArray: Array.isArray ? Array.isArray : function(value) {
			return Object.prototype.toString.call(value) === &#x27;[object Array]&#x27;;
		},

		/**
		 * Returns true if &#x60;value&#x60; is an object (excluding null), else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @since 2.7.0
		 */
		isObject: function(value) {
			return value !== null &amp;&amp; Object.prototype.toString.call(value) === &#x27;[object Object]&#x27;;
		},

		/**
		 * Returns &#x60;value&#x60; if defined, else returns &#x60;defaultValue&#x60;.
		 * @param {*} value - The value to return if defined.
		 * @param {*} defaultValue - The value to return if &#x60;value&#x60; is undefined.
		 * @returns {*}
		 */
		valueOrDefault: function(value, defaultValue) {
			return typeof value === &#x27;undefined&#x27; ? defaultValue : value;
		},

		/**
		 * Returns value at the given &#x60;index&#x60; in array if defined, else returns &#x60;defaultValue&#x60;.
		 * @param {Array} value - The array to lookup for value at &#x60;index&#x60;.
		 * @param {Number} index - The index in &#x60;value&#x60; to lookup for value.
		 * @param {*} defaultValue - The value to return if &#x60;value[index]&#x60; is undefined.
		 * @returns {*}
		 */
		valueAtIndexOrDefault: function(value, index, defaultValue) {
			return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
		},

		/**
		 * Calls &#x60;fn&#x60; with the given &#x60;args&#x60; in the scope defined by &#x60;thisArg&#x60; and returns the
		 * value returned by &#x60;fn&#x60;. If &#x60;fn&#x60; is not a function, this method returns undefined.
		 * @param {Function} fn - The function to call.
		 * @param {Array|undefined|null} args - The arguments with which &#x60;fn&#x60; should be called.
		 * @param {Object} [thisArg] - The value of &#x60;this&#x60; provided for the call to &#x60;fn&#x60;.
		 * @returns {*}
		 */
		callback: function(fn, args, thisArg) {
			if (fn &amp;&amp; typeof fn.call === &#x27;function&#x27;) {
				return fn.apply(thisArg, args);
			}
		},

		/**
		 * Note(SB) for performance sake, this method should only be used when loopable type
		 * is unknown or in none intensive code (not called often and small loopable). Else
		 * it&#x27;s preferable to use a regular for() loop and save extra function calls.
		 * @param {Object|Array} loopable - The object or array to be iterated.
		 * @param {Function} fn - The function to call for each item.
		 * @param {Object} [thisArg] - The value of &#x60;this&#x60; provided for the call to &#x60;fn&#x60;.
		 * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
		 */
		each: function(loopable, fn, thisArg, reverse) {
			var i, len, keys;
			if (helpers.isArray(loopable)) {
				len = loopable.length;
				if (reverse) {
					for (i = len - 1; i &gt;= 0; i--) {
						fn.call(thisArg, loopable[i], i);
					}
				} else {
					for (i = 0; i &lt; len; i++) {
						fn.call(thisArg, loopable[i], i);
					}
				}
			} else if (helpers.isObject(loopable)) {
				keys = Object.keys(loopable);
				len = keys.length;
				for (i = 0; i &lt; len; i++) {
					fn.call(thisArg, loopable[keys[i]], keys[i]);
				}
			}
		},

		/**
		 * Returns true if the &#x60;a0&#x60; and &#x60;a1&#x60; arrays have the same content, else returns false.
		 * @see http://stackoverflow.com/a/14853974
		 * @param {Array} a0 - The array to compare
		 * @param {Array} a1 - The array to compare
		 * @returns {Boolean}
		 */
		arrayEquals: function(a0, a1) {
			var i, ilen, v0, v1;

			if (!a0 || !a1 || a0.length !== a1.length) {
				return false;
			}

			for (i = 0, ilen = a0.length; i &lt; ilen; ++i) {
				v0 = a0[i];
				v1 = a1[i];

				if (v0 instanceof Array &amp;&amp; v1 instanceof Array) {
					if (!helpers.arrayEquals(v0, v1)) {
						return false;
					}
				} else if (v0 !== v1) {
					// NOTE: two different object instances will never be equal: {x:20} != {x:20}
					return false;
				}
			}

			return true;
		},

		/**
		 * Returns a deep copy of &#x60;source&#x60; without keeping references on objects and arrays.
		 * @param {*} source - The value to clone.
		 * @returns {*}
		 */
		clone: function(source) {
			if (helpers.isArray(source)) {
				return source.map(helpers.clone);
			}

			if (helpers.isObject(source)) {
				var target = {};
				var keys = Object.keys(source);
				var klen = keys.length;
				var k = 0;

				for (; k &lt; klen; ++k) {
					target[keys[k]] = helpers.clone(source[keys[k]]);
				}

				return target;
			}

			return source;
		},

		/**
		 * The default merger when Chart.helpers.merge is called without merger option.
		 * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
		 * @private
		 */
		_merger: function(key, target, source, options) {
			var tval = target[key];
			var sval = source[key];

			if (helpers.isObject(tval) &amp;&amp; helpers.isObject(sval)) {
				helpers.merge(tval, sval, options);
			} else {
				target[key] = helpers.clone(sval);
			}
		},

		/**
		 * Merges source[key] in target[key] only if target[key] is undefined.
		 * @private
		 */
		_mergerIf: function(key, target, source) {
			var tval = target[key];
			var sval = source[key];

			if (helpers.isObject(tval) &amp;&amp; helpers.isObject(sval)) {
				helpers.mergeIf(tval, sval);
			} else if (!target.hasOwnProperty(key)) {
				target[key] = helpers.clone(sval);
			}
		},

		/**
		 * Recursively deep copies &#x60;source&#x60; properties into &#x60;target&#x60; with the given &#x60;options&#x60;.
		 * IMPORTANT: &#x60;target&#x60; is not cloned and will be updated with &#x60;source&#x60; properties.
		 * @param {Object} target - The target object in which all sources are merged into.
		 * @param {Object|Array(Object)} source - Object(s) to merge into &#x60;target&#x60;.
		 * @param {Object} [options] - Merging options:
		 * @param {Function} [options.merger] - The merge method (key, target, source, options)
		 * @returns {Object} The &#x60;target&#x60; object.
		 */
		merge: function(target, source, options) {
			var sources = helpers.isArray(source) ? source : [source];
			var ilen = sources.length;
			var merge, i, keys, klen, k;

			if (!helpers.isObject(target)) {
				return target;
			}

			options = options || {};
			merge = options.merger || helpers._merger;

			for (i = 0; i &lt; ilen; ++i) {
				source = sources[i];
				if (!helpers.isObject(source)) {
					continue;
				}

				keys = Object.keys(source);
				for (k = 0, klen = keys.length; k &lt; klen; ++k) {
					merge(keys[k], target, source, options);
				}
			}

			return target;
		},

		/**
		 * Recursively deep copies &#x60;source&#x60; properties into &#x60;target&#x60; *only* if not defined in target.
		 * IMPORTANT: &#x60;target&#x60; is not cloned and will be updated with &#x60;source&#x60; properties.
		 * @param {Object} target - The target object in which all sources are merged into.
		 * @param {Object|Array(Object)} source - Object(s) to merge into &#x60;target&#x60;.
		 * @returns {Object} The &#x60;target&#x60; object.
		 */
		mergeIf: function(target, source) {
			return helpers.merge(target, source, {merger: helpers._mergerIf});
		},

		/**
		 * Applies the contents of two or more objects together into the first object.
		 * @param {Object} target - The target object in which all objects are merged into.
		 * @param {Object} arg1 - Object containing additional properties to merge in target.
		 * @param {Object} argN - Additional objects containing properties to merge in target.
		 * @returns {Object} The &#x60;target&#x60; object.
		 */
		extend: function(target) {
			var setFn = function(value, key) {
				target[key] = value;
			};
			for (var i = 1, ilen = arguments.length; i &lt; ilen; ++i) {
				helpers.each(arguments[i], setFn);
			}
			return target;
		},

		/**
		 * Basic javascript inheritance based on the model created in Backbone.js
		 */
		inherits: function(extensions) {
			var me = this;
			var ChartElement = (extensions &amp;&amp; extensions.hasOwnProperty(&#x27;constructor&#x27;)) ? extensions.constructor : function() {
				return me.apply(this, arguments);
			};

			var Surrogate = function() {
				this.constructor = ChartElement;
			};

			Surrogate.prototype = me.prototype;
			ChartElement.prototype = new Surrogate();
			ChartElement.extend = helpers.inherits;

			if (extensions) {
				helpers.extend(ChartElement.prototype, extensions);
			}

			ChartElement.__super__ = me.prototype;
			return ChartElement;
		}
	};

	module.exports = helpers;

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.callback instead.
	 * @function Chart.helpers.callCallback
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.callCallback = helpers.callback;

	/**
	 * Provided for backward compatibility, use Array.prototype.indexOf instead.
	 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
	 * @function Chart.helpers.indexOf
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.indexOf = function(array, item, fromIndex) {
		return Array.prototype.indexOf.call(array, item, fromIndex);
	};

	/**
	 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
	 * @function Chart.helpers.getValueOrDefault
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.getValueOrDefault = helpers.valueOrDefault;

	/**
	 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
	 * @function Chart.helpers.getValueAtIndexOrDefault
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(37);

	/**
	 * Easing functions adapted from Robert Penner&#x27;s easing equations.
	 * @namespace Chart.helpers.easingEffects
	 * @see http://www.robertpenner.com/easing/
	 */
	var effects = {
		linear: function(t) {
			return t;
		},

		easeInQuad: function(t) {
			return t * t;
		},

		easeOutQuad: function(t) {
			return -t * (t - 2);
		},

		easeInOutQuad: function(t) {
			if ((t /= 0.5) &lt; 1) {
				return 0.5 * t * t;
			}
			return -0.5 * ((--t) * (t - 2) - 1);
		},

		easeInCubic: function(t) {
			return t * t * t;
		},

		easeOutCubic: function(t) {
			return (t = t - 1) * t * t + 1;
		},

		easeInOutCubic: function(t) {
			if ((t /= 0.5) &lt; 1) {
				return 0.5 * t * t * t;
			}
			return 0.5 * ((t -= 2) * t * t + 2);
		},

		easeInQuart: function(t) {
			return t * t * t * t;
		},

		easeOutQuart: function(t) {
			return -((t = t - 1) * t * t * t - 1);
		},

		easeInOutQuart: function(t) {
			if ((t /= 0.5) &lt; 1) {
				return 0.5 * t * t * t * t;
			}
			return -0.5 * ((t -= 2) * t * t * t - 2);
		},

		easeInQuint: function(t) {
			return t * t * t * t * t;
		},

		easeOutQuint: function(t) {
			return (t = t - 1) * t * t * t * t + 1;
		},

		easeInOutQuint: function(t) {
			if ((t /= 0.5) &lt; 1) {
				return 0.5 * t * t * t * t * t;
			}
			return 0.5 * ((t -= 2) * t * t * t * t + 2);
		},

		easeInSine: function(t) {
			return -Math.cos(t * (Math.PI / 2)) + 1;
		},

		easeOutSine: function(t) {
			return Math.sin(t * (Math.PI / 2));
		},

		easeInOutSine: function(t) {
			return -0.5 * (Math.cos(Math.PI * t) - 1);
		},

		easeInExpo: function(t) {
			return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
		},

		easeOutExpo: function(t) {
			return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
		},

		easeInOutExpo: function(t) {
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if ((t /= 0.5) &lt; 1) {
				return 0.5 * Math.pow(2, 10 * (t - 1));
			}
			return 0.5 * (-Math.pow(2, -10 * --t) + 2);
		},

		easeInCirc: function(t) {
			if (t &gt;= 1) {
				return t;
			}
			return -(Math.sqrt(1 - t * t) - 1);
		},

		easeOutCirc: function(t) {
			return Math.sqrt(1 - (t = t - 1) * t);
		},

		easeInOutCirc: function(t) {
			if ((t /= 0.5) &lt; 1) {
				return -0.5 * (Math.sqrt(1 - t * t) - 1);
			}
			return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
		},

		easeInElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if (!p) {
				p = 0.3;
			}
			if (a &lt; 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
		},

		easeOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if (!p) {
				p = 0.3;
			}
			if (a &lt; 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
		},

		easeInOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 0.5) === 2) {
				return 1;
			}
			if (!p) {
				p = 0.45;
			}
			if (a &lt; 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			if (t &lt; 1) {
				return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
		},
		easeInBack: function(t) {
			var s = 1.70158;
			return t * t * ((s + 1) * t - s);
		},

		easeOutBack: function(t) {
			var s = 1.70158;
			return (t = t - 1) * t * ((s + 1) * t + s) + 1;
		},

		easeInOutBack: function(t) {
			var s = 1.70158;
			if ((t /= 0.5) &lt; 1) {
				return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
			}
			return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
		},

		easeInBounce: function(t) {
			return 1 - effects.easeOutBounce(1 - t);
		},

		easeOutBounce: function(t) {
			if (t &lt; (1 / 2.75)) {
				return 7.5625 * t * t;
			}
			if (t &lt; (2 / 2.75)) {
				return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
			}
			if (t &lt; (2.5 / 2.75)) {
				return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
			}
			return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
		},

		easeInOutBounce: function(t) {
			if (t &lt; 0.5) {
				return effects.easeInBounce(t * 2) * 0.5;
			}
			return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
		}
	};

	module.exports = {
		effects: effects
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
	 * @function Chart.helpers.easingEffects
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.easingEffects = effects;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(37);

	/**
	 * @namespace Chart.helpers.canvas
	 */
	var exports = module.exports = {
		/**
		 * Clears the entire canvas associated to the given &#x60;chart&#x60;.
		 * @param {Chart} chart - The chart for which to clear the canvas.
		 */
		clear: function(chart) {
			chart.ctx.clearRect(0, 0, chart.width, chart.height);
		},

		/**
		 * Creates a &quot;path&quot; for a rectangle with rounded corners at position (x, y) with a
		 * given size (width, height) and the same &#x60;radius&#x60; for all corners.
		 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
		 * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
		 * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
		 * @param {Number} width - The rectangle&#x27;s width.
		 * @param {Number} height - The rectangle&#x27;s height.
		 * @param {Number} radius - The rounded amount (in pixels) for the four corners.
		 * @todo handle &#x60;radius&#x60; as top-left, top-right, bottom-right, bottom-left array/object?
		 */
		roundedRect: function(ctx, x, y, width, height, radius) {
			if (radius) {
				var rx = Math.min(radius, width / 2);
				var ry = Math.min(radius, height / 2);

				ctx.moveTo(x + rx, y);
				ctx.lineTo(x + width - rx, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
				ctx.lineTo(x + width, y + height - ry);
				ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
				ctx.lineTo(x + rx, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
				ctx.lineTo(x, y + ry);
				ctx.quadraticCurveTo(x, y, x + rx, y);
			} else {
				ctx.rect(x, y, width, height);
			}
		},

		drawPoint: function(ctx, style, radius, x, y) {
			var type, edgeLength, xOffset, yOffset, height, size;

			if (style &amp;&amp; typeof style === &#x27;object&#x27;) {
				type = style.toString();
				if (type === &#x27;[object HTMLImageElement]&#x27; || type === &#x27;[object HTMLCanvasElement]&#x27;) {
					ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
					return;
				}
			}

			if (isNaN(radius) || radius &lt;= 0) {
				return;
			}

			switch (style) {
			// Default includes circle
			default:
				ctx.beginPath();
				ctx.arc(x, y, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;triangle&#x27;:
				ctx.beginPath();
				edgeLength = 3 * radius / Math.sqrt(3);
				height = edgeLength * Math.sqrt(3) / 2;
				ctx.moveTo(x - edgeLength / 2, y + height / 3);
				ctx.lineTo(x + edgeLength / 2, y + height / 3);
				ctx.lineTo(x, y - 2 * height / 3);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;rect&#x27;:
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
				ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
				break;
			case &#x27;rectRounded&#x27;:
				var offset = radius / Math.SQRT2;
				var leftX = x - offset;
				var topY = y - offset;
				var sideSize = Math.SQRT2 * radius;
				ctx.beginPath();
				this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;rectRot&#x27;:
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.moveTo(x - size, y);
				ctx.lineTo(x, y + size);
				ctx.lineTo(x + size, y);
				ctx.lineTo(x, y - size);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;cross&#x27;:
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case &#x27;crossRot&#x27;:
				ctx.beginPath();
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case &#x27;star&#x27;:
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case &#x27;line&#x27;:
				ctx.beginPath();
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case &#x27;dash&#x27;:
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			}

			ctx.stroke();
		},

		clipArea: function(ctx, area) {
			ctx.save();
			ctx.beginPath();
			ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
			ctx.clip();
		},

		unclipArea: function(ctx) {
			ctx.restore();
		},

		lineTo: function(ctx, previous, target, flip) {
			if (target.steppedLine) {
				if ((target.steppedLine === &#x27;after&#x27; &amp;&amp; !flip) || (target.steppedLine !== &#x27;after&#x27; &amp;&amp; flip)) {
					ctx.lineTo(previous.x, target.y);
				} else {
					ctx.lineTo(target.x, previous.y);
				}
				ctx.lineTo(target.x, target.y);
				return;
			}

			if (!target.tension) {
				ctx.lineTo(target.x, target.y);
				return;
			}

			ctx.bezierCurveTo(
				flip ? previous.controlPointPreviousX : previous.controlPointNextX,
				flip ? previous.controlPointPreviousY : previous.controlPointNextY,
				flip ? target.controlPointNextX : target.controlPointPreviousX,
				flip ? target.controlPointNextY : target.controlPointPreviousY,
				target.x,
				target.y);
		}
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
	 * @namespace Chart.helpers.clear
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.clear = exports.clear;

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
	 * @namespace Chart.helpers.drawRoundedRectangle
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.drawRoundedRectangle = function(ctx) {
		ctx.beginPath();
		exports.roundedRect.apply(exports, arguments);
		ctx.closePath();
	};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(37);

	/**
	 * @alias Chart.helpers.options
	 * @namespace
	 */
	module.exports = {
		/**
		 * Converts the given line height &#x60;value&#x60; in pixels for a specific font &#x60;size&#x60;.
		 * @param {Number|String} value - The lineHeight to parse (eg. 1.6, &#x27;14px&#x27;, &#x27;75%&#x27;, &#x27;1.6em&#x27;).
		 * @param {Number} size - The font size (in pixels) used to resolve relative &#x60;value&#x60;.
		 * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
		 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
		 * @since 2.7.0
		 */
		toLineHeight: function(value, size) {
			var matches = (&#x27;&#x27; + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
			if (!matches || matches[1] === &#x27;normal&#x27;) {
				return size * 1.2;
			}

			value = +matches[2];

			switch (matches[3]) {
			case &#x27;px&#x27;:
				return value;
			case &#x27;%&#x27;:
				value /= 100;
				break;
			default:
				break;
			}

			return size * value;
		},

		/**
		 * Converts the given value into a padding object with pre-computed width/height.
		 * @param {Number|Object} value - If a number, set the value to all TRBL component,
		 *  else, if and object, use defined properties and sets undefined ones to 0.
		 * @returns {Object} The padding values (top, right, bottom, left, width, height)
		 * @since 2.7.0
		 */
		toPadding: function(value) {
			var t, r, b, l;

			if (helpers.isObject(value)) {
				t = +value.top || 0;
				r = +value.right || 0;
				b = +value.bottom || 0;
				l = +value.left || 0;
			} else {
				t = r = b = l = +value || 0;
			}

			return {
				top: t,
				right: r,
				bottom: b,
				left: l,
				height: t + b,
				width: l + r
			};
		},

		/**
		 * Evaluates the given &#x60;inputs&#x60; sequentially and returns the first defined value.
		 * @param {Array[]} inputs - An array of values, falling back to the last value.
		 * @param {Object} [context] - If defined and the current value is a function, the value
		 * is called with &#x60;context&#x60; as first argument and the result becomes the new input.
		 * @param {Number} [index] - If defined and the current value is an array, the value
		 * at &#x60;index&#x60; become the new input.
		 * @since 2.7.0
		 */
		resolve: function(inputs, context, index) {
			var i, ilen, value;

			for (i = 0, ilen = inputs.length; i &lt; ilen; ++i) {
				value = inputs[i];
				if (value === undefined) {
					continue;
				}
				if (context !== undefined &amp;&amp; typeof value === &#x27;function&#x27;) {
					value = value(context);
				}
				if (index !== undefined &amp;&amp; helpers.isArray(value)) {
					value = value[index];
				}
				if (value !== undefined) {
					return value;
				}
			}
		}
	};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	/* global document: false */
	&#x27;use strict&#x27;;

	var color = __webpack_require__(42);
	var defaults = __webpack_require__(35);
	var helpers = __webpack_require__(36);

	module.exports = function(Chart) {

		// -- Basic js utility methods

		helpers.configMerge = function(/* objects ... */) {
			return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
				merger: function(key, target, source, options) {
					var tval = target[key] || {};
					var sval = source[key];

					if (key === &#x27;scales&#x27;) {
						// scale config merging is complex. Add our own function here for that
						target[key] = helpers.scaleMerge(tval, sval);
					} else if (key === &#x27;scale&#x27;) {
						// used in polar area &amp; radar charts since there is only one scale
						target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
					} else {
						helpers._merger(key, target, source, options);
					}
				}
			});
		};

		helpers.scaleMerge = function(/* objects ... */) {
			return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
				merger: function(key, target, source, options) {
					if (key === &#x27;xAxes&#x27; || key === &#x27;yAxes&#x27;) {
						var slen = source[key].length;
						var i, type, scale;

						if (!target[key]) {
							target[key] = [];
						}

						for (i = 0; i &lt; slen; ++i) {
							scale = source[key][i];
							type = helpers.valueOrDefault(scale.type, key === &#x27;xAxes&#x27; ? &#x27;category&#x27; : &#x27;linear&#x27;);

							if (i &gt;= target[key].length) {
								target[key].push({});
							}

							if (!target[key][i].type || (scale.type &amp;&amp; scale.type !== target[key][i].type)) {
								// new/untyped scale or type changed: let&#x27;s apply the new defaults
								// then merge source scale to correctly overwrite the defaults.
								helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
							} else {
								// scales type are the same
								helpers.merge(target[key][i], scale);
							}
						}
					} else {
						helpers._merger(key, target, source, options);
					}
				}
			});
		};

		helpers.where = function(collection, filterCallback) {
			if (helpers.isArray(collection) &amp;&amp; Array.prototype.filter) {
				return collection.filter(filterCallback);
			}
			var filtered = [];

			helpers.each(collection, function(item) {
				if (filterCallback(item)) {
					filtered.push(item);
				}
			});

			return filtered;
		};
		helpers.findIndex = Array.prototype.findIndex ?
			function(array, callback, scope) {
				return array.findIndex(callback, scope);
			} :
			function(array, callback, scope) {
				scope = scope === undefined ? array : scope;
				for (var i = 0, ilen = array.length; i &lt; ilen; ++i) {
					if (callback.call(scope, array[i], i, array)) {
						return i;
					}
				}
				return -1;
			};
		helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
			// Default to start of the array
			if (helpers.isNullOrUndef(startIndex)) {
				startIndex = -1;
			}
			for (var i = startIndex + 1; i &lt; arrayToSearch.length; i++) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};
		helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
			// Default to end of the array
			if (helpers.isNullOrUndef(startIndex)) {
				startIndex = arrayToSearch.length;
			}
			for (var i = startIndex - 1; i &gt;= 0; i--) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};

		// -- Math methods
		helpers.isNumber = function(n) {
			return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
		};
		helpers.almostEquals = function(x, y, epsilon) {
			return Math.abs(x - y) &lt; epsilon;
		};
		helpers.almostWhole = function(x, epsilon) {
			var rounded = Math.round(x);
			return (((rounded - epsilon) &lt; x) &amp;&amp; ((rounded + epsilon) &gt; x));
		};
		helpers.max = function(array) {
			return array.reduce(function(max, value) {
				if (!isNaN(value)) {
					return Math.max(max, value);
				}
				return max;
			}, Number.NEGATIVE_INFINITY);
		};
		helpers.min = function(array) {
			return array.reduce(function(min, value) {
				if (!isNaN(value)) {
					return Math.min(min, value);
				}
				return min;
			}, Number.POSITIVE_INFINITY);
		};
		helpers.sign = Math.sign ?
			function(x) {
				return Math.sign(x);
			} :
			function(x) {
				x = +x; // convert to a number
				if (x === 0 || isNaN(x)) {
					return x;
				}
				return x &gt; 0 ? 1 : -1;
			};
		helpers.log10 = Math.log10 ?
			function(x) {
				return Math.log10(x);
			} :
			function(x) {
				var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
				// Check for whole powers of 10,
				// which due to floating point rounding error should be corrected.
				var powerOf10 = Math.round(exponent);
				var isPowerOf10 = x === Math.pow(10, powerOf10);

				return isPowerOf10 ? powerOf10 : exponent;
			};
		helpers.toRadians = function(degrees) {
			return degrees * (Math.PI / 180);
		};
		helpers.toDegrees = function(radians) {
			return radians * (180 / Math.PI);
		};
		// Gets the angle from vertical upright to the point about a centre.
		helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
			var distanceFromXCenter = anglePoint.x - centrePoint.x;
			var distanceFromYCenter = anglePoint.y - centrePoint.y;
			var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

			var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

			if (angle &lt; (-0.5 * Math.PI)) {
				angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
			}

			return {
				angle: angle,
				distance: radialDistanceFromCenter
			};
		};
		helpers.distanceBetweenPoints = function(pt1, pt2) {
			return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
		};
		helpers.aliasPixel = function(pixelWidth) {
			return (pixelWidth % 2 === 0) ? 0 : 0.5;
		};
		helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
			// Props to Rob Spencer at scaled innovation for his post on splining between points
			// http://scaledinnovation.com/analytics/splines/aboutSplines.html

			// This function must also respect &quot;skipped&quot; points

			var previous = firstPoint.skip ? middlePoint : firstPoint;
			var current = middlePoint;
			var next = afterPoint.skip ? middlePoint : afterPoint;

			var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
			var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

			var s01 = d01 / (d01 + d12);
			var s12 = d12 / (d01 + d12);

			// If all points are the same, s01 &amp; s02 will be inf
			s01 = isNaN(s01) ? 0 : s01;
			s12 = isNaN(s12) ? 0 : s12;

			var fa = t * s01; // scaling factor for triangle Ta
			var fb = t * s12;

			return {
				previous: {
					x: current.x - fa * (next.x - previous.x),
					y: current.y - fa * (next.y - previous.y)
				},
				next: {
					x: current.x + fb * (next.x - previous.x),
					y: current.y + fb * (next.y - previous.y)
				}
			};
		};
		helpers.EPSILON = Number.EPSILON || 1e-14;
		helpers.splineCurveMonotone = function(points) {
			// This function calculates Bézier control points in a similar way than |splineCurve|,
			// but preserves monotonicity of the provided data and ensures no local extremums are added
			// between the dataset discrete points due to the interpolation.
			// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

			var pointsWithTangents = (points || []).map(function(point) {
				return {
					model: point._model,
					deltaK: 0,
					mK: 0
				};
			});

			// Calculate slopes (deltaK) and initialize tangents (mK)
			var pointsLen = pointsWithTangents.length;
			var i, pointBefore, pointCurrent, pointAfter;
			for (i = 0; i &lt; pointsLen; ++i) {
				pointCurrent = pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}

				pointBefore = i &gt; 0 ? pointsWithTangents[i - 1] : null;
				pointAfter = i &lt; pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointAfter &amp;&amp; !pointAfter.model.skip) {
					var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

					// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
					pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
				}

				if (!pointBefore || pointBefore.model.skip) {
					pointCurrent.mK = pointCurrent.deltaK;
				} else if (!pointAfter || pointAfter.model.skip) {
					pointCurrent.mK = pointBefore.deltaK;
				} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
					pointCurrent.mK = 0;
				} else {
					pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
				}
			}

			// Adjust tangents to ensure monotonic properties
			var alphaK, betaK, tauK, squaredMagnitude;
			for (i = 0; i &lt; pointsLen - 1; ++i) {
				pointCurrent = pointsWithTangents[i];
				pointAfter = pointsWithTangents[i + 1];
				if (pointCurrent.model.skip || pointAfter.model.skip) {
					continue;
				}

				if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
					pointCurrent.mK = pointAfter.mK = 0;
					continue;
				}

				alphaK = pointCurrent.mK / pointCurrent.deltaK;
				betaK = pointAfter.mK / pointCurrent.deltaK;
				squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
				if (squaredMagnitude &lt;= 9) {
					continue;
				}

				tauK = 3 / Math.sqrt(squaredMagnitude);
				pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
				pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
			}

			// Compute control points
			var deltaX;
			for (i = 0; i &lt; pointsLen; ++i) {
				pointCurrent = pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}

				pointBefore = i &gt; 0 ? pointsWithTangents[i - 1] : null;
				pointAfter = i &lt; pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointBefore &amp;&amp; !pointBefore.model.skip) {
					deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
					pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
					pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
				}
				if (pointAfter &amp;&amp; !pointAfter.model.skip) {
					deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
					pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
					pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
				}
			}
		};
		helpers.nextItem = function(collection, index, loop) {
			if (loop) {
				return index &gt;= collection.length - 1 ? collection[0] : collection[index + 1];
			}
			return index &gt;= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
		};
		helpers.previousItem = function(collection, index, loop) {
			if (loop) {
				return index &lt;= 0 ? collection[collection.length - 1] : collection[index - 1];
			}
			return index &lt;= 0 ? collection[0] : collection[index - 1];
		};
		// Implementation of the nice number algorithm used in determining where axis labels will go
		helpers.niceNum = function(range, round) {
			var exponent = Math.floor(helpers.log10(range));
			var fraction = range / Math.pow(10, exponent);
			var niceFraction;

			if (round) {
				if (fraction &lt; 1.5) {
					niceFraction = 1;
				} else if (fraction &lt; 3) {
					niceFraction = 2;
				} else if (fraction &lt; 7) {
					niceFraction = 5;
				} else {
					niceFraction = 10;
				}
			} else if (fraction &lt;= 1.0) {
				niceFraction = 1;
			} else if (fraction &lt;= 2) {
				niceFraction = 2;
			} else if (fraction &lt;= 5) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}

			return niceFraction * Math.pow(10, exponent);
		};
		// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		helpers.requestAnimFrame = (function() {
			if (typeof window === &#x27;undefined&#x27;) {
				return function(callback) {
					callback();
				};
			}
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					return window.setTimeout(callback, 1000 / 60);
				};
		}());
		// -- DOM methods
		helpers.getRelativePosition = function(evt, chart) {
			var mouseX, mouseY;
			var e = evt.originalEvent || evt;
			var canvas = evt.currentTarget || evt.srcElement;
			var boundingRect = canvas.getBoundingClientRect();

			var touches = e.touches;
			if (touches &amp;&amp; touches.length &gt; 0) {
				mouseX = touches[0].clientX;
				mouseY = touches[0].clientY;

			} else {
				mouseX = e.clientX;
				mouseY = e.clientY;
			}

			// Scale mouse coordinates into canvas coordinates
			// by following the pattern laid out by &#x27;jerryj&#x27; in the comments of
			// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
			var paddingLeft = parseFloat(helpers.getStyle(canvas, &#x27;padding-left&#x27;));
			var paddingTop = parseFloat(helpers.getStyle(canvas, &#x27;padding-top&#x27;));
			var paddingRight = parseFloat(helpers.getStyle(canvas, &#x27;padding-right&#x27;));
			var paddingBottom = parseFloat(helpers.getStyle(canvas, &#x27;padding-bottom&#x27;));
			var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
			var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

			// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
			// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
			mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
			mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

			return {
				x: mouseX,
				y: mouseY
			};

		};

		// Private helper function to convert max-width/max-height values that may be percentages into a number
		function parseMaxStyle(styleValue, node, parentProperty) {
			var valueInPixels;
			if (typeof styleValue === &#x27;string&#x27;) {
				valueInPixels = parseInt(styleValue, 10);

				if (styleValue.indexOf(&#x27;%&#x27;) !== -1) {
					// percentage * size in dimension
					valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
				}
			} else {
				valueInPixels = styleValue;
			}

			return valueInPixels;
		}

		/**
		 * Returns if the given value contains an effective constraint.
		 * @private
		 */
		function isConstrainedValue(value) {
			return value !== undefined &amp;&amp; value !== null &amp;&amp; value !== &#x27;none&#x27;;
		}

		// Private helper to get a constraint dimension
		// @param domNode : the node to check the constraint on
		// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
		// @param percentageProperty : property of parent to use when calculating width as a percentage
		// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
		function getConstraintDimension(domNode, maxStyle, percentageProperty) {
			var view = document.defaultView;
			var parentNode = domNode.parentNode;
			var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
			var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
			var hasCNode = isConstrainedValue(constrainedNode);
			var hasCContainer = isConstrainedValue(constrainedContainer);
			var infinity = Number.POSITIVE_INFINITY;

			if (hasCNode || hasCContainer) {
				return Math.min(
					hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
					hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
			}

			return &#x27;none&#x27;;
		}
		// returns Number or undefined if no constraint
		helpers.getConstraintWidth = function(domNode) {
			return getConstraintDimension(domNode, &#x27;max-width&#x27;, &#x27;clientWidth&#x27;);
		};
		// returns Number or undefined if no constraint
		helpers.getConstraintHeight = function(domNode) {
			return getConstraintDimension(domNode, &#x27;max-height&#x27;, &#x27;clientHeight&#x27;);
		};
		helpers.getMaximumWidth = function(domNode) {
			var container = domNode.parentNode;
			if (!container) {
				return domNode.clientWidth;
			}

			var paddingLeft = parseInt(helpers.getStyle(container, &#x27;padding-left&#x27;), 10);
			var paddingRight = parseInt(helpers.getStyle(container, &#x27;padding-right&#x27;), 10);
			var w = container.clientWidth - paddingLeft - paddingRight;
			var cw = helpers.getConstraintWidth(domNode);
			return isNaN(cw) ? w : Math.min(w, cw);
		};
		helpers.getMaximumHeight = function(domNode) {
			var container = domNode.parentNode;
			if (!container) {
				return domNode.clientHeight;
			}

			var paddingTop = parseInt(helpers.getStyle(container, &#x27;padding-top&#x27;), 10);
			var paddingBottom = parseInt(helpers.getStyle(container, &#x27;padding-bottom&#x27;), 10);
			var h = container.clientHeight - paddingTop - paddingBottom;
			var ch = helpers.getConstraintHeight(domNode);
			return isNaN(ch) ? h : Math.min(h, ch);
		};
		helpers.getStyle = function(el, property) {
			return el.currentStyle ?
				el.currentStyle[property] :
				document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
		};
		helpers.retinaScale = function(chart, forceRatio) {
			var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
			if (pixelRatio === 1) {
				return;
			}

			var canvas = chart.canvas;
			var height = chart.height;
			var width = chart.width;

			canvas.height = height * pixelRatio;
			canvas.width = width * pixelRatio;
			chart.ctx.scale(pixelRatio, pixelRatio);

			// If no style has been set on the canvas, the render size is used as display size,
			// making the chart visually bigger, so let&#x27;s enforce it to the &quot;correct&quot; values.
			// See https://github.com/chartjs/Chart.js/issues/3575
			if (!canvas.style.height &amp;&amp; !canvas.style.width) {
				canvas.style.height = height + &#x27;px&#x27;;
				canvas.style.width = width + &#x27;px&#x27;;
			}
		};
		// -- Canvas methods
		helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
			return fontStyle + &#x27; &#x27; + pixelSize + &#x27;px &#x27; + fontFamily;
		};
		helpers.longestText = function(ctx, font, arrayOfThings, cache) {
			cache = cache || {};
			var data = cache.data = cache.data || {};
			var gc = cache.garbageCollect = cache.garbageCollect || [];

			if (cache.font !== font) {
				data = cache.data = {};
				gc = cache.garbageCollect = [];
				cache.font = font;
			}

			ctx.font = font;
			var longest = 0;
			helpers.each(arrayOfThings, function(thing) {
				// Undefined strings and arrays should not be measured
				if (thing !== undefined &amp;&amp; thing !== null &amp;&amp; helpers.isArray(thing) !== true) {
					longest = helpers.measureText(ctx, data, gc, longest, thing);
				} else if (helpers.isArray(thing)) {
					// if it is an array lets measure each element
					// to do maybe simplify this function a bit so we can do this more recursively?
					helpers.each(thing, function(nestedThing) {
						// Undefined strings and arrays should not be measured
						if (nestedThing !== undefined &amp;&amp; nestedThing !== null &amp;&amp; !helpers.isArray(nestedThing)) {
							longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
						}
					});
				}
			});

			var gcLen = gc.length / 2;
			if (gcLen &gt; arrayOfThings.length) {
				for (var i = 0; i &lt; gcLen; i++) {
					delete data[gc[i]];
				}
				gc.splice(0, gcLen);
			}
			return longest;
		};
		helpers.measureText = function(ctx, data, gc, longest, string) {
			var textWidth = data[string];
			if (!textWidth) {
				textWidth = data[string] = ctx.measureText(string).width;
				gc.push(string);
			}
			if (textWidth &gt; longest) {
				longest = textWidth;
			}
			return longest;
		};
		helpers.numberOfLabelLines = function(arrayOfThings) {
			var numberOfLines = 1;
			helpers.each(arrayOfThings, function(thing) {
				if (helpers.isArray(thing)) {
					if (thing.length &gt; numberOfLines) {
						numberOfLines = thing.length;
					}
				}
			});
			return numberOfLines;
		};

		helpers.color = !color ?
			function(value) {
				console.error(&#x27;Color.js not found!&#x27;);
				return value;
			} :
			function(value) {
				/* global CanvasGradient */
				if (value instanceof CanvasGradient) {
					value = defaults.global.defaultColor;
				}

				return color(value);
			};

		helpers.getHoverColor = function(colorValue) {
			/* global CanvasPattern */
			return (colorValue instanceof CanvasPattern) ?
				colorValue :
				helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
		};
	};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/* MIT license */
	var convert = __webpack_require__(43);
	var string = __webpack_require__(45);

	var Color = function (obj) {
		if (obj instanceof Color) {
			return obj;
		}
		if (!(this instanceof Color)) {
			return new Color(obj);
		}

		this.valid = false;
		this.values = {
			rgb: [0, 0, 0],
			hsl: [0, 0, 0],
			hsv: [0, 0, 0],
			hwb: [0, 0, 0],
			cmyk: [0, 0, 0, 0],
			alpha: 1
		};

		// parse Color() argument
		var vals;
		if (typeof obj === &#x27;string&#x27;) {
			vals = string.getRgba(obj);
			if (vals) {
				this.setValues(&#x27;rgb&#x27;, vals);
			} else if (vals = string.getHsla(obj)) {
				this.setValues(&#x27;hsl&#x27;, vals);
			} else if (vals = string.getHwb(obj)) {
				this.setValues(&#x27;hwb&#x27;, vals);
			}
		} else if (typeof obj === &#x27;object&#x27;) {
			vals = obj;
			if (vals.r !== undefined || vals.red !== undefined) {
				this.setValues(&#x27;rgb&#x27;, vals);
			} else if (vals.l !== undefined || vals.lightness !== undefined) {
				this.setValues(&#x27;hsl&#x27;, vals);
			} else if (vals.v !== undefined || vals.value !== undefined) {
				this.setValues(&#x27;hsv&#x27;, vals);
			} else if (vals.w !== undefined || vals.whiteness !== undefined) {
				this.setValues(&#x27;hwb&#x27;, vals);
			} else if (vals.c !== undefined || vals.cyan !== undefined) {
				this.setValues(&#x27;cmyk&#x27;, vals);
			}
		}
	};

	Color.prototype = {
		isValid: function () {
			return this.valid;
		},
		rgb: function () {
			return this.setSpace(&#x27;rgb&#x27;, arguments);
		},
		hsl: function () {
			return this.setSpace(&#x27;hsl&#x27;, arguments);
		},
		hsv: function () {
			return this.setSpace(&#x27;hsv&#x27;, arguments);
		},
		hwb: function () {
			return this.setSpace(&#x27;hwb&#x27;, arguments);
		},
		cmyk: function () {
			return this.setSpace(&#x27;cmyk&#x27;, arguments);
		},

		rgbArray: function () {
			return this.values.rgb;
		},
		hslArray: function () {
			return this.values.hsl;
		},
		hsvArray: function () {
			return this.values.hsv;
		},
		hwbArray: function () {
			var values = this.values;
			if (values.alpha !== 1) {
				return values.hwb.concat([values.alpha]);
			}
			return values.hwb;
		},
		cmykArray: function () {
			return this.values.cmyk;
		},
		rgbaArray: function () {
			var values = this.values;
			return values.rgb.concat([values.alpha]);
		},
		hslaArray: function () {
			var values = this.values;
			return values.hsl.concat([values.alpha]);
		},
		alpha: function (val) {
			if (val === undefined) {
				return this.values.alpha;
			}
			this.setValues(&#x27;alpha&#x27;, val);
			return this;
		},

		red: function (val) {
			return this.setChannel(&#x27;rgb&#x27;, 0, val);
		},
		green: function (val) {
			return this.setChannel(&#x27;rgb&#x27;, 1, val);
		},
		blue: function (val) {
			return this.setChannel(&#x27;rgb&#x27;, 2, val);
		},
		hue: function (val) {
			if (val) {
				val %= 360;
				val = val &lt; 0 ? 360 + val : val;
			}
			return this.setChannel(&#x27;hsl&#x27;, 0, val);
		},
		saturation: function (val) {
			return this.setChannel(&#x27;hsl&#x27;, 1, val);
		},
		lightness: function (val) {
			return this.setChannel(&#x27;hsl&#x27;, 2, val);
		},
		saturationv: function (val) {
			return this.setChannel(&#x27;hsv&#x27;, 1, val);
		},
		whiteness: function (val) {
			return this.setChannel(&#x27;hwb&#x27;, 1, val);
		},
		blackness: function (val) {
			return this.setChannel(&#x27;hwb&#x27;, 2, val);
		},
		value: function (val) {
			return this.setChannel(&#x27;hsv&#x27;, 2, val);
		},
		cyan: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 0, val);
		},
		magenta: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 1, val);
		},
		yellow: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 2, val);
		},
		black: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 3, val);
		},

		hexString: function () {
			return string.hexString(this.values.rgb);
		},
		rgbString: function () {
			return string.rgbString(this.values.rgb, this.values.alpha);
		},
		rgbaString: function () {
			return string.rgbaString(this.values.rgb, this.values.alpha);
		},
		percentString: function () {
			return string.percentString(this.values.rgb, this.values.alpha);
		},
		hslString: function () {
			return string.hslString(this.values.hsl, this.values.alpha);
		},
		hslaString: function () {
			return string.hslaString(this.values.hsl, this.values.alpha);
		},
		hwbString: function () {
			return string.hwbString(this.values.hwb, this.values.alpha);
		},
		keyword: function () {
			return string.keyword(this.values.rgb, this.values.alpha);
		},

		rgbNumber: function () {
			var rgb = this.values.rgb;
			return (rgb[0] &lt;&lt; 16) | (rgb[1] &lt;&lt; 8) | rgb[2];
		},

		luminosity: function () {
			// http://www.w3.org/TR/WCAG20/#relativeluminancedef
			var rgb = this.values.rgb;
			var lum = [];
			for (var i = 0; i &lt; rgb.length; i++) {
				var chan = rgb[i] / 255;
				lum[i] = (chan &lt;= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
			}
			return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
		},

		contrast: function (color2) {
			// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
			var lum1 = this.luminosity();
			var lum2 = color2.luminosity();
			if (lum1 &gt; lum2) {
				return (lum1 + 0.05) / (lum2 + 0.05);
			}
			return (lum2 + 0.05) / (lum1 + 0.05);
		},

		level: function (color2) {
			var contrastRatio = this.contrast(color2);
			if (contrastRatio &gt;= 7.1) {
				return &#x27;AAA&#x27;;
			}

			return (contrastRatio &gt;= 4.5) ? &#x27;AA&#x27; : &#x27;&#x27;;
		},

		dark: function () {
			// YIQ equation from http://24ways.org/2010/calculating-color-contrast
			var rgb = this.values.rgb;
			var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
			return yiq &lt; 128;
		},

		light: function () {
			return !this.dark();
		},

		negate: function () {
			var rgb = [];
			for (var i = 0; i &lt; 3; i++) {
				rgb[i] = 255 - this.values.rgb[i];
			}
			this.setValues(&#x27;rgb&#x27;, rgb);
			return this;
		},

		lighten: function (ratio) {
			var hsl = this.values.hsl;
			hsl[2] += hsl[2] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		darken: function (ratio) {
			var hsl = this.values.hsl;
			hsl[2] -= hsl[2] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		saturate: function (ratio) {
			var hsl = this.values.hsl;
			hsl[1] += hsl[1] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		desaturate: function (ratio) {
			var hsl = this.values.hsl;
			hsl[1] -= hsl[1] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		whiten: function (ratio) {
			var hwb = this.values.hwb;
			hwb[1] += hwb[1] * ratio;
			this.setValues(&#x27;hwb&#x27;, hwb);
			return this;
		},

		blacken: function (ratio) {
			var hwb = this.values.hwb;
			hwb[2] += hwb[2] * ratio;
			this.setValues(&#x27;hwb&#x27;, hwb);
			return this;
		},

		greyscale: function () {
			var rgb = this.values.rgb;
			// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
			var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
			this.setValues(&#x27;rgb&#x27;, [val, val, val]);
			return this;
		},

		clearer: function (ratio) {
			var alpha = this.values.alpha;
			this.setValues(&#x27;alpha&#x27;, alpha - (alpha * ratio));
			return this;
		},

		opaquer: function (ratio) {
			var alpha = this.values.alpha;
			this.setValues(&#x27;alpha&#x27;, alpha + (alpha * ratio));
			return this;
		},

		rotate: function (degrees) {
			var hsl = this.values.hsl;
			var hue = (hsl[0] + degrees) % 360;
			hsl[0] = hue &lt; 0 ? 360 + hue : hue;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		/**
		 * Ported from sass implementation in C
		 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		 */
		mix: function (mixinColor, weight) {
			var color1 = this;
			var color2 = mixinColor;
			var p = weight === undefined ? 0.5 : weight;

			var w = 2 * p - 1;
			var a = color1.alpha() - color2.alpha();

			var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			var w2 = 1 - w1;

			return this
				.rgb(
					w1 * color1.red() + w2 * color2.red(),
					w1 * color1.green() + w2 * color2.green(),
					w1 * color1.blue() + w2 * color2.blue()
				)
				.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
		},

		toJSON: function () {
			return this.rgb();
		},

		clone: function () {
			// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
			// making the final build way to big to embed in Chart.js. So let&#x27;s do it manually,
			// assuming that values to clone are 1 dimension arrays containing only numbers,
			// except &#x27;alpha&#x27; which is a number.
			var result = new Color();
			var source = this.values;
			var target = result.values;
			var value, type;

			for (var prop in source) {
				if (source.hasOwnProperty(prop)) {
					value = source[prop];
					type = ({}).toString.call(value);
					if (type === &#x27;[object Array]&#x27;) {
						target[prop] = value.slice(0);
					} else if (type === &#x27;[object Number]&#x27;) {
						target[prop] = value;
					} else {
						console.error(&#x27;unexpected color value:&#x27;, value);
					}
				}
			}

			return result;
		}
	};

	Color.prototype.spaces = {
		rgb: [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;],
		hsl: [&#x27;hue&#x27;, &#x27;saturation&#x27;, &#x27;lightness&#x27;],
		hsv: [&#x27;hue&#x27;, &#x27;saturation&#x27;, &#x27;value&#x27;],
		hwb: [&#x27;hue&#x27;, &#x27;whiteness&#x27;, &#x27;blackness&#x27;],
		cmyk: [&#x27;cyan&#x27;, &#x27;magenta&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]
	};

	Color.prototype.maxes = {
		rgb: [255, 255, 255],
		hsl: [360, 100, 100],
		hsv: [360, 100, 100],
		hwb: [360, 100, 100],
		cmyk: [100, 100, 100, 100]
	};

	Color.prototype.getValues = function (space) {
		var values = this.values;
		var vals = {};

		for (var i = 0; i &lt; space.length; i++) {
			vals[space.charAt(i)] = values[space][i];
		}

		if (values.alpha !== 1) {
			vals.a = values.alpha;
		}

		// {r: 255, g: 255, b: 255, a: 0.4}
		return vals;
	};

	Color.prototype.setValues = function (space, vals) {
		var values = this.values;
		var spaces = this.spaces;
		var maxes = this.maxes;
		var alpha = 1;
		var i;

		this.valid = true;

		if (space === &#x27;alpha&#x27;) {
			alpha = vals;
		} else if (vals.length) {
			// [10, 10, 10]
			values[space] = vals.slice(0, space.length);
			alpha = vals[space.length];
		} else if (vals[space.charAt(0)] !== undefined) {
			// {r: 10, g: 10, b: 10}
			for (i = 0; i &lt; space.length; i++) {
				values[space][i] = vals[space.charAt(i)];
			}

			alpha = vals.a;
		} else if (vals[spaces[space][0]] !== undefined) {
			// {red: 10, green: 10, blue: 10}
			var chans = spaces[space];

			for (i = 0; i &lt; space.length; i++) {
				values[space][i] = vals[chans[i]];
			}

			alpha = vals.alpha;
		}

		values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));

		if (space === &#x27;alpha&#x27;) {
			return false;
		}

		var capped;

		// cap values of the space prior converting all values
		for (i = 0; i &lt; space.length; i++) {
			capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
			values[space][i] = Math.round(capped);
		}

		// convert to all the other color spaces
		for (var sname in spaces) {
			if (sname !== space) {
				values[sname] = convert[space][sname](values[space]);
			}
		}

		return true;
	};

	Color.prototype.setSpace = function (space, args) {
		var vals = args[0];

		if (vals === undefined) {
			// color.rgb()
			return this.getValues(space);
		}

		// color.rgb(10, 10, 10)
		if (typeof vals === &#x27;number&#x27;) {
			vals = Array.prototype.slice.call(args);
		}

		this.setValues(space, vals);
		return this;
	};

	Color.prototype.setChannel = function (space, index, val) {
		var svalues = this.values[space];
		if (val === undefined) {
			// color.red()
			return svalues[index];
		} else if (val === svalues[index]) {
			// color.red(color.red())
			return this;
		}

		// color.red(100)
		svalues[index] = val;
		this.setValues(space, svalues);

		return this;
	};

	if (typeof window !== &#x27;undefined&#x27;) {
		window.Color = Color;
	}

	module.exports = Color;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	var conversions = __webpack_require__(44);

	var convert = function() {
	   return new Converter();
	}

	for (var func in conversions) {
	  // export Raw versions
	  convert[func + &quot;Raw&quot;] =  (function(func) {
	    // accept array or plain args
	    return function(arg) {
	      if (typeof arg == &quot;number&quot;)
	        arg = Array.prototype.slice.call(arguments);
	      return conversions[func](arg);
	    }
	  })(func);

	  var pair = /(\w+)2(\w+)/.exec(func),
	      from = pair[1],
	      to = pair[2];

	  // export rgb2hsl and [&quot;rgb&quot;][&quot;hsl&quot;]
	  convert[from] = convert[from] || {};

	  convert[from][to] = convert[func] = (function(func) { 
	    return function(arg) {
	      if (typeof arg == &quot;number&quot;)
	        arg = Array.prototype.slice.call(arguments);
	      
	      var val = conversions[func](arg);
	      if (typeof val == &quot;string&quot; || val === undefined)
	        return val; // keyword

	      for (var i = 0; i &lt; val.length; i++)
	        val[i] = Math.round(val[i]);
	      return val;
	    }
	  })(func);
	}


	/* Converter does lazy conversion and caching */
	var Converter = function() {
	   this.convs = {};
	};

	/* Either get the values for a space or
	  set the values for a space, depending on args */
	Converter.prototype.routeSpace = function(space, args) {
	   var values = args[0];
	   if (values === undefined) {
	      // color.rgb()
	      return this.getValues(space);
	   }
	   // color.rgb(10, 10, 10)
	   if (typeof values == &quot;number&quot;) {
	      values = Array.prototype.slice.call(args);        
	   }

	   return this.setValues(space, values);
	};
	  
	/* Set the values for a space, invalidating cache */
	Converter.prototype.setValues = function(space, values) {
	   this.space = space;
	   this.convs = {};
	   this.convs[space] = values;
	   return this;
	};

	/* Get the values for a space. If there&#x27;s already
	  a conversion for the space, fetch it, otherwise
	  compute it */
	Converter.prototype.getValues = function(space) {
	   var vals = this.convs[space];
	   if (!vals) {
	      var fspace = this.space,
	          from = this.convs[fspace];
	      vals = convert[fspace][space](from);

	      this.convs[space] = vals;
	   }
	  return vals;
	};

	[&quot;rgb&quot;, &quot;hsl&quot;, &quot;hsv&quot;, &quot;cmyk&quot;, &quot;keyword&quot;].forEach(function(space) {
	   Converter.prototype[space] = function(vals) {
	      return this.routeSpace(space, arguments);
	   }
	});

	module.exports = convert;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	/* MIT license */

	module.exports = {
	  rgb2hsl: rgb2hsl,
	  rgb2hsv: rgb2hsv,
	  rgb2hwb: rgb2hwb,
	  rgb2cmyk: rgb2cmyk,
	  rgb2keyword: rgb2keyword,
	  rgb2xyz: rgb2xyz,
	  rgb2lab: rgb2lab,
	  rgb2lch: rgb2lch,

	  hsl2rgb: hsl2rgb,
	  hsl2hsv: hsl2hsv,
	  hsl2hwb: hsl2hwb,
	  hsl2cmyk: hsl2cmyk,
	  hsl2keyword: hsl2keyword,

	  hsv2rgb: hsv2rgb,
	  hsv2hsl: hsv2hsl,
	  hsv2hwb: hsv2hwb,
	  hsv2cmyk: hsv2cmyk,
	  hsv2keyword: hsv2keyword,

	  hwb2rgb: hwb2rgb,
	  hwb2hsl: hwb2hsl,
	  hwb2hsv: hwb2hsv,
	  hwb2cmyk: hwb2cmyk,
	  hwb2keyword: hwb2keyword,

	  cmyk2rgb: cmyk2rgb,
	  cmyk2hsl: cmyk2hsl,
	  cmyk2hsv: cmyk2hsv,
	  cmyk2hwb: cmyk2hwb,
	  cmyk2keyword: cmyk2keyword,

	  keyword2rgb: keyword2rgb,
	  keyword2hsl: keyword2hsl,
	  keyword2hsv: keyword2hsv,
	  keyword2hwb: keyword2hwb,
	  keyword2cmyk: keyword2cmyk,
	  keyword2lab: keyword2lab,
	  keyword2xyz: keyword2xyz,

	  xyz2rgb: xyz2rgb,
	  xyz2lab: xyz2lab,
	  xyz2lch: xyz2lch,

	  lab2xyz: lab2xyz,
	  lab2rgb: lab2rgb,
	  lab2lch: lab2lch,

	  lch2lab: lch2lab,
	  lch2xyz: lch2xyz,
	  lch2rgb: lch2rgb
	}


	function rgb2hsl(rgb) {
	  var r = rgb[0]/255,
	      g = rgb[1]/255,
	      b = rgb[2]/255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, l;

	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g)/ delta;

	  h = Math.min(h * 60, 360);

	  if (h &lt; 0)
	    h += 360;

	  l = (min + max) / 2;

	  if (max == min)
	    s = 0;
	  else if (l &lt;= 0.5)
	    s = delta / (max + min);
	  else
	    s = delta / (2 - max - min);

	  return [h, s * 100, l * 100];
	}

	function rgb2hsv(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, v;

	  if (max == 0)
	    s = 0;
	  else
	    s = (delta/max * 1000)/10;

	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g) / delta;

	  h = Math.min(h * 60, 360);

	  if (h &lt; 0)
	    h += 360;

	  v = ((max / 255) * 1000) / 10;

	  return [h, s, v];
	}

	function rgb2hwb(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      h = rgb2hsl(rgb)[0],
	      w = 1/255 * Math.min(r, Math.min(g, b)),
	      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

	  return [h, w * 100, b * 100];
	}

	function rgb2cmyk(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255,
	      c, m, y, k;

	  k = Math.min(1 - r, 1 - g, 1 - b);
	  c = (1 - r - k) / (1 - k) || 0;
	  m = (1 - g - k) / (1 - k) || 0;
	  y = (1 - b - k) / (1 - k) || 0;
	  return [c * 100, m * 100, y * 100, k * 100];
	}

	function rgb2keyword(rgb) {
	  return reverseKeywords[JSON.stringify(rgb)];
	}

	function rgb2xyz(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255;

	  // assume sRGB
	  r = r &gt; 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	  g = g &gt; 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	  b = b &gt; 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	  return [x * 100, y *100, z * 100];
	}

	function rgb2lab(rgb) {
	  var xyz = rgb2xyz(rgb),
	        x = xyz[0],
	        y = xyz[1],
	        z = xyz[2],
	        l, a, b;

	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;

	  x = x &gt; 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y &gt; 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z &gt; 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);

	  return [l, a, b];
	}

	function rgb2lch(args) {
	  return lab2lch(rgb2lab(args));
	}

	function hsl2rgb(hsl) {
	  var h = hsl[0] / 360,
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      t1, t2, t3, rgb, val;

	  if (s == 0) {
	    val = l * 255;
	    return [val, val, val];
	  }

	  if (l &lt; 0.5)
	    t2 = l * (1 + s);
	  else
	    t2 = l + s - l * s;
	  t1 = 2 * l - t2;

	  rgb = [0, 0, 0];
	  for (var i = 0; i &lt; 3; i++) {
	    t3 = h + 1 / 3 * - (i - 1);
	    t3 &lt; 0 &amp;&amp; t3++;
	    t3 &gt; 1 &amp;&amp; t3--;

	    if (6 * t3 &lt; 1)
	      val = t1 + (t2 - t1) * 6 * t3;
	    else if (2 * t3 &lt; 1)
	      val = t2;
	    else if (3 * t3 &lt; 2)
	      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	    else
	      val = t1;

	    rgb[i] = val * 255;
	  }

	  return rgb;
	}

	function hsl2hsv(hsl) {
	  var h = hsl[0],
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      sv, v;

	  if(l === 0) {
	      // no need to do calc on black
	      // also avoids divide by 0 error
	      return [0, 0, 0];
	  }

	  l *= 2;
	  s *= (l &lt;= 1) ? l : 2 - l;
	  v = (l + s) / 2;
	  sv = (2 * s) / (l + s);
	  return [h, sv * 100, v * 100];
	}

	function hsl2hwb(args) {
	  return rgb2hwb(hsl2rgb(args));
	}

	function hsl2cmyk(args) {
	  return rgb2cmyk(hsl2rgb(args));
	}

	function hsl2keyword(args) {
	  return rgb2keyword(hsl2rgb(args));
	}


	function hsv2rgb(hsv) {
	  var h = hsv[0] / 60,
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      hi = Math.floor(h) % 6;

	  var f = h - Math.floor(h),
	      p = 255 * v * (1 - s),
	      q = 255 * v * (1 - (s * f)),
	      t = 255 * v * (1 - (s * (1 - f))),
	      v = 255 * v;

	  switch(hi) {
	    case 0:
	      return [v, t, p];
	    case 1:
	      return [q, v, p];
	    case 2:
	      return [p, v, t];
	    case 3:
	      return [p, q, v];
	    case 4:
	      return [t, p, v];
	    case 5:
	      return [v, p, q];
	  }
	}

	function hsv2hsl(hsv) {
	  var h = hsv[0],
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      sl, l;

	  l = (2 - s) * v;
	  sl = s * v;
	  sl /= (l &lt;= 1) ? l : 2 - l;
	  sl = sl || 0;
	  l /= 2;
	  return [h, sl * 100, l * 100];
	}

	function hsv2hwb(args) {
	  return rgb2hwb(hsv2rgb(args))
	}

	function hsv2cmyk(args) {
	  return rgb2cmyk(hsv2rgb(args));
	}

	function hsv2keyword(args) {
	  return rgb2keyword(hsv2rgb(args));
	}

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	function hwb2rgb(hwb) {
	  var h = hwb[0] / 360,
	      wh = hwb[1] / 100,
	      bl = hwb[2] / 100,
	      ratio = wh + bl,
	      i, v, f, n;

	  // wh + bl cant be &gt; 1
	  if (ratio &gt; 1) {
	    wh /= ratio;
	    bl /= ratio;
	  }

	  i = Math.floor(6 * h);
	  v = 1 - bl;
	  f = 6 * h - i;
	  if ((i &amp; 0x01) != 0) {
	    f = 1 - f;
	  }
	  n = wh + f * (v - wh);  // linear interpolation

	  switch (i) {
	    default:
	    case 6:
	    case 0: r = v; g = n; b = wh; break;
	    case 1: r = n; g = v; b = wh; break;
	    case 2: r = wh; g = v; b = n; break;
	    case 3: r = wh; g = n; b = v; break;
	    case 4: r = n; g = wh; b = v; break;
	    case 5: r = v; g = wh; b = n; break;
	  }

	  return [r * 255, g * 255, b * 255];
	}

	function hwb2hsl(args) {
	  return rgb2hsl(hwb2rgb(args));
	}

	function hwb2hsv(args) {
	  return rgb2hsv(hwb2rgb(args));
	}

	function hwb2cmyk(args) {
	  return rgb2cmyk(hwb2rgb(args));
	}

	function hwb2keyword(args) {
	  return rgb2keyword(hwb2rgb(args));
	}

	function cmyk2rgb(cmyk) {
	  var c = cmyk[0] / 100,
	      m = cmyk[1] / 100,
	      y = cmyk[2] / 100,
	      k = cmyk[3] / 100,
	      r, g, b;

	  r = 1 - Math.min(1, c * (1 - k) + k);
	  g = 1 - Math.min(1, m * (1 - k) + k);
	  b = 1 - Math.min(1, y * (1 - k) + k);
	  return [r * 255, g * 255, b * 255];
	}

	function cmyk2hsl(args) {
	  return rgb2hsl(cmyk2rgb(args));
	}

	function cmyk2hsv(args) {
	  return rgb2hsv(cmyk2rgb(args));
	}

	function cmyk2hwb(args) {
	  return rgb2hwb(cmyk2rgb(args));
	}

	function cmyk2keyword(args) {
	  return rgb2keyword(cmyk2rgb(args));
	}


	function xyz2rgb(xyz) {
	  var x = xyz[0] / 100,
	      y = xyz[1] / 100,
	      z = xyz[2] / 100,
	      r, g, b;

	  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	  // assume sRGB
	  r = r &gt; 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
	    : r = (r * 12.92);

	  g = g &gt; 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
	    : g = (g * 12.92);

	  b = b &gt; 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
	    : b = (b * 12.92);

	  r = Math.min(Math.max(0, r), 1);
	  g = Math.min(Math.max(0, g), 1);
	  b = Math.min(Math.max(0, b), 1);

	  return [r * 255, g * 255, b * 255];
	}

	function xyz2lab(xyz) {
	  var x = xyz[0],
	      y = xyz[1],
	      z = xyz[2],
	      l, a, b;

	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;

	  x = x &gt; 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y &gt; 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z &gt; 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);

	  return [l, a, b];
	}

	function xyz2lch(args) {
	  return lab2lch(xyz2lab(args));
	}

	function lab2xyz(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      x, y, z, y2;

	  if (l &lt;= 8) {
	    y = (l * 100) / 903.3;
	    y2 = (7.787 * (y / 100)) + (16 / 116);
	  } else {
	    y = 100 * Math.pow((l + 16) / 116, 3);
	    y2 = Math.pow(y / 100, 1/3);
	  }

	  x = x / 95.047 &lt;= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

	  z = z / 108.883 &lt;= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

	  return [x, y, z];
	}

	function lab2lch(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      hr, h, c;

	  hr = Math.atan2(b, a);
	  h = hr * 360 / 2 / Math.PI;
	  if (h &lt; 0) {
	    h += 360;
	  }
	  c = Math.sqrt(a * a + b * b);
	  return [l, c, h];
	}

	function lab2rgb(args) {
	  return xyz2rgb(lab2xyz(args));
	}

	function lch2lab(lch) {
	  var l = lch[0],
	      c = lch[1],
	      h = lch[2],
	      a, b, hr;

	  hr = h / 360 * 2 * Math.PI;
	  a = c * Math.cos(hr);
	  b = c * Math.sin(hr);
	  return [l, a, b];
	}

	function lch2xyz(args) {
	  return lab2xyz(lch2lab(args));
	}

	function lch2rgb(args) {
	  return lab2rgb(lch2lab(args));
	}

	function keyword2rgb(keyword) {
	  return cssKeywords[keyword];
	}

	function keyword2hsl(args) {
	  return rgb2hsl(keyword2rgb(args));
	}

	function keyword2hsv(args) {
	  return rgb2hsv(keyword2rgb(args));
	}

	function keyword2hwb(args) {
	  return rgb2hwb(keyword2rgb(args));
	}

	function keyword2cmyk(args) {
	  return rgb2cmyk(keyword2rgb(args));
	}

	function keyword2lab(args) {
	  return rgb2lab(keyword2rgb(args));
	}

	function keyword2xyz(args) {
	  return rgb2xyz(keyword2rgb(args));
	}

	var cssKeywords = {
	  aliceblue:  [240,248,255],
	  antiquewhite: [250,235,215],
	  aqua: [0,255,255],
	  aquamarine: [127,255,212],
	  azure:  [240,255,255],
	  beige:  [245,245,220],
	  bisque: [255,228,196],
	  black:  [0,0,0],
	  blanchedalmond: [255,235,205],
	  blue: [0,0,255],
	  blueviolet: [138,43,226],
	  brown:  [165,42,42],
	  burlywood:  [222,184,135],
	  cadetblue:  [95,158,160],
	  chartreuse: [127,255,0],
	  chocolate:  [210,105,30],
	  coral:  [255,127,80],
	  cornflowerblue: [100,149,237],
	  cornsilk: [255,248,220],
	  crimson:  [220,20,60],
	  cyan: [0,255,255],
	  darkblue: [0,0,139],
	  darkcyan: [0,139,139],
	  darkgoldenrod:  [184,134,11],
	  darkgray: [169,169,169],
	  darkgreen:  [0,100,0],
	  darkgrey: [169,169,169],
	  darkkhaki:  [189,183,107],
	  darkmagenta:  [139,0,139],
	  darkolivegreen: [85,107,47],
	  darkorange: [255,140,0],
	  darkorchid: [153,50,204],
	  darkred:  [139,0,0],
	  darksalmon: [233,150,122],
	  darkseagreen: [143,188,143],
	  darkslateblue:  [72,61,139],
	  darkslategray:  [47,79,79],
	  darkslategrey:  [47,79,79],
	  darkturquoise:  [0,206,209],
	  darkviolet: [148,0,211],
	  deeppink: [255,20,147],
	  deepskyblue:  [0,191,255],
	  dimgray:  [105,105,105],
	  dimgrey:  [105,105,105],
	  dodgerblue: [30,144,255],
	  firebrick:  [178,34,34],
	  floralwhite:  [255,250,240],
	  forestgreen:  [34,139,34],
	  fuchsia:  [255,0,255],
	  gainsboro:  [220,220,220],
	  ghostwhite: [248,248,255],
	  gold: [255,215,0],
	  goldenrod:  [218,165,32],
	  gray: [128,128,128],
	  green:  [0,128,0],
	  greenyellow:  [173,255,47],
	  grey: [128,128,128],
	  honeydew: [240,255,240],
	  hotpink:  [255,105,180],
	  indianred:  [205,92,92],
	  indigo: [75,0,130],
	  ivory:  [255,255,240],
	  khaki:  [240,230,140],
	  lavender: [230,230,250],
	  lavenderblush:  [255,240,245],
	  lawngreen:  [124,252,0],
	  lemonchiffon: [255,250,205],
	  lightblue:  [173,216,230],
	  lightcoral: [240,128,128],
	  lightcyan:  [224,255,255],
	  lightgoldenrodyellow: [250,250,210],
	  lightgray:  [211,211,211],
	  lightgreen: [144,238,144],
	  lightgrey:  [211,211,211],
	  lightpink:  [255,182,193],
	  lightsalmon:  [255,160,122],
	  lightseagreen:  [32,178,170],
	  lightskyblue: [135,206,250],
	  lightslategray: [119,136,153],
	  lightslategrey: [119,136,153],
	  lightsteelblue: [176,196,222],
	  lightyellow:  [255,255,224],
	  lime: [0,255,0],
	  limegreen:  [50,205,50],
	  linen:  [250,240,230],
	  magenta:  [255,0,255],
	  maroon: [128,0,0],
	  mediumaquamarine: [102,205,170],
	  mediumblue: [0,0,205],
	  mediumorchid: [186,85,211],
	  mediumpurple: [147,112,219],
	  mediumseagreen: [60,179,113],
	  mediumslateblue:  [123,104,238],
	  mediumspringgreen:  [0,250,154],
	  mediumturquoise:  [72,209,204],
	  mediumvioletred:  [199,21,133],
	  midnightblue: [25,25,112],
	  mintcream:  [245,255,250],
	  mistyrose:  [255,228,225],
	  moccasin: [255,228,181],
	  navajowhite:  [255,222,173],
	  navy: [0,0,128],
	  oldlace:  [253,245,230],
	  olive:  [128,128,0],
	  olivedrab:  [107,142,35],
	  orange: [255,165,0],
	  orangered:  [255,69,0],
	  orchid: [218,112,214],
	  palegoldenrod:  [238,232,170],
	  palegreen:  [152,251,152],
	  paleturquoise:  [175,238,238],
	  palevioletred:  [219,112,147],
	  papayawhip: [255,239,213],
	  peachpuff:  [255,218,185],
	  peru: [205,133,63],
	  pink: [255,192,203],
	  plum: [221,160,221],
	  powderblue: [176,224,230],
	  purple: [128,0,128],
	  rebeccapurple: [102, 51, 153],
	  red:  [255,0,0],
	  rosybrown:  [188,143,143],
	  royalblue:  [65,105,225],
	  saddlebrown:  [139,69,19],
	  salmon: [250,128,114],
	  sandybrown: [244,164,96],
	  seagreen: [46,139,87],
	  seashell: [255,245,238],
	  sienna: [160,82,45],
	  silver: [192,192,192],
	  skyblue:  [135,206,235],
	  slateblue:  [106,90,205],
	  slategray:  [112,128,144],
	  slategrey:  [112,128,144],
	  snow: [255,250,250],
	  springgreen:  [0,255,127],
	  steelblue:  [70,130,180],
	  tan:  [210,180,140],
	  teal: [0,128,128],
	  thistle:  [216,191,216],
	  tomato: [255,99,71],
	  turquoise:  [64,224,208],
	  violet: [238,130,238],
	  wheat:  [245,222,179],
	  white:  [255,255,255],
	  whitesmoke: [245,245,245],
	  yellow: [255,255,0],
	  yellowgreen:  [154,205,50]
	};

	var reverseKeywords = {};
	for (var key in cssKeywords) {
	  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
	}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/* MIT license */
	var colorNames = __webpack_require__(46);

	module.exports = {
	   getRgba: getRgba,
	   getHsla: getHsla,
	   getRgb: getRgb,
	   getHsl: getHsl,
	   getHwb: getHwb,
	   getAlpha: getAlpha,

	   hexString: hexString,
	   rgbString: rgbString,
	   rgbaString: rgbaString,
	   percentString: percentString,
	   percentaString: percentaString,
	   hslString: hslString,
	   hslaString: hslaString,
	   hwbString: hwbString,
	   keyword: keyword
	}

	function getRgba(string) {
	   if (!string) {
	      return;
	   }
	   var abbr =  /^#([a-fA-F0-9]{3})$/i,
	       hex =  /^#([a-fA-F0-9]{6})$/i,
	       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
	       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
	       keyword = /(\w+)/;

	   var rgb = [0, 0, 0],
	       a = 1,
	       match = string.match(abbr);
	   if (match) {
	      match = match[1];
	      for (var i = 0; i &lt; rgb.length; i++) {
	         rgb[i] = parseInt(match[i] + match[i], 16);
	      }
	   }
	   else if (match = string.match(hex)) {
	      match = match[1];
	      for (var i = 0; i &lt; rgb.length; i++) {
	         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
	      }
	   }
	   else if (match = string.match(rgba)) {
	      for (var i = 0; i &lt; rgb.length; i++) {
	         rgb[i] = parseInt(match[i + 1]);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(per)) {
	      for (var i = 0; i &lt; rgb.length; i++) {
	         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(keyword)) {
	      if (match[1] == &quot;transparent&quot;) {
	         return [0, 0, 0, 0];
	      }
	      rgb = colorNames[match[1]];
	      if (!rgb) {
	         return;
	      }
	   }

	   for (var i = 0; i &lt; rgb.length; i++) {
	      rgb[i] = scale(rgb[i], 0, 255);
	   }
	   if (!a &amp;&amp; a != 0) {
	      a = 1;
	   }
	   else {
	      a = scale(a, 0, 1);
	   }
	   rgb[3] = a;
	   return rgb;
	}

	function getHsla(string) {
	   if (!string) {
	      return;
	   }
	   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hsl);
	   if (match) {
	      var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          s = scale(parseFloat(match[2]), 0, 100),
	          l = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, s, l, a];
	   }
	}

	function getHwb(string) {
	   if (!string) {
	      return;
	   }
	   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hwb);
	   if (match) {
	    var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          w = scale(parseFloat(match[2]), 0, 100),
	          b = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, w, b, a];
	   }
	}

	function getRgb(string) {
	   var rgba = getRgba(string);
	   return rgba &amp;&amp; rgba.slice(0, 3);
	}

	function getHsl(string) {
	  var hsla = getHsla(string);
	  return hsla &amp;&amp; hsla.slice(0, 3);
	}

	function getAlpha(string) {
	   var vals = getRgba(string);
	   if (vals) {
	      return vals[3];
	   }
	   else if (vals = getHsla(string)) {
	      return vals[3];
	   }
	   else if (vals = getHwb(string)) {
	      return vals[3];
	   }
	}

	// generators
	function hexString(rgb) {
	   return &quot;#&quot; + hexDouble(rgb[0]) + hexDouble(rgb[1])
	              + hexDouble(rgb[2]);
	}

	function rgbString(rgba, alpha) {
	   if (alpha &lt; 1 || (rgba[3] &amp;&amp; rgba[3] &lt; 1)) {
	      return rgbaString(rgba, alpha);
	   }
	   return &quot;rgb(&quot; + rgba[0] + &quot;, &quot; + rgba[1] + &quot;, &quot; + rgba[2] + &quot;)&quot;;
	}

	function rgbaString(rgba, alpha) {
	   if (alpha === undefined) {
	      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
	   }
	   return &quot;rgba(&quot; + rgba[0] + &quot;, &quot; + rgba[1] + &quot;, &quot; + rgba[2]
	           + &quot;, &quot; + alpha + &quot;)&quot;;
	}

	function percentString(rgba, alpha) {
	   if (alpha &lt; 1 || (rgba[3] &amp;&amp; rgba[3] &lt; 1)) {
	      return percentaString(rgba, alpha);
	   }
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);

	   return &quot;rgb(&quot; + r + &quot;%, &quot; + g + &quot;%, &quot; + b + &quot;%)&quot;;
	}

	function percentaString(rgba, alpha) {
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);
	   return &quot;rgba(&quot; + r + &quot;%, &quot; + g + &quot;%, &quot; + b + &quot;%, &quot; + (alpha || rgba[3] || 1) + &quot;)&quot;;
	}

	function hslString(hsla, alpha) {
	   if (alpha &lt; 1 || (hsla[3] &amp;&amp; hsla[3] &lt; 1)) {
	      return hslaString(hsla, alpha);
	   }
	   return &quot;hsl(&quot; + hsla[0] + &quot;, &quot; + hsla[1] + &quot;%, &quot; + hsla[2] + &quot;%)&quot;;
	}

	function hslaString(hsla, alpha) {
	   if (alpha === undefined) {
	      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
	   }
	   return &quot;hsla(&quot; + hsla[0] + &quot;, &quot; + hsla[1] + &quot;%, &quot; + hsla[2] + &quot;%, &quot;
	           + alpha + &quot;)&quot;;
	}

	// hwb is a bit different than rgb(a) &amp; hsl(a) since there is no alpha specific syntax
	// (hwb have alpha optional &amp; 1 is default value)
	function hwbString(hwb, alpha) {
	   if (alpha === undefined) {
	      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
	   }
	   return &quot;hwb(&quot; + hwb[0] + &quot;, &quot; + hwb[1] + &quot;%, &quot; + hwb[2] + &quot;%&quot;
	           + (alpha !== undefined &amp;&amp; alpha !== 1 ? &quot;, &quot; + alpha : &quot;&quot;) + &quot;)&quot;;
	}

	function keyword(rgb) {
	  return reverseNames[rgb.slice(0, 3)];
	}

	// helpers
	function scale(num, min, max) {
	   return Math.min(Math.max(min, num), max);
	}

	function hexDouble(num) {
	  var str = num.toString(16).toUpperCase();
	  return (str.length &lt; 2) ? &quot;0&quot; + str : str;
	}


	//create a list of reverse color names
	var reverseNames = {};
	for (var name in colorNames) {
	   reverseNames[colorNames[name]] = name;
	}


/***/ }),
/* 46 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;

	module.exports = {
		&quot;aliceblue&quot;: [240, 248, 255],
		&quot;antiquewhite&quot;: [250, 235, 215],
		&quot;aqua&quot;: [0, 255, 255],
		&quot;aquamarine&quot;: [127, 255, 212],
		&quot;azure&quot;: [240, 255, 255],
		&quot;beige&quot;: [245, 245, 220],
		&quot;bisque&quot;: [255, 228, 196],
		&quot;black&quot;: [0, 0, 0],
		&quot;blanchedalmond&quot;: [255, 235, 205],
		&quot;blue&quot;: [0, 0, 255],
		&quot;blueviolet&quot;: [138, 43, 226],
		&quot;brown&quot;: [165, 42, 42],
		&quot;burlywood&quot;: [222, 184, 135],
		&quot;cadetblue&quot;: [95, 158, 160],
		&quot;chartreuse&quot;: [127, 255, 0],
		&quot;chocolate&quot;: [210, 105, 30],
		&quot;coral&quot;: [255, 127, 80],
		&quot;cornflowerblue&quot;: [100, 149, 237],
		&quot;cornsilk&quot;: [255, 248, 220],
		&quot;crimson&quot;: [220, 20, 60],
		&quot;cyan&quot;: [0, 255, 255],
		&quot;darkblue&quot;: [0, 0, 139],
		&quot;darkcyan&quot;: [0, 139, 139],
		&quot;darkgoldenrod&quot;: [184, 134, 11],
		&quot;darkgray&quot;: [169, 169, 169],
		&quot;darkgreen&quot;: [0, 100, 0],
		&quot;darkgrey&quot;: [169, 169, 169],
		&quot;darkkhaki&quot;: [189, 183, 107],
		&quot;darkmagenta&quot;: [139, 0, 139],
		&quot;darkolivegreen&quot;: [85, 107, 47],
		&quot;darkorange&quot;: [255, 140, 0],
		&quot;darkorchid&quot;: [153, 50, 204],
		&quot;darkred&quot;: [139, 0, 0],
		&quot;darksalmon&quot;: [233, 150, 122],
		&quot;darkseagreen&quot;: [143, 188, 143],
		&quot;darkslateblue&quot;: [72, 61, 139],
		&quot;darkslategray&quot;: [47, 79, 79],
		&quot;darkslategrey&quot;: [47, 79, 79],
		&quot;darkturquoise&quot;: [0, 206, 209],
		&quot;darkviolet&quot;: [148, 0, 211],
		&quot;deeppink&quot;: [255, 20, 147],
		&quot;deepskyblue&quot;: [0, 191, 255],
		&quot;dimgray&quot;: [105, 105, 105],
		&quot;dimgrey&quot;: [105, 105, 105],
		&quot;dodgerblue&quot;: [30, 144, 255],
		&quot;firebrick&quot;: [178, 34, 34],
		&quot;floralwhite&quot;: [255, 250, 240],
		&quot;forestgreen&quot;: [34, 139, 34],
		&quot;fuchsia&quot;: [255, 0, 255],
		&quot;gainsboro&quot;: [220, 220, 220],
		&quot;ghostwhite&quot;: [248, 248, 255],
		&quot;gold&quot;: [255, 215, 0],
		&quot;goldenrod&quot;: [218, 165, 32],
		&quot;gray&quot;: [128, 128, 128],
		&quot;green&quot;: [0, 128, 0],
		&quot;greenyellow&quot;: [173, 255, 47],
		&quot;grey&quot;: [128, 128, 128],
		&quot;honeydew&quot;: [240, 255, 240],
		&quot;hotpink&quot;: [255, 105, 180],
		&quot;indianred&quot;: [205, 92, 92],
		&quot;indigo&quot;: [75, 0, 130],
		&quot;ivory&quot;: [255, 255, 240],
		&quot;khaki&quot;: [240, 230, 140],
		&quot;lavender&quot;: [230, 230, 250],
		&quot;lavenderblush&quot;: [255, 240, 245],
		&quot;lawngreen&quot;: [124, 252, 0],
		&quot;lemonchiffon&quot;: [255, 250, 205],
		&quot;lightblue&quot;: [173, 216, 230],
		&quot;lightcoral&quot;: [240, 128, 128],
		&quot;lightcyan&quot;: [224, 255, 255],
		&quot;lightgoldenrodyellow&quot;: [250, 250, 210],
		&quot;lightgray&quot;: [211, 211, 211],
		&quot;lightgreen&quot;: [144, 238, 144],
		&quot;lightgrey&quot;: [211, 211, 211],
		&quot;lightpink&quot;: [255, 182, 193],
		&quot;lightsalmon&quot;: [255, 160, 122],
		&quot;lightseagreen&quot;: [32, 178, 170],
		&quot;lightskyblue&quot;: [135, 206, 250],
		&quot;lightslategray&quot;: [119, 136, 153],
		&quot;lightslategrey&quot;: [119, 136, 153],
		&quot;lightsteelblue&quot;: [176, 196, 222],
		&quot;lightyellow&quot;: [255, 255, 224],
		&quot;lime&quot;: [0, 255, 0],
		&quot;limegreen&quot;: [50, 205, 50],
		&quot;linen&quot;: [250, 240, 230],
		&quot;magenta&quot;: [255, 0, 255],
		&quot;maroon&quot;: [128, 0, 0],
		&quot;mediumaquamarine&quot;: [102, 205, 170],
		&quot;mediumblue&quot;: [0, 0, 205],
		&quot;mediumorchid&quot;: [186, 85, 211],
		&quot;mediumpurple&quot;: [147, 112, 219],
		&quot;mediumseagreen&quot;: [60, 179, 113],
		&quot;mediumslateblue&quot;: [123, 104, 238],
		&quot;mediumspringgreen&quot;: [0, 250, 154],
		&quot;mediumturquoise&quot;: [72, 209, 204],
		&quot;mediumvioletred&quot;: [199, 21, 133],
		&quot;midnightblue&quot;: [25, 25, 112],
		&quot;mintcream&quot;: [245, 255, 250],
		&quot;mistyrose&quot;: [255, 228, 225],
		&quot;moccasin&quot;: [255, 228, 181],
		&quot;navajowhite&quot;: [255, 222, 173],
		&quot;navy&quot;: [0, 0, 128],
		&quot;oldlace&quot;: [253, 245, 230],
		&quot;olive&quot;: [128, 128, 0],
		&quot;olivedrab&quot;: [107, 142, 35],
		&quot;orange&quot;: [255, 165, 0],
		&quot;orangered&quot;: [255, 69, 0],
		&quot;orchid&quot;: [218, 112, 214],
		&quot;palegoldenrod&quot;: [238, 232, 170],
		&quot;palegreen&quot;: [152, 251, 152],
		&quot;paleturquoise&quot;: [175, 238, 238],
		&quot;palevioletred&quot;: [219, 112, 147],
		&quot;papayawhip&quot;: [255, 239, 213],
		&quot;peachpuff&quot;: [255, 218, 185],
		&quot;peru&quot;: [205, 133, 63],
		&quot;pink&quot;: [255, 192, 203],
		&quot;plum&quot;: [221, 160, 221],
		&quot;powderblue&quot;: [176, 224, 230],
		&quot;purple&quot;: [128, 0, 128],
		&quot;rebeccapurple&quot;: [102, 51, 153],
		&quot;red&quot;: [255, 0, 0],
		&quot;rosybrown&quot;: [188, 143, 143],
		&quot;royalblue&quot;: [65, 105, 225],
		&quot;saddlebrown&quot;: [139, 69, 19],
		&quot;salmon&quot;: [250, 128, 114],
		&quot;sandybrown&quot;: [244, 164, 96],
		&quot;seagreen&quot;: [46, 139, 87],
		&quot;seashell&quot;: [255, 245, 238],
		&quot;sienna&quot;: [160, 82, 45],
		&quot;silver&quot;: [192, 192, 192],
		&quot;skyblue&quot;: [135, 206, 235],
		&quot;slateblue&quot;: [106, 90, 205],
		&quot;slategray&quot;: [112, 128, 144],
		&quot;slategrey&quot;: [112, 128, 144],
		&quot;snow&quot;: [255, 250, 250],
		&quot;springgreen&quot;: [0, 255, 127],
		&quot;steelblue&quot;: [70, 130, 180],
		&quot;tan&quot;: [210, 180, 140],
		&quot;teal&quot;: [0, 128, 128],
		&quot;thistle&quot;: [216, 191, 216],
		&quot;tomato&quot;: [255, 99, 71],
		&quot;turquoise&quot;: [64, 224, 208],
		&quot;violet&quot;: [238, 130, 238],
		&quot;wheat&quot;: [245, 222, 179],
		&quot;white&quot;: [255, 255, 255],
		&quot;whitesmoke&quot;: [245, 245, 245],
		&quot;yellow&quot;: [255, 255, 0],
		&quot;yellowgreen&quot;: [154, 205, 50]
	};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var color = __webpack_require__(42);
	var helpers = __webpack_require__(36);

	function interpolate(start, view, model, ease) {
		var keys = Object.keys(model);
		var i, ilen, key, actual, origin, target, type, c0, c1;

		for (i = 0, ilen = keys.length; i &lt; ilen; ++i) {
			key = keys[i];

			target = model[key];

			// if a value is added to the model after pivot() has been called, the view
			// doesn&#x27;t contain it, so let&#x27;s initialize the view to the target value.
			if (!view.hasOwnProperty(key)) {
				view[key] = target;
			}

			actual = view[key];

			if (actual === target || key[0] === &#x27;_&#x27;) {
				continue;
			}

			if (!start.hasOwnProperty(key)) {
				start[key] = actual;
			}

			origin = start[key];

			type = typeof target;

			if (type === typeof origin) {
				if (type === &#x27;string&#x27;) {
					c0 = color(origin);
					if (c0.valid) {
						c1 = color(target);
						if (c1.valid) {
							view[key] = c1.mix(c0, ease).rgbString();
							continue;
						}
					}
				} else if (type === &#x27;number&#x27; &amp;&amp; isFinite(origin) &amp;&amp; isFinite(target)) {
					view[key] = origin + (target - origin) * ease;
					continue;
				}
			}

			view[key] = target;
		}
	}

	var Element = function(configuration) {
		helpers.extend(this, configuration);
		this.initialize.apply(this, arguments);
	};

	helpers.extend(Element.prototype, {

		initialize: function() {
			this.hidden = false;
		},

		pivot: function() {
			var me = this;
			if (!me._view) {
				me._view = helpers.clone(me._model);
			}
			me._start = {};
			return me;
		},

		transition: function(ease) {
			var me = this;
			var model = me._model;
			var start = me._start;
			var view = me._view;

			// No animation -&gt; No Transition
			if (!model || ease === 1) {
				me._view = model;
				me._start = null;
				return me;
			}

			if (!view) {
				view = me._view = {};
			}

			if (!start) {
				start = me._start = {};
			}

			interpolate(start, view, model, ease);

			return me;
		},

		tooltipPosition: function() {
			return {
				x: this._model.x,
				y: this._model.y
			};
		},

		hasValue: function() {
			return helpers.isNumber(this._model.x) &amp;&amp; helpers.isNumber(this._model.y);
		}
	});

	Element.extend = helpers.inherits;

	module.exports = Element;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	module.exports = {};
	module.exports.Arc = __webpack_require__(49);
	module.exports.Line = __webpack_require__(50);
	module.exports.Point = __webpack_require__(51);
	module.exports.Rectangle = __webpack_require__(52);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		elements: {
			arc: {
				backgroundColor: defaults.global.defaultColor,
				borderColor: &#x27;#fff&#x27;,
				borderWidth: 2
			}
		}
	});

	module.exports = Element.extend({
		inLabelRange: function(mouseX) {
			var vm = this._view;

			if (vm) {
				return (Math.pow(mouseX - vm.x, 2) &lt; Math.pow(vm.radius + vm.hoverRadius, 2));
			}
			return false;
		},

		inRange: function(chartX, chartY) {
			var vm = this._view;

			if (vm) {
				var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
				var	angle = pointRelativePosition.angle;
				var distance = pointRelativePosition.distance;

				// Sanitise angle range
				var startAngle = vm.startAngle;
				var endAngle = vm.endAngle;
				while (endAngle &lt; startAngle) {
					endAngle += 2.0 * Math.PI;
				}
				while (angle &gt; endAngle) {
					angle -= 2.0 * Math.PI;
				}
				while (angle &lt; startAngle) {
					angle += 2.0 * Math.PI;
				}

				// Check if within the range of the open/close angle
				var betweenAngles = (angle &gt;= startAngle &amp;&amp; angle &lt;= endAngle);
				var withinRadius = (distance &gt;= vm.innerRadius &amp;&amp; distance &lt;= vm.outerRadius);

				return (betweenAngles &amp;&amp; withinRadius);
			}
			return false;
		},

		getCenterPoint: function() {
			var vm = this._view;
			var halfAngle = (vm.startAngle + vm.endAngle) / 2;
			var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
			return {
				x: vm.x + Math.cos(halfAngle) * halfRadius,
				y: vm.y + Math.sin(halfAngle) * halfRadius
			};
		},

		getArea: function() {
			var vm = this._view;
			return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
		},

		tooltipPosition: function() {
			var vm = this._view;
			var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
			var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

			return {
				x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
				y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
			};
		},

		draw: function() {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var sA = vm.startAngle;
			var eA = vm.endAngle;

			ctx.beginPath();

			ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
			ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

			ctx.closePath();
			ctx.strokeStyle = vm.borderColor;
			ctx.lineWidth = vm.borderWidth;

			ctx.fillStyle = vm.backgroundColor;

			ctx.fill();
			ctx.lineJoin = &#x27;bevel&#x27;;

			if (vm.borderWidth) {
				ctx.stroke();
			}
		}
	});


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);

	var globalDefaults = defaults.global;

	defaults._set(&#x27;global&#x27;, {
		elements: {
			line: {
				tension: 0.4,
				backgroundColor: globalDefaults.defaultColor,
				borderWidth: 3,
				borderColor: globalDefaults.defaultColor,
				borderCapStyle: &#x27;butt&#x27;,
				borderDash: [],
				borderDashOffset: 0.0,
				borderJoinStyle: &#x27;miter&#x27;,
				capBezierPoints: true,
				fill: true, // do we fill in the area between the line and its base axis
			}
		}
	});

	module.exports = Element.extend({
		draw: function() {
			var me = this;
			var vm = me._view;
			var ctx = me._chart.ctx;
			var spanGaps = vm.spanGaps;
			var points = me._children.slice(); // clone array
			var globalOptionLineElements = globalDefaults.elements.line;
			var lastDrawnIndex = -1;
			var index, current, previous, currentVM;

			// If we are looping, adding the first point again
			if (me._loop &amp;&amp; points.length) {
				points.push(points[0]);
			}

			ctx.save();

			// Stroke Line Options
			ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

			// IE 9 and 10 do not support line dash
			if (ctx.setLineDash) {
				ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
			}

			ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
			ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
			ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
			ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

			// Stroke Line
			ctx.beginPath();
			lastDrawnIndex = -1;

			for (index = 0; index &lt; points.length; ++index) {
				current = points[index];
				previous = helpers.previousItem(points, index);
				currentVM = current._view;

				// First point moves to it&#x27;s starting position no matter what
				if (index === 0) {
					if (!currentVM.skip) {
						ctx.moveTo(currentVM.x, currentVM.y);
						lastDrawnIndex = index;
					}
				} else {
					previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

					if (!currentVM.skip) {
						if ((lastDrawnIndex !== (index - 1) &amp;&amp; !spanGaps) || lastDrawnIndex === -1) {
							// There was a gap and this is the first point after the gap
							ctx.moveTo(currentVM.x, currentVM.y);
						} else {
							// Line to next point
							helpers.canvas.lineTo(ctx, previous._view, current._view);
						}
						lastDrawnIndex = index;
					}
				}
			}

			ctx.stroke();
			ctx.restore();
		}
	});


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);

	var defaultColor = defaults.global.defaultColor;

	defaults._set(&#x27;global&#x27;, {
		elements: {
			point: {
				radius: 3,
				pointStyle: &#x27;circle&#x27;,
				backgroundColor: defaultColor,
				borderColor: defaultColor,
				borderWidth: 1,
				// Hover
				hitRadius: 1,
				hoverRadius: 4,
				hoverBorderWidth: 1
			}
		}
	});

	function xRange(mouseX) {
		var vm = this._view;
		return vm ? (Math.abs(mouseX - vm.x) &lt; vm.radius + vm.hitRadius) : false;
	}

	function yRange(mouseY) {
		var vm = this._view;
		return vm ? (Math.abs(mouseY - vm.y) &lt; vm.radius + vm.hitRadius) : false;
	}

	module.exports = Element.extend({
		inRange: function(mouseX, mouseY) {
			var vm = this._view;
			return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) &lt; Math.pow(vm.hitRadius + vm.radius, 2)) : false;
		},

		inLabelRange: xRange,
		inXRange: xRange,
		inYRange: yRange,

		getCenterPoint: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		},

		getArea: function() {
			return Math.PI * Math.pow(this._view.radius, 2);
		},

		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y,
				padding: vm.radius + vm.borderWidth
			};
		},

		draw: function(chartArea) {
			var vm = this._view;
			var model = this._model;
			var ctx = this._chart.ctx;
			var pointStyle = vm.pointStyle;
			var radius = vm.radius;
			var x = vm.x;
			var y = vm.y;
			var color = helpers.color;
			var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
			var ratio = 0;

			if (vm.skip) {
				return;
			}

			ctx.strokeStyle = vm.borderColor || defaultColor;
			ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
			ctx.fillStyle = vm.backgroundColor || defaultColor;

			// Cliping for Points.
			// going out from inner charArea?
			if ((chartArea !== undefined) &amp;&amp; ((model.x &lt; chartArea.left) || (chartArea.right * errMargin &lt; model.x) || (model.y &lt; chartArea.top) || (chartArea.bottom * errMargin &lt; model.y))) {
				// Point fade out
				if (model.x &lt; chartArea.left) {
					ratio = (x - model.x) / (chartArea.left - model.x);
				} else if (chartArea.right * errMargin &lt; model.x) {
					ratio = (model.x - x) / (model.x - chartArea.right);
				} else if (model.y &lt; chartArea.top) {
					ratio = (y - model.y) / (chartArea.top - model.y);
				} else if (chartArea.bottom * errMargin &lt; model.y) {
					ratio = (model.y - y) / (model.y - chartArea.bottom);
				}
				ratio = Math.round(ratio * 100) / 100;
				ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
				ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
			}

			helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
		}
	});


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);

	defaults._set(&#x27;global&#x27;, {
		elements: {
			rectangle: {
				backgroundColor: defaults.global.defaultColor,
				borderColor: defaults.global.defaultColor,
				borderSkipped: &#x27;bottom&#x27;,
				borderWidth: 0
			}
		}
	});

	function isVertical(bar) {
		return bar._view.width !== undefined;
	}

	/**
	 * Helper function to get the bounds of the bar regardless of the orientation
	 * @param bar {Chart.Element.Rectangle} the bar
	 * @return {Bounds} bounds of the bar
	 * @private
	 */
	function getBarBounds(bar) {
		var vm = bar._view;
		var x1, x2, y1, y2;

		if (isVertical(bar)) {
			// vertical
			var halfWidth = vm.width / 2;
			x1 = vm.x - halfWidth;
			x2 = vm.x + halfWidth;
			y1 = Math.min(vm.y, vm.base);
			y2 = Math.max(vm.y, vm.base);
		} else {
			// horizontal bar
			var halfHeight = vm.height / 2;
			x1 = Math.min(vm.x, vm.base);
			x2 = Math.max(vm.x, vm.base);
			y1 = vm.y - halfHeight;
			y2 = vm.y + halfHeight;
		}

		return {
			left: x1,
			top: y1,
			right: x2,
			bottom: y2
		};
	}

	module.exports = Element.extend({
		draw: function() {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var left, right, top, bottom, signX, signY, borderSkipped;
			var borderWidth = vm.borderWidth;

			if (!vm.horizontal) {
				// bar
				left = vm.x - vm.width / 2;
				right = vm.x + vm.width / 2;
				top = vm.y;
				bottom = vm.base;
				signX = 1;
				signY = bottom &gt; top ? 1 : -1;
				borderSkipped = vm.borderSkipped || &#x27;bottom&#x27;;
			} else {
				// horizontal bar
				left = vm.base;
				right = vm.x;
				top = vm.y - vm.height / 2;
				bottom = vm.y + vm.height / 2;
				signX = right &gt; left ? 1 : -1;
				signY = 1;
				borderSkipped = vm.borderSkipped || &#x27;left&#x27;;
			}

			// Canvas doesn&#x27;t allow us to stroke inside the width so we can
			// adjust the sizes to fit if we&#x27;re setting a stroke on the line
			if (borderWidth) {
				// borderWidth shold be less than bar width and bar height.
				var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
				borderWidth = borderWidth &gt; barSize ? barSize : borderWidth;
				var halfStroke = borderWidth / 2;
				// Adjust borderWidth when bar top position is near vm.base(zero).
				var borderLeft = left + (borderSkipped !== &#x27;left&#x27; ? halfStroke * signX : 0);
				var borderRight = right + (borderSkipped !== &#x27;right&#x27; ? -halfStroke * signX : 0);
				var borderTop = top + (borderSkipped !== &#x27;top&#x27; ? halfStroke * signY : 0);
				var borderBottom = bottom + (borderSkipped !== &#x27;bottom&#x27; ? -halfStroke * signY : 0);
				// not become a vertical line?
				if (borderLeft !== borderRight) {
					top = borderTop;
					bottom = borderBottom;
				}
				// not become a horizontal line?
				if (borderTop !== borderBottom) {
					left = borderLeft;
					right = borderRight;
				}
			}

			ctx.beginPath();
			ctx.fillStyle = vm.backgroundColor;
			ctx.strokeStyle = vm.borderColor;
			ctx.lineWidth = borderWidth;

			// Corner points, from bottom-left to bottom-right clockwise
			// | 1 2 |
			// | 0 3 |
			var corners = [
				[left, bottom],
				[left, top],
				[right, top],
				[right, bottom]
			];

			// Find first (starting) corner with fallback to &#x27;bottom&#x27;
			var borders = [&#x27;bottom&#x27;, &#x27;left&#x27;, &#x27;top&#x27;, &#x27;right&#x27;];
			var startCorner = borders.indexOf(borderSkipped, 0);
			if (startCorner === -1) {
				startCorner = 0;
			}

			function cornerAt(index) {
				return corners[(startCorner + index) % 4];
			}

			// Draw rectangle from &#x27;startCorner&#x27;
			var corner = cornerAt(0);
			ctx.moveTo(corner[0], corner[1]);

			for (var i = 1; i &lt; 4; i++) {
				corner = cornerAt(i);
				ctx.lineTo(corner[0], corner[1]);
			}

			ctx.fill();
			if (borderWidth) {
				ctx.stroke();
			}
		},

		height: function() {
			var vm = this._view;
			return vm.base - vm.y;
		},

		inRange: function(mouseX, mouseY) {
			var inRange = false;

			if (this._view) {
				var bounds = getBarBounds(this);
				inRange = mouseX &gt;= bounds.left &amp;&amp; mouseX &lt;= bounds.right &amp;&amp; mouseY &gt;= bounds.top &amp;&amp; mouseY &lt;= bounds.bottom;
			}

			return inRange;
		},

		inLabelRange: function(mouseX, mouseY) {
			var me = this;
			if (!me._view) {
				return false;
			}

			var inRange = false;
			var bounds = getBarBounds(me);

			if (isVertical(me)) {
				inRange = mouseX &gt;= bounds.left &amp;&amp; mouseX &lt;= bounds.right;
			} else {
				inRange = mouseY &gt;= bounds.top &amp;&amp; mouseY &lt;= bounds.bottom;
			}

			return inRange;
		},

		inXRange: function(mouseX) {
			var bounds = getBarBounds(this);
			return mouseX &gt;= bounds.left &amp;&amp; mouseX &lt;= bounds.right;
		},

		inYRange: function(mouseY) {
			var bounds = getBarBounds(this);
			return mouseY &gt;= bounds.top &amp;&amp; mouseY &lt;= bounds.bottom;
		},

		getCenterPoint: function() {
			var vm = this._view;
			var x, y;
			if (isVertical(this)) {
				x = vm.x;
				y = (vm.y + vm.base) / 2;
			} else {
				x = (vm.x + vm.base) / 2;
				y = vm.y;
			}

			return {x: x, y: y};
		},

		getArea: function() {
			var vm = this._view;
			return vm.width * Math.abs(vm.y - vm.base);
		},

		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		}
	});


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);

	/**
	 * Helper function to get relative position for an event
	 * @param {Event|IEvent} event - The event to get the position for
	 * @param {Chart} chart - The chart
	 * @returns {Point} the event position
	 */
	function getRelativePosition(e, chart) {
		if (e.native) {
			return {
				x: e.x,
				y: e.y
			};
		}

		return helpers.getRelativePosition(e, chart);
	}

	/**
	 * Helper function to traverse all of the visible elements in the chart
	 * @param chart {chart} the chart
	 * @param handler {Function} the callback to execute for each visible item
	 */
	function parseVisibleItems(chart, handler) {
		var datasets = chart.data.datasets;
		var meta, i, j, ilen, jlen;

		for (i = 0, ilen = datasets.length; i &lt; ilen; ++i) {
			if (!chart.isDatasetVisible(i)) {
				continue;
			}

			meta = chart.getDatasetMeta(i);
			for (j = 0, jlen = meta.data.length; j &lt; jlen; ++j) {
				var element = meta.data[j];
				if (!element._view.skip) {
					handler(element);
				}
			}
		}
	}

	/**
	 * Helper function to get the items that intersect the event position
	 * @param items {ChartElement[]} elements to filter
	 * @param position {Point} the point to be nearest to
	 * @return {ChartElement[]} the nearest items
	 */
	function getIntersectItems(chart, position) {
		var elements = [];

		parseVisibleItems(chart, function(element) {
			if (element.inRange(position.x, position.y)) {
				elements.push(element);
			}
		});

		return elements;
	}

	/**
	 * Helper function to get the items nearest to the event position considering all visible items in teh chart
	 * @param chart {Chart} the chart to look at elements from
	 * @param position {Point} the point to be nearest to
	 * @param intersect {Boolean} if true, only consider items that intersect the position
	 * @param distanceMetric {Function} function to provide the distance between points
	 * @return {ChartElement[]} the nearest items
	 */
	function getNearestItems(chart, position, intersect, distanceMetric) {
		var minDistance = Number.POSITIVE_INFINITY;
		var nearestItems = [];

		parseVisibleItems(chart, function(element) {
			if (intersect &amp;&amp; !element.inRange(position.x, position.y)) {
				return;
			}

			var center = element.getCenterPoint();
			var distance = distanceMetric(position, center);

			if (distance &lt; minDistance) {
				nearestItems = [element];
				minDistance = distance;
			} else if (distance === minDistance) {
				// Can have multiple items at the same distance in which case we sort by size
				nearestItems.push(element);
			}
		});

		return nearestItems;
	}

	/**
	 * Get a distance metric function for two points based on the
	 * axis mode setting
	 * @param {String} axis the axis mode. x|y|xy
	 */
	function getDistanceMetricForAxis(axis) {
		var useX = axis.indexOf(&#x27;x&#x27;) !== -1;
		var useY = axis.indexOf(&#x27;y&#x27;) !== -1;

		return function(pt1, pt2) {
			var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
			var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
			return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
		};
	}

	function indexMode(chart, e, options) {
		var position = getRelativePosition(e, chart);
		// Default axis for index mode is &#x27;x&#x27; to match old behaviour
		options.axis = options.axis || &#x27;x&#x27;;
		var distanceMetric = getDistanceMetricForAxis(options.axis);
		var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
		var elements = [];

		if (!items.length) {
			return [];
		}

		chart.data.datasets.forEach(function(dataset, datasetIndex) {
			if (chart.isDatasetVisible(datasetIndex)) {
				var meta = chart.getDatasetMeta(datasetIndex);
				var element = meta.data[items[0]._index];

				// don&#x27;t count items that are skipped (null data)
				if (element &amp;&amp; !element._view.skip) {
					elements.push(element);
				}
			}
		});

		return elements;
	}

	/**
	 * @interface IInteractionOptions
	 */
	/**
	 * If true, only consider items that intersect the point
	 * @name IInterfaceOptions#boolean
	 * @type Boolean
	 */

	/**
	 * Contains interaction related functions
	 * @namespace Chart.Interaction
	 */
	module.exports = {
		// Helper function for different modes
		modes: {
			single: function(chart, e) {
				var position = getRelativePosition(e, chart);
				var elements = [];

				parseVisibleItems(chart, function(element) {
					if (element.inRange(position.x, position.y)) {
						elements.push(element);
						return elements;
					}
				});

				return elements.slice(0, 1);
			},

			/**
			 * @function Chart.Interaction.modes.label
			 * @deprecated since version 2.4.0
			 * @todo remove at version 3
			 * @private
			 */
			label: indexMode,

			/**
			 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
			 * @function Chart.Interaction.modes.index
			 * @since v2.4.0
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			index: indexMode,

			/**
			 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect is false, we find the nearest item and return the items in that dataset
			 * @function Chart.Interaction.modes.dataset
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			dataset: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				options.axis = options.axis || &#x27;xy&#x27;;
				var distanceMetric = getDistanceMetricForAxis(options.axis);
				var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

				if (items.length &gt; 0) {
					items = chart.getDatasetMeta(items[0]._datasetIndex).data;
				}

				return items;
			},

			/**
			 * @function Chart.Interaction.modes.x-axis
			 * @deprecated since version 2.4.0. Use index mode and intersect == true
			 * @todo remove at version 3
			 * @private
			 */
			&#x27;x-axis&#x27;: function(chart, e) {
				return indexMode(chart, e, {intersect: false});
			},

			/**
			 * Point mode returns all elements that hit test based on the event position
			 * of the event
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			point: function(chart, e) {
				var position = getRelativePosition(e, chart);
				return getIntersectItems(chart, position);
			},

			/**
			 * nearest mode returns the element closest to the point
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			nearest: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				options.axis = options.axis || &#x27;xy&#x27;;
				var distanceMetric = getDistanceMetricForAxis(options.axis);
				var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

				// We have multiple items at the same distance from the event. Now sort by smallest
				if (nearestItems.length &gt; 1) {
					nearestItems.sort(function(a, b) {
						var sizeA = a.getArea();
						var sizeB = b.getArea();
						var ret = sizeA - sizeB;

						if (ret === 0) {
							// if equal sort by dataset index
							ret = a._datasetIndex - b._datasetIndex;
						}

						return ret;
					});
				}

				// Return only 1 item
				return nearestItems.slice(0, 1);
			},

			/**
			 * x mode returns the elements that hit-test at the current x coordinate
			 * @function Chart.Interaction.modes.x
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			x: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var items = [];
				var intersectsItem = false;

				parseVisibleItems(chart, function(element) {
					if (element.inXRange(position.x)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem = true;
					}
				});

				// If we want to trigger on an intersect and we don&#x27;t have any items
				// that intersect the position, return nothing
				if (options.intersect &amp;&amp; !intersectsItem) {
					items = [];
				}
				return items;
			},

			/**
			 * y mode returns the elements that hit-test at the current y coordinate
			 * @function Chart.Interaction.modes.y
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			y: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var items = [];
				var intersectsItem = false;

				parseVisibleItems(chart, function(element) {
					if (element.inYRange(position.y)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem = true;
					}
				});

				// If we want to trigger on an intersect and we don&#x27;t have any items
				// that intersect the position, return nothing
				if (options.intersect &amp;&amp; !intersectsItem) {
					items = [];
				}
				return items;
			}
		}
	};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);

	function filterByPosition(array, position) {
		return helpers.where(array, function(v) {
			return v.position === position;
		});
	}

	function sortByWeight(array, reverse) {
		array.forEach(function(v, i) {
			v._tmpIndex_ = i;
			return v;
		});
		array.sort(function(a, b) {
			var v0 = reverse ? b : a;
			var v1 = reverse ? a : b;
			return v0.weight === v1.weight ?
				v0._tmpIndex_ - v1._tmpIndex_ :
				v0.weight - v1.weight;
		});
		array.forEach(function(v) {
			delete v._tmpIndex_;
		});
	}

	/**
	 * @interface ILayoutItem
	 * @prop {String} position - The position of the item in the chart layout. Possible values are
	 * &#x27;left&#x27;, &#x27;top&#x27;, &#x27;right&#x27;, &#x27;bottom&#x27;, and &#x27;chartArea&#x27;
	 * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
	 * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
	 * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
	 * @prop {Function} update - Takes two parameters: width and height. Returns size of item
	 * @prop {Function} getPadding -  Returns an object with padding on the edges
	 * @prop {Number} width - Width of item. Must be valid after update()
	 * @prop {Number} height - Height of item. Must be valid after update()
	 * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
	 */

	// The layout service is very self explanatory.  It&#x27;s responsible for the layout within a chart.
	// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
	// It is this service&#x27;s responsibility of carrying out that layout.
	module.exports = {
		defaults: {},

		/**
		 * Register a box to a chart.
		 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
		 * @param {Chart} chart - the chart to use
		 * @param {ILayoutItem} item - the item to add to be layed out
		 */
		addBox: function(chart, item) {
			if (!chart.boxes) {
				chart.boxes = [];
			}

			// initialize item with default values
			item.fullWidth = item.fullWidth || false;
			item.position = item.position || &#x27;top&#x27;;
			item.weight = item.weight || 0;

			chart.boxes.push(item);
		},

		/**
		 * Remove a layoutItem from a chart
		 * @param {Chart} chart - the chart to remove the box from
		 * @param {Object} layoutItem - the item to remove from the layout
		 */
		removeBox: function(chart, layoutItem) {
			var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
			if (index !== -1) {
				chart.boxes.splice(index, 1);
			}
		},

		/**
		 * Sets (or updates) options on the given &#x60;item&#x60;.
		 * @param {Chart} chart - the chart in which the item lives (or will be added to)
		 * @param {Object} item - the item to configure with the given options
		 * @param {Object} options - the new item options.
		 */
		configure: function(chart, item, options) {
			var props = [&#x27;fullWidth&#x27;, &#x27;position&#x27;, &#x27;weight&#x27;];
			var ilen = props.length;
			var i = 0;
			var prop;

			for (; i &lt; ilen; ++i) {
				prop = props[i];
				if (options.hasOwnProperty(prop)) {
					item[prop] = options[prop];
				}
			}
		},

		/**
		 * Fits boxes of the given chart into the given size by having each box measure itself
		 * then running a fitting algorithm
		 * @param {Chart} chart - the chart
		 * @param {Number} width - the width to fit into
		 * @param {Number} height - the height to fit into
		 */
		update: function(chart, width, height) {
			if (!chart) {
				return;
			}

			var layoutOptions = chart.options.layout || {};
			var padding = helpers.options.toPadding(layoutOptions.padding);
			var leftPadding = padding.left;
			var rightPadding = padding.right;
			var topPadding = padding.top;
			var bottomPadding = padding.bottom;

			var leftBoxes = filterByPosition(chart.boxes, &#x27;left&#x27;);
			var rightBoxes = filterByPosition(chart.boxes, &#x27;right&#x27;);
			var topBoxes = filterByPosition(chart.boxes, &#x27;top&#x27;);
			var bottomBoxes = filterByPosition(chart.boxes, &#x27;bottom&#x27;);
			var chartAreaBoxes = filterByPosition(chart.boxes, &#x27;chartArea&#x27;);

			// Sort boxes by weight. A higher weight is further away from the chart area
			sortByWeight(leftBoxes, true);
			sortByWeight(rightBoxes, false);
			sortByWeight(topBoxes, true);
			sortByWeight(bottomBoxes, false);

			// Essentially we now have any number of boxes on each of the 4 sides.
			// Our canvas looks like the following.
			// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
			// B1 is the bottom axis
			// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
			// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
			// an error will be thrown.
			//
			// |----------------------------------------------------|
			// |                  T1 (Full Width)                   |
			// |----------------------------------------------------|
			// |    |    |                 T2                  |    |
			// |    |----|-------------------------------------|----|
			// |    |    | C1 |                           | C2 |    |
			// |    |    |----|                           |----|    |
			// |    |    |                                     |    |
			// | L1 | L2 |           ChartArea (C0)            | R1 |
			// |    |    |                                     |    |
			// |    |    |----|                           |----|    |
			// |    |    | C3 |                           | C4 |    |
			// |    |----|-------------------------------------|----|
			// |    |    |                 B1                  |    |
			// |----------------------------------------------------|
			// |                  B2 (Full Width)                   |
			// |----------------------------------------------------|
			//
			// What we do to find the best sizing, we do the following
			// 1. Determine the minimum size of the chart area.
			// 2. Split the remaining width equally between each vertical axis
			// 3. Split the remaining height equally between each horizontal axis
			// 4. Give each layout the maximum size it can be. The layout will return it&#x27;s minimum size
			// 5. Adjust the sizes of each axis based on it&#x27;s minimum reported size.
			// 6. Refit each axis
			// 7. Position each axis in the final location
			// 8. Tell the chart the final location of the chart area
			// 9. Tell any axes that overlay the chart area the positions of the chart area

			// Step 1
			var chartWidth = width - leftPadding - rightPadding;
			var chartHeight = height - topPadding - bottomPadding;
			var chartAreaWidth = chartWidth / 2; // min 50%
			var chartAreaHeight = chartHeight / 2; // min 50%

			// Step 2
			var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

			// Step 3
			var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

			// Step 4
			var maxChartAreaWidth = chartWidth;
			var maxChartAreaHeight = chartHeight;
			var minBoxSizes = [];

			function getMinimumBoxSize(box) {
				var minSize;
				var isHorizontal = box.isHorizontal();

				if (isHorizontal) {
					minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
					maxChartAreaHeight -= minSize.height;
				} else {
					minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
					maxChartAreaWidth -= minSize.width;
				}

				minBoxSizes.push({
					horizontal: isHorizontal,
					minSize: minSize,
					box: box,
				});
			}

			helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

			// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
			var maxHorizontalLeftPadding = 0;
			var maxHorizontalRightPadding = 0;
			var maxVerticalTopPadding = 0;
			var maxVerticalBottomPadding = 0;

			helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
				if (horizontalBox.getPadding) {
					var boxPadding = horizontalBox.getPadding();
					maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
					maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
				}
			});

			helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
				if (verticalBox.getPadding) {
					var boxPadding = verticalBox.getPadding();
					maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
					maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
				}
			});

			// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
			// be if the axes are drawn at their minimum sizes.
			// Steps 5 &amp; 6
			var totalLeftBoxesWidth = leftPadding;
			var totalRightBoxesWidth = rightPadding;
			var totalTopBoxesHeight = topPadding;
			var totalBottomBoxesHeight = bottomPadding;

			// Function to fit a box
			function fitBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
					return minBox.box === box;
				});

				if (minBoxSize) {
					if (box.isHorizontal()) {
						var scaleMargin = {
							left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
							right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
							top: 0,
							bottom: 0
						};

						// Don&#x27;t use min size here because of label rotation. When the labels are rotated, their rotation highly depends
						// on the margin. Sometimes they need to increase in size slightly
						box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
					} else {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight);
					}
				}
			}

			// Update, and calculate the left and right margins for the horizontal boxes
			helpers.each(leftBoxes.concat(rightBoxes), fitBox);

			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth += box.width;
			});

			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth += box.width;
			});

			// Set the Left and Right margins for the horizontal boxes
			helpers.each(topBoxes.concat(bottomBoxes), fitBox);

			// Figure out how much margin is on the top and bottom of the vertical boxes
			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight += box.height;
			});

			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight += box.height;
			});

			function finalFitVerticalBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
					return minSize.box === box;
				});

				var scaleMargin = {
					left: 0,
					right: 0,
					top: totalTopBoxesHeight,
					bottom: totalBottomBoxesHeight
				};

				if (minBoxSize) {
					box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
				}
			}

			// Let the left layout know the final margin
			helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

			// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
			totalLeftBoxesWidth = leftPadding;
			totalRightBoxesWidth = rightPadding;
			totalTopBoxesHeight = topPadding;
			totalBottomBoxesHeight = bottomPadding;

			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth += box.width;
			});

			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth += box.width;
			});

			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight += box.height;
			});
			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight += box.height;
			});

			// We may be adding some padding to account for rotated x axis labels
			var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
			totalLeftBoxesWidth += leftPaddingAddition;
			totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

			var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
			totalTopBoxesHeight += topPaddingAddition;
			totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

			// Figure out if our chart area changed. This would occur if the dataset layout label rotation
			// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
			// without calling &#x60;fit&#x60; again
			var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
			var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

			if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
				helpers.each(leftBoxes, function(box) {
					box.height = newMaxChartAreaHeight;
				});

				helpers.each(rightBoxes, function(box) {
					box.height = newMaxChartAreaHeight;
				});

				helpers.each(topBoxes, function(box) {
					if (!box.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});

				helpers.each(bottomBoxes, function(box) {
					if (!box.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});

				maxChartAreaHeight = newMaxChartAreaHeight;
				maxChartAreaWidth = newMaxChartAreaWidth;
			}

			// Step 7 - Position the boxes
			var left = leftPadding + leftPaddingAddition;
			var top = topPadding + topPaddingAddition;

			function placeBox(box) {
				if (box.isHorizontal()) {
					box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
					box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
					box.top = top;
					box.bottom = top + box.height;

					// Move to next point
					top = box.bottom;

				} else {

					box.left = left;
					box.right = left + box.width;
					box.top = totalTopBoxesHeight;
					box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

					// Move to next point
					left = box.right;
				}
			}

			helpers.each(leftBoxes.concat(topBoxes), placeBox);

			// Account for chart width and height
			left += maxChartAreaWidth;
			top += maxChartAreaHeight;

			helpers.each(rightBoxes, placeBox);
			helpers.each(bottomBoxes, placeBox);

			// Step 8
			chart.chartArea = {
				left: totalLeftBoxesWidth,
				top: totalTopBoxesHeight,
				right: totalLeftBoxesWidth + maxChartAreaWidth,
				bottom: totalTopBoxesHeight + maxChartAreaHeight
			};

			// Step 9
			helpers.each(chartAreaBoxes, function(box) {
				box.left = chart.chartArea.left;
				box.top = chart.chartArea.top;
				box.right = chart.chartArea.right;
				box.bottom = chart.chartArea.bottom;

				box.update(maxChartAreaWidth, maxChartAreaHeight);
			});
		}
	};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);
	var basic = __webpack_require__(56);
	var dom = __webpack_require__(57);

	// @TODO Make possible to select another platform at build time.
	var implementation = dom._enabled ? dom : basic;

	/**
	 * @namespace Chart.platform
	 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
	 * @since 2.4.0
	 */
	module.exports = helpers.extend({
		/**
		 * @since 2.7.0
		 */
		initialize: function() {},

		/**
		 * Called at chart construction time, returns a context2d instance implementing
		 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
		 * @param {*} item - The native item from which to acquire context (platform specific)
		 * @param {Object} options - The chart options
		 * @returns {CanvasRenderingContext2D} context2d instance
		 */
		acquireContext: function() {},

		/**
		 * Called at chart destruction time, releases any resources associated to the context
		 * previously returned by the acquireContext() method.
		 * @param {CanvasRenderingContext2D} context - The context2d instance
		 * @returns {Boolean} true if the method succeeded, else false
		 */
		releaseContext: function() {},

		/**
		 * Registers the specified listener on the given chart.
		 * @param {Chart} chart - Chart from which to listen for event
		 * @param {String} type - The ({@link IEvent}) type to listen for
		 * @param {Function} listener - Receives a notification (an object that implements
		 * the {@link IEvent} interface) when an event of the specified type occurs.
		 */
		addEventListener: function() {},

		/**
		 * Removes the specified listener previously registered with addEventListener.
		 * @param {Chart} chart -Chart from which to remove the listener
		 * @param {String} type - The ({@link IEvent}) type to remove
		 * @param {Function} listener - The listener function to remove from the event target.
		 */
		removeEventListener: function() {}

	}, implementation);

	/**
	 * @interface IPlatform
	 * Allows abstracting platform dependencies away from the chart
	 * @borrows Chart.platform.acquireContext as acquireContext
	 * @borrows Chart.platform.releaseContext as releaseContext
	 * @borrows Chart.platform.addEventListener as addEventListener
	 * @borrows Chart.platform.removeEventListener as removeEventListener
	 */

	/**
	 * @interface IEvent
	 * @prop {String} type - The event type name, possible values are:
	 * &#x27;contextmenu&#x27;, &#x27;mouseenter&#x27;, &#x27;mousedown&#x27;, &#x27;mousemove&#x27;, &#x27;mouseup&#x27;, &#x27;mouseout&#x27;,
	 * &#x27;click&#x27;, &#x27;dblclick&#x27;, &#x27;keydown&#x27;, &#x27;keypress&#x27;, &#x27;keyup&#x27; and &#x27;resize&#x27;
	 * @prop {*} native - The original native event (null for emulated events, e.g. &#x27;resize&#x27;)
	 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
	 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
	 */


/***/ }),
/* 56 */
/***/ (function(module, exports) {

	/**
	 * Platform fallback implementation (minimal).
	 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
	 */

	module.exports = {
		acquireContext: function(item) {
			if (item &amp;&amp; item.canvas) {
				// Support for any object associated to a canvas (including a context2d)
				item = item.canvas;
			}

			return item &amp;&amp; item.getContext(&#x27;2d&#x27;) || null;
		}
	};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Chart.Platform implementation for targeting a web browser
	 */

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);

	var EXPANDO_KEY = &#x27;$chartjs&#x27;;
	var CSS_PREFIX = &#x27;chartjs-&#x27;;
	var CSS_RENDER_MONITOR = CSS_PREFIX + &#x27;render-monitor&#x27;;
	var CSS_RENDER_ANIMATION = CSS_PREFIX + &#x27;render-animation&#x27;;
	var ANIMATION_START_EVENTS = [&#x27;animationstart&#x27;, &#x27;webkitAnimationStart&#x27;];

	/**
	 * DOM event types -&gt; Chart.js event types.
	 * Note: only events with different types are mapped.
	 * @see https://developer.mozilla.org/en-US/docs/Web/Events
	 */
	var EVENT_TYPES = {
		touchstart: &#x27;mousedown&#x27;,
		touchmove: &#x27;mousemove&#x27;,
		touchend: &#x27;mouseup&#x27;,
		pointerenter: &#x27;mouseenter&#x27;,
		pointerdown: &#x27;mousedown&#x27;,
		pointermove: &#x27;mousemove&#x27;,
		pointerup: &#x27;mouseup&#x27;,
		pointerleave: &#x27;mouseout&#x27;,
		pointerout: &#x27;mouseout&#x27;
	};

	/**
	 * The &quot;used&quot; size is the final value of a dimension property after all calculations have
	 * been performed. This method uses the computed style of &#x60;element&#x60; but returns undefined
	 * if the computed style is not expressed in pixels. That can happen in some cases where
	 * &#x60;element&#x60; has a size relative to its parent and this last one is not yet displayed,
	 * for example because of &#x60;display: none&#x60; on a parent node.
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
	 * @returns {Number} Size in pixels or undefined if unknown.
	 */
	function readUsedSize(element, property) {
		var value = helpers.getStyle(element, property);
		var matches = value &amp;&amp; value.match(/^(\d+)(\.\d+)?px$/);
		return matches ? Number(matches[1]) : undefined;
	}

	/**
	 * Initializes the canvas style and render size without modifying the canvas display size,
	 * since responsiveness is handled by the controller.resize() method. The config is used
	 * to determine the aspect ratio to apply in case no explicit height has been specified.
	 */
	function initCanvas(canvas, config) {
		var style = canvas.style;

		// NOTE(SB) canvas.getAttribute(&#x27;width&#x27;) !== canvas.width: in the first case it
		// returns null or &#x27;&#x27; if no explicit value has been set to the canvas attribute.
		var renderHeight = canvas.getAttribute(&#x27;height&#x27;);
		var renderWidth = canvas.getAttribute(&#x27;width&#x27;);

		// Chart.js modifies some canvas values that we want to restore on destroy
		canvas[EXPANDO_KEY] = {
			initial: {
				height: renderHeight,
				width: renderWidth,
				style: {
					display: style.display,
					height: style.height,
					width: style.width
				}
			}
		};

		// Force canvas to display as block to avoid extra space caused by inline
		// elements, which would interfere with the responsive resize process.
		// https://github.com/chartjs/Chart.js/issues/2538
		style.display = style.display || &#x27;block&#x27;;

		if (renderWidth === null || renderWidth === &#x27;&#x27;) {
			var displayWidth = readUsedSize(canvas, &#x27;width&#x27;);
			if (displayWidth !== undefined) {
				canvas.width = displayWidth;
			}
		}

		if (renderHeight === null || renderHeight === &#x27;&#x27;) {
			if (canvas.style.height === &#x27;&#x27;) {
				// If no explicit render height and style height, let&#x27;s apply the aspect ratio,
				// which one can be specified by the user but also by charts as default option
				// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
				canvas.height = canvas.width / (config.options.aspectRatio || 2);
			} else {
				var displayHeight = readUsedSize(canvas, &#x27;height&#x27;);
				if (displayWidth !== undefined) {
					canvas.height = displayHeight;
				}
			}
		}

		return canvas;
	}

	/**
	 * Detects support for options object argument in addEventListener.
	 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
	 * @private
	 */
	var supportsEventListenerOptions = (function() {
		var supports = false;
		try {
			var options = Object.defineProperty({}, &#x27;passive&#x27;, {
				get: function() {
					supports = true;
				}
			});
			window.addEventListener(&#x27;e&#x27;, null, options);
		} catch (e) {
			// continue regardless of error
		}
		return supports;
	}());

	// Default passive to true as expected by Chrome for &#x27;touchstart&#x27; and &#x27;touchend&#x27; events.
	// https://github.com/chartjs/Chart.js/issues/4287
	var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;

	function addEventListener(node, type, listener) {
		node.addEventListener(type, listener, eventListenerOptions);
	}

	function removeEventListener(node, type, listener) {
		node.removeEventListener(type, listener, eventListenerOptions);
	}

	function createEvent(type, chart, x, y, nativeEvent) {
		return {
			type: type,
			chart: chart,
			native: nativeEvent || null,
			x: x !== undefined ? x : null,
			y: y !== undefined ? y : null,
		};
	}

	function fromNativeEvent(event, chart) {
		var type = EVENT_TYPES[event.type] || event.type;
		var pos = helpers.getRelativePosition(event, chart);
		return createEvent(type, chart, pos.x, pos.y, event);
	}

	function throttled(fn, thisArg) {
		var ticking = false;
		var args = [];

		return function() {
			args = Array.prototype.slice.call(arguments);
			thisArg = thisArg || this;

			if (!ticking) {
				ticking = true;
				helpers.requestAnimFrame.call(window, function() {
					ticking = false;
					fn.apply(thisArg, args);
				});
			}
		};
	}

	// Implementation based on https://github.com/marcj/css-element-queries
	function createResizer(handler) {
		var resizer = document.createElement(&#x27;div&#x27;);
		var cls = CSS_PREFIX + &#x27;size-monitor&#x27;;
		var maxSize = 1000000;
		var style =
			&#x27;position:absolute;&#x27; +
			&#x27;left:0;&#x27; +
			&#x27;top:0;&#x27; +
			&#x27;right:0;&#x27; +
			&#x27;bottom:0;&#x27; +
			&#x27;overflow:hidden;&#x27; +
			&#x27;pointer-events:none;&#x27; +
			&#x27;visibility:hidden;&#x27; +
			&#x27;z-index:-1;&#x27;;

		resizer.style.cssText = style;
		resizer.className = cls;
		resizer.innerHTML =
			&#x27;&lt;div class=&quot;&#x27; + cls + &#x27;-expand&quot; style=&quot;&#x27; + style + &#x27;&quot;&gt;&#x27; +
				&#x27;&lt;div style=&quot;&#x27; +
					&#x27;position:absolute;&#x27; +
					&#x27;width:&#x27; + maxSize + &#x27;px;&#x27; +
					&#x27;height:&#x27; + maxSize + &#x27;px;&#x27; +
					&#x27;left:0;&#x27; +
					&#x27;top:0&quot;&gt;&#x27; +
				&#x27;&lt;/div&gt;&#x27; +
			&#x27;&lt;/div&gt;&#x27; +
			&#x27;&lt;div class=&quot;&#x27; + cls + &#x27;-shrink&quot; style=&quot;&#x27; + style + &#x27;&quot;&gt;&#x27; +
				&#x27;&lt;div style=&quot;&#x27; +
					&#x27;position:absolute;&#x27; +
					&#x27;width:200%;&#x27; +
					&#x27;height:200%;&#x27; +
					&#x27;left:0; &#x27; +
					&#x27;top:0&quot;&gt;&#x27; +
				&#x27;&lt;/div&gt;&#x27; +
			&#x27;&lt;/div&gt;&#x27;;

		var expand = resizer.childNodes[0];
		var shrink = resizer.childNodes[1];

		resizer._reset = function() {
			expand.scrollLeft = maxSize;
			expand.scrollTop = maxSize;
			shrink.scrollLeft = maxSize;
			shrink.scrollTop = maxSize;
		};
		var onScroll = function() {
			resizer._reset();
			handler();
		};

		addEventListener(expand, &#x27;scroll&#x27;, onScroll.bind(expand, &#x27;expand&#x27;));
		addEventListener(shrink, &#x27;scroll&#x27;, onScroll.bind(shrink, &#x27;shrink&#x27;));

		return resizer;
	}

	// https://davidwalsh.name/detect-node-insertion
	function watchForRender(node, handler) {
		var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
		var proxy = expando.renderProxy = function(e) {
			if (e.animationName === CSS_RENDER_ANIMATION) {
				handler();
			}
		};

		helpers.each(ANIMATION_START_EVENTS, function(type) {
			addEventListener(node, type, proxy);
		});

		// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
		// is removed then added back immediately (same animation frame?). Accessing the
		// &#x60;offsetParent&#x60; property will force a reflow and re-evaluate the CSS animation.
		// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
		// https://github.com/chartjs/Chart.js/issues/4737
		expando.reflow = !!node.offsetParent;

		node.classList.add(CSS_RENDER_MONITOR);
	}

	function unwatchForRender(node) {
		var expando = node[EXPANDO_KEY] || {};
		var proxy = expando.renderProxy;

		if (proxy) {
			helpers.each(ANIMATION_START_EVENTS, function(type) {
				removeEventListener(node, type, proxy);
			});

			delete expando.renderProxy;
		}

		node.classList.remove(CSS_RENDER_MONITOR);
	}

	function addResizeListener(node, listener, chart) {
		var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

		// Let&#x27;s keep track of this added resizer and thus avoid DOM query when removing it.
		var resizer = expando.resizer = createResizer(throttled(function() {
			if (expando.resizer) {
				return listener(createEvent(&#x27;resize&#x27;, chart));
			}
		}));

		// The resizer needs to be attached to the node parent, so we first need to be
		// sure that &#x60;node&#x60; is attached to the DOM before injecting the resizer element.
		watchForRender(node, function() {
			if (expando.resizer) {
				var container = node.parentNode;
				if (container &amp;&amp; container !== resizer.parentNode) {
					container.insertBefore(resizer, container.firstChild);
				}

				// The container size might have changed, let&#x27;s reset the resizer state.
				resizer._reset();
			}
		});
	}

	function removeResizeListener(node) {
		var expando = node[EXPANDO_KEY] || {};
		var resizer = expando.resizer;

		delete expando.resizer;
		unwatchForRender(node);

		if (resizer &amp;&amp; resizer.parentNode) {
			resizer.parentNode.removeChild(resizer);
		}
	}

	function injectCSS(platform, css) {
		// http://stackoverflow.com/q/3922139
		var style = platform._style || document.createElement(&#x27;style&#x27;);
		if (!platform._style) {
			platform._style = style;
			css = &#x27;/* Chart.js */\n&#x27; + css;
			style.setAttribute(&#x27;type&#x27;, &#x27;text/css&#x27;);
			document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(style);
		}

		style.appendChild(document.createTextNode(css));
	}

	module.exports = {
		/**
		 * This property holds whether this platform is enabled for the current environment.
		 * Currently used by platform.js to select the proper implementation.
		 * @private
		 */
		_enabled: typeof window !== &#x27;undefined&#x27; &amp;&amp; typeof document !== &#x27;undefined&#x27;,

		initialize: function() {
			var keyframes = &#x27;from{opacity:0.99}to{opacity:1}&#x27;;

			injectCSS(this,
				// DOM rendering detection
				// https://davidwalsh.name/detect-node-insertion
				&#x27;@-webkit-keyframes &#x27; + CSS_RENDER_ANIMATION + &#x27;{&#x27; + keyframes + &#x27;}&#x27; +
				&#x27;@keyframes &#x27; + CSS_RENDER_ANIMATION + &#x27;{&#x27; + keyframes + &#x27;}&#x27; +
				&#x27;.&#x27; + CSS_RENDER_MONITOR + &#x27;{&#x27; +
					&#x27;-webkit-animation:&#x27; + CSS_RENDER_ANIMATION + &#x27; 0.001s;&#x27; +
					&#x27;animation:&#x27; + CSS_RENDER_ANIMATION + &#x27; 0.001s;&#x27; +
				&#x27;}&#x27;
			);
		},

		acquireContext: function(item, config) {
			if (typeof item === &#x27;string&#x27;) {
				item = document.getElementById(item);
			} else if (item.length) {
				// Support for array based queries (such as jQuery)
				item = item[0];
			}

			if (item &amp;&amp; item.canvas) {
				// Support for any object associated to a canvas (including a context2d)
				item = item.canvas;
			}

			// To prevent canvas fingerprinting, some add-ons undefine the getContext
			// method, for example: https://github.com/kkapsner/CanvasBlocker
			// https://github.com/chartjs/Chart.js/issues/2807
			var context = item &amp;&amp; item.getContext &amp;&amp; item.getContext(&#x27;2d&#x27;);

			// &#x60;instanceof HTMLCanvasElement/CanvasRenderingContext2D&#x60; fails when the item is
			// inside an iframe or when running in a protected environment. We could guess the
			// types from their toString() value but let&#x27;s keep things flexible and assume it&#x27;s
			// a sufficient condition if the item has a context2D which has item as &#x60;canvas&#x60;.
			// https://github.com/chartjs/Chart.js/issues/3887
			// https://github.com/chartjs/Chart.js/issues/4102
			// https://github.com/chartjs/Chart.js/issues/4152
			if (context &amp;&amp; context.canvas === item) {
				initCanvas(item, config);
				return context;
			}

			return null;
		},

		releaseContext: function(context) {
			var canvas = context.canvas;
			if (!canvas[EXPANDO_KEY]) {
				return;
			}

			var initial = canvas[EXPANDO_KEY].initial;
			[&#x27;height&#x27;, &#x27;width&#x27;].forEach(function(prop) {
				var value = initial[prop];
				if (helpers.isNullOrUndef(value)) {
					canvas.removeAttribute(prop);
				} else {
					canvas.setAttribute(prop, value);
				}
			});

			helpers.each(initial.style || {}, function(value, key) {
				canvas.style[key] = value;
			});

			// The canvas render size might have been changed (and thus the state stack discarded),
			// we can&#x27;t use save() and restore() to restore the initial state. So make sure that at
			// least the canvas context is reset to the default state by setting the canvas width.
			// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
			canvas.width = canvas.width;

			delete canvas[EXPANDO_KEY];
		},

		addEventListener: function(chart, type, listener) {
			var canvas = chart.canvas;
			if (type === &#x27;resize&#x27;) {
				// Note: the resize event is not supported on all browsers.
				addResizeListener(canvas, listener, chart);
				return;
			}

			var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
			var proxies = expando.proxies || (expando.proxies = {});
			var proxy = proxies[chart.id + &#x27;_&#x27; + type] = function(event) {
				listener(fromNativeEvent(event, chart));
			};

			addEventListener(canvas, type, proxy);
		},

		removeEventListener: function(chart, type, listener) {
			var canvas = chart.canvas;
			if (type === &#x27;resize&#x27;) {
				// Note: the resize event is not supported on all browsers.
				removeResizeListener(canvas, listener);
				return;
			}

			var expando = listener[EXPANDO_KEY] || {};
			var proxies = expando.proxies || {};
			var proxy = proxies[chart.id + &#x27;_&#x27; + type];
			if (!proxy) {
				return;
			}

			removeEventListener(canvas, type, proxy);
		}
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use EventTarget.addEventListener instead.
	 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
	 * @function Chart.helpers.addEvent
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.addEvent = addEventListener;

	/**
	 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
	 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
	 * @function Chart.helpers.removeEvent
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.removeEvent = removeEventListener;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		plugins: {}
	});

	/**
	 * The plugin service singleton
	 * @namespace Chart.plugins
	 * @since 2.1.0
	 */
	module.exports = {
		/**
		 * Globally registered plugins.
		 * @private
		 */
		_plugins: [],

		/**
		 * This identifier is used to invalidate the descriptors cache attached to each chart
		 * when a global plugin is registered or unregistered. In this case, the cache ID is
		 * incremented and descriptors are regenerated during following API calls.
		 * @private
		 */
		_cacheId: 0,

		/**
		 * Registers the given plugin(s) if not already registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		register: function(plugins) {
			var p = this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				if (p.indexOf(plugin) === -1) {
					p.push(plugin);
				}
			});

			this._cacheId++;
		},

		/**
		 * Unregisters the given plugin(s) only if registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		unregister: function(plugins) {
			var p = this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				var idx = p.indexOf(plugin);
				if (idx !== -1) {
					p.splice(idx, 1);
				}
			});

			this._cacheId++;
		},

		/**
		 * Remove all registered plugins.
		 * @since 2.1.5
		 */
		clear: function() {
			this._plugins = [];
			this._cacheId++;
		},

		/**
		 * Returns the number of registered plugins?
		 * @returns {Number}
		 * @since 2.1.5
		 */
		count: function() {
			return this._plugins.length;
		},

		/**
		 * Returns all registered plugin instances.
		 * @returns {Array} array of plugin objects.
		 * @since 2.1.5
		 */
		getAll: function() {
			return this._plugins;
		},

		/**
		 * Calls enabled plugins for &#x60;chart&#x60; on the specified hook and with the given args.
		 * This method immediately returns as soon as a plugin explicitly returns false. The
		 * returned value can be used, for instance, to interrupt the current action.
		 * @param {Object} chart - The chart instance for which plugins should be called.
		 * @param {String} hook - The name of the plugin method to call (e.g. &#x27;beforeUpdate&#x27;).
		 * @param {Array} [args] - Extra arguments to apply to the hook call.
		 * @returns {Boolean} false if any of the plugins return false, else returns true.
		 */
		notify: function(chart, hook, args) {
			var descriptors = this.descriptors(chart);
			var ilen = descriptors.length;
			var i, descriptor, plugin, params, method;

			for (i = 0; i &lt; ilen; ++i) {
				descriptor = descriptors[i];
				plugin = descriptor.plugin;
				method = plugin[hook];
				if (typeof method === &#x27;function&#x27;) {
					params = [chart].concat(args || []);
					params.push(descriptor.options);
					if (method.apply(plugin, params) === false) {
						return false;
					}
				}
			}

			return true;
		},

		/**
		 * Returns descriptors of enabled plugins for the given chart.
		 * @returns {Array} [{ plugin, options }]
		 * @private
		 */
		descriptors: function(chart) {
			var cache = chart.$plugins || (chart.$plugins = {});
			if (cache.id === this._cacheId) {
				return cache.descriptors;
			}

			var plugins = [];
			var descriptors = [];
			var config = (chart &amp;&amp; chart.config) || {};
			var options = (config.options &amp;&amp; config.options.plugins) || {};

			this._plugins.concat(config.plugins || []).forEach(function(plugin) {
				var idx = plugins.indexOf(plugin);
				if (idx !== -1) {
					return;
				}

				var id = plugin.id;
				var opts = options[id];
				if (opts === false) {
					return;
				}

				if (opts === true) {
					opts = helpers.clone(defaults.global.plugins[id]);
				}

				plugins.push(plugin);
				descriptors.push({
					plugin: plugin,
					options: opts || {}
				});
			});

			cache.descriptors = descriptors;
			cache.id = this._cacheId;
			return descriptors;
		},

		/**
		 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
		 * but in some cases, this reference can be changed by the user when updating options.
		 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
		 * @private
		 */
		_invalidate: function(chart) {
			delete chart.$plugins;
		}
	};

	/**
	 * Plugin extension hooks.
	 * @interface IPlugin
	 * @since 2.1.0
	 */
	/**
	 * @method IPlugin#beforeInit
	 * @desc Called before initializing &#x60;chart&#x60;.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#afterInit
	 * @desc Called after &#x60;chart&#x60; has been initialized and before the first update.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeUpdate
	 * @desc Called before updating &#x60;chart&#x60;. If any plugin returns &#x60;false&#x60;, the update
	 * is cancelled (and thus subsequent render(s)) until another &#x60;update&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart update.
	 */
	/**
	 * @method IPlugin#afterUpdate
	 * @desc Called after &#x60;chart&#x60; has been updated and before rendering. Note that this
	 * hook will not be called if the chart update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetsUpdate
	 * @desc Called before updating the &#x60;chart&#x60; datasets. If any plugin returns &#x60;false&#x60;,
	 * the datasets update is cancelled until another &#x60;update&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} false to cancel the datasets update.
	 * @since version 2.1.5
	*/
	/**
	 * @method IPlugin#afterDatasetsUpdate
	 * @desc Called after the &#x60;chart&#x60; datasets have been updated. Note that this hook
	 * will not be called if the datasets update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @since version 2.1.5
	 */
	/**
	 * @method IPlugin#beforeDatasetUpdate
	 * @desc Called before updating the &#x60;chart&#x60; dataset at the given &#x60;args.index&#x60;. If any plugin
	 * returns &#x60;false&#x60;, the datasets update is cancelled until another &#x60;update&#x60; is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetUpdate
	 * @desc Called after the &#x60;chart&#x60; datasets at the given &#x60;args.index&#x60; has been updated. Note
	 * that this hook will not be called if the datasets update has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeLayout
	 * @desc Called before laying out &#x60;chart&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the layout update is cancelled until another &#x60;update&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart layout.
	 */
	/**
	 * @method IPlugin#afterLayout
	 * @desc Called after the &#x60;chart&#x60; has been layed out. Note that this hook will not
	 * be called if the layout update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeRender
	 * @desc Called before rendering &#x60;chart&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the rendering is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart rendering.
	 */
	/**
	 * @method IPlugin#afterRender
	 * @desc Called after the &#x60;chart&#x60; has been fully rendered (and animation completed). Note
	 * that this hook will not be called if the rendering has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDraw
	 * @desc Called before drawing &#x60;chart&#x60; at every animation frame specified by the given
	 * easing value. If any plugin returns &#x60;false&#x60;, the frame drawing is cancelled until
	 * another &#x60;render&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart drawing.
	 */
	/**
	 * @method IPlugin#afterDraw
	 * @desc Called after the &#x60;chart&#x60; has been drawn for the specific easing value. Note
	 * that this hook will not be called if the drawing has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetsDraw
	 * @desc Called before drawing the &#x60;chart&#x60; datasets. If any plugin returns &#x60;false&#x60;,
	 * the datasets drawing is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetsDraw
	 * @desc Called after the &#x60;chart&#x60; datasets have been drawn. Note that this hook
	 * will not be called if the datasets drawing has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetDraw
	 * @desc Called before drawing the &#x60;chart&#x60; dataset at the given &#x60;args.index&#x60; (datasets
	 * are drawn in the reverse order). If any plugin returns &#x60;false&#x60;, the datasets drawing
	 * is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetDraw
	 * @desc Called after the &#x60;chart&#x60; datasets at the given &#x60;args.index&#x60; have been drawn
	 * (datasets are drawn in the reverse order). Note that this hook will not be called
	 * if the datasets drawing has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeTooltipDraw
	 * @desc Called before drawing the &#x60;tooltip&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the tooltip drawing is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.tooltip - The tooltip.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart tooltip drawing.
	 */
	/**
	 * @method IPlugin#afterTooltipDraw
	 * @desc Called after drawing the &#x60;tooltip&#x60;. Note that this hook will not
	 * be called if the tooltip drawing has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.tooltip - The tooltip.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeEvent
	 * @desc Called before processing the specified &#x60;event&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the event will be discarded.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {IEvent} event - The event object.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#afterEvent
	 * @desc Called after the &#x60;event&#x60; has been consumed. Note that this hook
	 * will not be called if the &#x60;event&#x60; has been previously discarded.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {IEvent} event - The event object.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#resize
	 * @desc Called after the chart as been resized.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} size - The new canvas display size (eq. canvas.style width &amp; height).
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#destroy
	 * @desc Called after the chart as been destroyed.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);

	/**
	 * Namespace to hold static tick generation functions
	 * @namespace Chart.Ticks
	 */
	module.exports = {
		/**
		 * Namespace to hold formatters for different types of ticks
		 * @namespace Chart.Ticks.formatters
		 */
		formatters: {
			/**
			 * Formatter for value labels
			 * @method Chart.Ticks.formatters.values
			 * @param value the value to display
			 * @return {String|Array} the label to display
			 */
			values: function(value) {
				return helpers.isArray(value) ? value : &#x27;&#x27; + value;
			},

			/**
			 * Formatter for linear numeric ticks
			 * @method Chart.Ticks.formatters.linear
			 * @param tickValue {Number} the value to be formatted
			 * @param index {Number} the position of the tickValue parameter in the ticks array
			 * @param ticks {Array&lt;Number&gt;} the list of ticks being converted
			 * @return {String} string representation of the tickValue parameter
			 */
			linear: function(tickValue, index, ticks) {
				// If we have lots of ticks, don&#x27;t use the ones
				var delta = ticks.length &gt; 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

				// If we have a number like 2.5 as the delta, figure out how many decimal places we need
				if (Math.abs(delta) &gt; 1) {
					if (tickValue !== Math.floor(tickValue)) {
						// not an integer
						delta = tickValue - Math.floor(tickValue);
					}
				}

				var logDelta = helpers.log10(Math.abs(delta));
				var tickString = &#x27;&#x27;;

				if (tickValue !== 0) {
					var numDecimal = -1 * Math.floor(logDelta);
					numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
					tickString = tickValue.toFixed(numDecimal);
				} else {
					tickString = &#x27;0&#x27;; // never show decimal places for 0
				}

				return tickString;
			},

			logarithmic: function(tickValue, index, ticks) {
				var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));

				if (tickValue === 0) {
					return &#x27;0&#x27;;
				} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
					return tickValue.toExponential();
				}
				return &#x27;&#x27;;
			}
		}
	};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		animation: {
			duration: 1000,
			easing: &#x27;easeOutQuart&#x27;,
			onProgress: helpers.noop,
			onComplete: helpers.noop
		}
	});

	module.exports = function(Chart) {

		Chart.Animation = Element.extend({
			chart: null, // the animation associated chart instance
			currentStep: 0, // the current animation step
			numSteps: 60, // default number of steps
			easing: &#x27;&#x27;, // the easing to use for this animation
			render: null, // render function used by the animation service

			onAnimationProgress: null, // user specified callback to fire on each step of the animation
			onAnimationComplete: null, // user specified callback to fire when the animation finishes
		});

		Chart.animationService = {
			frameDuration: 17,
			animations: [],
			dropFrames: 0,
			request: null,

			/**
			 * @param {Chart} chart - The chart to animate.
			 * @param {Chart.Animation} animation - The animation that we will animate.
			 * @param {Number} duration - The animation duration in ms.
			 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
			 */
			addAnimation: function(chart, animation, duration, lazy) {
				var animations = this.animations;
				var i, ilen;

				animation.chart = chart;

				if (!lazy) {
					chart.animating = true;
				}

				for (i = 0, ilen = animations.length; i &lt; ilen; ++i) {
					if (animations[i].chart === chart) {
						animations[i] = animation;
						return;
					}
				}

				animations.push(animation);

				// If there are no animations queued, manually kickstart a digest, for lack of a better word
				if (animations.length === 1) {
					this.requestAnimationFrame();
				}
			},

			cancelAnimation: function(chart) {
				var index = helpers.findIndex(this.animations, function(animation) {
					return animation.chart === chart;
				});

				if (index !== -1) {
					this.animations.splice(index, 1);
					chart.animating = false;
				}
			},

			requestAnimationFrame: function() {
				var me = this;
				if (me.request === null) {
					// Skip animation frame requests until the active one is executed.
					// This can happen when processing mouse events, e.g. &#x27;mousemove&#x27;
					// and &#x27;mouseout&#x27; events will trigger multiple renders.
					me.request = helpers.requestAnimFrame.call(window, function() {
						me.request = null;
						me.startDigest();
					});
				}
			},

			/**
			 * @private
			 */
			startDigest: function() {
				var me = this;
				var startTime = Date.now();
				var framesToDrop = 0;

				if (me.dropFrames &gt; 1) {
					framesToDrop = Math.floor(me.dropFrames);
					me.dropFrames = me.dropFrames % 1;
				}

				me.advance(1 + framesToDrop);

				var endTime = Date.now();

				me.dropFrames += (endTime - startTime) / me.frameDuration;

				// Do we have more stuff to animate?
				if (me.animations.length &gt; 0) {
					me.requestAnimationFrame();
				}
			},

			/**
			 * @private
			 */
			advance: function(count) {
				var animations = this.animations;
				var animation, chart;
				var i = 0;

				while (i &lt; animations.length) {
					animation = animations[i];
					chart = animation.chart;

					animation.currentStep = (animation.currentStep || 0) + count;
					animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

					helpers.callback(animation.render, [chart, animation], chart);
					helpers.callback(animation.onAnimationProgress, [animation], chart);

					if (animation.currentStep &gt;= animation.numSteps) {
						helpers.callback(animation.onAnimationComplete, [animation], chart);
						chart.animating = false;
						animations.splice(i, 1);
					} else {
						++i;
					}
				}
			}
		};

		/**
		 * Provided for backward compatibility, use Chart.Animation instead
		 * @prop Chart.Animation#animationObject
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(Chart.Animation.prototype, &#x27;animationObject&#x27;, {
			get: function() {
				return this;
			}
		});

		/**
		 * Provided for backward compatibility, use Chart.Animation#chart instead
		 * @prop Chart.Animation#chartInstance
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(Chart.Animation.prototype, &#x27;chartInstance&#x27;, {
			get: function() {
				return this.chart;
			},
			set: function(value) {
				this.chart = value;
			}
		});

	};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var helpers = __webpack_require__(36);
	var Interaction = __webpack_require__(53);
	var layouts = __webpack_require__(54);
	var platform = __webpack_require__(55);
	var plugins = __webpack_require__(58);

	module.exports = function(Chart) {

		// Create a dictionary of chart types, to allow for extension of existing types
		Chart.types = {};

		// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
		// Destroy method on the chart will remove the instance of the chart from this reference.
		Chart.instances = {};

		// Controllers available for dataset visualization eg. bar, line, slice, etc.
		Chart.controllers = {};

		/**
		 * Initializes the given config with global and chart default values.
		 */
		function initConfig(config) {
			config = config || {};

			// Do NOT use configMerge() for the data object because this method merges arrays
			// and so would change references to labels and datasets, preventing data updates.
			var data = config.data = config.data || {};
			data.datasets = data.datasets || [];
			data.labels = data.labels || [];

			config.options = helpers.configMerge(
				defaults.global,
				defaults[config.type],
				config.options || {});

			return config;
		}

		/**
		 * Updates the config of the chart
		 * @param chart {Chart} chart to update the options for
		 */
		function updateConfig(chart) {
			var newOptions = chart.options;

			helpers.each(chart.scales, function(scale) {
				layouts.removeBox(chart, scale);
			});

			newOptions = helpers.configMerge(
				Chart.defaults.global,
				Chart.defaults[chart.config.type],
				newOptions);

			chart.options = chart.config.options = newOptions;
			chart.ensureScalesHaveIDs();
			chart.buildOrUpdateScales();
			// Tooltip
			chart.tooltip._options = newOptions.tooltips;
			chart.tooltip.initialize();
		}

		function positionIsHorizontal(position) {
			return position === &#x27;top&#x27; || position === &#x27;bottom&#x27;;
		}

		helpers.extend(Chart.prototype, /** @lends Chart */ {
			/**
			 * @private
			 */
			construct: function(item, config) {
				var me = this;

				config = initConfig(config);

				var context = platform.acquireContext(item, config);
				var canvas = context &amp;&amp; context.canvas;
				var height = canvas &amp;&amp; canvas.height;
				var width = canvas &amp;&amp; canvas.width;

				me.id = helpers.uid();
				me.ctx = context;
				me.canvas = canvas;
				me.config = config;
				me.width = width;
				me.height = height;
				me.aspectRatio = height ? width / height : null;
				me.options = config.options;
				me._bufferedRender = false;

				/**
				 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
				 * the &quot;instance&quot; still need to be defined since it might be called from plugins.
				 * @prop Chart#chart
				 * @deprecated since version 2.6.0
				 * @todo remove at version 3
				 * @private
				 */
				me.chart = me;
				me.controller = me; // chart.chart.controller #inception

				// Add the chart instance to the global namespace
				Chart.instances[me.id] = me;

				// Define alias to the config data: &#x60;chart.data === chart.config.data&#x60;
				Object.defineProperty(me, &#x27;data&#x27;, {
					get: function() {
						return me.config.data;
					},
					set: function(value) {
						me.config.data = value;
					}
				});

				if (!context || !canvas) {
					// The given item is not a compatible context2d element, let&#x27;s return before finalizing
					// the chart initialization but after setting basic chart / controller properties that
					// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
					// https://github.com/chartjs/Chart.js/issues/2807
					console.error(&quot;Failed to create chart: can&#x27;t acquire context from the given item&quot;);
					return;
				}

				me.initialize();
				me.update();
			},

			/**
			 * @private
			 */
			initialize: function() {
				var me = this;

				// Before init plugin notification
				plugins.notify(me, &#x27;beforeInit&#x27;);

				helpers.retinaScale(me, me.options.devicePixelRatio);

				me.bindEvents();

				if (me.options.responsive) {
					// Initial resize before chart draws (must be silent to preserve initial animations).
					me.resize(true);
				}

				// Make sure scales have IDs and are built before we build any controllers.
				me.ensureScalesHaveIDs();
				me.buildOrUpdateScales();
				me.initToolTip();

				// After init plugin notification
				plugins.notify(me, &#x27;afterInit&#x27;);

				return me;
			},

			clear: function() {
				helpers.canvas.clear(this);
				return this;
			},

			stop: function() {
				// Stops any current animation loop occurring
				Chart.animationService.cancelAnimation(this);
				return this;
			},

			resize: function(silent) {
				var me = this;
				var options = me.options;
				var canvas = me.canvas;
				var aspectRatio = (options.maintainAspectRatio &amp;&amp; me.aspectRatio) || null;

				// the canvas render width and height will be casted to integers so make sure that
				// the canvas display style uses the same integer values to avoid blurring effect.

				// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased
				var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
				var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

				if (me.width === newWidth &amp;&amp; me.height === newHeight) {
					return;
				}

				canvas.width = me.width = newWidth;
				canvas.height = me.height = newHeight;
				canvas.style.width = newWidth + &#x27;px&#x27;;
				canvas.style.height = newHeight + &#x27;px&#x27;;

				helpers.retinaScale(me, options.devicePixelRatio);

				if (!silent) {
					// Notify any plugins about the resize
					var newSize = {width: newWidth, height: newHeight};
					plugins.notify(me, &#x27;resize&#x27;, [newSize]);

					// Notify of resize
					if (me.options.onResize) {
						me.options.onResize(me, newSize);
					}

					me.stop();
					me.update(me.options.responsiveAnimationDuration);
				}
			},

			ensureScalesHaveIDs: function() {
				var options = this.options;
				var scalesOptions = options.scales || {};
				var scaleOptions = options.scale;

				helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
					xAxisOptions.id = xAxisOptions.id || (&#x27;x-axis-&#x27; + index);
				});

				helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
					yAxisOptions.id = yAxisOptions.id || (&#x27;y-axis-&#x27; + index);
				});

				if (scaleOptions) {
					scaleOptions.id = scaleOptions.id || &#x27;scale&#x27;;
				}
			},

			/**
			 * Builds a map of scale ID to scale object for future lookup.
			 */
			buildOrUpdateScales: function() {
				var me = this;
				var options = me.options;
				var scales = me.scales || {};
				var items = [];
				var updated = Object.keys(scales).reduce(function(obj, id) {
					obj[id] = false;
					return obj;
				}, {});

				if (options.scales) {
					items = items.concat(
						(options.scales.xAxes || []).map(function(xAxisOptions) {
							return {options: xAxisOptions, dtype: &#x27;category&#x27;, dposition: &#x27;bottom&#x27;};
						}),
						(options.scales.yAxes || []).map(function(yAxisOptions) {
							return {options: yAxisOptions, dtype: &#x27;linear&#x27;, dposition: &#x27;left&#x27;};
						})
					);
				}

				if (options.scale) {
					items.push({
						options: options.scale,
						dtype: &#x27;radialLinear&#x27;,
						isDefault: true,
						dposition: &#x27;chartArea&#x27;
					});
				}

				helpers.each(items, function(item) {
					var scaleOptions = item.options;
					var id = scaleOptions.id;
					var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);

					if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
						scaleOptions.position = item.dposition;
					}

					updated[id] = true;
					var scale = null;
					if (id in scales &amp;&amp; scales[id].type === scaleType) {
						scale = scales[id];
						scale.options = scaleOptions;
						scale.ctx = me.ctx;
						scale.chart = me;
					} else {
						var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
						if (!scaleClass) {
							return;
						}
						scale = new scaleClass({
							id: id,
							type: scaleType,
							options: scaleOptions,
							ctx: me.ctx,
							chart: me
						});
						scales[scale.id] = scale;
					}

					scale.mergeTicksOptions();

					// TODO(SB): I think we should be able to remove this custom case (options.scale)
					// and consider it as a regular scale part of the &quot;scales&quot;&quot; map only! This would
					// make the logic easier and remove some useless? custom code.
					if (item.isDefault) {
						me.scale = scale;
					}
				});
				// clear up discarded scales
				helpers.each(updated, function(hasUpdated, id) {
					if (!hasUpdated) {
						delete scales[id];
					}
				});

				me.scales = scales;

				Chart.scaleService.addScalesToLayout(this);
			},

			buildOrUpdateControllers: function() {
				var me = this;
				var types = [];
				var newControllers = [];

				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					var meta = me.getDatasetMeta(datasetIndex);
					var type = dataset.type || me.config.type;

					if (meta.type &amp;&amp; meta.type !== type) {
						me.destroyDatasetMeta(datasetIndex);
						meta = me.getDatasetMeta(datasetIndex);
					}
					meta.type = type;

					types.push(meta.type);

					if (meta.controller) {
						meta.controller.updateIndex(datasetIndex);
						meta.controller.linkScales();
					} else {
						var ControllerClass = Chart.controllers[meta.type];
						if (ControllerClass === undefined) {
							throw new Error(&#x27;&quot;&#x27; + meta.type + &#x27;&quot; is not a chart type.&#x27;);
						}

						meta.controller = new ControllerClass(me, datasetIndex);
						newControllers.push(meta.controller);
					}
				}, me);

				return newControllers;
			},

			/**
			 * Reset the elements of all datasets
			 * @private
			 */
			resetElements: function() {
				var me = this;
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.reset();
				}, me);
			},

			/**
			* Resets the chart back to it&#x27;s state before the initial animation
			*/
			reset: function() {
				this.resetElements();
				this.tooltip.initialize();
			},

			update: function(config) {
				var me = this;

				if (!config || typeof config !== &#x27;object&#x27;) {
					// backwards compatibility
					config = {
						duration: config,
						lazy: arguments[1]
					};
				}

				updateConfig(me);

				// plugins options references might have change, let&#x27;s invalidate the cache
				// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
				plugins._invalidate(me);

				if (plugins.notify(me, &#x27;beforeUpdate&#x27;) === false) {
					return;
				}

				// In case the entire data object changed
				me.tooltip._data = me.data;

				// Make sure dataset controllers are updated and new controllers are reset
				var newControllers = me.buildOrUpdateControllers();

				// Make sure all dataset controllers have correct meta data counts
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
				}, me);

				me.updateLayout();

				// Can only reset the new controllers after the scales have been updated
				if (me.options.animation &amp;&amp; me.options.animation.duration) {
					helpers.each(newControllers, function(controller) {
						controller.reset();
					});
				}

				me.updateDatasets();

				// Need to reset tooltip in case it is displayed with elements that are removed
				// after update.
				me.tooltip.initialize();

				// Last active contains items that were previously in the tooltip.
				// When we reset the tooltip, we need to clear it
				me.lastActive = [];

				// Do this before render so that any plugins that need final scale updates can use it
				plugins.notify(me, &#x27;afterUpdate&#x27;);

				if (me._bufferedRender) {
					me._bufferedRequest = {
						duration: config.duration,
						easing: config.easing,
						lazy: config.lazy
					};
				} else {
					me.render(config);
				}
			},

			/**
			 * Updates the chart layout unless a plugin returns &#x60;false&#x60; to the &#x60;beforeLayout&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterLayout&#x60;.
			 * @private
			 */
			updateLayout: function() {
				var me = this;

				if (plugins.notify(me, &#x27;beforeLayout&#x27;) === false) {
					return;
				}

				layouts.update(this, this.width, this.height);

				/**
				 * Provided for backward compatibility, use &#x60;afterLayout&#x60; instead.
				 * @method IPlugin#afterScaleUpdate
				 * @deprecated since version 2.5.0
				 * @todo remove at version 3
				 * @private
				 */
				plugins.notify(me, &#x27;afterScaleUpdate&#x27;);
				plugins.notify(me, &#x27;afterLayout&#x27;);
			},

			/**
			 * Updates all datasets unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetsUpdate&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetsUpdate&#x60;.
			 * @private
			 */
			updateDatasets: function() {
				var me = this;

				if (plugins.notify(me, &#x27;beforeDatasetsUpdate&#x27;) === false) {
					return;
				}

				for (var i = 0, ilen = me.data.datasets.length; i &lt; ilen; ++i) {
					me.updateDataset(i);
				}

				plugins.notify(me, &#x27;afterDatasetsUpdate&#x27;);
			},

			/**
			 * Updates dataset at index unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetUpdate&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetUpdate&#x60;.
			 * @private
			 */
			updateDataset: function(index) {
				var me = this;
				var meta = me.getDatasetMeta(index);
				var args = {
					meta: meta,
					index: index
				};

				if (plugins.notify(me, &#x27;beforeDatasetUpdate&#x27;, [args]) === false) {
					return;
				}

				meta.controller.update();

				plugins.notify(me, &#x27;afterDatasetUpdate&#x27;, [args]);
			},

			render: function(config) {
				var me = this;

				if (!config || typeof config !== &#x27;object&#x27;) {
					// backwards compatibility
					config = {
						duration: config,
						lazy: arguments[1]
					};
				}

				var duration = config.duration;
				var lazy = config.lazy;

				if (plugins.notify(me, &#x27;beforeRender&#x27;) === false) {
					return;
				}

				var animationOptions = me.options.animation;
				var onComplete = function(animation) {
					plugins.notify(me, &#x27;afterRender&#x27;);
					helpers.callback(animationOptions &amp;&amp; animationOptions.onComplete, [animation], me);
				};

				if (animationOptions &amp;&amp; ((typeof duration !== &#x27;undefined&#x27; &amp;&amp; duration !== 0) || (typeof duration === &#x27;undefined&#x27; &amp;&amp; animationOptions.duration !== 0))) {
					var animation = new Chart.Animation({
						numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
						easing: config.easing || animationOptions.easing,

						render: function(chart, animationObject) {
							var easingFunction = helpers.easing.effects[animationObject.easing];
							var currentStep = animationObject.currentStep;
							var stepDecimal = currentStep / animationObject.numSteps;

							chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
						},

						onAnimationProgress: animationOptions.onProgress,
						onAnimationComplete: onComplete
					});

					Chart.animationService.addAnimation(me, animation, duration, lazy);
				} else {
					me.draw();

					// See https://github.com/chartjs/Chart.js/issues/3781
					onComplete(new Chart.Animation({numSteps: 0, chart: me}));
				}

				return me;
			},

			draw: function(easingValue) {
				var me = this;

				me.clear();

				if (helpers.isNullOrUndef(easingValue)) {
					easingValue = 1;
				}

				me.transition(easingValue);

				if (plugins.notify(me, &#x27;beforeDraw&#x27;, [easingValue]) === false) {
					return;
				}

				// Draw all the scales
				helpers.each(me.boxes, function(box) {
					box.draw(me.chartArea);
				}, me);

				if (me.scale) {
					me.scale.draw();
				}

				me.drawDatasets(easingValue);
				me._drawTooltip(easingValue);

				plugins.notify(me, &#x27;afterDraw&#x27;, [easingValue]);
			},

			/**
			 * @private
			 */
			transition: function(easingValue) {
				var me = this;

				for (var i = 0, ilen = (me.data.datasets || []).length; i &lt; ilen; ++i) {
					if (me.isDatasetVisible(i)) {
						me.getDatasetMeta(i).controller.transition(easingValue);
					}
				}

				me.tooltip.transition(easingValue);
			},

			/**
			 * Draws all datasets unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetsDraw&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetsDraw&#x60;.
			 * @private
			 */
			drawDatasets: function(easingValue) {
				var me = this;

				if (plugins.notify(me, &#x27;beforeDatasetsDraw&#x27;, [easingValue]) === false) {
					return;
				}

				// Draw datasets reversed to support proper line stacking
				for (var i = (me.data.datasets || []).length - 1; i &gt;= 0; --i) {
					if (me.isDatasetVisible(i)) {
						me.drawDataset(i, easingValue);
					}
				}

				plugins.notify(me, &#x27;afterDatasetsDraw&#x27;, [easingValue]);
			},

			/**
			 * Draws dataset at index unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetDraw&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetDraw&#x60;.
			 * @private
			 */
			drawDataset: function(index, easingValue) {
				var me = this;
				var meta = me.getDatasetMeta(index);
				var args = {
					meta: meta,
					index: index,
					easingValue: easingValue
				};

				if (plugins.notify(me, &#x27;beforeDatasetDraw&#x27;, [args]) === false) {
					return;
				}

				meta.controller.draw(easingValue);

				plugins.notify(me, &#x27;afterDatasetDraw&#x27;, [args]);
			},

			/**
			 * Draws tooltip unless a plugin returns &#x60;false&#x60; to the &#x60;beforeTooltipDraw&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterTooltipDraw&#x60;.
			 * @private
			 */
			_drawTooltip: function(easingValue) {
				var me = this;
				var tooltip = me.tooltip;
				var args = {
					tooltip: tooltip,
					easingValue: easingValue
				};

				if (plugins.notify(me, &#x27;beforeTooltipDraw&#x27;, [args]) === false) {
					return;
				}

				tooltip.draw();

				plugins.notify(me, &#x27;afterTooltipDraw&#x27;, [args]);
			},

			// Get the single element that was clicked on
			// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
			getElementAtEvent: function(e) {
				return Interaction.modes.single(this, e);
			},

			getElementsAtEvent: function(e) {
				return Interaction.modes.label(this, e, {intersect: true});
			},

			getElementsAtXAxis: function(e) {
				return Interaction.modes[&#x27;x-axis&#x27;](this, e, {intersect: true});
			},

			getElementsAtEventForMode: function(e, mode, options) {
				var method = Interaction.modes[mode];
				if (typeof method === &#x27;function&#x27;) {
					return method(this, e, options);
				}

				return [];
			},

			getDatasetAtEvent: function(e) {
				return Interaction.modes.dataset(this, e, {intersect: true});
			},

			getDatasetMeta: function(datasetIndex) {
				var me = this;
				var dataset = me.data.datasets[datasetIndex];
				if (!dataset._meta) {
					dataset._meta = {};
				}

				var meta = dataset._meta[me.id];
				if (!meta) {
					meta = dataset._meta[me.id] = {
						type: null,
						data: [],
						dataset: null,
						controller: null,
						hidden: null,			// See isDatasetVisible() comment
						xAxisID: null,
						yAxisID: null
					};
				}

				return meta;
			},

			getVisibleDatasetCount: function() {
				var count = 0;
				for (var i = 0, ilen = this.data.datasets.length; i &lt; ilen; ++i) {
					if (this.isDatasetVisible(i)) {
						count++;
					}
				}
				return count;
			},

			isDatasetVisible: function(datasetIndex) {
				var meta = this.getDatasetMeta(datasetIndex);

				// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
				// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
				return typeof meta.hidden === &#x27;boolean&#x27; ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
			},

			generateLegend: function() {
				return this.options.legendCallback(this);
			},

			/**
			 * @private
			 */
			destroyDatasetMeta: function(datasetIndex) {
				var id = this.id;
				var dataset = this.data.datasets[datasetIndex];
				var meta = dataset._meta &amp;&amp; dataset._meta[id];

				if (meta) {
					meta.controller.destroy();
					delete dataset._meta[id];
				}
			},

			destroy: function() {
				var me = this;
				var canvas = me.canvas;
				var i, ilen;

				me.stop();

				// dataset controllers need to cleanup associated data
				for (i = 0, ilen = me.data.datasets.length; i &lt; ilen; ++i) {
					me.destroyDatasetMeta(i);
				}

				if (canvas) {
					me.unbindEvents();
					helpers.canvas.clear(me);
					platform.releaseContext(me.ctx);
					me.canvas = null;
					me.ctx = null;
				}

				plugins.notify(me, &#x27;destroy&#x27;);

				delete Chart.instances[me.id];
			},

			toBase64Image: function() {
				return this.canvas.toDataURL.apply(this.canvas, arguments);
			},

			initToolTip: function() {
				var me = this;
				me.tooltip = new Chart.Tooltip({
					_chart: me,
					_chartInstance: me, // deprecated, backward compatibility
					_data: me.data,
					_options: me.options.tooltips
				}, me);
			},

			/**
			 * @private
			 */
			bindEvents: function() {
				var me = this;
				var listeners = me._listeners = {};
				var listener = function() {
					me.eventHandler.apply(me, arguments);
				};

				helpers.each(me.options.events, function(type) {
					platform.addEventListener(me, type, listener);
					listeners[type] = listener;
				});

				// Elements used to detect size change should not be injected for non responsive charts.
				// See https://github.com/chartjs/Chart.js/issues/2210
				if (me.options.responsive) {
					listener = function() {
						me.resize();
					};

					platform.addEventListener(me, &#x27;resize&#x27;, listener);
					listeners.resize = listener;
				}
			},

			/**
			 * @private
			 */
			unbindEvents: function() {
				var me = this;
				var listeners = me._listeners;
				if (!listeners) {
					return;
				}

				delete me._listeners;
				helpers.each(listeners, function(listener, type) {
					platform.removeEventListener(me, type, listener);
				});
			},

			updateHoverStyle: function(elements, mode, enabled) {
				var method = enabled ? &#x27;setHoverStyle&#x27; : &#x27;removeHoverStyle&#x27;;
				var element, i, ilen;

				for (i = 0, ilen = elements.length; i &lt; ilen; ++i) {
					element = elements[i];
					if (element) {
						this.getDatasetMeta(element._datasetIndex).controller[method](element);
					}
				}
			},

			/**
			 * @private
			 */
			eventHandler: function(e) {
				var me = this;
				var tooltip = me.tooltip;

				if (plugins.notify(me, &#x27;beforeEvent&#x27;, [e]) === false) {
					return;
				}

				// Buffer any update calls so that renders do not occur
				me._bufferedRender = true;
				me._bufferedRequest = null;

				var changed = me.handleEvent(e);
				// for smooth tooltip animations issue #4989
				// the tooltip should be the source of change
				// Animation check workaround:
				// tooltip._start will be null when tooltip isn&#x27;t animating
				if (tooltip) {
					changed = tooltip._start
						? tooltip.handleEvent(e)
						: changed | tooltip.handleEvent(e);
				}

				plugins.notify(me, &#x27;afterEvent&#x27;, [e]);

				var bufferedRequest = me._bufferedRequest;
				if (bufferedRequest) {
					// If we have an update that was triggered, we need to do a normal render
					me.render(bufferedRequest);
				} else if (changed &amp;&amp; !me.animating) {
					// If entering, leaving, or changing elements, animate the change via pivot
					me.stop();

					// We only need to render at this point. Updating will cause scales to be
					// recomputed generating flicker &amp; using more memory than necessary.
					me.render(me.options.hover.animationDuration, true);
				}

				me._bufferedRender = false;
				me._bufferedRequest = null;

				return me;
			},

			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event the event to handle
			 * @return {Boolean} true if the chart needs to re-render
			 */
			handleEvent: function(e) {
				var me = this;
				var options = me.options || {};
				var hoverOptions = options.hover;
				var changed = false;

				me.lastActive = me.lastActive || [];

				// Find Active Elements for hover and tooltips
				if (e.type === &#x27;mouseout&#x27;) {
					me.active = [];
				} else {
					me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
				}

				// Invoke onHover hook
				// Need to call with native event here to not break backwards compatibility
				helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

				if (e.type === &#x27;mouseup&#x27; || e.type === &#x27;click&#x27;) {
					if (options.onClick) {
						// Use e.native here for backwards compatibility
						options.onClick.call(me, e.native, me.active);
					}
				}

				// Remove styling for last active (even if it may still be active)
				if (me.lastActive.length) {
					me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
				}

				// Built in hover styling
				if (me.active.length &amp;&amp; hoverOptions.mode) {
					me.updateHoverStyle(me.active, hoverOptions.mode, true);
				}

				changed = !helpers.arrayEquals(me.active, me.lastActive);

				// Remember Last Actives
				me.lastActive = me.active;

				return changed;
			}
		});

		/**
		 * Provided for backward compatibility, use Chart instead.
		 * @class Chart.Controller
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.Controller = Chart;
	};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);

	module.exports = function(Chart) {

		var arrayEvents = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;splice&#x27;, &#x27;unshift&#x27;];

		/**
		 * Hooks the array methods that add or remove values (&#x27;push&#x27;, pop&#x27;, &#x27;shift&#x27;, &#x27;splice&#x27;,
		 * &#x27;unshift&#x27;) and notify the listener AFTER the array has been altered. Listeners are
		 * called on the &#x27;onData*&#x27; callbacks (e.g. onDataPush, etc.) with same arguments.
		 */
		function listenArrayEvents(array, listener) {
			if (array._chartjs) {
				array._chartjs.listeners.push(listener);
				return;
			}

			Object.defineProperty(array, &#x27;_chartjs&#x27;, {
				configurable: true,
				enumerable: false,
				value: {
					listeners: [listener]
				}
			});

			arrayEvents.forEach(function(key) {
				var method = &#x27;onData&#x27; + key.charAt(0).toUpperCase() + key.slice(1);
				var base = array[key];

				Object.defineProperty(array, key, {
					configurable: true,
					enumerable: false,
					value: function() {
						var args = Array.prototype.slice.call(arguments);
						var res = base.apply(this, args);

						helpers.each(array._chartjs.listeners, function(object) {
							if (typeof object[method] === &#x27;function&#x27;) {
								object[method].apply(object, args);
							}
						});

						return res;
					}
				});
			});
		}

		/**
		 * Removes the given array event listener and cleanup extra attached properties (such as
		 * the _chartjs stub and overridden methods) if array doesn&#x27;t have any more listeners.
		 */
		function unlistenArrayEvents(array, listener) {
			var stub = array._chartjs;
			if (!stub) {
				return;
			}

			var listeners = stub.listeners;
			var index = listeners.indexOf(listener);
			if (index !== -1) {
				listeners.splice(index, 1);
			}

			if (listeners.length &gt; 0) {
				return;
			}

			arrayEvents.forEach(function(key) {
				delete array[key];
			});

			delete array._chartjs;
		}

		// Base class for all dataset controllers (line, bar, etc)
		Chart.DatasetController = function(chart, datasetIndex) {
			this.initialize(chart, datasetIndex);
		};

		helpers.extend(Chart.DatasetController.prototype, {

			/**
			 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
			 * @type {Chart.core.element}
			 */
			datasetElementType: null,

			/**
			 * Element type used to generate a meta data (e.g. Chart.element.Point).
			 * @type {Chart.core.element}
			 */
			dataElementType: null,

			initialize: function(chart, datasetIndex) {
				var me = this;
				me.chart = chart;
				me.index = datasetIndex;
				me.linkScales();
				me.addElements();
			},

			updateIndex: function(datasetIndex) {
				this.index = datasetIndex;
			},

			linkScales: function() {
				var me = this;
				var meta = me.getMeta();
				var dataset = me.getDataset();

				if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
					meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
				}
				if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
					meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
				}
			},

			getDataset: function() {
				return this.chart.data.datasets[this.index];
			},

			getMeta: function() {
				return this.chart.getDatasetMeta(this.index);
			},

			getScaleForId: function(scaleID) {
				return this.chart.scales[scaleID];
			},

			reset: function() {
				this.update(true);
			},

			/**
			 * @private
			 */
			destroy: function() {
				if (this._data) {
					unlistenArrayEvents(this._data, this);
				}
			},

			createMetaDataset: function() {
				var me = this;
				var type = me.datasetElementType;
				return type &amp;&amp; new type({
					_chart: me.chart,
					_datasetIndex: me.index
				});
			},

			createMetaData: function(index) {
				var me = this;
				var type = me.dataElementType;
				return type &amp;&amp; new type({
					_chart: me.chart,
					_datasetIndex: me.index,
					_index: index
				});
			},

			addElements: function() {
				var me = this;
				var meta = me.getMeta();
				var data = me.getDataset().data || [];
				var metaData = meta.data;
				var i, ilen;

				for (i = 0, ilen = data.length; i &lt; ilen; ++i) {
					metaData[i] = metaData[i] || me.createMetaData(i);
				}

				meta.dataset = meta.dataset || me.createMetaDataset();
			},

			addElementAndReset: function(index) {
				var element = this.createMetaData(index);
				this.getMeta().data.splice(index, 0, element);
				this.updateElement(element, index, true);
			},

			buildOrUpdateElements: function() {
				var me = this;
				var dataset = me.getDataset();
				var data = dataset.data || (dataset.data = []);

				// In order to correctly handle data addition/deletion animation (an thus simulate
				// real-time charts), we need to monitor these data modifications and synchronize
				// the internal meta data accordingly.
				if (me._data !== data) {
					if (me._data) {
						// This case happens when the user replaced the data array instance.
						unlistenArrayEvents(me._data, me);
					}

					listenArrayEvents(data, me);
					me._data = data;
				}

				// Re-sync meta data in case the user replaced the data array or if we missed
				// any updates and so make sure that we handle number of datapoints changing.
				me.resyncElements();
			},

			update: helpers.noop,

			transition: function(easingValue) {
				var meta = this.getMeta();
				var elements = meta.data || [];
				var ilen = elements.length;
				var i = 0;

				for (; i &lt; ilen; ++i) {
					elements[i].transition(easingValue);
				}

				if (meta.dataset) {
					meta.dataset.transition(easingValue);
				}
			},

			draw: function() {
				var meta = this.getMeta();
				var elements = meta.data || [];
				var ilen = elements.length;
				var i = 0;

				if (meta.dataset) {
					meta.dataset.draw();
				}

				for (; i &lt; ilen; ++i) {
					elements[i].draw();
				}
			},

			removeHoverStyle: function(element, elementOpts) {
				var dataset = this.chart.data.datasets[element._datasetIndex];
				var index = element._index;
				var custom = element.custom || {};
				var valueOrDefault = helpers.valueAtIndexOrDefault;
				var model = element._model;

				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
			},

			setHoverStyle: function(element) {
				var dataset = this.chart.data.datasets[element._datasetIndex];
				var index = element._index;
				var custom = element.custom || {};
				var valueOrDefault = helpers.valueAtIndexOrDefault;
				var getHoverColor = helpers.getHoverColor;
				var model = element._model;

				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},

			/**
			 * @private
			 */
			resyncElements: function() {
				var me = this;
				var meta = me.getMeta();
				var data = me.getDataset().data;
				var numMeta = meta.data.length;
				var numData = data.length;

				if (numData &lt; numMeta) {
					meta.data.splice(numData, numMeta - numData);
				} else if (numData &gt; numMeta) {
					me.insertElements(numMeta, numData - numMeta);
				}
			},

			/**
			 * @private
			 */
			insertElements: function(start, count) {
				for (var i = 0; i &lt; count; ++i) {
					this.addElementAndReset(start + i);
				}
			},

			/**
			 * @private
			 */
			onDataPush: function() {
				this.insertElements(this.getDataset().data.length - 1, arguments.length);
			},

			/**
			 * @private
			 */
			onDataPop: function() {
				this.getMeta().data.pop();
			},

			/**
			 * @private
			 */
			onDataShift: function() {
				this.getMeta().data.shift();
			},

			/**
			 * @private
			 */
			onDataSplice: function(start, count) {
				this.getMeta().data.splice(start, count);
				this.insertElements(start, arguments.length - 2);
			},

			/**
			 * @private
			 */
			onDataUnshift: function() {
				this.insertElements(0, arguments.length);
			}
		});

		Chart.DatasetController.extend = helpers.inherits;
	};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var helpers = __webpack_require__(36);
	var layouts = __webpack_require__(54);

	module.exports = function(Chart) {

		Chart.scaleService = {
			// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
			// use the new chart options to grab the correct scale
			constructors: {},
			// Use a registration function so that we can move to an ES6 map when we no longer need to support
			// old browsers

			// Scale config defaults
			defaults: {},
			registerScaleType: function(type, scaleConstructor, scaleDefaults) {
				this.constructors[type] = scaleConstructor;
				this.defaults[type] = helpers.clone(scaleDefaults);
			},
			getScaleConstructor: function(type) {
				return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
			},
			getScaleDefaults: function(type) {
				// Return the scale defaults merged with the global settings so that we always use the latest ones
				return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
			},
			updateScaleDefaults: function(type, additions) {
				var me = this;
				if (me.defaults.hasOwnProperty(type)) {
					me.defaults[type] = helpers.extend(me.defaults[type], additions);
				}
			},
			addScalesToLayout: function(chart) {
				// Adds each scale to the chart.boxes array to be sized accordingly
				helpers.each(chart.scales, function(scale) {
					// Set ILayoutItem parameters for backwards compatibility
					scale.fullWidth = scale.options.fullWidth;
					scale.position = scale.options.position;
					scale.weight = scale.options.weight;
					layouts.addBox(chart, scale);
				});
			}
		};
	};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);
	var Ticks = __webpack_require__(59);

	defaults._set(&#x27;scale&#x27;, {
		display: true,
		position: &#x27;left&#x27;,
		offset: false,

		// grid line settings
		gridLines: {
			display: true,
			color: &#x27;rgba(0, 0, 0, 0.1)&#x27;,
			lineWidth: 1,
			drawBorder: true,
			drawOnChartArea: true,
			drawTicks: true,
			tickMarkLength: 10,
			zeroLineWidth: 1,
			zeroLineColor: &#x27;rgba(0,0,0,0.25)&#x27;,
			zeroLineBorderDash: [],
			zeroLineBorderDashOffset: 0.0,
			offsetGridLines: false,
			borderDash: [],
			borderDashOffset: 0.0
		},

		// scale label
		scaleLabel: {
			// display property
			display: false,

			// actual label
			labelString: &#x27;&#x27;,

			// line height
			lineHeight: 1.2,

			// top/bottom padding
			padding: {
				top: 4,
				bottom: 4
			}
		},

		// label settings
		ticks: {
			beginAtZero: false,
			minRotation: 0,
			maxRotation: 50,
			mirror: false,
			padding: 0,
			reverse: false,
			display: true,
			autoSkip: true,
			autoSkipPadding: 0,
			labelOffset: 0,
			// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
			callback: Ticks.formatters.values,
			minor: {},
			major: {}
		}
	});

	function labelsFromTicks(ticks) {
		var labels = [];
		var i, ilen;

		for (i = 0, ilen = ticks.length; i &lt; ilen; ++i) {
			labels.push(ticks[i].label);
		}

		return labels;
	}

	function getLineValue(scale, index, offsetGridLines) {
		var lineValue = scale.getPixelForTick(index);

		if (offsetGridLines) {
			if (index === 0) {
				lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
			} else {
				lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
			}
		}
		return lineValue;
	}

	module.exports = function(Chart) {

		function computeTextSize(context, tick, font) {
			return helpers.isArray(tick) ?
				helpers.longestText(context, font, tick) :
				context.measureText(tick).width;
		}

		function parseFontOptions(options) {
			var valueOrDefault = helpers.valueOrDefault;
			var globalDefaults = defaults.global;
			var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
			var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
			var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

			return {
				size: size,
				style: style,
				family: family,
				font: helpers.fontString(size, style, family)
			};
		}

		function parseLineHeight(options) {
			return helpers.options.toLineHeight(
				helpers.valueOrDefault(options.lineHeight, 1.2),
				helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
		}

		Chart.Scale = Element.extend({
			/**
			 * Get the padding needed for the scale
			 * @method getPadding
			 * @private
			 * @returns {Padding} the necessary padding
			 */
			getPadding: function() {
				var me = this;
				return {
					left: me.paddingLeft || 0,
					top: me.paddingTop || 0,
					right: me.paddingRight || 0,
					bottom: me.paddingBottom || 0
				};
			},

			/**
			 * Returns the scale tick objects ({label, major})
			 * @since 2.7
			 */
			getTicks: function() {
				return this._ticks;
			},

			// These methods are ordered by lifecyle. Utilities then follow.
			// Any function defined here is inherited by all scale types.
			// Any function can be extended by the scale type

			mergeTicksOptions: function() {
				var ticks = this.options.ticks;
				if (ticks.minor === false) {
					ticks.minor = {
						display: false
					};
				}
				if (ticks.major === false) {
					ticks.major = {
						display: false
					};
				}
				for (var key in ticks) {
					if (key !== &#x27;major&#x27; &amp;&amp; key !== &#x27;minor&#x27;) {
						if (typeof ticks.minor[key] === &#x27;undefined&#x27;) {
							ticks.minor[key] = ticks[key];
						}
						if (typeof ticks.major[key] === &#x27;undefined&#x27;) {
							ticks.major[key] = ticks[key];
						}
					}
				}
			},
			beforeUpdate: function() {
				helpers.callback(this.options.beforeUpdate, [this]);
			},
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
				var i, ilen, labels, label, ticks, tick;

				// Update Lifecycle - Probably don&#x27;t want to ever extend or overwrite this function ;)
				me.beforeUpdate();

				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = helpers.extend({
					left: 0,
					right: 0,
					top: 0,
					bottom: 0
				}, margins);
				me.longestTextCache = me.longestTextCache || {};

				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();

				// Data min/max
				me.beforeDataLimits();
				me.determineDataLimits();
				me.afterDataLimits();

				// Ticks - &#x60;this.ticks&#x60; is now DEPRECATED!
				// Internal ticks are now stored as objects in the PRIVATE &#x60;this._ticks&#x60; member
				// and must not be accessed directly from outside this class. &#x60;this.ticks&#x60; being
				// around for long time and not marked as private, we can&#x27;t change its structure
				// without unexpected breaking changes. If you need to access the scale ticks,
				// use scale.getTicks() instead.

				me.beforeBuildTicks();

				// New implementations should return an array of objects but for BACKWARD COMPAT,
				// we still support no return (&#x60;this.ticks&#x60; internally set by calling this method).
				ticks = me.buildTicks() || [];

				me.afterBuildTicks();

				me.beforeTickToLabelConversion();

				// New implementations should return the formatted tick labels but for BACKWARD
				// COMPAT, we still support no return (&#x60;this.ticks&#x60; internally changed by calling
				// this method and supposed to contain only string values).
				labels = me.convertTicksToLabels(ticks) || me.ticks;

				me.afterTickToLabelConversion();

				me.ticks = labels;   // BACKWARD COMPATIBILITY

				// IMPORTANT: from this point, we consider that &#x60;this.ticks&#x60; will NEVER change!

				// BACKWARD COMPAT: synchronize &#x60;_ticks&#x60; with labels (so potentially &#x60;this.ticks&#x60;)
				for (i = 0, ilen = labels.length; i &lt; ilen; ++i) {
					label = labels[i];
					tick = ticks[i];
					if (!tick) {
						ticks.push(tick = {
							label: label,
							major: false
						});
					} else {
						tick.label = label;
					}
				}

				me._ticks = ticks;

				// Tick Rotation
				me.beforeCalculateTickRotation();
				me.calculateTickRotation();
				me.afterCalculateTickRotation();
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();

				return me.minSize;

			},
			afterUpdate: function() {
				helpers.callback(this.options.afterUpdate, [this]);
			},

			//

			beforeSetDimensions: function() {
				helpers.callback(this.options.beforeSetDimensions, [this]);
			},
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;

					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}

				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
			},
			afterSetDimensions: function() {
				helpers.callback(this.options.afterSetDimensions, [this]);
			},

			// Data limits
			beforeDataLimits: function() {
				helpers.callback(this.options.beforeDataLimits, [this]);
			},
			determineDataLimits: helpers.noop,
			afterDataLimits: function() {
				helpers.callback(this.options.afterDataLimits, [this]);
			},

			//
			beforeBuildTicks: function() {
				helpers.callback(this.options.beforeBuildTicks, [this]);
			},
			buildTicks: helpers.noop,
			afterBuildTicks: function() {
				helpers.callback(this.options.afterBuildTicks, [this]);
			},

			beforeTickToLabelConversion: function() {
				helpers.callback(this.options.beforeTickToLabelConversion, [this]);
			},
			convertTicksToLabels: function() {
				var me = this;
				// Convert ticks to strings
				var tickOpts = me.options.ticks;
				me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
			},
			afterTickToLabelConversion: function() {
				helpers.callback(this.options.afterTickToLabelConversion, [this]);
			},

			//

			beforeCalculateTickRotation: function() {
				helpers.callback(this.options.beforeCalculateTickRotation, [this]);
			},
			calculateTickRotation: function() {
				var me = this;
				var context = me.ctx;
				var tickOpts = me.options.ticks;
				var labels = labelsFromTicks(me._ticks);

				// Get the width of each grid by calculating the difference
				// between x offsets between 0 and 1.
				var tickFont = parseFontOptions(tickOpts);
				context.font = tickFont.font;

				var labelRotation = tickOpts.minRotation || 0;

				if (labels.length &amp;&amp; me.options.display &amp;&amp; me.isHorizontal()) {
					var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
					var labelWidth = originalLabelWidth;
					var cosRotation, sinRotation;

					// Allow 3 pixels x2 padding either side for label readability
					var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

					// Max label rotation can be set or default to 90 - also act as a loop counter
					while (labelWidth &gt; tickWidth &amp;&amp; labelRotation &lt; tickOpts.maxRotation) {
						var angleRadians = helpers.toRadians(labelRotation);
						cosRotation = Math.cos(angleRadians);
						sinRotation = Math.sin(angleRadians);

						if (sinRotation * originalLabelWidth &gt; me.maxHeight) {
							// go back one step
							labelRotation--;
							break;
						}

						labelRotation++;
						labelWidth = cosRotation * originalLabelWidth;
					}
				}

				me.labelRotation = labelRotation;
			},
			afterCalculateTickRotation: function() {
				helpers.callback(this.options.afterCalculateTickRotation, [this]);
			},

			//

			beforeFit: function() {
				helpers.callback(this.options.beforeFit, [this]);
			},
			fit: function() {
				var me = this;
				// Reset
				var minSize = me.minSize = {
					width: 0,
					height: 0
				};

				var labels = labelsFromTicks(me._ticks);

				var opts = me.options;
				var tickOpts = opts.ticks;
				var scaleLabelOpts = opts.scaleLabel;
				var gridLineOpts = opts.gridLines;
				var display = opts.display;
				var isHorizontal = me.isHorizontal();

				var tickFont = parseFontOptions(tickOpts);
				var tickMarkLength = opts.gridLines.tickMarkLength;

				// Width
				if (isHorizontal) {
					// subtract the margins to line up with the chartArea if we are a full width scale
					minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
				} else {
					minSize.width = display &amp;&amp; gridLineOpts.drawTicks ? tickMarkLength : 0;
				}

				// height
				if (isHorizontal) {
					minSize.height = display &amp;&amp; gridLineOpts.drawTicks ? tickMarkLength : 0;
				} else {
					minSize.height = me.maxHeight; // fill all the height
				}

				// Are we showing a title for the scale?
				if (scaleLabelOpts.display &amp;&amp; display) {
					var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
					var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
					var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

					if (isHorizontal) {
						minSize.height += deltaHeight;
					} else {
						minSize.width += deltaHeight;
					}
				}

				// Don&#x27;t bother fitting the ticks if we are not showing them
				if (tickOpts.display &amp;&amp; display) {
					var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
					var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
					var lineSpace = tickFont.size * 0.5;
					var tickPadding = me.options.ticks.padding;

					if (isHorizontal) {
						// A horizontal axis is more constrained by the height.
						me.longestLabelWidth = largestTextWidth;

						var angleRadians = helpers.toRadians(me.labelRotation);
						var cosRotation = Math.cos(angleRadians);
						var sinRotation = Math.sin(angleRadians);

						// TODO - improve this calculation
						var labelHeight = (sinRotation * largestTextWidth)
							+ (tickFont.size * tallestLabelHeightInLines)
							+ (lineSpace * (tallestLabelHeightInLines - 1))
							+ lineSpace; // padding

						minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

						me.ctx.font = tickFont.font;
						var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
						var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

						// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
						// which means that the right padding is dominated by the font height
						if (me.labelRotation !== 0) {
							me.paddingLeft = opts.position === &#x27;bottom&#x27; ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
							me.paddingRight = opts.position === &#x27;bottom&#x27; ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
						} else {
							me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
							me.paddingRight = lastLabelWidth / 2 + 3;
						}
					} else {
						// A vertical axis is more constrained by the width. Labels are the
						// dominant factor here, so get that length first and account for padding
						if (tickOpts.mirror) {
							largestTextWidth = 0;
						} else {
							// use lineSpace for consistency with horizontal axis
							// tickPadding is not implemented for horizontal
							largestTextWidth += tickPadding + lineSpace;
						}

						minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

						me.paddingTop = tickFont.size / 2;
						me.paddingBottom = tickFont.size / 2;
					}
				}

				me.handleMargins();

				me.width = minSize.width;
				me.height = minSize.height;
			},

			/**
			 * Handle margins and padding interactions
			 * @private
			 */
			handleMargins: function() {
				var me = this;
				if (me.margins) {
					me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
					me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
					me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
					me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
				}
			},

			afterFit: function() {
				helpers.callback(this.options.afterFit, [this]);
			},

			// Shared Methods
			isHorizontal: function() {
				return this.options.position === &#x27;top&#x27; || this.options.position === &#x27;bottom&#x27;;
			},
			isFullWidth: function() {
				return (this.options.fullWidth);
			},

			// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
			getRightValue: function(rawValue) {
				// Null and undefined values first
				if (helpers.isNullOrUndef(rawValue)) {
					return NaN;
				}
				// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
				if (typeof rawValue === &#x27;number&#x27; &amp;&amp; !isFinite(rawValue)) {
					return NaN;
				}
				// If it is in fact an object, dive in one more level
				if (rawValue) {
					if (this.isHorizontal()) {
						if (rawValue.x !== undefined) {
							return this.getRightValue(rawValue.x);
						}
					} else if (rawValue.y !== undefined) {
						return this.getRightValue(rawValue.y);
					}
				}

				// Value is good, return it
				return rawValue;
			},

			/**
			 * Used to get the value to display in the tooltip for the data at the given index
			 * @param index
			 * @param datasetIndex
			 */
			getLabelForIndex: helpers.noop,

			/**
			 * Returns the location of the given data point. Value can either be an index or a numerical value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param value
			 * @param index
			 * @param datasetIndex
			 */
			getPixelForValue: helpers.noop,

			/**
			 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param pixel
			 */
			getValueForPixel: helpers.noop,

			/**
			 * Returns the location of the tick at the given index
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForTick: function(index) {
				var me = this;
				var offset = me.options.offset;
				if (me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
					var pixel = (tickWidth * index) + me.paddingLeft;

					if (offset) {
						pixel += tickWidth / 2;
					}

					var finalVal = me.left + Math.round(pixel);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
				return me.top + (index * (innerHeight / (me._ticks.length - 1)));
			},

			/**
			 * Utility for getting the pixel location of a percentage of scale
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForDecimal: function(decimal) {
				var me = this;
				if (me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var valueOffset = (innerWidth * decimal) + me.paddingLeft;

					var finalVal = me.left + Math.round(valueOffset);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				return me.top + (decimal * me.height);
			},

			/**
			 * Returns the pixel for the minimum chart value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getBasePixel: function() {
				return this.getPixelForValue(this.getBaseValue());
			},

			getBaseValue: function() {
				var me = this;
				var min = me.min;
				var max = me.max;

				return me.beginAtZero ? 0 :
					min &lt; 0 &amp;&amp; max &lt; 0 ? max :
					min &gt; 0 &amp;&amp; max &gt; 0 ? min :
					0;
			},

			/**
			 * Returns a subset of ticks to be plotted to avoid overlapping labels.
			 * @private
			 */
			_autoSkip: function(ticks) {
				var skipRatio;
				var me = this;
				var isHorizontal = me.isHorizontal();
				var optionTicks = me.options.ticks.minor;
				var tickCount = ticks.length;
				var labelRotationRadians = helpers.toRadians(me.labelRotation);
				var cosRotation = Math.cos(labelRotationRadians);
				var longestRotatedLabel = me.longestLabelWidth * cosRotation;
				var result = [];
				var i, tick, shouldSkip;

				// figure out the maximum number of gridlines to show
				var maxTicks;
				if (optionTicks.maxTicksLimit) {
					maxTicks = optionTicks.maxTicksLimit;
				}

				if (isHorizontal) {
					skipRatio = false;

					if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount &gt; (me.width - (me.paddingLeft + me.paddingRight))) {
						skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
					}

					// if they defined a max number of optionTicks,
					// increase skipRatio until that number is met
					if (maxTicks &amp;&amp; tickCount &gt; maxTicks) {
						skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
					}
				}

				for (i = 0; i &lt; tickCount; i++) {
					tick = ticks[i];

					// Since we always show the last tick,we need may need to hide the last shown one before
					shouldSkip = (skipRatio &gt; 1 &amp;&amp; i % skipRatio &gt; 0) || (i % skipRatio === 0 &amp;&amp; i + skipRatio &gt;= tickCount);
					if (shouldSkip &amp;&amp; i !== tickCount - 1) {
						// leave tick in place but make sure it&#x27;s not displayed (#4635)
						delete tick.label;
					}
					result.push(tick);
				}
				return result;
			},

			// Actually draw the scale on the canvas
			// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
			draw: function(chartArea) {
				var me = this;
				var options = me.options;
				if (!options.display) {
					return;
				}

				var context = me.ctx;
				var globalDefaults = defaults.global;
				var optionTicks = options.ticks.minor;
				var optionMajorTicks = options.ticks.major || optionTicks;
				var gridLines = options.gridLines;
				var scaleLabel = options.scaleLabel;

				var isRotated = me.labelRotation !== 0;
				var isHorizontal = me.isHorizontal();

				var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
				var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
				var tickFont = parseFontOptions(optionTicks);
				var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
				var majorTickFont = parseFontOptions(optionMajorTicks);

				var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

				var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
				var scaleLabelFont = parseFontOptions(scaleLabel);
				var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
				var labelRotationRadians = helpers.toRadians(me.labelRotation);

				var itemsToDraw = [];

				var axisWidth = me.options.gridLines.lineWidth;
				var xTickStart = options.position === &#x27;right&#x27; ? me.right : me.right - axisWidth - tl;
				var xTickEnd = options.position === &#x27;right&#x27; ? me.right + tl : me.right;
				var yTickStart = options.position === &#x27;bottom&#x27; ? me.top + axisWidth : me.bottom - tl - axisWidth;
				var yTickEnd = options.position === &#x27;bottom&#x27; ? me.top + axisWidth + tl : me.bottom + axisWidth;

				helpers.each(ticks, function(tick, index) {
					// autoskipper skipped this tick (#4635)
					if (helpers.isNullOrUndef(tick.label)) {
						return;
					}

					var label = tick.label;
					var lineWidth, lineColor, borderDash, borderDashOffset;
					if (index === me.zeroLineIndex &amp;&amp; options.offset === gridLines.offsetGridLines) {
						// Draw the first index specially
						lineWidth = gridLines.zeroLineWidth;
						lineColor = gridLines.zeroLineColor;
						borderDash = gridLines.zeroLineBorderDash;
						borderDashOffset = gridLines.zeroLineBorderDashOffset;
					} else {
						lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
						lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
						borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
						borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
					}

					// Common properties
					var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
					var textAlign = &#x27;middle&#x27;;
					var textBaseline = &#x27;middle&#x27;;
					var tickPadding = optionTicks.padding;

					if (isHorizontal) {
						var labelYOffset = tl + tickPadding;

						if (options.position === &#x27;bottom&#x27;) {
							// bottom
							textBaseline = !isRotated ? &#x27;top&#x27; : &#x27;middle&#x27;;
							textAlign = !isRotated ? &#x27;center&#x27; : &#x27;right&#x27;;
							labelY = me.top + labelYOffset;
						} else {
							// top
							textBaseline = !isRotated ? &#x27;bottom&#x27; : &#x27;middle&#x27;;
							textAlign = !isRotated ? &#x27;center&#x27; : &#x27;left&#x27;;
							labelY = me.bottom - labelYOffset;
						}

						var xLineValue = getLineValue(me, index, gridLines.offsetGridLines &amp;&amp; ticks.length &gt; 1);
						if (xLineValue &lt; me.left) {
							lineColor = &#x27;rgba(0,0,0,0)&#x27;;
						}
						xLineValue += helpers.aliasPixel(lineWidth);

						labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

						tx1 = tx2 = x1 = x2 = xLineValue;
						ty1 = yTickStart;
						ty2 = yTickEnd;
						y1 = chartArea.top;
						y2 = chartArea.bottom + axisWidth;
					} else {
						var isLeft = options.position === &#x27;left&#x27;;
						var labelXOffset;

						if (optionTicks.mirror) {
							textAlign = isLeft ? &#x27;left&#x27; : &#x27;right&#x27;;
							labelXOffset = tickPadding;
						} else {
							textAlign = isLeft ? &#x27;right&#x27; : &#x27;left&#x27;;
							labelXOffset = tl + tickPadding;
						}

						labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

						var yLineValue = getLineValue(me, index, gridLines.offsetGridLines &amp;&amp; ticks.length &gt; 1);
						if (yLineValue &lt; me.top) {
							lineColor = &#x27;rgba(0,0,0,0)&#x27;;
						}
						yLineValue += helpers.aliasPixel(lineWidth);

						labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

						tx1 = xTickStart;
						tx2 = xTickEnd;
						x1 = chartArea.left;
						x2 = chartArea.right + axisWidth;
						ty1 = ty2 = y1 = y2 = yLineValue;
					}

					itemsToDraw.push({
						tx1: tx1,
						ty1: ty1,
						tx2: tx2,
						ty2: ty2,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
						labelX: labelX,
						labelY: labelY,
						glWidth: lineWidth,
						glColor: lineColor,
						glBorderDash: borderDash,
						glBorderDashOffset: borderDashOffset,
						rotation: -1 * labelRotationRadians,
						label: label,
						major: tick.major,
						textBaseline: textBaseline,
						textAlign: textAlign
					});
				});

				// Draw all of the tick labels, tick marks, and grid lines at the correct places
				helpers.each(itemsToDraw, function(itemToDraw) {
					if (gridLines.display) {
						context.save();
						context.lineWidth = itemToDraw.glWidth;
						context.strokeStyle = itemToDraw.glColor;
						if (context.setLineDash) {
							context.setLineDash(itemToDraw.glBorderDash);
							context.lineDashOffset = itemToDraw.glBorderDashOffset;
						}

						context.beginPath();

						if (gridLines.drawTicks) {
							context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
							context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
						}

						if (gridLines.drawOnChartArea) {
							context.moveTo(itemToDraw.x1, itemToDraw.y1);
							context.lineTo(itemToDraw.x2, itemToDraw.y2);
						}

						context.stroke();
						context.restore();
					}

					if (optionTicks.display) {
						// Make sure we draw text in the correct color and font
						context.save();
						context.translate(itemToDraw.labelX, itemToDraw.labelY);
						context.rotate(itemToDraw.rotation);
						context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
						context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
						context.textBaseline = itemToDraw.textBaseline;
						context.textAlign = itemToDraw.textAlign;

						var label = itemToDraw.label;
						if (helpers.isArray(label)) {
							var lineCount = label.length;
							var lineHeight = tickFont.size * 1.5;
							var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;

							for (var i = 0; i &lt; lineCount; ++i) {
								// We just make sure the multiline element is a string here..
								context.fillText(&#x27;&#x27; + label[i], 0, y);
								// apply same lineSpacing as calculated @ L#320
								y += lineHeight;
							}
						} else {
							context.fillText(label, 0, 0);
						}
						context.restore();
					}
				});

				if (scaleLabel.display) {
					// Draw the scale label
					var scaleLabelX;
					var scaleLabelY;
					var rotation = 0;
					var halfLineHeight = parseLineHeight(scaleLabel) / 2;

					if (isHorizontal) {
						scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
						scaleLabelY = options.position === &#x27;bottom&#x27;
							? me.bottom - halfLineHeight - scaleLabelPadding.bottom
							: me.top + halfLineHeight + scaleLabelPadding.top;
					} else {
						var isLeft = options.position === &#x27;left&#x27;;
						scaleLabelX = isLeft
							? me.left + halfLineHeight + scaleLabelPadding.top
							: me.right - halfLineHeight - scaleLabelPadding.top;
						scaleLabelY = me.top + ((me.bottom - me.top) / 2);
						rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
					}

					context.save();
					context.translate(scaleLabelX, scaleLabelY);
					context.rotate(rotation);
					context.textAlign = &#x27;center&#x27;;
					context.textBaseline = &#x27;middle&#x27;;
					context.fillStyle = scaleLabelFontColor; // render in correct colour
					context.font = scaleLabelFont.font;
					context.fillText(scaleLabel.labelString, 0, 0);
					context.restore();
				}

				if (gridLines.drawBorder) {
					// Draw the line at the edge of the axis
					context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
					context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
					var x1 = me.left;
					var x2 = me.right + axisWidth;
					var y1 = me.top;
					var y2 = me.bottom + axisWidth;

					var aliasPixel = helpers.aliasPixel(context.lineWidth);
					if (isHorizontal) {
						y1 = y2 = options.position === &#x27;top&#x27; ? me.bottom : me.top;
						y1 += aliasPixel;
						y2 += aliasPixel;
					} else {
						x1 = x2 = options.position === &#x27;left&#x27; ? me.right : me.left;
						x1 += aliasPixel;
						x2 += aliasPixel;
					}

					context.beginPath();
					context.moveTo(x1, y1);
					context.lineTo(x2, y2);
					context.stroke();
				}
			}
		});
	};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		tooltips: {
			enabled: true,
			custom: null,
			mode: &#x27;nearest&#x27;,
			position: &#x27;average&#x27;,
			intersect: true,
			backgroundColor: &#x27;rgba(0,0,0,0.8)&#x27;,
			titleFontStyle: &#x27;bold&#x27;,
			titleSpacing: 2,
			titleMarginBottom: 6,
			titleFontColor: &#x27;#fff&#x27;,
			titleAlign: &#x27;left&#x27;,
			bodySpacing: 2,
			bodyFontColor: &#x27;#fff&#x27;,
			bodyAlign: &#x27;left&#x27;,
			footerFontStyle: &#x27;bold&#x27;,
			footerSpacing: 2,
			footerMarginTop: 6,
			footerFontColor: &#x27;#fff&#x27;,
			footerAlign: &#x27;left&#x27;,
			yPadding: 6,
			xPadding: 6,
			caretPadding: 2,
			caretSize: 5,
			cornerRadius: 6,
			multiKeyBackground: &#x27;#fff&#x27;,
			displayColors: true,
			borderColor: &#x27;rgba(0,0,0,0)&#x27;,
			borderWidth: 0,
			callbacks: {
				// Args are: (tooltipItems, data)
				beforeTitle: helpers.noop,
				title: function(tooltipItems, data) {
					// Pick first xLabel for now
					var title = &#x27;&#x27;;
					var labels = data.labels;
					var labelCount = labels ? labels.length : 0;

					if (tooltipItems.length &gt; 0) {
						var item = tooltipItems[0];

						if (item.xLabel) {
							title = item.xLabel;
						} else if (labelCount &gt; 0 &amp;&amp; item.index &lt; labelCount) {
							title = labels[item.index];
						}
					}

					return title;
				},
				afterTitle: helpers.noop,

				// Args are: (tooltipItems, data)
				beforeBody: helpers.noop,

				// Args are: (tooltipItem, data)
				beforeLabel: helpers.noop,
				label: function(tooltipItem, data) {
					var label = data.datasets[tooltipItem.datasetIndex].label || &#x27;&#x27;;

					if (label) {
						label += &#x27;: &#x27;;
					}
					label += tooltipItem.yLabel;
					return label;
				},
				labelColor: function(tooltipItem, chart) {
					var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
					var activeElement = meta.data[tooltipItem.index];
					var view = activeElement._view;
					return {
						borderColor: view.borderColor,
						backgroundColor: view.backgroundColor
					};
				},
				labelTextColor: function() {
					return this._options.bodyFontColor;
				},
				afterLabel: helpers.noop,

				// Args are: (tooltipItems, data)
				afterBody: helpers.noop,

				// Args are: (tooltipItems, data)
				beforeFooter: helpers.noop,
				footer: helpers.noop,
				afterFooter: helpers.noop
			}
		}
	});

	module.exports = function(Chart) {

		/**
	 	 * Helper method to merge the opacity into a color
	 	 */
		function mergeOpacity(colorString, opacity) {
			var color = helpers.color(colorString);
			return color.alpha(opacity * color.alpha()).rgbaString();
		}

		// Helper to push or concat based on if the 2nd parameter is an array or not
		function pushOrConcat(base, toPush) {
			if (toPush) {
				if (helpers.isArray(toPush)) {
					// base = base.concat(toPush);
					Array.prototype.push.apply(base, toPush);
				} else {
					base.push(toPush);
				}
			}

			return base;
		}

		// Private helper to create a tooltip item model
		// @param element : the chart element (point, arc, bar) to create the tooltip item for
		// @return : new tooltip item
		function createTooltipItem(element) {
			var xScale = element._xScale;
			var yScale = element._yScale || element._scale; // handle radar || polarArea charts
			var index = element._index;
			var datasetIndex = element._datasetIndex;

			return {
				xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : &#x27;&#x27;,
				yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : &#x27;&#x27;,
				index: index,
				datasetIndex: datasetIndex,
				x: element._model.x,
				y: element._model.y
			};
		}

		/**
		 * Helper to get the reset model for the tooltip
		 * @param tooltipOpts {Object} the tooltip options
		 */
		function getBaseModel(tooltipOpts) {
			var globalDefaults = defaults.global;
			var valueOrDefault = helpers.valueOrDefault;

			return {
				// Positioning
				xPadding: tooltipOpts.xPadding,
				yPadding: tooltipOpts.yPadding,
				xAlign: tooltipOpts.xAlign,
				yAlign: tooltipOpts.yAlign,

				// Body
				bodyFontColor: tooltipOpts.bodyFontColor,
				_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
				_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
				_bodyAlign: tooltipOpts.bodyAlign,
				bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
				bodySpacing: tooltipOpts.bodySpacing,

				// Title
				titleFontColor: tooltipOpts.titleFontColor,
				_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
				_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
				titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
				_titleAlign: tooltipOpts.titleAlign,
				titleSpacing: tooltipOpts.titleSpacing,
				titleMarginBottom: tooltipOpts.titleMarginBottom,

				// Footer
				footerFontColor: tooltipOpts.footerFontColor,
				_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
				_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
				footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
				_footerAlign: tooltipOpts.footerAlign,
				footerSpacing: tooltipOpts.footerSpacing,
				footerMarginTop: tooltipOpts.footerMarginTop,

				// Appearance
				caretSize: tooltipOpts.caretSize,
				cornerRadius: tooltipOpts.cornerRadius,
				backgroundColor: tooltipOpts.backgroundColor,
				opacity: 0,
				legendColorBackground: tooltipOpts.multiKeyBackground,
				displayColors: tooltipOpts.displayColors,
				borderColor: tooltipOpts.borderColor,
				borderWidth: tooltipOpts.borderWidth
			};
		}

		/**
		 * Get the size of the tooltip
		 */
		function getTooltipSize(tooltip, model) {
			var ctx = tooltip._chart.ctx;

			var height = model.yPadding * 2; // Tooltip Padding
			var width = 0;

			// Count of all lines in the body
			var body = model.body;
			var combinedBodyLength = body.reduce(function(count, bodyItem) {
				return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
			}, 0);
			combinedBodyLength += model.beforeBody.length + model.afterBody.length;

			var titleLineCount = model.title.length;
			var footerLineCount = model.footer.length;
			var titleFontSize = model.titleFontSize;
			var bodyFontSize = model.bodyFontSize;
			var footerFontSize = model.footerFontSize;

			height += titleLineCount * titleFontSize; // Title Lines
			height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
			height += titleLineCount ? model.titleMarginBottom : 0; // Title&#x27;s bottom Margin
			height += combinedBodyLength * bodyFontSize; // Body Lines
			height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
			height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
			height += footerLineCount * (footerFontSize); // Footer Lines
			height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

			// Title width
			var widthPadding = 0;
			var maxLineWidth = function(line) {
				width = Math.max(width, ctx.measureText(line).width + widthPadding);
			};

			ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
			helpers.each(model.title, maxLineWidth);

			// Body width
			ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
			helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

			// Body lines may include some extra width due to the color box
			widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
			helpers.each(body, function(bodyItem) {
				helpers.each(bodyItem.before, maxLineWidth);
				helpers.each(bodyItem.lines, maxLineWidth);
				helpers.each(bodyItem.after, maxLineWidth);
			});

			// Reset back to 0
			widthPadding = 0;

			// Footer width
			ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
			helpers.each(model.footer, maxLineWidth);

			// Add padding
			width += 2 * model.xPadding;

			return {
				width: width,
				height: height
			};
		}

		/**
		 * Helper to get the alignment of a tooltip given the size
		 */
		function determineAlignment(tooltip, size) {
			var model = tooltip._model;
			var chart = tooltip._chart;
			var chartArea = tooltip._chart.chartArea;
			var xAlign = &#x27;center&#x27;;
			var yAlign = &#x27;center&#x27;;

			if (model.y &lt; size.height) {
				yAlign = &#x27;top&#x27;;
			} else if (model.y &gt; (chart.height - size.height)) {
				yAlign = &#x27;bottom&#x27;;
			}

			var lf, rf; // functions to determine left, right alignment
			var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
			var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
			var midX = (chartArea.left + chartArea.right) / 2;
			var midY = (chartArea.top + chartArea.bottom) / 2;

			if (yAlign === &#x27;center&#x27;) {
				lf = function(x) {
					return x &lt;= midX;
				};
				rf = function(x) {
					return x &gt; midX;
				};
			} else {
				lf = function(x) {
					return x &lt;= (size.width / 2);
				};
				rf = function(x) {
					return x &gt;= (chart.width - (size.width / 2));
				};
			}

			olf = function(x) {
				return x + size.width + model.caretSize + model.caretPadding &gt; chart.width;
			};
			orf = function(x) {
				return x - size.width - model.caretSize - model.caretPadding &lt; 0;
			};
			yf = function(y) {
				return y &lt;= midY ? &#x27;top&#x27; : &#x27;bottom&#x27;;
			};

			if (lf(model.x)) {
				xAlign = &#x27;left&#x27;;

				// Is tooltip too wide and goes over the right side of the chart.?
				if (olf(model.x)) {
					xAlign = &#x27;center&#x27;;
					yAlign = yf(model.y);
				}
			} else if (rf(model.x)) {
				xAlign = &#x27;right&#x27;;

				// Is tooltip too wide and goes outside left edge of canvas?
				if (orf(model.x)) {
					xAlign = &#x27;center&#x27;;
					yAlign = yf(model.y);
				}
			}

			var opts = tooltip._options;
			return {
				xAlign: opts.xAlign ? opts.xAlign : xAlign,
				yAlign: opts.yAlign ? opts.yAlign : yAlign
			};
		}

		/**
		 * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
		 */
		function getBackgroundPoint(vm, size, alignment, chart) {
			// Background Position
			var x = vm.x;
			var y = vm.y;

			var caretSize = vm.caretSize;
			var caretPadding = vm.caretPadding;
			var cornerRadius = vm.cornerRadius;
			var xAlign = alignment.xAlign;
			var yAlign = alignment.yAlign;
			var paddingAndSize = caretSize + caretPadding;
			var radiusAndPadding = cornerRadius + caretPadding;

			if (xAlign === &#x27;right&#x27;) {
				x -= size.width;
			} else if (xAlign === &#x27;center&#x27;) {
				x -= (size.width / 2);
				if (x + size.width &gt; chart.width) {
					x = chart.width - size.width;
				}
				if (x &lt; 0) {
					x = 0;
				}
			}

			if (yAlign === &#x27;top&#x27;) {
				y += paddingAndSize;
			} else if (yAlign === &#x27;bottom&#x27;) {
				y -= size.height + paddingAndSize;
			} else {
				y -= (size.height / 2);
			}

			if (yAlign === &#x27;center&#x27;) {
				if (xAlign === &#x27;left&#x27;) {
					x += paddingAndSize;
				} else if (xAlign === &#x27;right&#x27;) {
					x -= paddingAndSize;
				}
			} else if (xAlign === &#x27;left&#x27;) {
				x -= radiusAndPadding;
			} else if (xAlign === &#x27;right&#x27;) {
				x += radiusAndPadding;
			}

			return {
				x: x,
				y: y
			};
		}

		Chart.Tooltip = Element.extend({
			initialize: function() {
				this._model = getBaseModel(this._options);
				this._lastActive = [];
			},

			// Get the title
			// Args are: (tooltipItem, data)
			getTitle: function() {
				var me = this;
				var opts = me._options;
				var callbacks = opts.callbacks;

				var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
				var title = callbacks.title.apply(me, arguments);
				var afterTitle = callbacks.afterTitle.apply(me, arguments);

				var lines = [];
				lines = pushOrConcat(lines, beforeTitle);
				lines = pushOrConcat(lines, title);
				lines = pushOrConcat(lines, afterTitle);

				return lines;
			},

			// Args are: (tooltipItem, data)
			getBeforeBody: function() {
				var lines = this._options.callbacks.beforeBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
			},

			// Args are: (tooltipItem, data)
			getBody: function(tooltipItems, data) {
				var me = this;
				var callbacks = me._options.callbacks;
				var bodyItems = [];

				helpers.each(tooltipItems, function(tooltipItem) {
					var bodyItem = {
						before: [],
						lines: [],
						after: []
					};
					pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

					bodyItems.push(bodyItem);
				});

				return bodyItems;
			},

			// Args are: (tooltipItem, data)
			getAfterBody: function() {
				var lines = this._options.callbacks.afterBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
			},

			// Get the footer and beforeFooter and afterFooter lines
			// Args are: (tooltipItem, data)
			getFooter: function() {
				var me = this;
				var callbacks = me._options.callbacks;

				var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
				var footer = callbacks.footer.apply(me, arguments);
				var afterFooter = callbacks.afterFooter.apply(me, arguments);

				var lines = [];
				lines = pushOrConcat(lines, beforeFooter);
				lines = pushOrConcat(lines, footer);
				lines = pushOrConcat(lines, afterFooter);

				return lines;
			},

			update: function(changed) {
				var me = this;
				var opts = me._options;

				// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
				// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
				// which breaks any animations.
				var existingModel = me._model;
				var model = me._model = getBaseModel(opts);
				var active = me._active;

				var data = me._data;

				// In the case where active.length === 0 we need to keep these at existing values for good animations
				var alignment = {
					xAlign: existingModel.xAlign,
					yAlign: existingModel.yAlign
				};
				var backgroundPoint = {
					x: existingModel.x,
					y: existingModel.y
				};
				var tooltipSize = {
					width: existingModel.width,
					height: existingModel.height
				};
				var tooltipPosition = {
					x: existingModel.caretX,
					y: existingModel.caretY
				};

				var i, len;

				if (active.length) {
					model.opacity = 1;

					var labelColors = [];
					var labelTextColors = [];
					tooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);

					var tooltipItems = [];
					for (i = 0, len = active.length; i &lt; len; ++i) {
						tooltipItems.push(createTooltipItem(active[i]));
					}

					// If the user provided a filter function, use it to modify the tooltip items
					if (opts.filter) {
						tooltipItems = tooltipItems.filter(function(a) {
							return opts.filter(a, data);
						});
					}

					// If the user provided a sorting function, use it to modify the tooltip items
					if (opts.itemSort) {
						tooltipItems = tooltipItems.sort(function(a, b) {
							return opts.itemSort(a, b, data);
						});
					}

					// Determine colors for boxes
					helpers.each(tooltipItems, function(tooltipItem) {
						labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
						labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
					});


					// Build the Text Lines
					model.title = me.getTitle(tooltipItems, data);
					model.beforeBody = me.getBeforeBody(tooltipItems, data);
					model.body = me.getBody(tooltipItems, data);
					model.afterBody = me.getAfterBody(tooltipItems, data);
					model.footer = me.getFooter(tooltipItems, data);

					// Initial positioning and colors
					model.x = Math.round(tooltipPosition.x);
					model.y = Math.round(tooltipPosition.y);
					model.caretPadding = opts.caretPadding;
					model.labelColors = labelColors;
					model.labelTextColors = labelTextColors;

					// data points
					model.dataPoints = tooltipItems;

					// We need to determine alignment of the tooltip
					tooltipSize = getTooltipSize(this, model);
					alignment = determineAlignment(this, tooltipSize);
					// Final Size and Position
					backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
				} else {
					model.opacity = 0;
				}

				model.xAlign = alignment.xAlign;
				model.yAlign = alignment.yAlign;
				model.x = backgroundPoint.x;
				model.y = backgroundPoint.y;
				model.width = tooltipSize.width;
				model.height = tooltipSize.height;

				// Point where the caret on the tooltip points to
				model.caretX = tooltipPosition.x;
				model.caretY = tooltipPosition.y;

				me._model = model;

				if (changed &amp;&amp; opts.custom) {
					opts.custom.call(me, model);
				}

				return me;
			},
			drawCaret: function(tooltipPoint, size) {
				var ctx = this._chart.ctx;
				var vm = this._view;
				var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

				ctx.lineTo(caretPosition.x1, caretPosition.y1);
				ctx.lineTo(caretPosition.x2, caretPosition.y2);
				ctx.lineTo(caretPosition.x3, caretPosition.y3);
			},
			getCaretPosition: function(tooltipPoint, size, vm) {
				var x1, x2, x3, y1, y2, y3;
				var caretSize = vm.caretSize;
				var cornerRadius = vm.cornerRadius;
				var xAlign = vm.xAlign;
				var yAlign = vm.yAlign;
				var ptX = tooltipPoint.x;
				var ptY = tooltipPoint.y;
				var width = size.width;
				var height = size.height;

				if (yAlign === &#x27;center&#x27;) {
					y2 = ptY + (height / 2);

					if (xAlign === &#x27;left&#x27;) {
						x1 = ptX;
						x2 = x1 - caretSize;
						x3 = x1;

						y1 = y2 + caretSize;
						y3 = y2 - caretSize;
					} else {
						x1 = ptX + width;
						x2 = x1 + caretSize;
						x3 = x1;

						y1 = y2 - caretSize;
						y3 = y2 + caretSize;
					}
				} else {
					if (xAlign === &#x27;left&#x27;) {
						x2 = ptX + cornerRadius + (caretSize);
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					} else if (xAlign === &#x27;right&#x27;) {
						x2 = ptX + width - cornerRadius - caretSize;
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					} else {
						x2 = vm.caretX;
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					}
					if (yAlign === &#x27;top&#x27;) {
						y1 = ptY;
						y2 = y1 - caretSize;
						y3 = y1;
					} else {
						y1 = ptY + height;
						y2 = y1 + caretSize;
						y3 = y1;
						// invert drawing order
						var tmp = x3;
						x3 = x1;
						x1 = tmp;
					}
				}
				return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
			},
			drawTitle: function(pt, vm, ctx, opacity) {
				var title = vm.title;

				if (title.length) {
					ctx.textAlign = vm._titleAlign;
					ctx.textBaseline = &#x27;top&#x27;;

					var titleFontSize = vm.titleFontSize;
					var titleSpacing = vm.titleSpacing;

					ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
					ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

					var i, len;
					for (i = 0, len = title.length; i &lt; len; ++i) {
						ctx.fillText(title[i], pt.x, pt.y);
						pt.y += titleFontSize + titleSpacing; // Line Height and spacing

						if (i + 1 === title.length) {
							pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
						}
					}
				}
			},
			drawBody: function(pt, vm, ctx, opacity) {
				var bodyFontSize = vm.bodyFontSize;
				var bodySpacing = vm.bodySpacing;
				var body = vm.body;

				ctx.textAlign = vm._bodyAlign;
				ctx.textBaseline = &#x27;top&#x27;;
				ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

				// Before Body
				var xLinePadding = 0;
				var fillLineOfText = function(line) {
					ctx.fillText(line, pt.x + xLinePadding, pt.y);
					pt.y += bodyFontSize + bodySpacing;
				};

				// Before body lines
				ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
				helpers.each(vm.beforeBody, fillLineOfText);

				var drawColorBoxes = vm.displayColors;
				xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;

				// Draw body lines now
				helpers.each(body, function(bodyItem, i) {
					var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
					ctx.fillStyle = textColor;
					helpers.each(bodyItem.before, fillLineOfText);

					helpers.each(bodyItem.lines, function(line) {
						// Draw Legend-like boxes if needed
						if (drawColorBoxes) {
							// Fill a white rect so that colours merge nicely if the opacity is &lt; 1
							ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
							ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

							// Border
							ctx.lineWidth = 1;
							ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
							ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

							// Inner square
							ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
							ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
							ctx.fillStyle = textColor;
						}

						fillLineOfText(line);
					});

					helpers.each(bodyItem.after, fillLineOfText);
				});

				// Reset back to 0 for after body
				xLinePadding = 0;

				// After body lines
				helpers.each(vm.afterBody, fillLineOfText);
				pt.y -= bodySpacing; // Remove last body spacing
			},
			drawFooter: function(pt, vm, ctx, opacity) {
				var footer = vm.footer;

				if (footer.length) {
					pt.y += vm.footerMarginTop;

					ctx.textAlign = vm._footerAlign;
					ctx.textBaseline = &#x27;top&#x27;;

					ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
					ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

					helpers.each(footer, function(line) {
						ctx.fillText(line, pt.x, pt.y);
						pt.y += vm.footerFontSize + vm.footerSpacing;
					});
				}
			},
			drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
				ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
				ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
				ctx.lineWidth = vm.borderWidth;
				var xAlign = vm.xAlign;
				var yAlign = vm.yAlign;
				var x = pt.x;
				var y = pt.y;
				var width = tooltipSize.width;
				var height = tooltipSize.height;
				var radius = vm.cornerRadius;

				ctx.beginPath();
				ctx.moveTo(x + radius, y);
				if (yAlign === &#x27;top&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width - radius, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
				if (yAlign === &#x27;center&#x27; &amp;&amp; xAlign === &#x27;right&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width, y + height - radius);
				ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
				if (yAlign === &#x27;bottom&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + radius, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
				if (yAlign === &#x27;center&#x27; &amp;&amp; xAlign === &#x27;left&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x, y + radius);
				ctx.quadraticCurveTo(x, y, x + radius, y);
				ctx.closePath();

				ctx.fill();

				if (vm.borderWidth &gt; 0) {
					ctx.stroke();
				}
			},
			draw: function() {
				var ctx = this._chart.ctx;
				var vm = this._view;

				if (vm.opacity === 0) {
					return;
				}

				var tooltipSize = {
					width: vm.width,
					height: vm.height
				};
				var pt = {
					x: vm.x,
					y: vm.y
				};

				// IE11/Edge does not like very small opacities, so snap to 0
				var opacity = Math.abs(vm.opacity &lt; 1e-3) ? 0 : vm.opacity;

				// Truthy/falsey value for empty tooltip
				var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

				if (this._options.enabled &amp;&amp; hasTooltipContent) {
					// Draw Background
					this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

					// Draw Title, Body, and Footer
					pt.x += vm.xPadding;
					pt.y += vm.yPadding;

					// Titles
					this.drawTitle(pt, vm, ctx, opacity);

					// Body
					this.drawBody(pt, vm, ctx, opacity);

					// Footer
					this.drawFooter(pt, vm, ctx, opacity);
				}
			},

			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @returns {Boolean} true if the tooltip changed
			 */
			handleEvent: function(e) {
				var me = this;
				var options = me._options;
				var changed = false;

				me._lastActive = me._lastActive || [];

				// Find Active Elements for tooltips
				if (e.type === &#x27;mouseout&#x27;) {
					me._active = [];
				} else {
					me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
				}

				// Remember Last Actives
				changed = !helpers.arrayEquals(me._active, me._lastActive);

				// Only handle target event on tooltip change
				if (changed) {
					me._lastActive = me._active;

					if (options.enabled || options.custom) {
						me._eventPosition = {
							x: e.x,
							y: e.y
						};

						me.update(true);
						me.pivot();
					}
				}

				return changed;
			}
		});

		/**
		 * @namespace Chart.Tooltip.positioners
		 */
		Chart.Tooltip.positioners = {
			/**
			 * Average mode places the tooltip at the average position of the elements shown
			 * @function Chart.Tooltip.positioners.average
			 * @param elements {ChartElement[]} the elements being displayed in the tooltip
			 * @returns {Point} tooltip position
			 */
			average: function(elements) {
				if (!elements.length) {
					return false;
				}

				var i, len;
				var x = 0;
				var y = 0;
				var count = 0;

				for (i = 0, len = elements.length; i &lt; len; ++i) {
					var el = elements[i];
					if (el &amp;&amp; el.hasValue()) {
						var pos = el.tooltipPosition();
						x += pos.x;
						y += pos.y;
						++count;
					}
				}

				return {
					x: Math.round(x / count),
					y: Math.round(y / count)
				};
			},

			/**
			 * Gets the tooltip position nearest of the item nearest to the event position
			 * @function Chart.Tooltip.positioners.nearest
			 * @param elements {Chart.Element[]} the tooltip elements
			 * @param eventPosition {Point} the position of the event in canvas coordinates
			 * @returns {Point} the tooltip position
			 */
			nearest: function(elements, eventPosition) {
				var x = eventPosition.x;
				var y = eventPosition.y;
				var minDistance = Number.POSITIVE_INFINITY;
				var i, len, nearestElement;

				for (i = 0, len = elements.length; i &lt; len; ++i) {
					var el = elements[i];
					if (el &amp;&amp; el.hasValue()) {
						var center = el.getCenterPoint();
						var d = helpers.distanceBetweenPoints(eventPosition, center);

						if (d &lt; minDistance) {
							minDistance = d;
							nearestElement = el;
						}
					}
				}

				if (nearestElement) {
					var tp = nearestElement.tooltipPosition();
					x = tp.x;
					y = tp.y;
				}

				return {
					x: x,
					y: y
				};
			}
		};
	};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);

	/**
	 * Generate a set of linear ticks
	 * @param generationOptions the options used to generate the ticks
	 * @param dataRange the range of the data
	 * @returns {Array&lt;Number&gt;} array of tick values
	 */
	function generateTicks(generationOptions, dataRange) {
		var ticks = [];
		// To get a &quot;nice&quot; value for the tick spacing, we will use the appropriately named
		// &quot;nice number&quot; algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
		// for details.

		var spacing;
		if (generationOptions.stepSize &amp;&amp; generationOptions.stepSize &gt; 0) {
			spacing = generationOptions.stepSize;
		} else {
			var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
			spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
		}
		var niceMin = Math.floor(dataRange.min / spacing) * spacing;
		var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

		// If min, max and stepSize is set and they make an evenly spaced scale use it.
		if (generationOptions.min &amp;&amp; generationOptions.max &amp;&amp; generationOptions.stepSize) {
			// If very close to our whole number, use it.
			if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
				niceMin = generationOptions.min;
				niceMax = generationOptions.max;
			}
		}

		var numSpaces = (niceMax - niceMin) / spacing;
		// If very close to our rounded value, use it.
		if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
			numSpaces = Math.round(numSpaces);
		} else {
			numSpaces = Math.ceil(numSpaces);
		}

		var precision = 1;
		if (spacing &lt; 1) {
			precision = Math.pow(10, spacing.toString().length - 2);
			niceMin = Math.round(niceMin * precision) / precision;
			niceMax = Math.round(niceMax * precision) / precision;
		}
		ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
		for (var j = 1; j &lt; numSpaces; ++j) {
			ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);
		}
		ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

		return ticks;
	}


	module.exports = function(Chart) {

		var noop = helpers.noop;

		Chart.LinearScaleBase = Chart.Scale.extend({
			getRightValue: function(value) {
				if (typeof value === &#x27;string&#x27;) {
					return +value;
				}
				return Chart.Scale.prototype.getRightValue.call(this, value);
			},

			handleTickRangeOptions: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;

				// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
				// do nothing since that would make the chart weird. If the user really wants a weird chart
				// axis, they can manually override it
				if (tickOpts.beginAtZero) {
					var minSign = helpers.sign(me.min);
					var maxSign = helpers.sign(me.max);

					if (minSign &lt; 0 &amp;&amp; maxSign &lt; 0) {
						// move the top up to 0
						me.max = 0;
					} else if (minSign &gt; 0 &amp;&amp; maxSign &gt; 0) {
						// move the bottom down to 0
						me.min = 0;
					}
				}

				var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
				var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

				if (tickOpts.min !== undefined) {
					me.min = tickOpts.min;
				} else if (tickOpts.suggestedMin !== undefined) {
					if (me.min === null) {
						me.min = tickOpts.suggestedMin;
					} else {
						me.min = Math.min(me.min, tickOpts.suggestedMin);
					}
				}

				if (tickOpts.max !== undefined) {
					me.max = tickOpts.max;
				} else if (tickOpts.suggestedMax !== undefined) {
					if (me.max === null) {
						me.max = tickOpts.suggestedMax;
					} else {
						me.max = Math.max(me.max, tickOpts.suggestedMax);
					}
				}

				if (setMin !== setMax) {
					// We set the min or the max but not both.
					// So ensure that our range is good
					// Inverted or 0 length range can happen when
					// ticks.min is set, and no datasets are visible
					if (me.min &gt;= me.max) {
						if (setMin) {
							me.max = me.min + 1;
						} else {
							me.min = me.max - 1;
						}
					}
				}

				if (me.min === me.max) {
					me.max++;

					if (!tickOpts.beginAtZero) {
						me.min--;
					}
				}
			},
			getTickLimit: noop,
			handleDirectionalChanges: noop,

			buildTicks: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;

				// Figure out what the max number of ticks we can support it is based on the size of
				// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
				// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
				// the graph. Make sure we always have at least 2 ticks
				var maxTicks = me.getTickLimit();
				maxTicks = Math.max(2, maxTicks);

				var numericGeneratorOptions = {
					maxTicks: maxTicks,
					min: tickOpts.min,
					max: tickOpts.max,
					stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
				};
				var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);

				me.handleDirectionalChanges();

				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max = helpers.max(ticks);
				me.min = helpers.min(ticks);

				if (tickOpts.reverse) {
					ticks.reverse();

					me.start = me.max;
					me.end = me.min;
				} else {
					me.start = me.min;
					me.end = me.max;
				}
			},
			convertTicksToLabels: function() {
				var me = this;
				me.ticksAsNumbers = me.ticks.slice();
				me.zeroLineIndex = me.ticks.indexOf(0);

				Chart.Scale.prototype.convertTicksToLabels.call(me);
			}
		});
	};


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {

		// Default config for a category scale
		var defaultConfig = {
			position: &#x27;bottom&#x27;
		};

		var DatasetScale = Chart.Scale.extend({
			/**
			* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
			* else fall back to data.labels
			* @private
			*/
			getLabels: function() {
				var data = this.chart.data;
				return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
			},

			determineDataLimits: function() {
				var me = this;
				var labels = me.getLabels();
				me.minIndex = 0;
				me.maxIndex = labels.length - 1;
				var findIndex;

				if (me.options.ticks.min !== undefined) {
					// user specified min value
					findIndex = labels.indexOf(me.options.ticks.min);
					me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
				}

				if (me.options.ticks.max !== undefined) {
					// user specified max value
					findIndex = labels.indexOf(me.options.ticks.max);
					me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
				}

				me.min = labels[me.minIndex];
				me.max = labels[me.maxIndex];
			},

			buildTicks: function() {
				var me = this;
				var labels = me.getLabels();
				// If we are viewing some subset of labels, slice the original array
				me.ticks = (me.minIndex === 0 &amp;&amp; me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
			},

			getLabelForIndex: function(index, datasetIndex) {
				var me = this;
				var data = me.chart.data;
				var isHorizontal = me.isHorizontal();

				if (data.yLabels &amp;&amp; !isHorizontal) {
					return me.getRightValue(data.datasets[datasetIndex].data[index]);
				}
				return me.ticks[index - me.minIndex];
			},

			// Used to get data value locations.  Value can either be an index or a numerical value
			getPixelForValue: function(value, index) {
				var me = this;
				var offset = me.options.offset;
				// 1 is added because we need the length but we have the indexes
				var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);

				// If value is a data object, then index is the index in the data array,
				// not the index of the scale. We need to change that.
				var valueCategory;
				if (value !== undefined &amp;&amp; value !== null) {
					valueCategory = me.isHorizontal() ? value.x : value.y;
				}
				if (valueCategory !== undefined || (value !== undefined &amp;&amp; isNaN(index))) {
					var labels = me.getLabels();
					value = valueCategory || value;
					var idx = labels.indexOf(value);
					index = idx !== -1 ? idx : index;
				}

				if (me.isHorizontal()) {
					var valueWidth = me.width / offsetAmt;
					var widthOffset = (valueWidth * (index - me.minIndex));

					if (offset) {
						widthOffset += (valueWidth / 2);
					}

					return me.left + Math.round(widthOffset);
				}
				var valueHeight = me.height / offsetAmt;
				var heightOffset = (valueHeight * (index - me.minIndex));

				if (offset) {
					heightOffset += (valueHeight / 2);
				}

				return me.top + Math.round(heightOffset);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var offset = me.options.offset;
				var value;
				var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
				var horz = me.isHorizontal();
				var valueDimension = (horz ? me.width : me.height) / offsetAmt;

				pixel -= horz ? me.left : me.top;

				if (offset) {
					pixel -= (valueDimension / 2);
				}

				if (pixel &lt;= 0) {
					value = 0;
				} else {
					value = Math.round(pixel / valueDimension);
				}

				return value + me.minIndex;
			},
			getBasePixel: function() {
				return this.bottom;
			}
		});

		Chart.scaleService.registerScaleType(&#x27;category&#x27;, DatasetScale, defaultConfig);

	};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var helpers = __webpack_require__(36);
	var Ticks = __webpack_require__(59);

	module.exports = function(Chart) {

		var defaultConfig = {
			position: &#x27;left&#x27;,
			ticks: {
				callback: Ticks.formatters.linear
			}
		};

		var LinearScale = Chart.LinearScaleBase.extend({

			determineDataLimits: function() {
				var me = this;
				var opts = me.options;
				var chart = me.chart;
				var data = chart.data;
				var datasets = data.datasets;
				var isHorizontal = me.isHorizontal();
				var DEFAULT_MIN = 0;
				var DEFAULT_MAX = 1;

				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
				}

				// First Calculate the range
				me.min = null;
				me.max = null;

				var hasStacks = opts.stacked;
				if (hasStacks === undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}

						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta) &amp;&amp;
							meta.stack !== undefined) {
							hasStacks = true;
						}
					});
				}

				if (opts.stacked || hasStacks) {
					var valuesPerStack = {};

					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var key = [
							meta.type,
							// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
							((opts.stacked === undefined &amp;&amp; meta.stack === undefined) ? datasetIndex : &#x27;&#x27;),
							meta.stack
						].join(&#x27;.&#x27;);

						if (valuesPerStack[key] === undefined) {
							valuesPerStack[key] = {
								positiveValues: [],
								negativeValues: []
							};
						}

						// Store these per type
						var positiveValues = valuesPerStack[key].positiveValues;
						var negativeValues = valuesPerStack[key].negativeValues;

						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								positiveValues[index] = positiveValues[index] || 0;
								negativeValues[index] = negativeValues[index] || 0;

								if (opts.relativePoints) {
									positiveValues[index] = 100;
								} else if (value &lt; 0) {
									negativeValues[index] += value;
								} else {
									positiveValues[index] += value;
								}
							});
						}
					});

					helpers.each(valuesPerStack, function(valuesForType) {
						var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
						var minVal = helpers.min(values);
						var maxVal = helpers.max(values);
						me.min = me.min === null ? minVal : Math.min(me.min, minVal);
						me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
					});

				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								if (me.min === null) {
									me.min = value;
								} else if (value &lt; me.min) {
									me.min = value;
								}

								if (me.max === null) {
									me.max = value;
								} else if (value &gt; me.max) {
									me.max = value;
								}
							});
						}
					});
				}

				me.min = isFinite(me.min) &amp;&amp; !isNaN(me.min) ? me.min : DEFAULT_MIN;
				me.max = isFinite(me.max) &amp;&amp; !isNaN(me.max) ? me.max : DEFAULT_MAX;

				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				this.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var maxTicks;
				var me = this;
				var tickOpts = me.options.ticks;

				if (me.isHorizontal()) {
					maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
				} else {
					// The factor of 2 used to scale the font size has been experimentally determined.
					var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
					maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
				}

				return maxTicks;
			},
			// Called after the ticks are built. We need
			handleDirectionalChanges: function() {
				if (!this.isHorizontal()) {
					// We are in a vertical orientation. The top value is the highest. So reverse the array
					this.ticks.reverse();
				}
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			// Utils
			getPixelForValue: function(value) {
				// This must be called after fit has been run so that
				// this.left, this.top, this.right, and this.bottom have been defined
				var me = this;
				var start = me.start;

				var rightValue = +me.getRightValue(value);
				var pixel;
				var range = me.end - start;

				if (me.isHorizontal()) {
					pixel = me.left + (me.width / range * (rightValue - start));
				} else {
					pixel = me.bottom - (me.height / range * (rightValue - start));
				}
				return pixel;
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var isHorizontal = me.isHorizontal();
				var innerDimension = isHorizontal ? me.width : me.height;
				var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
				return me.start + ((me.end - me.start) * offset);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.ticksAsNumbers[index]);
			}
		});
		Chart.scaleService.registerScaleType(&#x27;linear&#x27;, LinearScale, defaultConfig);

	};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers = __webpack_require__(36);
	var Ticks = __webpack_require__(59);

	/**
	 * Generate a set of logarithmic ticks
	 * @param generationOptions the options used to generate the ticks
	 * @param dataRange the range of the data
	 * @returns {Array&lt;Number&gt;} array of tick values
	 */
	function generateTicks(generationOptions, dataRange) {
		var ticks = [];
		var valueOrDefault = helpers.valueOrDefault;

		// Figure out what the max number of ticks we can support it is based on the size of
		// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
		// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
		// the graph
		var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

		var endExp = Math.floor(helpers.log10(dataRange.max));
		var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
		var exp, significand;

		if (tickVal === 0) {
			exp = Math.floor(helpers.log10(dataRange.minNotZero));
			significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

			ticks.push(tickVal);
			tickVal = significand * Math.pow(10, exp);
		} else {
			exp = Math.floor(helpers.log10(tickVal));
			significand = Math.floor(tickVal / Math.pow(10, exp));
		}
		var precision = exp &lt; 0 ? Math.pow(10, Math.abs(exp)) : 1;

		do {
			ticks.push(tickVal);

			++significand;
			if (significand === 10) {
				significand = 1;
				++exp;
				precision = exp &gt;= 0 ? 1 : precision;
			}

			tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
		} while (exp &lt; endExp || (exp === endExp &amp;&amp; significand &lt; endSignificand));

		var lastTick = valueOrDefault(generationOptions.max, tickVal);
		ticks.push(lastTick);

		return ticks;
	}


	module.exports = function(Chart) {

		var defaultConfig = {
			position: &#x27;left&#x27;,

			// label settings
			ticks: {
				callback: Ticks.formatters.logarithmic
			}
		};

		var LogarithmicScale = Chart.Scale.extend({
			determineDataLimits: function() {
				var me = this;
				var opts = me.options;
				var chart = me.chart;
				var data = chart.data;
				var datasets = data.datasets;
				var isHorizontal = me.isHorizontal();
				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
				}

				// Calculate Range
				me.min = null;
				me.max = null;
				me.minNotZero = null;

				var hasStacks = opts.stacked;
				if (hasStacks === undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}

						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta) &amp;&amp;
							meta.stack !== undefined) {
							hasStacks = true;
						}
					});
				}

				if (opts.stacked || hasStacks) {
					var valuesPerStack = {};

					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var key = [
							meta.type,
							// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
							((opts.stacked === undefined &amp;&amp; meta.stack === undefined) ? datasetIndex : &#x27;&#x27;),
							meta.stack
						].join(&#x27;.&#x27;);

						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							if (valuesPerStack[key] === undefined) {
								valuesPerStack[key] = [];
							}

							helpers.each(dataset.data, function(rawValue, index) {
								var values = valuesPerStack[key];
								var value = +me.getRightValue(rawValue);
								// invalid, hidden and negative values are ignored
								if (isNaN(value) || meta.data[index].hidden || value &lt; 0) {
									return;
								}
								values[index] = values[index] || 0;
								values[index] += value;
							});
						}
					});

					helpers.each(valuesPerStack, function(valuesForType) {
						if (valuesForType.length &gt; 0) {
							var minVal = helpers.min(valuesForType);
							var maxVal = helpers.max(valuesForType);
							me.min = me.min === null ? minVal : Math.min(me.min, minVal);
							me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
						}
					});

				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								// invalid, hidden and negative values are ignored
								if (isNaN(value) || meta.data[index].hidden || value &lt; 0) {
									return;
								}

								if (me.min === null) {
									me.min = value;
								} else if (value &lt; me.min) {
									me.min = value;
								}

								if (me.max === null) {
									me.max = value;
								} else if (value &gt; me.max) {
									me.max = value;
								}

								if (value !== 0 &amp;&amp; (me.minNotZero === null || value &lt; me.minNotZero)) {
									me.minNotZero = value;
								}
							});
						}
					});
				}

				// Common base implementation to handle ticks.min, ticks.max
				this.handleTickRangeOptions();
			},
			handleTickRangeOptions: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
				var valueOrDefault = helpers.valueOrDefault;
				var DEFAULT_MIN = 1;
				var DEFAULT_MAX = 10;

				me.min = valueOrDefault(tickOpts.min, me.min);
				me.max = valueOrDefault(tickOpts.max, me.max);

				if (me.min === me.max) {
					if (me.min !== 0 &amp;&amp; me.min !== null) {
						me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
						me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
					} else {
						me.min = DEFAULT_MIN;
						me.max = DEFAULT_MAX;
					}
				}
				if (me.min === null) {
					me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);
				}
				if (me.max === null) {
					me.max = me.min !== 0
						? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)
						: DEFAULT_MAX;
				}
				if (me.minNotZero === null) {
					if (me.min &gt; 0) {
						me.minNotZero = me.min;
					} else if (me.max &lt; 1) {
						me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));
					} else {
						me.minNotZero = DEFAULT_MIN;
					}
				}
			},
			buildTicks: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
				var reverse = !me.isHorizontal();

				var generationOptions = {
					min: tickOpts.min,
					max: tickOpts.max
				};
				var ticks = me.ticks = generateTicks(generationOptions, me);

				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max = helpers.max(ticks);
				me.min = helpers.min(ticks);

				if (tickOpts.reverse) {
					reverse = !reverse;
					me.start = me.max;
					me.end = me.min;
				} else {
					me.start = me.min;
					me.end = me.max;
				}
				if (reverse) {
					ticks.reverse();
				}
			},
			convertTicksToLabels: function() {
				this.tickValues = this.ticks.slice();

				Chart.Scale.prototype.convertTicksToLabels.call(this);
			},
			// Get the correct tooltip label
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.tickValues[index]);
			},
			/**
			 * Returns the value of the first tick.
			 * @param {Number} value - The minimum not zero value.
			 * @return {Number} The first tick value.
			 * @private
			 */
			_getFirstTickValue: function(value) {
				var exp = Math.floor(helpers.log10(value));
				var significand = Math.floor(value / Math.pow(10, exp));

				return significand * Math.pow(10, exp);
			},
			getPixelForValue: function(value) {
				var me = this;
				var reverse = me.options.ticks.reverse;
				var log10 = helpers.log10;
				var firstTickValue = me._getFirstTickValue(me.minNotZero);
				var offset = 0;
				var innerDimension, pixel, start, end, sign;

				value = +me.getRightValue(value);
				if (reverse) {
					start = me.end;
					end = me.start;
					sign = -1;
				} else {
					start = me.start;
					end = me.end;
					sign = 1;
				}
				if (me.isHorizontal()) {
					innerDimension = me.width;
					pixel = reverse ? me.right : me.left;
				} else {
					innerDimension = me.height;
					sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
					pixel = reverse ? me.top : me.bottom;
				}
				if (value !== start) {
					if (start === 0) { // include zero tick
						offset = helpers.getValueOrDefault(
							me.options.ticks.fontSize,
							Chart.defaults.global.defaultFontSize
						);
						innerDimension -= offset;
						start = firstTickValue;
					}
					if (value !== 0) {
						offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
					}
					pixel += sign * offset;
				}
				return pixel;
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var reverse = me.options.ticks.reverse;
				var log10 = helpers.log10;
				var firstTickValue = me._getFirstTickValue(me.minNotZero);
				var innerDimension, start, end, value;

				if (reverse) {
					start = me.end;
					end = me.start;
				} else {
					start = me.start;
					end = me.end;
				}
				if (me.isHorizontal()) {
					innerDimension = me.width;
					value = reverse ? me.right - pixel : pixel - me.left;
				} else {
					innerDimension = me.height;
					value = reverse ? pixel - me.top : me.bottom - pixel;
				}
				if (value !== start) {
					if (start === 0) { // include zero tick
						var offset = helpers.getValueOrDefault(
							me.options.ticks.fontSize,
							Chart.defaults.global.defaultFontSize
						);
						value -= offset;
						innerDimension -= offset;
						start = firstTickValue;
					}
					value *= log10(end) - log10(start);
					value /= innerDimension;
					value = Math.pow(10, log10(start) + value);
				}
				return value;
			}
		});
		Chart.scaleService.registerScaleType(&#x27;logarithmic&#x27;, LogarithmicScale, defaultConfig);

	};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var helpers = __webpack_require__(36);
	var Ticks = __webpack_require__(59);

	module.exports = function(Chart) {

		var globalDefaults = defaults.global;

		var defaultConfig = {
			display: true,

			// Boolean - Whether to animate scaling the chart from the centre
			animate: true,
			position: &#x27;chartArea&#x27;,

			angleLines: {
				display: true,
				color: &#x27;rgba(0, 0, 0, 0.1)&#x27;,
				lineWidth: 1
			},

			gridLines: {
				circular: false
			},

			// label settings
			ticks: {
				// Boolean - Show a backdrop to the scale label
				showLabelBackdrop: true,

				// String - The colour of the label backdrop
				backdropColor: &#x27;rgba(255,255,255,0.75)&#x27;,

				// Number - The backdrop padding above &amp; below the label in pixels
				backdropPaddingY: 2,

				// Number - The backdrop padding to the side of the label in pixels
				backdropPaddingX: 2,

				callback: Ticks.formatters.linear
			},

			pointLabels: {
				// Boolean - if true, show point labels
				display: true,

				// Number - Point label font size in pixels
				fontSize: 10,

				// Function - Used to convert point labels
				callback: function(label) {
					return label;
				}
			}
		};

		function getValueCount(scale) {
			var opts = scale.options;
			return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
		}

		function getPointLabelFontOptions(scale) {
			var pointLabelOptions = scale.options.pointLabels;
			var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
			var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
			var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
			var font = helpers.fontString(fontSize, fontStyle, fontFamily);

			return {
				size: fontSize,
				style: fontStyle,
				family: fontFamily,
				font: font
			};
		}

		function measureLabelSize(ctx, fontSize, label) {
			if (helpers.isArray(label)) {
				return {
					w: helpers.longestText(ctx, ctx.font, label),
					h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
				};
			}

			return {
				w: ctx.measureText(label).width,
				h: fontSize
			};
		}

		function determineLimits(angle, pos, size, min, max) {
			if (angle === min || angle === max) {
				return {
					start: pos - (size / 2),
					end: pos + (size / 2)
				};
			} else if (angle &lt; min || angle &gt; max) {
				return {
					start: pos - size - 5,
					end: pos
				};
			}

			return {
				start: pos,
				end: pos + size + 5
			};
		}

		/**
		 * Helper function to fit a radial linear scale with point labels
		 */
		function fitWithPointLabels(scale) {
			/*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
			 *
			 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
			 */

			var plFont = getPointLabelFontOptions(scale);

			// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
			// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
			var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
			var furthestLimits = {
				r: scale.width,
				l: 0,
				t: scale.height,
				b: 0
			};
			var furthestAngles = {};
			var i, textSize, pointPosition;

			scale.ctx.font = plFont.font;
			scale._pointLabelSizes = [];

			var valueCount = getValueCount(scale);
			for (i = 0; i &lt; valueCount; i++) {
				pointPosition = scale.getPointPosition(i, largestPossibleRadius);
				textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || &#x27;&#x27;);
				scale._pointLabelSizes[i] = textSize;

				// Add quarter circle to make degree 0 mean top of circle
				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians) % 360;
				var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
				var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

				if (hLimits.start &lt; furthestLimits.l) {
					furthestLimits.l = hLimits.start;
					furthestAngles.l = angleRadians;
				}

				if (hLimits.end &gt; furthestLimits.r) {
					furthestLimits.r = hLimits.end;
					furthestAngles.r = angleRadians;
				}

				if (vLimits.start &lt; furthestLimits.t) {
					furthestLimits.t = vLimits.start;
					furthestAngles.t = angleRadians;
				}

				if (vLimits.end &gt; furthestLimits.b) {
					furthestLimits.b = vLimits.end;
					furthestAngles.b = angleRadians;
				}
			}

			scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
		}

		/**
		 * Helper function to fit a radial linear scale with no point labels
		 */
		function fit(scale) {
			var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
			scale.drawingArea = Math.round(largestPossibleRadius);
			scale.setCenterPoint(0, 0, 0, 0);
		}

		function getTextAlignForAngle(angle) {
			if (angle === 0 || angle === 180) {
				return &#x27;center&#x27;;
			} else if (angle &lt; 180) {
				return &#x27;left&#x27;;
			}

			return &#x27;right&#x27;;
		}

		function fillText(ctx, text, position, fontSize) {
			if (helpers.isArray(text)) {
				var y = position.y;
				var spacing = 1.5 * fontSize;

				for (var i = 0; i &lt; text.length; ++i) {
					ctx.fillText(text[i], position.x, y);
					y += spacing;
				}
			} else {
				ctx.fillText(text, position.x, position.y);
			}
		}

		function adjustPointPositionForLabelHeight(angle, textSize, position) {
			if (angle === 90 || angle === 270) {
				position.y -= (textSize.h / 2);
			} else if (angle &gt; 270 || angle &lt; 90) {
				position.y -= textSize.h;
			}
		}

		function drawPointLabels(scale) {
			var ctx = scale.ctx;
			var opts = scale.options;
			var angleLineOpts = opts.angleLines;
			var pointLabelOpts = opts.pointLabels;

			ctx.lineWidth = angleLineOpts.lineWidth;
			ctx.strokeStyle = angleLineOpts.color;

			var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

			// Point Label Font
			var plFont = getPointLabelFontOptions(scale);

			ctx.textBaseline = &#x27;top&#x27;;

			for (var i = getValueCount(scale) - 1; i &gt;= 0; i--) {
				if (angleLineOpts.display) {
					var outerPosition = scale.getPointPosition(i, outerDistance);
					ctx.beginPath();
					ctx.moveTo(scale.xCenter, scale.yCenter);
					ctx.lineTo(outerPosition.x, outerPosition.y);
					ctx.stroke();
					ctx.closePath();
				}

				if (pointLabelOpts.display) {
					// Extra 3px out for some label spacing
					var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

					// Keep this in loop since we may support array properties here
					var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
					ctx.font = plFont.font;
					ctx.fillStyle = pointLabelFontColor;

					var angleRadians = scale.getIndexAngle(i);
					var angle = helpers.toDegrees(angleRadians);
					ctx.textAlign = getTextAlignForAngle(angle);
					adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
					fillText(ctx, scale.pointLabels[i] || &#x27;&#x27;, pointLabelPosition, plFont.size);
				}
			}
		}

		function drawRadiusLine(scale, gridLineOpts, radius, index) {
			var ctx = scale.ctx;
			ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
			ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

			if (scale.options.gridLines.circular) {
				// Draw circular arcs between the points
				ctx.beginPath();
				ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.stroke();
			} else {
				// Draw straight lines connecting each index
				var valueCount = getValueCount(scale);

				if (valueCount === 0) {
					return;
				}

				ctx.beginPath();
				var pointPosition = scale.getPointPosition(0, radius);
				ctx.moveTo(pointPosition.x, pointPosition.y);

				for (var i = 1; i &lt; valueCount; i++) {
					pointPosition = scale.getPointPosition(i, radius);
					ctx.lineTo(pointPosition.x, pointPosition.y);
				}

				ctx.closePath();
				ctx.stroke();
			}
		}

		function numberOrZero(param) {
			return helpers.isNumber(param) ? param : 0;
		}

		var LinearRadialScale = Chart.LinearScaleBase.extend({
			setDimensions: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
				// Set the unconstrained dimension before label rotation
				me.width = me.maxWidth;
				me.height = me.maxHeight;
				me.xCenter = Math.round(me.width / 2);
				me.yCenter = Math.round(me.height / 2);

				var minSize = helpers.min([me.height, me.width]);
				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
			},
			determineDataLimits: function() {
				var me = this;
				var chart = me.chart;
				var min = Number.POSITIVE_INFINITY;
				var max = Number.NEGATIVE_INFINITY;

				helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
					if (chart.isDatasetVisible(datasetIndex)) {
						var meta = chart.getDatasetMeta(datasetIndex);

						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							min = Math.min(value, min);
							max = Math.max(value, max);
						});
					}
				});

				me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
				me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);

				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				me.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var tickOpts = this.options.ticks;
				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
			},
			convertTicksToLabels: function() {
				var me = this;

				Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

				// Point labels
				me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			fit: function() {
				if (this.options.pointLabels.display) {
					fitWithPointLabels(this);
				} else {
					fit(this);
				}
			},
			/**
			 * Set radius reductions and determine new radius and center point
			 * @private
			 */
			setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
				var me = this;
				var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
				var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
				var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
				var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

				radiusReductionLeft = numberOrZero(radiusReductionLeft);
				radiusReductionRight = numberOrZero(radiusReductionRight);
				radiusReductionTop = numberOrZero(radiusReductionTop);
				radiusReductionBottom = numberOrZero(radiusReductionBottom);

				me.drawingArea = Math.min(
					Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
					Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
				me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
			},
			setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
				var me = this;
				var maxRight = me.width - rightMovement - me.drawingArea;
				var maxLeft = leftMovement + me.drawingArea;
				var maxTop = topMovement + me.drawingArea;
				var maxBottom = me.height - bottomMovement - me.drawingArea;

				me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
				me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
			},

			getIndexAngle: function(index) {
				var angleMultiplier = (Math.PI * 2) / getValueCount(this);
				var startAngle = this.chart.options &amp;&amp; this.chart.options.startAngle ?
					this.chart.options.startAngle :
					0;

				var startAngleRadians = startAngle * Math.PI * 2 / 360;

				// Start from the top instead of right, so remove a quarter of the circle
				return index * angleMultiplier + startAngleRadians;
			},
			getDistanceFromCenterForValue: function(value) {
				var me = this;

				if (value === null) {
					return 0; // null always in center
				}

				// Take into account half font size + the yPadding of the top value
				var scalingFactor = me.drawingArea / (me.max - me.min);
				if (me.options.ticks.reverse) {
					return (me.max - value) * scalingFactor;
				}
				return (value - me.min) * scalingFactor;
			},
			getPointPosition: function(index, distanceFromCenter) {
				var me = this;
				var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
				return {
					x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
					y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
				};
			},
			getPointPositionForValue: function(index, value) {
				return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
			},

			getBasePosition: function() {
				var me = this;
				var min = me.min;
				var max = me.max;

				return me.getPointPositionForValue(0,
					me.beginAtZero ? 0 :
					min &lt; 0 &amp;&amp; max &lt; 0 ? max :
					min &gt; 0 &amp;&amp; max &gt; 0 ? min :
					0);
			},

			draw: function() {
				var me = this;
				var opts = me.options;
				var gridLineOpts = opts.gridLines;
				var tickOpts = opts.ticks;
				var valueOrDefault = helpers.valueOrDefault;

				if (opts.display) {
					var ctx = me.ctx;
					var startAngle = this.getIndexAngle(0);

					// Tick Font
					var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
					var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
					var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
					var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

					helpers.each(me.ticks, function(label, index) {
						// Don&#x27;t draw a centre value (if it is minimum)
						if (index &gt; 0 || tickOpts.reverse) {
							var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

							// Draw circular lines around the scale
							if (gridLineOpts.display &amp;&amp; index !== 0) {
								drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
							}

							if (tickOpts.display) {
								var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
								ctx.font = tickLabelFont;

								ctx.save();
								ctx.translate(me.xCenter, me.yCenter);
								ctx.rotate(startAngle);

								if (tickOpts.showLabelBackdrop) {
									var labelWidth = ctx.measureText(label).width;
									ctx.fillStyle = tickOpts.backdropColor;
									ctx.fillRect(
										-labelWidth / 2 - tickOpts.backdropPaddingX,
										-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
										labelWidth + tickOpts.backdropPaddingX * 2,
										tickFontSize + tickOpts.backdropPaddingY * 2
									);
								}

								ctx.textAlign = &#x27;center&#x27;;
								ctx.textBaseline = &#x27;middle&#x27;;
								ctx.fillStyle = tickFontColor;
								ctx.fillText(label, 0, -yCenterOffset);
								ctx.restore();
							}
						}
					});

					if (opts.angleLines.display || opts.pointLabels.display) {
						drawPointLabels(me);
					}
				}
			}
		});
		Chart.scaleService.registerScaleType(&#x27;radialLinear&#x27;, LinearRadialScale, defaultConfig);

	};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	&#x27;use strict&#x27;;

	var moment = __webpack_require__(72);
	moment = typeof moment === &#x27;function&#x27; ? moment : window.moment;

	var defaults = __webpack_require__(35);
	var helpers = __webpack_require__(36);

	// Integer constants are from the ES6 spec.
	var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
	var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

	var INTERVALS = {
		millisecond: {
			common: true,
			size: 1,
			steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
		},
		second: {
			common: true,
			size: 1000,
			steps: [1, 2, 5, 10, 30]
		},
		minute: {
			common: true,
			size: 60000,
			steps: [1, 2, 5, 10, 30]
		},
		hour: {
			common: true,
			size: 3600000,
			steps: [1, 2, 3, 6, 12]
		},
		day: {
			common: true,
			size: 86400000,
			steps: [1, 2, 5]
		},
		week: {
			common: false,
			size: 604800000,
			steps: [1, 2, 3, 4]
		},
		month: {
			common: true,
			size: 2.628e9,
			steps: [1, 2, 3]
		},
		quarter: {
			common: false,
			size: 7.884e9,
			steps: [1, 2, 3, 4]
		},
		year: {
			common: true,
			size: 3.154e10
		}
	};

	var UNITS = Object.keys(INTERVALS);

	function sorter(a, b) {
		return a - b;
	}

	function arrayUnique(items) {
		var hash = {};
		var out = [];
		var i, ilen, item;

		for (i = 0, ilen = items.length; i &lt; ilen; ++i) {
			item = items[i];
			if (!hash[item]) {
				hash[item] = true;
				out.push(item);
			}
		}

		return out;
	}

	/**
	 * Returns an array of {time, pos} objects used to interpolate a specific &#x60;time&#x60; or position
	 * (&#x60;pos&#x60;) on the scale, by searching entries before and after the requested value. &#x60;pos&#x60; is
	 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
	 * extremity (left + width or top + height). Note that it would be more optimized to directly
	 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
	 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
	 *
	 * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
	 * @param {String} distribution - If &#x27;linear&#x27;, timestamps will be spread linearly along the min
	 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
	 * If &#x27;series&#x27;, timestamps will be positioned at the same distance from each other. In this
	 * case, only timestamps that break the time linearity are registered, meaning that in the
	 * best case, all timestamps are linear, the table contains only min and max.
	 */
	function buildLookupTable(timestamps, min, max, distribution) {
		if (distribution === &#x27;linear&#x27; || !timestamps.length) {
			return [
				{time: min, pos: 0},
				{time: max, pos: 1}
			];
		}

		var table = [];
		var items = [min];
		var i, ilen, prev, curr, next;

		for (i = 0, ilen = timestamps.length; i &lt; ilen; ++i) {
			curr = timestamps[i];
			if (curr &gt; min &amp;&amp; curr &lt; max) {
				items.push(curr);
			}
		}

		items.push(max);

		for (i = 0, ilen = items.length; i &lt; ilen; ++i) {
			next = items[i + 1];
			prev = items[i - 1];
			curr = items[i];

			// only add points that breaks the scale linearity
			if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
				table.push({time: curr, pos: i / (ilen - 1)});
			}
		}

		return table;
	}

	// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
	function lookup(table, key, value) {
		var lo = 0;
		var hi = table.length - 1;
		var mid, i0, i1;

		while (lo &gt;= 0 &amp;&amp; lo &lt;= hi) {
			mid = (lo + hi) &gt;&gt; 1;
			i0 = table[mid - 1] || null;
			i1 = table[mid];

			if (!i0) {
				// given value is outside table (before first item)
				return {lo: null, hi: i1};
			} else if (i1[key] &lt; value) {
				lo = mid + 1;
			} else if (i0[key] &gt; value) {
				hi = mid - 1;
			} else {
				return {lo: i0, hi: i1};
			}
		}

		// given value is outside table (after last item)
		return {lo: i1, hi: null};
	}

	/**
	 * Linearly interpolates the given source &#x60;value&#x60; using the table items &#x60;skey&#x60; values and
	 * returns the associated &#x60;tkey&#x60; value. For example, interpolate(table, &#x27;time&#x27;, 42, &#x27;pos&#x27;)
	 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
	 * index [0, 1] or [n - 1, n] are used for the interpolation.
	 */
	function interpolate(table, skey, sval, tkey) {
		var range = lookup(table, skey, sval);

		// Note: the lookup table ALWAYS contains at least 2 items (min and max)
		var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
		var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

		var span = next[skey] - prev[skey];
		var ratio = span ? (sval - prev[skey]) / span : 0;
		var offset = (next[tkey] - prev[tkey]) * ratio;

		return prev[tkey] + offset;
	}

	/**
	 * Convert the given value to a moment object using the given time options.
	 * @see http://momentjs.com/docs/#/parsing/
	 */
	function momentify(value, options) {
		var parser = options.parser;
		var format = options.parser || options.format;

		if (typeof parser === &#x27;function&#x27;) {
			return parser(value);
		}

		if (typeof value === &#x27;string&#x27; &amp;&amp; typeof format === &#x27;string&#x27;) {
			return moment(value, format);
		}

		if (!(value instanceof moment)) {
			value = moment(value);
		}

		if (value.isValid()) {
			return value;
		}

		// Labels are in an incompatible moment format and no &#x60;parser&#x60; has been provided.
		// The user might still use the deprecated &#x60;format&#x60; option to convert his inputs.
		if (typeof format === &#x27;function&#x27;) {
			return format(value);
		}

		return value;
	}

	function parse(input, scale) {
		if (helpers.isNullOrUndef(input)) {
			return null;
		}

		var options = scale.options.time;
		var value = momentify(scale.getRightValue(input), options);
		if (!value.isValid()) {
			return null;
		}

		if (options.round) {
			value.startOf(options.round);
		}

		return value.valueOf();
	}

	/**
	 * Returns the number of unit to skip to be able to display up to &#x60;capacity&#x60; number of ticks
	 * in &#x60;unit&#x60; for the given &#x60;min&#x60; / &#x60;max&#x60; range and respecting the interval steps constraints.
	 */
	function determineStepSize(min, max, unit, capacity) {
		var range = max - min;
		var interval = INTERVALS[unit];
		var milliseconds = interval.size;
		var steps = interval.steps;
		var i, ilen, factor;

		if (!steps) {
			return Math.ceil(range / (capacity * milliseconds));
		}

		for (i = 0, ilen = steps.length; i &lt; ilen; ++i) {
			factor = steps[i];
			if (Math.ceil(range / (milliseconds * factor)) &lt;= capacity) {
				break;
			}
		}

		return factor;
	}

	/**
	 * Figures out what unit results in an appropriate number of auto-generated ticks
	 */
	function determineUnitForAutoTicks(minUnit, min, max, capacity) {
		var ilen = UNITS.length;
		var i, interval, factor;

		for (i = UNITS.indexOf(minUnit); i &lt; ilen - 1; ++i) {
			interval = INTERVALS[UNITS[i]];
			factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

			if (interval.common &amp;&amp; Math.ceil((max - min) / (factor * interval.size)) &lt;= capacity) {
				return UNITS[i];
			}
		}

		return UNITS[ilen - 1];
	}

	/**
	 * Figures out what unit to format a set of ticks with
	 */
	function determineUnitForFormatting(ticks, minUnit, min, max) {
		var duration = moment.duration(moment(max).diff(moment(min)));
		var ilen = UNITS.length;
		var i, unit;

		for (i = ilen - 1; i &gt;= UNITS.indexOf(minUnit); i--) {
			unit = UNITS[i];
			if (INTERVALS[unit].common &amp;&amp; duration.as(unit) &gt;= ticks.length) {
				return unit;
			}
		}

		return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
	}

	function determineMajorUnit(unit) {
		for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i &lt; ilen; ++i) {
			if (INTERVALS[UNITS[i]].common) {
				return UNITS[i];
			}
		}
	}

	/**
	 * Generates a maximum of &#x60;capacity&#x60; timestamps between min and max, rounded to the
	 * &#x60;minor&#x60; unit, aligned on the &#x60;major&#x60; unit and using the given scale time &#x60;options&#x60;.
	 * Important: this method can return ticks outside the min and max range, it&#x27;s the
	 * responsibility of the calling code to clamp values if needed.
	 */
	function generate(min, max, capacity, options) {
		var timeOpts = options.time;
		var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
		var major = determineMajorUnit(minor);
		var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
		var weekday = minor === &#x27;week&#x27; ? timeOpts.isoWeekday : false;
		var majorTicksEnabled = options.ticks.major.enabled;
		var interval = INTERVALS[minor];
		var first = moment(min);
		var last = moment(max);
		var ticks = [];
		var time;

		if (!stepSize) {
			stepSize = determineStepSize(min, max, minor, capacity);
		}

		// For &#x27;week&#x27; unit, handle the first day of week option
		if (weekday) {
			first = first.isoWeekday(weekday);
			last = last.isoWeekday(weekday);
		}

		// Align first/last ticks on unit
		first = first.startOf(weekday ? &#x27;day&#x27; : minor);
		last = last.startOf(weekday ? &#x27;day&#x27; : minor);

		// Make sure that the last tick include max
		if (last &lt; max) {
			last.add(1, minor);
		}

		time = moment(first);

		if (majorTicksEnabled &amp;&amp; major &amp;&amp; !weekday &amp;&amp; !timeOpts.round) {
			// Align the first tick on the previous &#x60;minor&#x60; unit aligned on the &#x60;major&#x60; unit:
			// we first aligned time on the previous &#x60;major&#x60; unit then add the number of full
			// stepSize there is between first and the previous major time.
			time.startOf(major);
			time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
		}

		for (; time &lt; last; time.add(stepSize, minor)) {
			ticks.push(+time);
		}

		ticks.push(+time);

		return ticks;
	}

	/**
	 * Returns the right and left offsets from edges in the form of {left, right}.
	 * Offsets are added when the &#x60;offset&#x60; option is true.
	 */
	function computeOffsets(table, ticks, min, max, options) {
		var left = 0;
		var right = 0;
		var upper, lower;

		if (options.offset &amp;&amp; ticks.length) {
			if (!options.time.min) {
				upper = ticks.length &gt; 1 ? ticks[1] : max;
				lower = ticks[0];
				left = (
					interpolate(table, &#x27;time&#x27;, upper, &#x27;pos&#x27;) -
					interpolate(table, &#x27;time&#x27;, lower, &#x27;pos&#x27;)
				) / 2;
			}
			if (!options.time.max) {
				upper = ticks[ticks.length - 1];
				lower = ticks.length &gt; 1 ? ticks[ticks.length - 2] : min;
				right = (
					interpolate(table, &#x27;time&#x27;, upper, &#x27;pos&#x27;) -
					interpolate(table, &#x27;time&#x27;, lower, &#x27;pos&#x27;)
				) / 2;
			}
		}

		return {left: left, right: right};
	}

	function ticksFromTimestamps(values, majorUnit) {
		var ticks = [];
		var i, ilen, value, major;

		for (i = 0, ilen = values.length; i &lt; ilen; ++i) {
			value = values[i];
			major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;

			ticks.push({
				value: value,
				major: major
			});
		}

		return ticks;
	}

	function determineLabelFormat(data, timeOpts) {
		var i, momentDate, hasTime;
		var ilen = data.length;

		// find the label with the most parts (milliseconds, minutes, etc.)
		// format all labels with the same level of detail as the most specific label
		for (i = 0; i &lt; ilen; i++) {
			momentDate = momentify(data[i], timeOpts);
			if (momentDate.millisecond() !== 0) {
				return &#x27;MMM D, YYYY h:mm:ss.SSS a&#x27;;
			}
			if (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {
				hasTime = true;
			}
		}
		if (hasTime) {
			return &#x27;MMM D, YYYY h:mm:ss a&#x27;;
		}
		return &#x27;MMM D, YYYY&#x27;;
	}

	module.exports = function(Chart) {

		var defaultConfig = {
			position: &#x27;bottom&#x27;,

			/**
			 * Data distribution along the scale:
			 * - &#x27;linear&#x27;: data are spread according to their time (distances can vary),
			 * - &#x27;series&#x27;: data are spread at the same distance from each other.
			 * @see https://github.com/chartjs/Chart.js/pull/4507
			 * @since 2.7.0
			 */
			distribution: &#x27;linear&#x27;,

			/**
			 * Scale boundary strategy (bypassed by min/max time options)
			 * - &#x60;data&#x60;: make sure data are fully visible, ticks outside are removed
			 * - &#x60;ticks&#x60;: make sure ticks are fully visible, data outside are truncated
			 * @see https://github.com/chartjs/Chart.js/pull/4556
			 * @since 2.7.0
			 */
			bounds: &#x27;data&#x27;,

			time: {
				parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
				format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
				unit: false, // false == automatic or override with week, month, year, etc.
				round: false, // none, or override with week, month, year, etc.
				displayFormat: false, // DEPRECATED
				isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
				minUnit: &#x27;millisecond&#x27;,

				// defaults to unit&#x27;s corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
				displayFormats: {
					millisecond: &#x27;h:mm:ss.SSS a&#x27;, // 11:20:01.123 AM,
					second: &#x27;h:mm:ss a&#x27;, // 11:20:01 AM
					minute: &#x27;h:mm a&#x27;, // 11:20 AM
					hour: &#x27;hA&#x27;, // 5PM
					day: &#x27;MMM D&#x27;, // Sep 4
					week: &#x27;ll&#x27;, // Week 46, or maybe &quot;[W]WW - YYYY&quot; ?
					month: &#x27;MMM YYYY&#x27;, // Sept 2015
					quarter: &#x27;[Q]Q - YYYY&#x27;, // Q3
					year: &#x27;YYYY&#x27; // 2015
				},
			},
			ticks: {
				autoSkip: false,

				/**
				 * Ticks generation input values:
				 * - &#x27;auto&#x27;: generates &quot;optimal&quot; ticks based on scale size and time options.
				 * - &#x27;data&#x27;: generates ticks from data (including labels from data {t|x|y} objects).
				 * - &#x27;labels&#x27;: generates ticks from user given &#x60;data.labels&#x60; values ONLY.
				 * @see https://github.com/chartjs/Chart.js/pull/4507
				 * @since 2.7.0
				 */
				source: &#x27;auto&#x27;,

				major: {
					enabled: false
				}
			}
		};

		var TimeScale = Chart.Scale.extend({
			initialize: function() {
				if (!moment) {
					throw new Error(&#x27;Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com&#x27;);
				}

				this.mergeTicksOptions();

				Chart.Scale.prototype.initialize.call(this);
			},

			update: function() {
				var me = this;
				var options = me.options;

				// DEPRECATIONS: output a message only one time per update
				if (options.time &amp;&amp; options.time.format) {
					console.warn(&#x27;options.time.format is deprecated and replaced by options.time.parser.&#x27;);
				}

				return Chart.Scale.prototype.update.apply(me, arguments);
			},

			/**
			 * Allows data to be referenced via &#x27;t&#x27; attribute
			 */
			getRightValue: function(rawValue) {
				if (rawValue &amp;&amp; rawValue.t !== undefined) {
					rawValue = rawValue.t;
				}
				return Chart.Scale.prototype.getRightValue.call(this, rawValue);
			},

			determineDataLimits: function() {
				var me = this;
				var chart = me.chart;
				var timeOpts = me.options.time;
				var unit = timeOpts.unit || &#x27;day&#x27;;
				var min = MAX_INTEGER;
				var max = MIN_INTEGER;
				var timestamps = [];
				var datasets = [];
				var labels = [];
				var i, j, ilen, jlen, data, timestamp;

				// Convert labels to timestamps
				for (i = 0, ilen = chart.data.labels.length; i &lt; ilen; ++i) {
					labels.push(parse(chart.data.labels[i], me));
				}

				// Convert data to timestamps
				for (i = 0, ilen = (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					if (chart.isDatasetVisible(i)) {
						data = chart.data.datasets[i].data;

						// Let&#x27;s consider that all data have the same format.
						if (helpers.isObject(data[0])) {
							datasets[i] = [];

							for (j = 0, jlen = data.length; j &lt; jlen; ++j) {
								timestamp = parse(data[j], me);
								timestamps.push(timestamp);
								datasets[i][j] = timestamp;
							}
						} else {
							timestamps.push.apply(timestamps, labels);
							datasets[i] = labels.slice(0);
						}
					} else {
						datasets[i] = [];
					}
				}

				if (labels.length) {
					// Sort labels **after** data have been converted
					labels = arrayUnique(labels).sort(sorter);
					min = Math.min(min, labels[0]);
					max = Math.max(max, labels[labels.length - 1]);
				}

				if (timestamps.length) {
					timestamps = arrayUnique(timestamps).sort(sorter);
					min = Math.min(min, timestamps[0]);
					max = Math.max(max, timestamps[timestamps.length - 1]);
				}

				min = parse(timeOpts.min, me) || min;
				max = parse(timeOpts.max, me) || max;

				// In case there is no valid min/max, set limits based on unit time option
				min = min === MAX_INTEGER ? +moment().startOf(unit) : min;
				max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;

				// Make sure that max is strictly higher than min (required by the lookup table)
				me.min = Math.min(min, max);
				me.max = Math.max(min + 1, max);

				// PRIVATE
				me._horizontal = me.isHorizontal();
				me._table = [];
				me._timestamps = {
					data: timestamps,
					datasets: datasets,
					labels: labels
				};
			},

			buildTicks: function() {
				var me = this;
				var min = me.min;
				var max = me.max;
				var options = me.options;
				var timeOpts = options.time;
				var timestamps = [];
				var ticks = [];
				var i, ilen, timestamp;

				switch (options.ticks.source) {
				case &#x27;data&#x27;:
					timestamps = me._timestamps.data;
					break;
				case &#x27;labels&#x27;:
					timestamps = me._timestamps.labels;
					break;
				case &#x27;auto&#x27;:
				default:
					timestamps = generate(min, max, me.getLabelCapacity(min), options);
				}

				if (options.bounds === &#x27;ticks&#x27; &amp;&amp; timestamps.length) {
					min = timestamps[0];
					max = timestamps[timestamps.length - 1];
				}

				// Enforce limits with user min/max options
				min = parse(timeOpts.min, me) || min;
				max = parse(timeOpts.max, me) || max;

				// Remove ticks outside the min/max range
				for (i = 0, ilen = timestamps.length; i &lt; ilen; ++i) {
					timestamp = timestamps[i];
					if (timestamp &gt;= min &amp;&amp; timestamp &lt;= max) {
						ticks.push(timestamp);
					}
				}

				me.min = min;
				me.max = max;

				// PRIVATE
				me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
				me._majorUnit = determineMajorUnit(me._unit);
				me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
				me._offsets = computeOffsets(me._table, ticks, min, max, options);
				me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);

				return ticksFromTimestamps(ticks, me._majorUnit);
			},

			getLabelForIndex: function(index, datasetIndex) {
				var me = this;
				var data = me.chart.data;
				var timeOpts = me.options.time;
				var label = data.labels &amp;&amp; index &lt; data.labels.length ? data.labels[index] : &#x27;&#x27;;
				var value = data.datasets[datasetIndex].data[index];

				if (helpers.isObject(value)) {
					label = me.getRightValue(value);
				}
				if (timeOpts.tooltipFormat) {
					return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
				}
				if (typeof label === &#x27;string&#x27;) {
					return label;
				}

				return momentify(label, timeOpts).format(me._labelFormat);
			},

			/**
			 * Function to format an individual tick mark
			 * @private
			 */
			tickFormatFunction: function(tick, index, ticks, formatOverride) {
				var me = this;
				var options = me.options;
				var time = tick.valueOf();
				var formats = options.time.displayFormats;
				var minorFormat = formats[me._unit];
				var majorUnit = me._majorUnit;
				var majorFormat = formats[majorUnit];
				var majorTime = tick.clone().startOf(majorUnit).valueOf();
				var majorTickOpts = options.ticks.major;
				var major = majorTickOpts.enabled &amp;&amp; majorUnit &amp;&amp; majorFormat &amp;&amp; time === majorTime;
				var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
				var tickOpts = major ? majorTickOpts : options.ticks.minor;
				var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

				return formatter ? formatter(label, index, ticks) : label;
			},

			convertTicksToLabels: function(ticks) {
				var labels = [];
				var i, ilen;

				for (i = 0, ilen = ticks.length; i &lt; ilen; ++i) {
					labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
				}

				return labels;
			},

			/**
			 * @private
			 */
			getPixelForOffset: function(time) {
				var me = this;
				var size = me._horizontal ? me.width : me.height;
				var start = me._horizontal ? me.left : me.top;
				var pos = interpolate(me._table, &#x27;time&#x27;, time, &#x27;pos&#x27;);

				return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
			},

			getPixelForValue: function(value, index, datasetIndex) {
				var me = this;
				var time = null;

				if (index !== undefined &amp;&amp; datasetIndex !== undefined) {
					time = me._timestamps.datasets[datasetIndex][index];
				}

				if (time === null) {
					time = parse(value, me);
				}

				if (time !== null) {
					return me.getPixelForOffset(time);
				}
			},

			getPixelForTick: function(index) {
				var ticks = this.getTicks();
				return index &gt;= 0 &amp;&amp; index &lt; ticks.length ?
					this.getPixelForOffset(ticks[index].value) :
					null;
			},

			getValueForPixel: function(pixel) {
				var me = this;
				var size = me._horizontal ? me.width : me.height;
				var start = me._horizontal ? me.left : me.top;
				var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
				var time = interpolate(me._table, &#x27;pos&#x27;, pos, &#x27;time&#x27;);

				return moment(time);
			},

			/**
			 * Crude approximation of what the label width might be
			 * @private
			 */
			getLabelWidth: function(label) {
				var me = this;
				var ticksOpts = me.options.ticks;
				var tickLabelWidth = me.ctx.measureText(label).width;
				var angle = helpers.toRadians(ticksOpts.maxRotation);
				var cosRotation = Math.cos(angle);
				var sinRotation = Math.sin(angle);
				var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

				return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
			},

			/**
			 * @private
			 */
			getLabelCapacity: function(exampleTime) {
				var me = this;

				var formatOverride = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation

				var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
				var tickLabelWidth = me.getLabelWidth(exampleLabel);
				var innerWidth = me.isHorizontal() ? me.width : me.height;

				var capacity = Math.floor(innerWidth / tickLabelWidth);
				return capacity &gt; 0 ? capacity : 1;
			}
		});

		Chart.scaleService.registerScaleType(&#x27;time&#x27;, TimeScale, defaultConfig);
	};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(module) {//! moment.js

	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define(factory) :
	    global.moment = factory()
	}(this, (function () { &#x27;use strict&#x27;;

	var hookCallback;

	function hooks () {
	    return hookCallback.apply(null, arguments);
	}

	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback = callback;
	}

	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === &#x27;[object Array]&#x27;;
	}

	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn&#x27;t for
	    // input != null
	    return input != null &amp;&amp; Object.prototype.toString.call(input) === &#x27;[object Object]&#x27;;
	}

	function isObjectEmpty(obj) {
	    if (Object.getOwnPropertyNames) {
	        return (Object.getOwnPropertyNames(obj).length === 0);
	    } else {
	        var k;
	        for (k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                return false;
	            }
	        }
	        return true;
	    }
	}

	function isUndefined(input) {
	    return input === void 0;
	}

	function isNumber(input) {
	    return typeof input === &#x27;number&#x27; || Object.prototype.toString.call(input) === &#x27;[object Number]&#x27;;
	}

	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === &#x27;[object Date]&#x27;;
	}

	function map(arr, fn) {
	    var res = [], i;
	    for (i = 0; i &lt; arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}

	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] = b[i];
	        }
	    }

	    if (hasOwnProp(b, &#x27;toString&#x27;)) {
	        a.toString = b.toString;
	    }

	    if (hasOwnProp(b, &#x27;valueOf&#x27;)) {
	        a.valueOf = b.valueOf;
	    }

	    return a;
	}

	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null,
	        rfc2822         : false,
	        weekdayMismatch : false
	    };
	}

	function getParsingFlags(m) {
	    if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	    }
	    return m._pf;
	}

	var some;
	if (Array.prototype.some) {
	    some = Array.prototype.some;
	} else {
	    some = function (fun) {
	        var t = Object(this);
	        var len = t.length &gt;&gt;&gt; 0;

	        for (var i = 0; i &lt; len; i++) {
	            if (i in t &amp;&amp; fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }

	        return false;
	    };
	}

	function isValid(m) {
	    if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some.call(flags.parsedDateParts, function (i) {
	            return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) &amp;&amp;
	            flags.overflow &lt; 0 &amp;&amp;
	            !flags.empty &amp;&amp;
	            !flags.invalidMonth &amp;&amp;
	            !flags.invalidWeekday &amp;&amp;
	            !flags.weekdayMismatch &amp;&amp;
	            !flags.nullInput &amp;&amp;
	            !flags.invalidFormat &amp;&amp;
	            !flags.userInvalidated &amp;&amp;
	            (!flags.meridiem || (flags.meridiem &amp;&amp; parsedParts));

	        if (m._strict) {
	            isNowValid = isNowValid &amp;&amp;
	                flags.charsLeftOver === 0 &amp;&amp;
	                flags.unusedTokens.length === 0 &amp;&amp;
	                flags.bigHour === undefined;
	        }

	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}

	function createInvalid (flags) {
	    var m = createUTC(NaN);
	    if (flags != null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated = true;
	    }

	    return m;
	}

	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];

	function copyConfig(to, from) {
	    var i, prop, val;

	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i = from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f = from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l = from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	    }

	    if (momentProperties.length &gt; 0) {
	        for (i = 0; i &lt; momentProperties.length; i++) {
	            prop = momentProperties[i];
	            val = from[prop];
	            if (!isUndefined(val)) {
	                to[prop] = val;
	            }
	        }
	    }

	    return to;
	}

	var updateInProgress = false;

	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d = new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	    }
	}

	function isMoment (obj) {
	    return obj instanceof Moment || (obj != null &amp;&amp; obj._isAMomentObject != null);
	}

	function absFloor (number) {
	    if (number &lt; 0) {
	        // -0 -&gt; 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}

	function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;

	    if (coercedNumber !== 0 &amp;&amp; isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	    }

	    return value;
	}

	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;
	    for (i = 0; i &lt; len; i++) {
	        if ((dontConvert &amp;&amp; array1[i] !== array2[i]) ||
	            (!dontConvert &amp;&amp; toInt(array1[i]) !== toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}

	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false &amp;&amp;
	            (typeof console !==  &#x27;undefined&#x27;) &amp;&amp; console.warn) {
	        console.warn(&#x27;Deprecation warning: &#x27; + msg);
	    }
	}

	function deprecate(msg, fn) {
	    var firstTime = true;

	    return extend(function () {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args = [];
	            var arg;
	            for (var i = 0; i &lt; arguments.length; i++) {
	                arg = &#x27;&#x27;;
	                if (typeof arguments[i] === &#x27;object&#x27;) {
	                    arg += &#x27;\n[&#x27; + i + &#x27;] &#x27;;
	                    for (var key in arguments[0]) {
	                        arg += key + &#x27;: &#x27; + arguments[0][key] + &#x27;, &#x27;;
	                    }
	                    arg = arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg = arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + &#x27;\nArguments: &#x27; + Array.prototype.slice.call(args).join(&#x27;&#x27;) + &#x27;\n&#x27; + (new Error()).stack);
	            firstTime = false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}

	var deprecations = {};

	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	    }
	}

	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === &#x27;[object Function]&#x27;;
	}

	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop = config[i];
	        if (isFunction(prop)) {
	            this[i] = prop;
	        } else {
	            this[&#x27;_&#x27; + i] = prop;
	        }
	    }
	    this._config = config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	    // TODO: Remove &quot;ordinalParse&quot; fallback in next major release.
	    this._dayOfMonthOrdinalParseLenient = new RegExp(
	        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	            &#x27;|&#x27; + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) &amp;&amp; isObject(childConfig[prop])) {
	                res[prop] = {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] != null) {
	                res[prop] = childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &amp;&amp;
	                !hasOwnProp(childConfig, prop) &amp;&amp;
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don&#x27;t modify parent config
	            res[prop] = extend({}, res[prop]);
	        }
	    }
	    return res;
	}

	function Locale(config) {
	    if (config != null) {
	        this.set(config);
	    }
	}

	var keys;

	if (Object.keys) {
	    keys = Object.keys;
	} else {
	    keys = function (obj) {
	        var i, res = [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}

	var defaultCalendar = {
	    sameDay : &#x27;[Today at] LT&#x27;,
	    nextDay : &#x27;[Tomorrow at] LT&#x27;,
	    nextWeek : &#x27;dddd [at] LT&#x27;,
	    lastDay : &#x27;[Yesterday at] LT&#x27;,
	    lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	    sameElse : &#x27;L&#x27;
	};

	function calendar (key, mom, now) {
	    var output = this._calendar[key] || this._calendar[&#x27;sameElse&#x27;];
	    return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat = {
	    LTS  : &#x27;h:mm:ss A&#x27;,
	    LT   : &#x27;h:mm A&#x27;,
	    L    : &#x27;MM/DD/YYYY&#x27;,
	    LL   : &#x27;MMMM D, YYYY&#x27;,
	    LLL  : &#x27;MMMM D, YYYY h:mm A&#x27;,
	    LLLL : &#x27;dddd, MMMM D, YYYY h:mm A&#x27;
	};

	function longDateFormat (key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];

	    if (format || !formatUpper) {
	        return format;
	    }

	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });

	    return this._longDateFormat[key];
	}

	var defaultInvalidDate = &#x27;Invalid date&#x27;;

	function invalidDate () {
	    return this._invalidDate;
	}

	var defaultOrdinal = &#x27;%d&#x27;;
	var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	function ordinal (number) {
	    return this._ordinal.replace(&#x27;%d&#x27;, number);
	}

	var defaultRelativeTime = {
	    future : &#x27;in %s&#x27;,
	    past   : &#x27;%s ago&#x27;,
	    s  : &#x27;a few seconds&#x27;,
	    ss : &#x27;%d seconds&#x27;,
	    m  : &#x27;a minute&#x27;,
	    mm : &#x27;%d minutes&#x27;,
	    h  : &#x27;an hour&#x27;,
	    hh : &#x27;%d hours&#x27;,
	    d  : &#x27;a day&#x27;,
	    dd : &#x27;%d days&#x27;,
	    M  : &#x27;a month&#x27;,
	    MM : &#x27;%d months&#x27;,
	    y  : &#x27;a year&#x27;,
	    yy : &#x27;%d years&#x27;
	};

	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}

	function pastFuture (diff, output) {
	    var format = this._relativeTime[diff &gt; 0 ? &#x27;future&#x27; : &#x27;past&#x27;];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var aliases = {};

	function addUnitAlias (unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + &#x27;s&#x27;] = aliases[shorthand] = unit;
	}

	function normalizeUnits(units) {
	    return typeof units === &#x27;string&#x27; ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;

	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp = normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] = inputObject[prop];
	            }
	        }
	    }

	    return normalizedInput;
	}

	var priorities = {};

	function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	}

	function getPrioritizedUnits(unitsObj) {
	    var units = [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}

	function zeroFill(number, targetLength, forceSign) {
	    var absNumber = &#x27;&#x27; + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number &gt;= 0;
	    return (sign ? (forceSign ? &#x27;+&#x27; : &#x27;&#x27;) : &#x27;-&#x27;) +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions = {};

	var formatTokenFunctions = {};

	// token:    &#x27;M&#x27;
	// padded:   [&#x27;MM&#x27;, 2]
	// ordinal:  &#x27;Mo&#x27;
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func = callback;
	    if (typeof callback === &#x27;string&#x27;) {
	        func = function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] = func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}

	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, &#x27;&#x27;);
	    }
	    return input.replace(/\\/g, &#x27;&#x27;);
	}

	function makeFormatFunction(format) {
	    var array = format.match(formattingTokens), i, length;

	    for (i = 0, length = array.length; i &lt; length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] = formatTokenFunctions[array[i]];
	        } else {
	            array[i] = removeFormattingTokens(array[i]);
	        }
	    }

	    return function (mom) {
	        var output = &#x27;&#x27;, i;
	        for (i = 0; i &lt; length; i++) {
	            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}

	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }

	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	    return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
	    var i = 5;

	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }

	    localFormattingTokens.lastIndex = 0;
	    while (i &gt;= 0 &amp;&amp; localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	    }

	    return format;
	}

	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]{0,256}[&#x27;a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

	var regexes = {};

	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict &amp;&amp; strictRegex) ? strictRegex : regex;
	    };
	}

	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }

	    return regexes[token](config._strict, config._locale);
	}

	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace(&#x27;\\&#x27;, &#x27;&#x27;).replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}

	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, &#x27;\\$&amp;&#x27;);
	}

	var tokens = {};

	function addParseToken (token, callback) {
	    var i, func = callback;
	    if (typeof token === &#x27;string&#x27;) {
	        token = [token];
	    }
	    if (isNumber(callback)) {
	        func = function (input, array) {
	            array[callback] = toInt(input);
	        };
	    }
	    for (i = 0; i &lt; token.length; i++) {
	        tokens[token[i]] = func;
	    }
	}

	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	    });
	}

	function addTimeToArrayFromToken(token, input, config) {
	    if (input != null &amp;&amp; hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}

	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;

	// FORMATTING

	addFormatToken(&#x27;Y&#x27;, 0, 0, function () {
	    var y = this.year();
	    return y &lt;= 9999 ? &#x27;&#x27; + y : &#x27;+&#x27; + y;
	});

	addFormatToken(0, [&#x27;YY&#x27;, 2], 0, function () {
	    return this.year() % 100;
	});

	addFormatToken(0, [&#x27;YYYY&#x27;,   4],       0, &#x27;year&#x27;);
	addFormatToken(0, [&#x27;YYYYY&#x27;,  5],       0, &#x27;year&#x27;);
	addFormatToken(0, [&#x27;YYYYYY&#x27;, 6, true], 0, &#x27;year&#x27;);

	// ALIASES

	addUnitAlias(&#x27;year&#x27;, &#x27;y&#x27;);

	// PRIORITIES

	addUnitPriority(&#x27;year&#x27;, 1);

	// PARSING

	addRegexToken(&#x27;Y&#x27;,      matchSigned);
	addRegexToken(&#x27;YY&#x27;,     match1to2, match2);
	addRegexToken(&#x27;YYYY&#x27;,   match1to4, match4);
	addRegexToken(&#x27;YYYYY&#x27;,  match1to6, match6);
	addRegexToken(&#x27;YYYYYY&#x27;, match1to6, match6);

	addParseToken([&#x27;YYYYY&#x27;, &#x27;YYYYYY&#x27;], YEAR);
	addParseToken(&#x27;YYYY&#x27;, function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken(&#x27;YY&#x27;, function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken(&#x27;Y&#x27;, function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	});

	// HELPERS

	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
	    return (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0;
	}

	// HOOKS

	hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) &gt; 68 ? 1900 : 2000);
	};

	// MOMENTS

	var getSetYear = makeGetSet(&#x27;FullYear&#x27;, true);

	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}

	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value != null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}

	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d[&#x27;get&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + unit]() : NaN;
	}

	function set$1 (mom, unit, value) {
	    if (mom.isValid() &amp;&amp; !isNaN(value)) {
	        if (unit === &#x27;FullYear&#x27; &amp;&amp; isLeapYear(mom.year()) &amp;&amp; mom.month() === 1 &amp;&amp; mom.date() === 29) {
	            mom._d[&#x27;set&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + unit](value, mom.month(), daysInMonth(value, mom.month()));
	        }
	        else {
	            mom._d[&#x27;set&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + unit](value);
	        }
	    }
	}

	// MOMENTS

	function stringGet (units) {
	    units = normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}


	function stringSet (units, value) {
	    if (typeof units === &#x27;object&#x27;) {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);
	        for (var i = 0; i &lt; prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}

	function mod(n, x) {
	    return ((n % x) + x) % x;
	}

	var indexOf;

	if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	} else {
	    indexOf = function (o) {
	        // I know
	        var i;
	        for (i = 0; i &lt; this.length; ++i) {
	            if (this[i] === o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}

	function daysInMonth(year, month) {
	    if (isNaN(year) || isNaN(month)) {
	        return NaN;
	    }
	    var modMonth = mod(month, 12);
	    year += (month - modMonth) / 12;
	    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
	}

	// FORMATTING

	addFormatToken(&#x27;M&#x27;, [&#x27;MM&#x27;, 2], &#x27;Mo&#x27;, function () {
	    return this.month() + 1;
	});

	addFormatToken(&#x27;MMM&#x27;, 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});

	addFormatToken(&#x27;MMMM&#x27;, 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});

	// ALIASES

	addUnitAlias(&#x27;month&#x27;, &#x27;M&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;month&#x27;, 8);

	// PARSING

	addRegexToken(&#x27;M&#x27;,    match1to2);
	addRegexToken(&#x27;MM&#x27;,   match1to2, match2);
	addRegexToken(&#x27;MMM&#x27;,  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken(&#x27;MMMM&#x27;, function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});

	addParseToken([&#x27;M&#x27;, &#x27;MM&#x27;], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	});

	addParseToken([&#x27;MMM&#x27;, &#x27;MMMM&#x27;], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict);
	    // if we didn&#x27;t find a month name, mark the date as invalid.
	    if (month != null) {
	        array[MONTH] = month;
	    } else {
	        getParsingFlags(config).invalidMonth = input;
	    }
	});

	// LOCALES

	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;);
	function localeMonths (m, format) {
	    if (!m) {
	        return isArray(this._months) ? this._months :
	            this._months[&#x27;standalone&#x27;];
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? &#x27;format&#x27; : &#x27;standalone&#x27;][m.month()];
	}

	var defaultLocaleMonthsShort = &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;);
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return isArray(this._monthsShort) ? this._monthsShort :
	            this._monthsShort[&#x27;standalone&#x27;];
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? &#x27;format&#x27; : &#x27;standalone&#x27;][m.month()];
	}

	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc = monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	        for (i = 0; i &lt; 12; ++i) {
	            mom = createUTC([2000, i]);
	            this._shortMonthsParse[i] = this.monthsShort(mom, &#x27;&#x27;).toLocaleLowerCase();
	            this._longMonthsParse[i] = this.months(mom, &#x27;&#x27;).toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === &#x27;MMM&#x27;) {
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === &#x27;MMM&#x27;) {
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._longMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;

	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }

	    if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	    }

	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i = 0; i &lt; 12; i++) {
	        // make the regex if we don&#x27;t have it already
	        mom = createUTC([2000, i]);
	        if (strict &amp;&amp; !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] = new RegExp(&#x27;^&#x27; + this.months(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	            this._shortMonthsParse[i] = new RegExp(&#x27;^&#x27; + this.monthsShort(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        if (!strict &amp;&amp; !this._monthsParse[i]) {
	            regex = &#x27;^&#x27; + this.months(mom, &#x27;&#x27;) + &#x27;|^&#x27; + this.monthsShort(mom, &#x27;&#x27;);
	            this._monthsParse[i] = new RegExp(regex.replace(&#x27;.&#x27;, &#x27;&#x27;), &#x27;i&#x27;);
	        }
	        // test the regex
	        if (strict &amp;&amp; format === &#x27;MMMM&#x27; &amp;&amp; this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict &amp;&amp; format === &#x27;MMM&#x27; &amp;&amp; this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict &amp;&amp; this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function setMonth (mom, value) {
	    var dayOfMonth;

	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }

	    if (typeof value === &#x27;string&#x27;) {
	        if (/^\d+$/.test(value)) {
	            value = toInt(value);
	        } else {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }

	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d[&#x27;set&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + &#x27;Month&#x27;](value, dayOfMonth);
	    return mom;
	}

	function getSetMonth (value) {
	    if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, &#x27;Month&#x27;);
	    }
	}

	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, &#x27;_monthsRegex&#x27;)) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_monthsShortRegex&#x27;)) {
	            this._monthsShortRegex = defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex &amp;&amp; isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}

	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, &#x27;_monthsRegex&#x27;)) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_monthsRegex&#x27;)) {
	            this._monthsRegex = defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex &amp;&amp; isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}

	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom;
	    for (i = 0; i &lt; 12; i++) {
	        // make the regex if we don&#x27;t have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, &#x27;&#x27;));
	        longPieces.push(this.months(mom, &#x27;&#x27;));
	        mixedPieces.push(this.months(mom, &#x27;&#x27;));
	        mixedPieces.push(this.monthsShort(mom, &#x27;&#x27;));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i &lt; 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	    }
	    for (i = 0; i &lt; 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._monthsRegex = new RegExp(&#x27;^(&#x27; + mixedPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp(&#x27;^(&#x27; + longPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._monthsShortStrictRegex = new RegExp(&#x27;^(&#x27; + shortPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	}

	function createDate (y, m, d, h, M, s, ms) {
	    // can&#x27;t just apply() to create a date:
	    // https://stackoverflow.com/q/181348
	    var date = new Date(y, m, d, h, M, s, ms);

	    // the date constructor remaps years 0-99 to 1900-1999
	    if (y &lt; 100 &amp;&amp; y &gt;= 0 &amp;&amp; isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	    }
	    return date;
	}

	function createUTCDate (y) {
	    var date = new Date(Date.UTC.apply(null, arguments));

	    // the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y &lt; 100 &amp;&amp; y &gt;= 0 &amp;&amp; isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	    }
	    return date;
	}

	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	    return -fwdlw + fwd - 1;
	}

	// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;

	    if (dayOfYear &lt;= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear &gt; daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	    }

	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}

	function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;

	    if (week &lt; 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week &gt; weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	    } else {
	        resYear = mom.year();
	        resWeek = week;
	    }

	    return {
	        week: resWeek,
	        year: resYear
	    };
	}

	function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

	// FORMATTING

	addFormatToken(&#x27;w&#x27;, [&#x27;ww&#x27;, 2], &#x27;wo&#x27;, &#x27;week&#x27;);
	addFormatToken(&#x27;W&#x27;, [&#x27;WW&#x27;, 2], &#x27;Wo&#x27;, &#x27;isoWeek&#x27;);

	// ALIASES

	addUnitAlias(&#x27;week&#x27;, &#x27;w&#x27;);
	addUnitAlias(&#x27;isoWeek&#x27;, &#x27;W&#x27;);

	// PRIORITIES

	addUnitPriority(&#x27;week&#x27;, 5);
	addUnitPriority(&#x27;isoWeek&#x27;, 5);

	// PARSING

	addRegexToken(&#x27;w&#x27;,  match1to2);
	addRegexToken(&#x27;ww&#x27;, match1to2, match2);
	addRegexToken(&#x27;W&#x27;,  match1to2);
	addRegexToken(&#x27;WW&#x27;, match1to2, match2);

	addWeekParseToken([&#x27;w&#x27;, &#x27;ww&#x27;, &#x27;W&#x27;, &#x27;WW&#x27;], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	});

	// HELPERS

	// LOCALES

	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek = {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 1st is the first week of the year.
	};

	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}

	function localeFirstDayOfYear () {
	    return this._week.doy;
	}

	// MOMENTS

	function getSetWeek (input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, &#x27;d&#x27;);
	}

	function getSetISOWeek (input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, &#x27;d&#x27;);
	}

	// FORMATTING

	addFormatToken(&#x27;d&#x27;, 0, &#x27;do&#x27;, &#x27;day&#x27;);

	addFormatToken(&#x27;dd&#x27;, 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken(&#x27;ddd&#x27;, 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken(&#x27;dddd&#x27;, 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});

	addFormatToken(&#x27;e&#x27;, 0, 0, &#x27;weekday&#x27;);
	addFormatToken(&#x27;E&#x27;, 0, 0, &#x27;isoWeekday&#x27;);

	// ALIASES

	addUnitAlias(&#x27;day&#x27;, &#x27;d&#x27;);
	addUnitAlias(&#x27;weekday&#x27;, &#x27;e&#x27;);
	addUnitAlias(&#x27;isoWeekday&#x27;, &#x27;E&#x27;);

	// PRIORITY
	addUnitPriority(&#x27;day&#x27;, 11);
	addUnitPriority(&#x27;weekday&#x27;, 11);
	addUnitPriority(&#x27;isoWeekday&#x27;, 11);

	// PARSING

	addRegexToken(&#x27;d&#x27;,    match1to2);
	addRegexToken(&#x27;e&#x27;,    match1to2);
	addRegexToken(&#x27;E&#x27;,    match1to2);
	addRegexToken(&#x27;dd&#x27;,   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken(&#x27;ddd&#x27;,   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken(&#x27;dddd&#x27;,   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});

	addWeekParseToken([&#x27;dd&#x27;, &#x27;ddd&#x27;, &#x27;dddd&#x27;], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn&#x27;t get a weekday name, mark the date as invalid
	    if (weekday != null) {
	        week.d = weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday = input;
	    }
	});

	addWeekParseToken([&#x27;d&#x27;, &#x27;e&#x27;, &#x27;E&#x27;], function (input, week, config, token) {
	    week[token] = toInt(input);
	});

	// HELPERS

	function parseWeekday(input, locale) {
	    if (typeof input !== &#x27;string&#x27;) {
	        return input;
	    }

	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }

	    input = locale.weekdaysParse(input);
	    if (typeof input === &#x27;number&#x27;) {
	        return input;
	    }

	    return null;
	}

	function parseIsoWeekday(input, locale) {
	    if (typeof input === &#x27;string&#x27;) {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}

	// LOCALES

	var defaultLocaleWeekdays = &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;);
	function localeWeekdays (m, format) {
	    if (!m) {
	        return isArray(this._weekdays) ? this._weekdays :
	            this._weekdays[&#x27;standalone&#x27;];
	    }
	    return isArray(this._weekdays) ? this._weekdays[m.day()] :
	        this._weekdays[this._weekdays.isFormat.test(format) ? &#x27;format&#x27; : &#x27;standalone&#x27;][m.day()];
	}

	var defaultLocaleWeekdaysShort = &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;);
	function localeWeekdaysShort (m) {
	    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}

	var defaultLocaleWeekdaysMin = &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;);
	function localeWeekdaysMin (m) {
	    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}

	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];

	        for (i = 0; i &lt; 7; ++i) {
	            mom = createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] = this.weekdaysMin(mom, &#x27;&#x27;).toLocaleLowerCase();
	            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, &#x27;&#x27;).toLocaleLowerCase();
	            this._weekdaysParse[i] = this.weekdays(mom, &#x27;&#x27;).toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === &#x27;dddd&#x27;) {
	            ii = indexOf.call(this._weekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === &#x27;ddd&#x27;) {
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === &#x27;dddd&#x27;) {
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === &#x27;ddd&#x27;) {
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;

	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }

	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	    }

	    for (i = 0; i &lt; 7; i++) {
	        // make the regex if we don&#x27;t have it already

	        mom = createUTC([2000, 1]).day(i);
	        if (strict &amp;&amp; !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] = new RegExp(&#x27;^&#x27; + this.weekdays(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;\.?&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	            this._shortWeekdaysParse[i] = new RegExp(&#x27;^&#x27; + this.weekdaysShort(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;\.?&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	            this._minWeekdaysParse[i] = new RegExp(&#x27;^&#x27; + this.weekdaysMin(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;\.?&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        if (!this._weekdaysParse[i]) {
	            regex = &#x27;^&#x27; + this.weekdays(mom, &#x27;&#x27;) + &#x27;|^&#x27; + this.weekdaysShort(mom, &#x27;&#x27;) + &#x27;|^&#x27; + this.weekdaysMin(mom, &#x27;&#x27;);
	            this._weekdaysParse[i] = new RegExp(regex.replace(&#x27;.&#x27;, &#x27;&#x27;), &#x27;i&#x27;);
	        }
	        // test the regex
	        if (strict &amp;&amp; format === &#x27;dddd&#x27; &amp;&amp; this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict &amp;&amp; format === &#x27;ddd&#x27; &amp;&amp; this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict &amp;&amp; format === &#x27;dd&#x27; &amp;&amp; this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict &amp;&amp; this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, &#x27;d&#x27;);
	    } else {
	        return day;
	    }
	}

	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, &#x27;d&#x27;);
	}

	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }

	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.

	    if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}

	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            this._weekdaysRegex = defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex &amp;&amp; isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}

	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_weekdaysShortRegex&#x27;)) {
	            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex &amp;&amp; isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}

	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_weekdaysMinRegex&#x27;)) {
	            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex &amp;&amp; isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}


	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom, minp, shortp, longp;
	    for (i = 0; i &lt; 7; i++) {
	        // make the regex if we don&#x27;t have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, &#x27;&#x27;);
	        shortp = this.weekdaysShort(mom, &#x27;&#x27;);
	        longp = this.weekdays(mom, &#x27;&#x27;);
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i &lt; 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._weekdaysRegex = new RegExp(&#x27;^(&#x27; + mixedPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;

	    this._weekdaysStrictRegex = new RegExp(&#x27;^(&#x27; + longPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._weekdaysShortStrictRegex = new RegExp(&#x27;^(&#x27; + shortPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._weekdaysMinStrictRegex = new RegExp(&#x27;^(&#x27; + minPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	}

	// FORMATTING

	function hFormat() {
	    return this.hours() % 12 || 12;
	}

	function kFormat() {
	    return this.hours() || 24;
	}

	addFormatToken(&#x27;H&#x27;, [&#x27;HH&#x27;, 2], 0, &#x27;hour&#x27;);
	addFormatToken(&#x27;h&#x27;, [&#x27;hh&#x27;, 2], 0, hFormat);
	addFormatToken(&#x27;k&#x27;, [&#x27;kk&#x27;, 2], 0, kFormat);

	addFormatToken(&#x27;hmm&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken(&#x27;hmmss&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	addFormatToken(&#x27;Hmm&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken(&#x27;Hmmss&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}

	meridiem(&#x27;a&#x27;, true);
	meridiem(&#x27;A&#x27;, false);

	// ALIASES

	addUnitAlias(&#x27;hour&#x27;, &#x27;h&#x27;);

	// PRIORITY
	addUnitPriority(&#x27;hour&#x27;, 13);

	// PARSING

	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}

	addRegexToken(&#x27;a&#x27;,  matchMeridiem);
	addRegexToken(&#x27;A&#x27;,  matchMeridiem);
	addRegexToken(&#x27;H&#x27;,  match1to2);
	addRegexToken(&#x27;h&#x27;,  match1to2);
	addRegexToken(&#x27;k&#x27;,  match1to2);
	addRegexToken(&#x27;HH&#x27;, match1to2, match2);
	addRegexToken(&#x27;hh&#x27;, match1to2, match2);
	addRegexToken(&#x27;kk&#x27;, match1to2, match2);

	addRegexToken(&#x27;hmm&#x27;, match3to4);
	addRegexToken(&#x27;hmmss&#x27;, match5to6);
	addRegexToken(&#x27;Hmm&#x27;, match3to4);
	addRegexToken(&#x27;Hmmss&#x27;, match5to6);

	addParseToken([&#x27;H&#x27;, &#x27;HH&#x27;], HOUR);
	addParseToken([&#x27;k&#x27;, &#x27;kk&#x27;], function (input, array, config) {
	    var kInput = toInt(input);
	    array[HOUR] = kInput === 24 ? 0 : kInput;
	});
	addParseToken([&#x27;a&#x27;, &#x27;A&#x27;], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	});
	addParseToken([&#x27;h&#x27;, &#x27;hh&#x27;], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken(&#x27;hmm&#x27;, function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken(&#x27;hmmss&#x27;, function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken(&#x27;Hmm&#x27;, function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken(&#x27;Hmmss&#x27;, function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	});

	// LOCALES

	function localeIsPM (input) {
	    // IE8 Quirks Mode &amp; IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + &#x27;&#x27;).toLowerCase().charAt(0) === &#x27;p&#x27;);
	}

	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours &gt; 11) {
	        return isLower ? &#x27;pm&#x27; : &#x27;PM&#x27;;
	    } else {
	        return isLower ? &#x27;am&#x27; : &#x27;AM&#x27;;
	    }
	}


	// MOMENTS

	// Setting the hour should keep the time, because the user explicitly
	// specified which hour he wants. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet(&#x27;Hours&#x27;, true);

	var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	    relativeTime: defaultRelativeTime,

	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,

	    week: defaultLocaleWeek,

	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,

	    meridiemParse: defaultLocaleMeridiemParse
	};

	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;

	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace(&#x27;_&#x27;, &#x27;-&#x27;) : key;
	}

	// pick the locale from the array
	// try [&#x27;en-au&#x27;, &#x27;en-gb&#x27;] as &#x27;en-au&#x27;, &#x27;en-gb&#x27;, &#x27;en&#x27;, as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it&#x27;s a more specific variant than the current root
	function chooseLocale(names) {
	    var i = 0, j, next, locale, split;

	    while (i &lt; names.length) {
	        split = normalizeLocale(names[i]).split(&#x27;-&#x27;);
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split(&#x27;-&#x27;) : null;
	        while (j &gt; 0) {
	            locale = loadLocale(split.slice(0, j).join(&#x27;-&#x27;));
	            if (locale) {
	                return locale;
	            }
	            if (next &amp;&amp; next.length &gt;= j &amp;&amp; compareArrays(split, next, true) &gt;= j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return globalLocale;
	}

	function loadLocale(name) {
	    var oldLocale = null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] &amp;&amp; (typeof module !== &#x27;undefined&#x27;) &amp;&amp;
	            module &amp;&amp; module.exports) {
	        try {
	            oldLocale = globalLocale._abbr;
	            var aliasedRequire = require;
	            __webpack_require__(74)(&quot;./&quot; + name);
	            getSetGlobalLocale(oldLocale);
	        } catch (e) {}
	    }
	    return locales[name];
	}

	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data = getLocale(key);
	        }
	        else {
	            data = defineLocale(key, values);
	        }

	        if (data) {
	            // moment.duration._locale = moment._locale = data;
	            globalLocale = data;
	        }
	        else {
	            if ((typeof console !==  &#x27;undefined&#x27;) &amp;&amp; console.warn) {
	                //warn user if arguments are passed but the locale could not be set
	                console.warn(&#x27;Locale &#x27; + key +  &#x27; not found. Did you forget to load it?&#x27;);
	            }
	        }
	    }

	    return globalLocale._abbr;
	}

	function defineLocale (name, config) {
	    if (config !== null) {
	        var locale, parentConfig = baseConfig;
	        config.abbr = name;
	        if (locales[name] != null) {
	            deprecateSimple(&#x27;defineLocaleOverride&#x27;,
	                    &#x27;use moment.updateLocale(localeName, config) to change &#x27; +
	                    &#x27;an existing locale. moment.defineLocale(localeName, &#x27; +
	                    &#x27;config) should only be used for creating a new locale &#x27; +
	                    &#x27;See http://momentjs.com/guides/#/warnings/define-locale/ for more info.&#x27;);
	            parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	            if (locales[config.parentLocale] != null) {
	                parentConfig = locales[config.parentLocale]._config;
	            } else {
	                locale = loadLocale(config.parentLocale);
	                if (locale != null) {
	                    parentConfig = locale._config;
	                } else {
	                    if (!localeFamilies[config.parentLocale]) {
	                        localeFamilies[config.parentLocale] = [];
	                    }
	                    localeFamilies[config.parentLocale].push({
	                        name: name,
	                        config: config
	                    });
	                    return null;
	                }
	            }
	        }
	        locales[name] = new Locale(mergeConfigs(parentConfig, config));

	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }

	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won&#x27;t end up with the child locale set.
	        getSetGlobalLocale(name);


	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}

	function updateLocale(name, config) {
	    if (config != null) {
	        var locale, tmpLocale, parentConfig = baseConfig;
	        // MERGE
	        tmpLocale = loadLocale(name);
	        if (tmpLocale != null) {
	            parentConfig = tmpLocale._config;
	        }
	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale;

	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	            if (locales[name].parentLocale != null) {
	                locales[name] = locales[name].parentLocale;
	            } else if (locales[name] != null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}

	// returns locale data
	function getLocale (key) {
	    var locale;

	    if (key &amp;&amp; key._locale &amp;&amp; key._locale._abbr) {
	        key = key._locale._abbr;
	    }

	    if (!key) {
	        return globalLocale;
	    }

	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key = [key];
	    }

	    return chooseLocale(key);
	}

	function listLocales() {
	    return keys(locales);
	}

	function checkOverflow (m) {
	    var overflow;
	    var a = m._a;

	    if (a &amp;&amp; getParsingFlags(m).overflow === -2) {
	        overflow =
	            a[MONTH]       &lt; 0 || a[MONTH]       &gt; 11  ? MONTH :
	            a[DATE]        &lt; 1 || a[DATE]        &gt; daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        &lt; 0 || a[HOUR]        &gt; 24 || (a[HOUR] === 24 &amp;&amp; (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	            a[MINUTE]      &lt; 0 || a[MINUTE]      &gt; 59  ? MINUTE :
	            a[SECOND]      &lt; 0 || a[SECOND]      &gt; 59  ? SECOND :
	            a[MILLISECOND] &lt; 0 || a[MILLISECOND] &gt; 999 ? MILLISECOND :
	            -1;

	        if (getParsingFlags(m)._overflowDayOfYear &amp;&amp; (overflow &lt; YEAR || overflow &gt; DATE)) {
	            overflow = DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks &amp;&amp; overflow === -1) {
	            overflow = WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday &amp;&amp; overflow === -1) {
	            overflow = WEEKDAY;
	        }

	        getParsingFlags(m).overflow = overflow;
	    }

	    return m;
	}

	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a != null) {
	        return a;
	    }
	    if (b != null) {
	        return b;
	    }
	    return c;
	}

	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

	    if (config._d) {
	        return;
	    }

	    currentDate = currentDateArray(config);

	    //compute day of the year from weeks and weekdays
	    if (config._w &amp;&amp; config._a[DATE] == null &amp;&amp; config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	    }

	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear != null) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	        if (config._dayOfYear &gt; daysInYear(yearToUse) || config._dayOfYear === 0) {
	            getParsingFlags(config)._overflowDayOfYear = true;
	        }

	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	    }

	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don&#x27;t default anything
	    for (i = 0; i &lt; 3 &amp;&amp; config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	    }

	    // Zero out whatever was not defaulted, including time
	    for (; i &lt; 7; i++) {
	        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	    }

	    // Check for 24:00:00.000
	    if (config._a[HOUR] === 24 &amp;&amp;
	            config._a[MINUTE] === 0 &amp;&amp;
	            config._a[SECOND] === 0 &amp;&amp;
	            config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	    }

	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }

	    if (config._nextDay) {
	        config._a[HOUR] = 24;
	    }

	    // check for mismatching day of week
	    if (config._w &amp;&amp; typeof config._w.d !== &#x27;undefined&#x27; &amp;&amp; config._w.d !== expectedWeekday) {
	        getParsingFlags(config).weekdayMismatch = true;
	    }
	}

	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	    w = config._w;
	    if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4;

	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);
	        if (weekday &lt; 1 || weekday &gt; 7) {
	            weekdayOverflow = true;
	        }
	    } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;

	        var curWeek = weekOfYear(createLocal(), dow, doy);

	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	        // Default to current week.
	        week = defaults(w.w, curWeek.week);

	        if (w.d != null) {
	            // weekday -- low day numbers are considered next week
	            weekday = w.d;
	            if (weekday &lt; 0 || weekday &gt; 6) {
	                weekdayOverflow = true;
	            }
	        } else if (w.e != null) {
	            // local weekday -- counting starts from begining of week
	            weekday = w.e + dow;
	            if (w.e &lt; 0 || w.e &gt; 6) {
	                weekdayOverflow = true;
	            }
	        } else {
	            // default to begining of week
	            weekday = dow;
	        }
	    }
	    if (week &lt; 1 || week &gt; weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	    } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	}

	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates = [
	    [&#x27;YYYYYY-MM-DD&#x27;, /[+-]\d{6}-\d\d-\d\d/],
	    [&#x27;YYYY-MM-DD&#x27;, /\d{4}-\d\d-\d\d/],
	    [&#x27;GGGG-[W]WW-E&#x27;, /\d{4}-W\d\d-\d/],
	    [&#x27;GGGG-[W]WW&#x27;, /\d{4}-W\d\d/, false],
	    [&#x27;YYYY-DDD&#x27;, /\d{4}-\d{3}/],
	    [&#x27;YYYY-MM&#x27;, /\d{4}-\d\d/, false],
	    [&#x27;YYYYYYMMDD&#x27;, /[+-]\d{10}/],
	    [&#x27;YYYYMMDD&#x27;, /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    [&#x27;GGGG[W]WWE&#x27;, /\d{4}W\d{3}/],
	    [&#x27;GGGG[W]WW&#x27;, /\d{4}W\d{2}/, false],
	    [&#x27;YYYYDDD&#x27;, /\d{7}/]
	];

	// iso time formats and regexes
	var isoTimes = [
	    [&#x27;HH:mm:ss.SSSS&#x27;, /\d\d:\d\d:\d\d\.\d+/],
	    [&#x27;HH:mm:ss,SSSS&#x27;, /\d\d:\d\d:\d\d,\d+/],
	    [&#x27;HH:mm:ss&#x27;, /\d\d:\d\d:\d\d/],
	    [&#x27;HH:mm&#x27;, /\d\d:\d\d/],
	    [&#x27;HHmmss.SSSS&#x27;, /\d\d\d\d\d\d\.\d+/],
	    [&#x27;HHmmss,SSSS&#x27;, /\d\d\d\d\d\d,\d+/],
	    [&#x27;HHmmss&#x27;, /\d\d\d\d\d\d/],
	    [&#x27;HHmm&#x27;, /\d\d\d\d/],
	    [&#x27;HH&#x27;, /\d\d/]
	];

	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;

	    if (match) {
	        getParsingFlags(config).iso = true;

	        for (i = 0, l = isoDates.length; i &lt; l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat = isoDates[i][0];
	                allowTime = isoDates[i][2] !== false;
	                break;
	            }
	        }
	        if (dateFormat == null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[3]) {
	            for (i = 0, l = isoTimes.length; i &lt; l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be &#x27;T&#x27; or space
	                    timeFormat = (match[2] || &#x27; &#x27;) + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat == null) {
	                config._isValid = false;
	                return;
	            }
	        }
	        if (!allowTime &amp;&amp; timeFormat != null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat = &#x27;Z&#x27;;
	            } else {
	                config._isValid = false;
	                return;
	            }
	        }
	        config._f = dateFormat + (timeFormat || &#x27;&#x27;) + (tzFormat || &#x27;&#x27;);
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid = false;
	    }
	}

	// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	    var result = [
	        untruncateYear(yearStr),
	        defaultLocaleMonthsShort.indexOf(monthStr),
	        parseInt(dayStr, 10),
	        parseInt(hourStr, 10),
	        parseInt(minuteStr, 10)
	    ];

	    if (secondStr) {
	        result.push(parseInt(secondStr, 10));
	    }

	    return result;
	}

	function untruncateYear(yearStr) {
	    var year = parseInt(yearStr, 10);
	    if (year &lt;= 49) {
	        return 2000 + year;
	    } else if (year &lt;= 999) {
	        return 1900 + year;
	    }
	    return year;
	}

	function preprocessRFC2822(s) {
	    // Remove comments and folding whitespace and replace multiple-spaces with a single space
	    return s.replace(/\([^)]*\)|[\n\t]/g, &#x27; &#x27;).replace(/(\s\s+)/g, &#x27; &#x27;).trim();
	}

	function checkWeekday(weekdayStr, parsedInput, config) {
	    if (weekdayStr) {
	        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
	        if (weekdayProvided !== weekdayActual) {
	            getParsingFlags(config).weekdayMismatch = true;
	            config._isValid = false;
	            return false;
	        }
	    }
	    return true;
	}

	var obsOffsets = {
	    UT: 0,
	    GMT: 0,
	    EDT: -4 * 60,
	    EST: -5 * 60,
	    CDT: -5 * 60,
	    CST: -6 * 60,
	    MDT: -6 * 60,
	    MST: -7 * 60,
	    PDT: -7 * 60,
	    PST: -8 * 60
	};

	function calculateOffset(obsOffset, militaryOffset, numOffset) {
	    if (obsOffset) {
	        return obsOffsets[obsOffset];
	    } else if (militaryOffset) {
	        // the only allowed military tz is Z
	        return 0;
	    } else {
	        var hm = parseInt(numOffset, 10);
	        var m = hm % 100, h = (hm - m) / 100;
	        return h * 60 + m;
	    }
	}

	// date and time from ref 2822 format
	function configFromRFC2822(config) {
	    var match = rfc2822.exec(preprocessRFC2822(config._i));
	    if (match) {
	        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
	        if (!checkWeekday(match[1], parsedArray, config)) {
	            return;
	        }

	        config._a = parsedArray;
	        config._tzm = calculateOffset(match[8], match[9], match[10]);

	        config._d = createUTCDate.apply(null, config._a);
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	        getParsingFlags(config).rfc2822 = true;
	    } else {
	        config._isValid = false;
	    }
	}

	// date from iso format or fallback
	function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);

	    if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	    }

	    configFromISO(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    configFromRFC2822(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    // Final attempt, use Input Fallback
	    hooks.createFromInputFallback(config);
	}

	hooks.createFromInputFallback = deprecate(
	    &#x27;value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), &#x27; +
	    &#x27;which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are &#x27; +
	    &#x27;discouraged and will be removed in an upcoming major release. Please refer to &#x27; +
	    &#x27;http://momentjs.com/guides/#/warnings/js-date/ for more info.&#x27;,
	    function (config) {
	        config._d = new Date(config._i + (config._useUTC ? &#x27; UTC&#x27; : &#x27;&#x27;));
	    }
	);

	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};

	// constant that refers to the RFC 2822 form
	hooks.RFC_2822 = function () {};

	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }
	    if (config._f === hooks.RFC_2822) {
	        configFromRFC2822(config);
	        return;
	    }
	    config._a = [];
	    getParsingFlags(config).empty = true;

	    // This array is used to make a Date, either with &#x60;new Date&#x60; or &#x60;Date.UTC&#x60;
	    var string = &#x27;&#x27; + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;

	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	    for (i = 0; i &lt; tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log(&#x27;token&#x27;, token, &#x27;parsedInput&#x27;, parsedInput,
	        //         &#x27;regex&#x27;, getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped = string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length &gt; 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength += parsedInput.length;
	        }
	        // don&#x27;t parse if it&#x27;s not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty = false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict &amp;&amp; !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }

	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	    if (string.length &gt; 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }

	    // clear _12h flag if hour is &lt;= 12
	    if (config._a[HOUR] &lt;= 12 &amp;&amp;
	        getParsingFlags(config).bigHour === true &amp;&amp;
	        config._a[HOUR] &gt; 0) {
	        getParsingFlags(config).bigHour = undefined;
	    }

	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem;
	    // handle meridiem
	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	    configFromArray(config);
	    checkOverflow(config);
	}


	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;

	    if (meridiem == null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);
	        if (isPm &amp;&amp; hour &lt; 12) {
	            hour += 12;
	        }
	        if (!isPm &amp;&amp; hour === 12) {
	            hour = 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}

	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,

	        scoreToBeat,
	        i,
	        currentScore;

	    if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	    }

	    for (i = 0; i &lt; config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);
	        if (config._useUTC != null) {
	            tempConfig._useUTC = config._useUTC;
	        }
	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);

	        if (!isValid(tempConfig)) {
	            continue;
	        }

	        // if there is any input that was not parsed add a penalty for that format
	        currentScore += getParsingFlags(tempConfig).charsLeftOver;

	        //or tokens
	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	        getParsingFlags(tempConfig).score = currentScore;

	        if (scoreToBeat == null || currentScore &lt; scoreToBeat) {
	            scoreToBeat = currentScore;
	            bestMoment = tempConfig;
	        }
	    }

	    extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }

	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj &amp;&amp; parseInt(obj, 10);
	    });

	    configFromArray(config);
	}

	function createFromConfig (config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, &#x27;d&#x27;);
	        res._nextDay = undefined;
	    }

	    return res;
	}

	function prepareConfig (config) {
	    var input = config._i,
	        format = config._f;

	    config._locale = config._locale || getLocale(config._l);

	    if (input === null || (format === undefined &amp;&amp; input === &#x27;&#x27;)) {
	        return createInvalid({nullInput: true});
	    }

	    if (typeof input === &#x27;string&#x27;) {
	        config._i = input = config._locale.preparse(input);
	    }

	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d = input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }

	    if (!isValid(config)) {
	        config._d = null;
	    }

	    return config;
	}

	function configFromInput(config) {
	    var input = config._i;
	    if (isUndefined(input)) {
	        config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	    } else if (typeof input === &#x27;string&#x27;) {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (isObject(input)) {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}

	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c = {};

	    if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	    }

	    if ((isObject(input) &amp;&amp; isObjectEmpty(input)) ||
	            (isArray(input) &amp;&amp; input.length === 0)) {
	        input = undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;

	    return createFromConfig(c);
	}

	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin = deprecate(
	    &#x27;moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/&#x27;,
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() &amp;&amp; other.isValid()) {
	            return other &lt; this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	var prototypeMax = deprecate(
	    &#x27;moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/&#x27;,
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() &amp;&amp; other.isValid()) {
	            return other &gt; this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length === 1 &amp;&amp; isArray(moments[0])) {
	        moments = moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res = moments[0];
	    for (i = 1; i &lt; moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res = moments[i];
	        }
	    }
	    return res;
	}

	// TODO: Use [].sort instead?
	function min () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy(&#x27;isBefore&#x27;, args);
	}

	function max () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy(&#x27;isAfter&#x27;, args);
	}

	var now = function () {
	    return Date.now ? Date.now() : +(new Date());
	};

	var ordering = [&#x27;year&#x27;, &#x27;quarter&#x27;, &#x27;month&#x27;, &#x27;week&#x27;, &#x27;day&#x27;, &#x27;hour&#x27;, &#x27;minute&#x27;, &#x27;second&#x27;, &#x27;millisecond&#x27;];

	function isDurationValid(m) {
	    for (var key in m) {
	        if (!(indexOf.call(ordering, key) !== -1 &amp;&amp; (m[key] == null || !isNaN(m[key])))) {
	            return false;
	        }
	    }

	    var unitHasDecimal = false;
	    for (var i = 0; i &lt; ordering.length; ++i) {
	        if (m[ordering[i]]) {
	            if (unitHasDecimal) {
	                return false; // only allow non-integers for smallest unit
	            }
	            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	                unitHasDecimal = true;
	            }
	        }
	    }

	    return true;
	}

	function isValid$1() {
	    return this._isValid;
	}

	function createInvalid$1() {
	    return createDuration(NaN);
	}

	function Duration (duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;

	    this._isValid = isDurationValid(normalizedInput);

	    // representation for dateAddRemove
	    this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days = +days +
	        weeks * 7;
	    // It is impossible to translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months = +months +
	        quarters * 3 +
	        years * 12;

	    this._data = {};

	    this._locale = getLocale();

	    this._bubble();
	}

	function isDuration (obj) {
	    return obj instanceof Duration;
	}

	function absRound (number) {
	    if (number &lt; 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}

	// FORMATTING

	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = &#x27;+&#x27;;
	        if (offset &lt; 0) {
	            offset = -offset;
	            sign = &#x27;-&#x27;;
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}

	offset(&#x27;Z&#x27;, &#x27;:&#x27;);
	offset(&#x27;ZZ&#x27;, &#x27;&#x27;);

	// PARSING

	addRegexToken(&#x27;Z&#x27;,  matchShortOffset);
	addRegexToken(&#x27;ZZ&#x27;, matchShortOffset);
	addParseToken([&#x27;Z&#x27;, &#x27;ZZ&#x27;], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	});

	// HELPERS

	// timezone chunker
	// &#x27;+10:00&#x27; &gt; [&#x27;10&#x27;,  &#x27;00&#x27;]
	// &#x27;-1530&#x27;  &gt; [&#x27;-15&#x27;, &#x27;30&#x27;]
	var chunkOffset = /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
	    var matches = (string || &#x27;&#x27;).match(matcher);

	    if (matches === null) {
	        return null;
	    }

	    var chunk   = matches[matches.length - 1] || [];
	    var parts   = (chunk + &#x27;&#x27;).match(chunkOffset) || [&#x27;-&#x27;, 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);

	    return minutes === 0 ?
	      0 :
	      parts[0] === &#x27;+&#x27; ? minutes : -minutes;
	}

	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}

	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

	// HOOKS

	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};

	// MOMENTS

	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--&gt;
	// 5:31:26 +0200 It is possible that 5:31:26 doesn&#x27;t exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime, keepMinutes) {
	    var offset = this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    if (input != null) {
	        if (typeof input === &#x27;string&#x27;) {
	            input = offsetFromString(matchShortOffset, input);
	            if (input === null) {
	                return this;
	            }
	        } else if (Math.abs(input) &lt; 16 &amp;&amp; !keepMinutes) {
	            input = input * 60;
	        }
	        if (!this._isUTC &amp;&amp; keepLocalTime) {
	            localAdjust = getDateOffset(this);
	        }
	        this._offset = input;
	        this._isUTC = true;
	        if (localAdjust != null) {
	            this.add(localAdjust, &#x27;m&#x27;);
	        }
	        if (offset !== input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, &#x27;m&#x27;), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress = true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress = null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}

	function getSetZone (input, keepLocalTime) {
	    if (input != null) {
	        if (typeof input !== &#x27;string&#x27;) {
	            input = -input;
	        }

	        this.utcOffset(input, keepLocalTime);

	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}

	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;

	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), &#x27;m&#x27;);
	        }
	    }
	    return this;
	}

	function setOffsetToParsedOffset () {
	    if (this._tzm != null) {
	        this.utcOffset(this._tzm, false, true);
	    } else if (typeof this._i === &#x27;string&#x27;) {
	        var tZone = offsetFromString(matchOffset, this._i);
	        if (tZone != null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}

	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input = input ? createLocal(input).utcOffset() : 0;

	    return (this.utcOffset() - input) % 60 === 0;
	}

	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() &gt; this.clone().month(0).utcOffset() ||
	        this.utcOffset() &gt; this.clone().month(5).utcOffset()
	    );
	}

	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }

	    var c = {};

	    copyConfig(c, this);
	    c = prepareConfig(c);

	    if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() &amp;&amp;
	            compareArrays(c._a, other.toArray()) &gt; 0;
	    } else {
	        this._isDSTShifted = false;
	    }

	    return this._isDSTShifted;
	}

	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}

	function isUtc () {
	    return this.isValid() ? this._isUTC &amp;&amp; this._offset === 0 : false;
	}

	// ASP.NET json date format regex
	var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	function createDuration (input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	        match = null,
	        sign,
	        ret,
	        diffRes;

	    if (isDuration(input)) {
	        duration = {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration = {};
	        if (key) {
	            duration[key] = input;
	        } else {
	            duration.milliseconds = input;
	        }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = (match[1] === &#x27;-&#x27;) ? -1 : 1;
	        duration = {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match = isoRegex.exec(input))) {
	        sign = (match[1] === &#x27;-&#x27;) ? -1 : (match[1] === &#x27;+&#x27;) ? 1 : 1;
	        duration = {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration == null) {// checks for null or undefined
	        duration = {};
	    } else if (typeof duration === &#x27;object&#x27; &amp;&amp; (&#x27;from&#x27; in duration || &#x27;to&#x27; in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	    }

	    ret = new Duration(duration);

	    if (isDuration(input) &amp;&amp; hasOwnProp(input, &#x27;_locale&#x27;)) {
	        ret._locale = input._locale;
	    }

	    return ret;
	}

	createDuration.fn = Duration.prototype;
	createDuration.invalid = createInvalid$1;

	function parseIso (inp, sign) {
	    // We&#x27;d normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp &amp;&amp; parseFloat(inp.replace(&#x27;,&#x27;, &#x27;.&#x27;));
	    // apply sign while we&#x27;re at it
	    return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
	    var res = {milliseconds: 0, months: 0};

	    res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, &#x27;M&#x27;).isAfter(other)) {
	        --res.months;
	    }

	    res.milliseconds = +other - +(base.clone().add(res.months, &#x27;M&#x27;));

	    return res;
	}

	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() &amp;&amp; other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }

	    other = cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	    } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	    }

	    return res;
	}

	// TODO: remove &#x27;name&#x27; arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !== null &amp;&amp; !isNaN(+period)) {
	            deprecateSimple(name, &#x27;moment().&#x27; + name  + &#x27;(period, number) is deprecated. Please use moment().&#x27; + name + &#x27;(number, period). &#x27; +
	            &#x27;See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.&#x27;);
	            tmp = val; val = period; period = tmp;
	        }

	        val = typeof val === &#x27;string&#x27; ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}

	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);

	    if (!mom.isValid()) {
	        // No op
	        return;
	    }

	    updateOffset = updateOffset == null ? true : updateOffset;

	    if (months) {
	        setMonth(mom, get(mom, &#x27;Month&#x27;) + months * isAdding);
	    }
	    if (days) {
	        set$1(mom, &#x27;Date&#x27;, get(mom, &#x27;Date&#x27;) + days * isAdding);
	    }
	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}

	var add      = createAdder(1, &#x27;add&#x27;);
	var subtract = createAdder(-1, &#x27;subtract&#x27;);

	function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, &#x27;days&#x27;, true);
	    return diff &lt; -6 ? &#x27;sameElse&#x27; :
	            diff &lt; -1 ? &#x27;lastWeek&#x27; :
	            diff &lt; 0 ? &#x27;lastDay&#x27; :
	            diff &lt; 1 ? &#x27;sameDay&#x27; :
	            diff &lt; 2 ? &#x27;nextDay&#x27; :
	            diff &lt; 7 ? &#x27;nextWeek&#x27; : &#x27;sameElse&#x27;;
	}

	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we&#x27;re local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf(&#x27;day&#x27;),
	        format = hooks.calendarFormat(this, sod) || &#x27;sameElse&#x27;;

	    var output = formats &amp;&amp; (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}

	function clone () {
	    return new Moment(this);
	}

	function isAfter (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() &amp;&amp; localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : &#x27;millisecond&#x27;);
	    if (units === &#x27;millisecond&#x27;) {
	        return this.valueOf() &gt; localInput.valueOf();
	    } else {
	        return localInput.valueOf() &lt; this.clone().startOf(units).valueOf();
	    }
	}

	function isBefore (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() &amp;&amp; localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : &#x27;millisecond&#x27;);
	    if (units === &#x27;millisecond&#x27;) {
	        return this.valueOf() &lt; localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() &lt; localInput.valueOf();
	    }
	}

	function isBetween (from, to, units, inclusivity) {
	    inclusivity = inclusivity || &#x27;()&#x27;;
	    return (inclusivity[0] === &#x27;(&#x27; ? this.isAfter(from, units) : !this.isBefore(from, units)) &amp;&amp;
	        (inclusivity[1] === &#x27;)&#x27; ? this.isBefore(to, units) : !this.isAfter(to, units));
	}

	function isSame (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() &amp;&amp; localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units || &#x27;millisecond&#x27;);
	    if (units === &#x27;millisecond&#x27;) {
	        return this.valueOf() === localInput.valueOf();
	    } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() &lt;= inputMs &amp;&amp; inputMs &lt;= this.clone().endOf(units).valueOf();
	    }
	}

	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input,units);
	}

	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input,units);
	}

	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        output;

	    if (!this.isValid()) {
	        return NaN;
	    }

	    that = cloneWithOffset(input, this);

	    if (!that.isValid()) {
	        return NaN;
	    }

	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	    units = normalizeUnits(units);

	    switch (units) {
	        case &#x27;year&#x27;: output = monthDiff(this, that) / 12; break;
	        case &#x27;month&#x27;: output = monthDiff(this, that); break;
	        case &#x27;quarter&#x27;: output = monthDiff(this, that) / 3; break;
	        case &#x27;second&#x27;: output = (this - that) / 1e3; break; // 1000
	        case &#x27;minute&#x27;: output = (this - that) / 6e4; break; // 1000 * 60
	        case &#x27;hour&#x27;: output = (this - that) / 36e5; break; // 1000 * 60 * 60
	        case &#x27;day&#x27;: output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
	        case &#x27;week&#x27;: output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
	        default: output = this - that;
	    }

	    return asFloat ? output : absFloor(output);
	}

	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor = a.clone().add(wholeMonthDiff, &#x27;months&#x27;),
	        anchor2, adjust;

	    if (b - anchor &lt; 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, &#x27;months&#x27;);
	        // linear across the month
	        adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, &#x27;months&#x27;);
	        // linear across the month
	        adjust = (b - anchor) / (anchor2 - anchor);
	    }

	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}

	hooks.defaultFormat = &#x27;YYYY-MM-DDTHH:mm:ssZ&#x27;;
	hooks.defaultFormatUtc = &#x27;YYYY-MM-DDTHH:mm:ss[Z]&#x27;;

	function toString () {
	    return this.clone().locale(&#x27;en&#x27;).format(&#x27;ddd MMM DD YYYY HH:mm:ss [GMT]ZZ&#x27;);
	}

	function toISOString(keepOffset) {
	    if (!this.isValid()) {
	        return null;
	    }
	    var utc = keepOffset !== true;
	    var m = utc ? this.clone().utc() : this;
	    if (m.year() &lt; 0 || m.year() &gt; 9999) {
	        return formatMoment(m, utc ? &#x27;YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]&#x27; : &#x27;YYYYYY-MM-DD[T]HH:mm:ss.SSSZ&#x27;);
	    }
	    if (isFunction(Date.prototype.toISOString)) {
	        // native implementation is ~50x faster, use it when we can
	        if (utc) {
	            return this.toDate().toISOString();
	        } else {
	            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace(&#x27;Z&#x27;, formatMoment(m, &#x27;Z&#x27;));
	        }
	    }
	    return formatMoment(m, utc ? &#x27;YYYY-MM-DD[T]HH:mm:ss.SSS[Z]&#x27; : &#x27;YYYY-MM-DD[T]HH:mm:ss.SSSZ&#x27;);
	}

	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return &#x27;moment.invalid(/* &#x27; + this._i + &#x27; */)&#x27;;
	    }
	    var func = &#x27;moment&#x27;;
	    var zone = &#x27;&#x27;;
	    if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? &#x27;moment.utc&#x27; : &#x27;moment.parseZone&#x27;;
	        zone = &#x27;Z&#x27;;
	    }
	    var prefix = &#x27;[&#x27; + func + &#x27;(&quot;]&#x27;;
	    var year = (0 &lt;= this.year() &amp;&amp; this.year() &lt;= 9999) ? &#x27;YYYY&#x27; : &#x27;YYYYYY&#x27;;
	    var datetime = &#x27;-MM-DD[T]HH:mm:ss.SSS&#x27;;
	    var suffix = zone + &#x27;[&quot;)]&#x27;;

	    return this.format(prefix + year + datetime + suffix);
	}

	function format (inputString) {
	    if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}

	function from (time, withoutSuffix) {
	    if (this.isValid() &amp;&amp;
	            ((isMoment(time) &amp;&amp; time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}

	function to (time, withoutSuffix) {
	    if (this.isValid() &amp;&amp;
	            ((isMoment(time) &amp;&amp; time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}

	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;

	    if (key === undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData = getLocale(key);
	        if (newLocaleData != null) {
	            this._locale = newLocaleData;
	        }
	        return this;
	    }
	}

	var lang = deprecate(
	    &#x27;moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.&#x27;,
	    function (key) {
	        if (key === undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);

	function localeData () {
	    return this._locale;
	}

	function startOf (units) {
	    units = normalizeUnits(units);
	    // the following switch intentionally omits break keywords
	    // to utilize falling through the cases.
	    switch (units) {
	        case &#x27;year&#x27;:
	            this.month(0);
	            /* falls through */
	        case &#x27;quarter&#x27;:
	        case &#x27;month&#x27;:
	            this.date(1);
	            /* falls through */
	        case &#x27;week&#x27;:
	        case &#x27;isoWeek&#x27;:
	        case &#x27;day&#x27;:
	        case &#x27;date&#x27;:
	            this.hours(0);
	            /* falls through */
	        case &#x27;hour&#x27;:
	            this.minutes(0);
	            /* falls through */
	        case &#x27;minute&#x27;:
	            this.seconds(0);
	            /* falls through */
	        case &#x27;second&#x27;:
	            this.milliseconds(0);
	    }

	    // weeks are a special case
	    if (units === &#x27;week&#x27;) {
	        this.weekday(0);
	    }
	    if (units === &#x27;isoWeek&#x27;) {
	        this.isoWeekday(1);
	    }

	    // quarters are also special
	    if (units === &#x27;quarter&#x27;) {
	        this.month(Math.floor(this.month() / 3) * 3);
	    }

	    return this;
	}

	function endOf (units) {
	    units = normalizeUnits(units);
	    if (units === undefined || units === &#x27;millisecond&#x27;) {
	        return this;
	    }

	    // &#x27;date&#x27; is an alias for &#x27;day&#x27;, so it should be considered as such.
	    if (units === &#x27;date&#x27;) {
	        units = &#x27;day&#x27;;
	    }

	    return this.startOf(units).add(1, (units === &#x27;isoWeek&#x27; ? &#x27;week&#x27; : units)).subtract(1, &#x27;ms&#x27;);
	}

	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}

	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}

	function toDate () {
	    return new Date(this.valueOf());
	}

	function toArray () {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject () {
	    var m = this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}

	function toJSON () {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	}

	function isValid$2 () {
	    return isValid(this);
	}

	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}

	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}

	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}

	// FORMATTING

	addFormatToken(0, [&#x27;gg&#x27;, 2], 0, function () {
	    return this.weekYear() % 100;
	});

	addFormatToken(0, [&#x27;GG&#x27;, 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken(&#x27;gggg&#x27;,     &#x27;weekYear&#x27;);
	addWeekYearFormatToken(&#x27;ggggg&#x27;,    &#x27;weekYear&#x27;);
	addWeekYearFormatToken(&#x27;GGGG&#x27;,  &#x27;isoWeekYear&#x27;);
	addWeekYearFormatToken(&#x27;GGGGG&#x27;, &#x27;isoWeekYear&#x27;);

	// ALIASES

	addUnitAlias(&#x27;weekYear&#x27;, &#x27;gg&#x27;);
	addUnitAlias(&#x27;isoWeekYear&#x27;, &#x27;GG&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;weekYear&#x27;, 1);
	addUnitPriority(&#x27;isoWeekYear&#x27;, 1);


	// PARSING

	addRegexToken(&#x27;G&#x27;,      matchSigned);
	addRegexToken(&#x27;g&#x27;,      matchSigned);
	addRegexToken(&#x27;GG&#x27;,     match1to2, match2);
	addRegexToken(&#x27;gg&#x27;,     match1to2, match2);
	addRegexToken(&#x27;GGGG&#x27;,   match1to4, match4);
	addRegexToken(&#x27;gggg&#x27;,   match1to4, match4);
	addRegexToken(&#x27;GGGGG&#x27;,  match1to6, match6);
	addRegexToken(&#x27;ggggg&#x27;,  match1to6, match6);

	addWeekParseToken([&#x27;gggg&#x27;, &#x27;ggggg&#x27;, &#x27;GGGG&#x27;, &#x27;GGGGG&#x27;], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	});

	addWeekParseToken([&#x27;gg&#x27;, &#x27;GG&#x27;], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	});

	// MOMENTS

	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}

	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear () {
	    var weekInfo = this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget = weeksInYear(input, dow, doy);
	        if (week &gt; weeksTarget) {
	            week = weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}

	// FORMATTING

	addFormatToken(&#x27;Q&#x27;, 0, &#x27;Qo&#x27;, &#x27;quarter&#x27;);

	// ALIASES

	addUnitAlias(&#x27;quarter&#x27;, &#x27;Q&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;quarter&#x27;, 7);

	// PARSING

	addRegexToken(&#x27;Q&#x27;, match1);
	addParseToken(&#x27;Q&#x27;, function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	});

	// MOMENTS

	function getSetQuarter (input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

	// FORMATTING

	addFormatToken(&#x27;D&#x27;, [&#x27;DD&#x27;, 2], &#x27;Do&#x27;, &#x27;date&#x27;);

	// ALIASES

	addUnitAlias(&#x27;date&#x27;, &#x27;D&#x27;);

	// PRIOROITY
	addUnitPriority(&#x27;date&#x27;, 9);

	// PARSING

	addRegexToken(&#x27;D&#x27;,  match1to2);
	addRegexToken(&#x27;DD&#x27;, match1to2, match2);
	addRegexToken(&#x27;Do&#x27;, function (isStrict, locale) {
	    // TODO: Remove &quot;ordinalParse&quot; fallback in next major release.
	    return isStrict ?
	      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
	      locale._dayOfMonthOrdinalParseLenient;
	});

	addParseToken([&#x27;D&#x27;, &#x27;DD&#x27;], DATE);
	addParseToken(&#x27;Do&#x27;, function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0]);
	});

	// MOMENTS

	var getSetDayOfMonth = makeGetSet(&#x27;Date&#x27;, true);

	// FORMATTING

	addFormatToken(&#x27;DDD&#x27;, [&#x27;DDDD&#x27;, 3], &#x27;DDDo&#x27;, &#x27;dayOfYear&#x27;);

	// ALIASES

	addUnitAlias(&#x27;dayOfYear&#x27;, &#x27;DDD&#x27;);

	// PRIORITY
	addUnitPriority(&#x27;dayOfYear&#x27;, 4);

	// PARSING

	addRegexToken(&#x27;DDD&#x27;,  match1to3);
	addRegexToken(&#x27;DDDD&#x27;, match3);
	addParseToken([&#x27;DDD&#x27;, &#x27;DDDD&#x27;], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	});

	// HELPERS

	// MOMENTS

	function getSetDayOfYear (input) {
	    var dayOfYear = Math.round((this.clone().startOf(&#x27;day&#x27;) - this.clone().startOf(&#x27;year&#x27;)) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add((input - dayOfYear), &#x27;d&#x27;);
	}

	// FORMATTING

	addFormatToken(&#x27;m&#x27;, [&#x27;mm&#x27;, 2], 0, &#x27;minute&#x27;);

	// ALIASES

	addUnitAlias(&#x27;minute&#x27;, &#x27;m&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;minute&#x27;, 14);

	// PARSING

	addRegexToken(&#x27;m&#x27;,  match1to2);
	addRegexToken(&#x27;mm&#x27;, match1to2, match2);
	addParseToken([&#x27;m&#x27;, &#x27;mm&#x27;], MINUTE);

	// MOMENTS

	var getSetMinute = makeGetSet(&#x27;Minutes&#x27;, false);

	// FORMATTING

	addFormatToken(&#x27;s&#x27;, [&#x27;ss&#x27;, 2], 0, &#x27;second&#x27;);

	// ALIASES

	addUnitAlias(&#x27;second&#x27;, &#x27;s&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;second&#x27;, 15);

	// PARSING

	addRegexToken(&#x27;s&#x27;,  match1to2);
	addRegexToken(&#x27;ss&#x27;, match1to2, match2);
	addParseToken([&#x27;s&#x27;, &#x27;ss&#x27;], SECOND);

	// MOMENTS

	var getSetSecond = makeGetSet(&#x27;Seconds&#x27;, false);

	// FORMATTING

	addFormatToken(&#x27;S&#x27;, 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, [&#x27;SS&#x27;, 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, [&#x27;SSS&#x27;, 3], 0, &#x27;millisecond&#x27;);
	addFormatToken(0, [&#x27;SSSS&#x27;, 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, [&#x27;SSSSS&#x27;, 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, [&#x27;SSSSSS&#x27;, 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, [&#x27;SSSSSSS&#x27;, 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, [&#x27;SSSSSSSS&#x27;, 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, [&#x27;SSSSSSSSS&#x27;, 9], 0, function () {
	    return this.millisecond() * 1000000;
	});


	// ALIASES

	addUnitAlias(&#x27;millisecond&#x27;, &#x27;ms&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;millisecond&#x27;, 16);

	// PARSING

	addRegexToken(&#x27;S&#x27;,    match1to3, match1);
	addRegexToken(&#x27;SS&#x27;,   match1to3, match2);
	addRegexToken(&#x27;SSS&#x27;,  match1to3, match3);

	var token;
	for (token = &#x27;SSSS&#x27;; token.length &lt;= 9; token += &#x27;S&#x27;) {
	    addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
	    array[MILLISECOND] = toInt((&#x27;0.&#x27; + input) * 1000);
	}

	for (token = &#x27;S&#x27;; token.length &lt;= 9; token += &#x27;S&#x27;) {
	    addParseToken(token, parseMs);
	}
	// MOMENTS

	var getSetMillisecond = makeGetSet(&#x27;Milliseconds&#x27;, false);

	// FORMATTING

	addFormatToken(&#x27;z&#x27;,  0, 0, &#x27;zoneAbbr&#x27;);
	addFormatToken(&#x27;zz&#x27;, 0, 0, &#x27;zoneName&#x27;);

	// MOMENTS

	function getZoneAbbr () {
	    return this._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;;
	}

	function getZoneName () {
	    return this._isUTC ? &#x27;Coordinated Universal Time&#x27; : &#x27;&#x27;;
	}

	var proto = Moment.prototype;

	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$2;
	proto.lang              = lang;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;
	proto.quarter = proto.quarters = getSetQuarter;
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;
	proto.hour = proto.hours = getSetHour;
	proto.minute = proto.minutes = getSetMinute;
	proto.second = proto.seconds = getSetSecond;
	proto.millisecond = proto.milliseconds = getSetMillisecond;
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;
	proto.dates  = deprecate(&#x27;dates accessor is deprecated. Use date instead.&#x27;, getSetDayOfMonth);
	proto.months = deprecate(&#x27;months accessor is deprecated. Use month instead&#x27;, getSetMonth);
	proto.years  = deprecate(&#x27;years accessor is deprecated. Use year instead&#x27;, getSetYear);
	proto.zone   = deprecate(&#x27;moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/&#x27;, getSetZone);
	proto.isDSTShifted = deprecate(&#x27;isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information&#x27;, isDaylightSavingTimeShifted);

	function createUnix (input) {
	    return createLocal(input * 1000);
	}

	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}

	function preParsePostFormat (string) {
	    return string;
	}

	var proto$1 = Locale.prototype;

	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;

	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;

	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;

	function get$1 (format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	}

	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index = format;
	        format = undefined;
	    }

	    format = format || &#x27;&#x27;;

	    if (index != null) {
	        return get$1(format, index, field, &#x27;month&#x27;);
	    }

	    var i;
	    var out = [];
	    for (i = 0; i &lt; 12; i++) {
	        out[i] = get$1(format, i, field, &#x27;month&#x27;);
	    }
	    return out;
	}

	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted === &#x27;boolean&#x27;) {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || &#x27;&#x27;;
	    } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;

	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || &#x27;&#x27;;
	    }

	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;

	    if (index != null) {
	        return get$1(format, (index + shift) % 7, field, &#x27;day&#x27;);
	    }

	    var i;
	    var out = [];
	    for (i = 0; i &lt; 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, &#x27;day&#x27;);
	    }
	    return out;
	}

	function listMonths (format, index) {
	    return listMonthsImpl(format, index, &#x27;months&#x27;);
	}

	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, &#x27;monthsShort&#x27;);
	}

	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, &#x27;weekdays&#x27;);
	}

	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, &#x27;weekdaysShort&#x27;);
	}

	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, &#x27;weekdaysMin&#x27;);
	}

	getSetGlobalLocale(&#x27;en&#x27;, {
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (toInt(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    }
	});

	// Side effect imports

	hooks.lang = deprecate(&#x27;moment.lang is deprecated. Use moment.locale instead.&#x27;, getSetGlobalLocale);
	hooks.langData = deprecate(&#x27;moment.langData is deprecated. Use moment.localeData instead.&#x27;, getLocale);

	var mathAbs = Math.abs;

	function abs () {
	    var data           = this._data;

	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days         = mathAbs(this._days);
	    this._months       = mathAbs(this._months);

	    data.milliseconds  = mathAbs(data.milliseconds);
	    data.seconds       = mathAbs(data.seconds);
	    data.minutes       = mathAbs(data.minutes);
	    data.hours         = mathAbs(data.hours);
	    data.months        = mathAbs(data.months);
	    data.years         = mathAbs(data.years);

	    return this;
	}

	function addSubtract$1 (duration, input, value, direction) {
	    var other = createDuration(input, value);

	    duration._milliseconds += direction * other._milliseconds;
	    duration._days         += direction * other._days;
	    duration._months       += direction * other._months;

	    return duration._bubble();
	}

	// supports only 2.0-style add(1, &#x27;s&#x27;) or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}

	// supports only 2.0-style subtract(1, &#x27;s&#x27;) or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}

	function absCeil (number) {
	    if (number &lt; 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}

	function bubble () {
	    var milliseconds = this._milliseconds;
	    var days         = this._days;
	    var months       = this._months;
	    var data         = this._data;
	    var seconds, minutes, hours, years, monthsFromDays;

	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds &gt;= 0 &amp;&amp; days &gt;= 0 &amp;&amp; months &gt;= 0) ||
	            (milliseconds &lt;= 0 &amp;&amp; days &lt;= 0 &amp;&amp; months &lt;= 0))) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	    }

	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds = milliseconds % 1000;

	    seconds           = absFloor(milliseconds / 1000);
	    data.seconds      = seconds % 60;

	    minutes           = absFloor(seconds / 60);
	    data.minutes      = minutes % 60;

	    hours             = absFloor(minutes / 60);
	    data.hours        = hours % 24;

	    days += absFloor(hours / 24);

	    // convert days to months
	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays));

	    // 12 months -&gt; 1 year
	    years = absFloor(months / 12);
	    months %= 12;

	    data.days   = days;
	    data.months = months;
	    data.years  = years;

	    return this;
	}

	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	}

	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}

	function as (units) {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    var days;
	    var months;
	    var milliseconds = this._milliseconds;

	    units = normalizeUnits(units);

	    if (units === &#x27;month&#x27; || units === &#x27;year&#x27;) {
	        days   = this._days   + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);
	        return units === &#x27;month&#x27; ? months : months / 12;
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case &#x27;week&#x27;   : return days / 7     + milliseconds / 6048e5;
	            case &#x27;day&#x27;    : return days         + milliseconds / 864e5;
	            case &#x27;hour&#x27;   : return days * 24    + milliseconds / 36e5;
	            case &#x27;minute&#x27; : return days * 1440  + milliseconds / 6e4;
	            case &#x27;second&#x27; : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case &#x27;millisecond&#x27;: return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error(&#x27;Unknown unit &#x27; + units);
	        }
	    }
	}

	// TODO: Use this.as(&#x27;ms&#x27;)?
	function valueOf$1 () {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}

	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}

	var asMilliseconds = makeAs(&#x27;ms&#x27;);
	var asSeconds      = makeAs(&#x27;s&#x27;);
	var asMinutes      = makeAs(&#x27;m&#x27;);
	var asHours        = makeAs(&#x27;h&#x27;);
	var asDays         = makeAs(&#x27;d&#x27;);
	var asWeeks        = makeAs(&#x27;w&#x27;);
	var asMonths       = makeAs(&#x27;M&#x27;);
	var asYears        = makeAs(&#x27;y&#x27;);

	function clone$1 () {
	    return createDuration(this);
	}

	function get$2 (units) {
	    units = normalizeUnits(units);
	    return this.isValid() ? this[units + &#x27;s&#x27;]() : NaN;
	}

	function makeGetter(name) {
	    return function () {
	        return this.isValid() ? this._data[name] : NaN;
	    };
	}

	var milliseconds = makeGetter(&#x27;milliseconds&#x27;);
	var seconds      = makeGetter(&#x27;seconds&#x27;);
	var minutes      = makeGetter(&#x27;minutes&#x27;);
	var hours        = makeGetter(&#x27;hours&#x27;);
	var days         = makeGetter(&#x27;days&#x27;);
	var months       = makeGetter(&#x27;months&#x27;);
	var years        = makeGetter(&#x27;years&#x27;);

	function weeks () {
	    return absFloor(this.days() / 7);
	}

	var round = Math.round;
	var thresholds = {
	    ss: 44,         // a few seconds to seconds
	    s : 45,         // seconds to minute
	    m : 45,         // minutes to hour
	    h : 22,         // hours to day
	    d : 26,         // days to month
	    M : 11          // months to year
	};

	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds  = round(duration.as(&#x27;s&#x27;));
	    var minutes  = round(duration.as(&#x27;m&#x27;));
	    var hours    = round(duration.as(&#x27;h&#x27;));
	    var days     = round(duration.as(&#x27;d&#x27;));
	    var months   = round(duration.as(&#x27;M&#x27;));
	    var years    = round(duration.as(&#x27;y&#x27;));

	    var a = seconds &lt;= thresholds.ss &amp;&amp; [&#x27;s&#x27;, seconds]  ||
	            seconds &lt; thresholds.s   &amp;&amp; [&#x27;ss&#x27;, seconds] ||
	            minutes &lt;= 1             &amp;&amp; [&#x27;m&#x27;]           ||
	            minutes &lt; thresholds.m   &amp;&amp; [&#x27;mm&#x27;, minutes] ||
	            hours   &lt;= 1             &amp;&amp; [&#x27;h&#x27;]           ||
	            hours   &lt; thresholds.h   &amp;&amp; [&#x27;hh&#x27;, hours]   ||
	            days    &lt;= 1             &amp;&amp; [&#x27;d&#x27;]           ||
	            days    &lt; thresholds.d   &amp;&amp; [&#x27;dd&#x27;, days]    ||
	            months  &lt;= 1             &amp;&amp; [&#x27;M&#x27;]           ||
	            months  &lt; thresholds.M   &amp;&amp; [&#x27;MM&#x27;, months]  ||
	            years   &lt;= 1             &amp;&amp; [&#x27;y&#x27;]           || [&#x27;yy&#x27;, years];

	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration &gt; 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	}

	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction === undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) === &#x27;function&#x27;) {
	        round = roundingFunction;
	        return true;
	    }
	    return false;
	}

	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	        return false;
	    }
	    if (limit === undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] = limit;
	    if (threshold === &#x27;s&#x27;) {
	        thresholds.ss = limit - 1;
	    }
	    return true;
	}

	function humanize (withSuffix) {
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);

	    if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	    }

	    return locale.postformat(output);
	}

	var abs$1 = Math.abs;

	function sign(x) {
	    return ((x &gt; 0) - (x &lt; 0)) || +x;
	}

	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days         = abs$1(this._days);
	    var months       = abs$1(this._months);
	    var minutes, hours, years;

	    // 3600 seconds -&gt; 60 minutes -&gt; 1 hour
	    minutes           = absFloor(seconds / 60);
	    hours             = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60;

	    // 12 months -&gt; 1 year
	    years  = absFloor(months / 12);
	    months %= 12;


	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, &#x27;&#x27;) : &#x27;&#x27;;
	    var total = this.asSeconds();

	    if (!total) {
	        // this is the same as C#&#x27;s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return &#x27;P0D&#x27;;
	    }

	    var totalSign = total &lt; 0 ? &#x27;-&#x27; : &#x27;&#x27;;
	    var ymSign = sign(this._months) !== sign(total) ? &#x27;-&#x27; : &#x27;&#x27;;
	    var daysSign = sign(this._days) !== sign(total) ? &#x27;-&#x27; : &#x27;&#x27;;
	    var hmsSign = sign(this._milliseconds) !== sign(total) ? &#x27;-&#x27; : &#x27;&#x27;;

	    return totalSign + &#x27;P&#x27; +
	        (Y ? ymSign + Y + &#x27;Y&#x27; : &#x27;&#x27;) +
	        (M ? ymSign + M + &#x27;M&#x27; : &#x27;&#x27;) +
	        (D ? daysSign + D + &#x27;D&#x27; : &#x27;&#x27;) +
	        ((h || m || s) ? &#x27;T&#x27; : &#x27;&#x27;) +
	        (h ? hmsSign + h + &#x27;H&#x27; : &#x27;&#x27;) +
	        (m ? hmsSign + m + &#x27;M&#x27; : &#x27;&#x27;) +
	        (s ? hmsSign + s + &#x27;S&#x27; : &#x27;&#x27;);
	}

	var proto$2 = Duration.prototype;

	proto$2.isValid        = isValid$1;
	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.clone          = clone$1;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;

	proto$2.toIsoString = deprecate(&#x27;toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)&#x27;, toISOString$1);
	proto$2.lang = lang;

	// Side effect imports

	// FORMATTING

	addFormatToken(&#x27;X&#x27;, 0, 0, &#x27;unix&#x27;);
	addFormatToken(&#x27;x&#x27;, 0, 0, &#x27;valueOf&#x27;);

	// PARSING

	addRegexToken(&#x27;x&#x27;, matchSigned);
	addRegexToken(&#x27;X&#x27;, matchTimestamp);
	addParseToken(&#x27;X&#x27;, function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken(&#x27;x&#x27;, function (input, array, config) {
	    config._d = new Date(toInt(input));
	});

	// Side effect imports


	hooks.version = &#x27;2.21.0&#x27;;

	setHookCallback(createLocal);

	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;

	// currently HTML5 input type only supports 24-hour formats
	hooks.HTML5_FMT = {
	    DATETIME_LOCAL: &#x27;YYYY-MM-DDTHH:mm&#x27;,             // &lt;input type=&quot;datetime-local&quot; /&gt;
	    DATETIME_LOCAL_SECONDS: &#x27;YYYY-MM-DDTHH:mm:ss&#x27;,  // &lt;input type=&quot;datetime-local&quot; step=&quot;1&quot; /&gt;
	    DATETIME_LOCAL_MS: &#x27;YYYY-MM-DDTHH:mm:ss.SSS&#x27;,   // &lt;input type=&quot;datetime-local&quot; step=&quot;0.001&quot; /&gt;
	    DATE: &#x27;YYYY-MM-DD&#x27;,                             // &lt;input type=&quot;date&quot; /&gt;
	    TIME: &#x27;HH:mm&#x27;,                                  // &lt;input type=&quot;time&quot; /&gt;
	    TIME_SECONDS: &#x27;HH:mm:ss&#x27;,                       // &lt;input type=&quot;time&quot; step=&quot;1&quot; /&gt;
	    TIME_MS: &#x27;HH:mm:ss.SSS&#x27;,                        // &lt;input type=&quot;time&quot; step=&quot;0.001&quot; /&gt;
	    WEEK: &#x27;YYYY-[W]WW&#x27;,                             // &lt;input type=&quot;week&quot; /&gt;
	    MONTH: &#x27;YYYY-MM&#x27;                                // &lt;input type=&quot;month&quot; /&gt;
	};

	return hooks;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),
/* 73 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		&quot;./af&quot;: 75,
		&quot;./af.js&quot;: 75,
		&quot;./ar&quot;: 76,
		&quot;./ar-dz&quot;: 77,
		&quot;./ar-dz.js&quot;: 77,
		&quot;./ar-kw&quot;: 78,
		&quot;./ar-kw.js&quot;: 78,
		&quot;./ar-ly&quot;: 79,
		&quot;./ar-ly.js&quot;: 79,
		&quot;./ar-ma&quot;: 80,
		&quot;./ar-ma.js&quot;: 80,
		&quot;./ar-sa&quot;: 81,
		&quot;./ar-sa.js&quot;: 81,
		&quot;./ar-tn&quot;: 82,
		&quot;./ar-tn.js&quot;: 82,
		&quot;./ar.js&quot;: 76,
		&quot;./az&quot;: 83,
		&quot;./az.js&quot;: 83,
		&quot;./be&quot;: 84,
		&quot;./be.js&quot;: 84,
		&quot;./bg&quot;: 85,
		&quot;./bg.js&quot;: 85,
		&quot;./bm&quot;: 86,
		&quot;./bm.js&quot;: 86,
		&quot;./bn&quot;: 87,
		&quot;./bn.js&quot;: 87,
		&quot;./bo&quot;: 88,
		&quot;./bo.js&quot;: 88,
		&quot;./br&quot;: 89,
		&quot;./br.js&quot;: 89,
		&quot;./bs&quot;: 90,
		&quot;./bs.js&quot;: 90,
		&quot;./ca&quot;: 91,
		&quot;./ca.js&quot;: 91,
		&quot;./cs&quot;: 92,
		&quot;./cs.js&quot;: 92,
		&quot;./cv&quot;: 93,
		&quot;./cv.js&quot;: 93,
		&quot;./cy&quot;: 94,
		&quot;./cy.js&quot;: 94,
		&quot;./da&quot;: 95,
		&quot;./da.js&quot;: 95,
		&quot;./de&quot;: 96,
		&quot;./de-at&quot;: 97,
		&quot;./de-at.js&quot;: 97,
		&quot;./de-ch&quot;: 98,
		&quot;./de-ch.js&quot;: 98,
		&quot;./de.js&quot;: 96,
		&quot;./dv&quot;: 99,
		&quot;./dv.js&quot;: 99,
		&quot;./el&quot;: 100,
		&quot;./el.js&quot;: 100,
		&quot;./en-au&quot;: 101,
		&quot;./en-au.js&quot;: 101,
		&quot;./en-ca&quot;: 102,
		&quot;./en-ca.js&quot;: 102,
		&quot;./en-gb&quot;: 103,
		&quot;./en-gb.js&quot;: 103,
		&quot;./en-ie&quot;: 104,
		&quot;./en-ie.js&quot;: 104,
		&quot;./en-il&quot;: 105,
		&quot;./en-il.js&quot;: 105,
		&quot;./en-nz&quot;: 106,
		&quot;./en-nz.js&quot;: 106,
		&quot;./eo&quot;: 107,
		&quot;./eo.js&quot;: 107,
		&quot;./es&quot;: 108,
		&quot;./es-do&quot;: 109,
		&quot;./es-do.js&quot;: 109,
		&quot;./es-us&quot;: 110,
		&quot;./es-us.js&quot;: 110,
		&quot;./es.js&quot;: 108,
		&quot;./et&quot;: 111,
		&quot;./et.js&quot;: 111,
		&quot;./eu&quot;: 112,
		&quot;./eu.js&quot;: 112,
		&quot;./fa&quot;: 113,
		&quot;./fa.js&quot;: 113,
		&quot;./fi&quot;: 114,
		&quot;./fi.js&quot;: 114,
		&quot;./fo&quot;: 115,
		&quot;./fo.js&quot;: 115,
		&quot;./fr&quot;: 116,
		&quot;./fr-ca&quot;: 117,
		&quot;./fr-ca.js&quot;: 117,
		&quot;./fr-ch&quot;: 118,
		&quot;./fr-ch.js&quot;: 118,
		&quot;./fr.js&quot;: 116,
		&quot;./fy&quot;: 119,
		&quot;./fy.js&quot;: 119,
		&quot;./gd&quot;: 120,
		&quot;./gd.js&quot;: 120,
		&quot;./gl&quot;: 121,
		&quot;./gl.js&quot;: 121,
		&quot;./gom-latn&quot;: 122,
		&quot;./gom-latn.js&quot;: 122,
		&quot;./gu&quot;: 123,
		&quot;./gu.js&quot;: 123,
		&quot;./he&quot;: 124,
		&quot;./he.js&quot;: 124,
		&quot;./hi&quot;: 125,
		&quot;./hi.js&quot;: 125,
		&quot;./hr&quot;: 126,
		&quot;./hr.js&quot;: 126,
		&quot;./hu&quot;: 127,
		&quot;./hu.js&quot;: 127,
		&quot;./hy-am&quot;: 128,
		&quot;./hy-am.js&quot;: 128,
		&quot;./id&quot;: 129,
		&quot;./id.js&quot;: 129,
		&quot;./is&quot;: 130,
		&quot;./is.js&quot;: 130,
		&quot;./it&quot;: 131,
		&quot;./it.js&quot;: 131,
		&quot;./ja&quot;: 132,
		&quot;./ja.js&quot;: 132,
		&quot;./jv&quot;: 133,
		&quot;./jv.js&quot;: 133,
		&quot;./ka&quot;: 134,
		&quot;./ka.js&quot;: 134,
		&quot;./kk&quot;: 135,
		&quot;./kk.js&quot;: 135,
		&quot;./km&quot;: 136,
		&quot;./km.js&quot;: 136,
		&quot;./kn&quot;: 137,
		&quot;./kn.js&quot;: 137,
		&quot;./ko&quot;: 138,
		&quot;./ko.js&quot;: 138,
		&quot;./ky&quot;: 139,
		&quot;./ky.js&quot;: 139,
		&quot;./lb&quot;: 140,
		&quot;./lb.js&quot;: 140,
		&quot;./lo&quot;: 141,
		&quot;./lo.js&quot;: 141,
		&quot;./lt&quot;: 142,
		&quot;./lt.js&quot;: 142,
		&quot;./lv&quot;: 143,
		&quot;./lv.js&quot;: 143,
		&quot;./me&quot;: 144,
		&quot;./me.js&quot;: 144,
		&quot;./mi&quot;: 145,
		&quot;./mi.js&quot;: 145,
		&quot;./mk&quot;: 146,
		&quot;./mk.js&quot;: 146,
		&quot;./ml&quot;: 147,
		&quot;./ml.js&quot;: 147,
		&quot;./mr&quot;: 148,
		&quot;./mr.js&quot;: 148,
		&quot;./ms&quot;: 149,
		&quot;./ms-my&quot;: 150,
		&quot;./ms-my.js&quot;: 150,
		&quot;./ms.js&quot;: 149,
		&quot;./mt&quot;: 151,
		&quot;./mt.js&quot;: 151,
		&quot;./my&quot;: 152,
		&quot;./my.js&quot;: 152,
		&quot;./nb&quot;: 153,
		&quot;./nb.js&quot;: 153,
		&quot;./ne&quot;: 154,
		&quot;./ne.js&quot;: 154,
		&quot;./nl&quot;: 155,
		&quot;./nl-be&quot;: 156,
		&quot;./nl-be.js&quot;: 156,
		&quot;./nl.js&quot;: 155,
		&quot;./nn&quot;: 157,
		&quot;./nn.js&quot;: 157,
		&quot;./pa-in&quot;: 158,
		&quot;./pa-in.js&quot;: 158,
		&quot;./pl&quot;: 159,
		&quot;./pl.js&quot;: 159,
		&quot;./pt&quot;: 160,
		&quot;./pt-br&quot;: 161,
		&quot;./pt-br.js&quot;: 161,
		&quot;./pt.js&quot;: 160,
		&quot;./ro&quot;: 162,
		&quot;./ro.js&quot;: 162,
		&quot;./ru&quot;: 163,
		&quot;./ru.js&quot;: 163,
		&quot;./sd&quot;: 164,
		&quot;./sd.js&quot;: 164,
		&quot;./se&quot;: 165,
		&quot;./se.js&quot;: 165,
		&quot;./si&quot;: 166,
		&quot;./si.js&quot;: 166,
		&quot;./sk&quot;: 167,
		&quot;./sk.js&quot;: 167,
		&quot;./sl&quot;: 168,
		&quot;./sl.js&quot;: 168,
		&quot;./sq&quot;: 169,
		&quot;./sq.js&quot;: 169,
		&quot;./sr&quot;: 170,
		&quot;./sr-cyrl&quot;: 171,
		&quot;./sr-cyrl.js&quot;: 171,
		&quot;./sr.js&quot;: 170,
		&quot;./ss&quot;: 172,
		&quot;./ss.js&quot;: 172,
		&quot;./sv&quot;: 173,
		&quot;./sv.js&quot;: 173,
		&quot;./sw&quot;: 174,
		&quot;./sw.js&quot;: 174,
		&quot;./ta&quot;: 175,
		&quot;./ta.js&quot;: 175,
		&quot;./te&quot;: 176,
		&quot;./te.js&quot;: 176,
		&quot;./tet&quot;: 177,
		&quot;./tet.js&quot;: 177,
		&quot;./tg&quot;: 178,
		&quot;./tg.js&quot;: 178,
		&quot;./th&quot;: 179,
		&quot;./th.js&quot;: 179,
		&quot;./tl-ph&quot;: 180,
		&quot;./tl-ph.js&quot;: 180,
		&quot;./tlh&quot;: 181,
		&quot;./tlh.js&quot;: 181,
		&quot;./tr&quot;: 182,
		&quot;./tr.js&quot;: 182,
		&quot;./tzl&quot;: 183,
		&quot;./tzl.js&quot;: 183,
		&quot;./tzm&quot;: 184,
		&quot;./tzm-latn&quot;: 185,
		&quot;./tzm-latn.js&quot;: 185,
		&quot;./tzm.js&quot;: 184,
		&quot;./ug-cn&quot;: 186,
		&quot;./ug-cn.js&quot;: 186,
		&quot;./uk&quot;: 187,
		&quot;./uk.js&quot;: 187,
		&quot;./ur&quot;: 188,
		&quot;./ur.js&quot;: 188,
		&quot;./uz&quot;: 189,
		&quot;./uz-latn&quot;: 190,
		&quot;./uz-latn.js&quot;: 190,
		&quot;./uz.js&quot;: 189,
		&quot;./vi&quot;: 191,
		&quot;./vi.js&quot;: 191,
		&quot;./x-pseudo&quot;: 192,
		&quot;./x-pseudo.js&quot;: 192,
		&quot;./yo&quot;: 193,
		&quot;./yo.js&quot;: 193,
		&quot;./zh-cn&quot;: 194,
		&quot;./zh-cn.js&quot;: 194,
		&quot;./zh-hk&quot;: 195,
		&quot;./zh-hk.js&quot;: 195,
		&quot;./zh-tw&quot;: 196,
		&quot;./zh-tw.js&quot;: 196
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error(&quot;Cannot find module &#x27;&quot; + req + &quot;&#x27;.&quot;) }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 74;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var af = moment.defineLocale(&#x27;af&#x27;, {
	    months : &#x27;Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Son_Maa_Din_Woe_Don_Vry_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Ma_Di_Wo_Do_Vr_Sa&#x27;.split(&#x27;_&#x27;),
	    meridiemParse: /vm|nm/i,
	    isPM : function (input) {
	        return /^nm$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 12) {
	            return isLower ? &#x27;vm&#x27; : &#x27;VM&#x27;;
	        } else {
	            return isLower ? &#x27;nm&#x27; : &#x27;NM&#x27;;
	        }
	    },
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Vandag om] LT&#x27;,
	        nextDay : &#x27;[Môre om] LT&#x27;,
	        nextWeek : &#x27;dddd [om] LT&#x27;,
	        lastDay : &#x27;[Gister om] LT&#x27;,
	        lastWeek : &#x27;[Laas] dddd [om] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;oor %s&#x27;,
	        past : &#x27;%s gelede&#x27;,
	        s : &#x27;\&#x27;n paar sekondes&#x27;,
	        ss : &#x27;%d sekondes&#x27;,
	        m : &#x27;\&#x27;n minuut&#x27;,
	        mm : &#x27;%d minute&#x27;,
	        h : &#x27;\&#x27;n uur&#x27;,
	        hh : &#x27;%d ure&#x27;,
	        d : &#x27;\&#x27;n dag&#x27;,
	        dd : &#x27;%d dae&#x27;,
	        M : &#x27;\&#x27;n maand&#x27;,
	        MM : &#x27;%d maande&#x27;,
	        y : &#x27;\&#x27;n jaar&#x27;,
	        yy : &#x27;%d jaar&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number &gt;= 20) ? &#x27;ste&#x27; : &#x27;de&#x27;); // Thanks to Joris Röling : https://github.com/jjupiter
	    },
	    week : {
	        dow : 1, // Maandag is die eerste dag van die week.
	        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	    }
	});

	return af;

	})));


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;١&#x27;,
	    &#x27;2&#x27;: &#x27;٢&#x27;,
	    &#x27;3&#x27;: &#x27;٣&#x27;,
	    &#x27;4&#x27;: &#x27;٤&#x27;,
	    &#x27;5&#x27;: &#x27;٥&#x27;,
	    &#x27;6&#x27;: &#x27;٦&#x27;,
	    &#x27;7&#x27;: &#x27;٧&#x27;,
	    &#x27;8&#x27;: &#x27;٨&#x27;,
	    &#x27;9&#x27;: &#x27;٩&#x27;,
	    &#x27;0&#x27;: &#x27;٠&#x27;
	}, numberMap = {
	    &#x27;١&#x27;: &#x27;1&#x27;,
	    &#x27;٢&#x27;: &#x27;2&#x27;,
	    &#x27;٣&#x27;: &#x27;3&#x27;,
	    &#x27;٤&#x27;: &#x27;4&#x27;,
	    &#x27;٥&#x27;: &#x27;5&#x27;,
	    &#x27;٦&#x27;: &#x27;6&#x27;,
	    &#x27;٧&#x27;: &#x27;7&#x27;,
	    &#x27;٨&#x27;: &#x27;8&#x27;,
	    &#x27;٩&#x27;: &#x27;9&#x27;,
	    &#x27;٠&#x27;: &#x27;0&#x27;
	}, pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 &gt;= 3 &amp;&amp; n % 100 &lt;= 10 ? 3 : n % 100 &gt;= 11 ? 4 : 5;
	}, plurals = {
	    s : [&#x27;أقل من ثانية&#x27;, &#x27;ثانية واحدة&#x27;, [&#x27;ثانيتان&#x27;, &#x27;ثانيتين&#x27;], &#x27;%d ثوان&#x27;, &#x27;%d ثانية&#x27;, &#x27;%d ثانية&#x27;],
	    m : [&#x27;أقل من دقيقة&#x27;, &#x27;دقيقة واحدة&#x27;, [&#x27;دقيقتان&#x27;, &#x27;دقيقتين&#x27;], &#x27;%d دقائق&#x27;, &#x27;%d دقيقة&#x27;, &#x27;%d دقيقة&#x27;],
	    h : [&#x27;أقل من ساعة&#x27;, &#x27;ساعة واحدة&#x27;, [&#x27;ساعتان&#x27;, &#x27;ساعتين&#x27;], &#x27;%d ساعات&#x27;, &#x27;%d ساعة&#x27;, &#x27;%d ساعة&#x27;],
	    d : [&#x27;أقل من يوم&#x27;, &#x27;يوم واحد&#x27;, [&#x27;يومان&#x27;, &#x27;يومين&#x27;], &#x27;%d أيام&#x27;, &#x27;%d يومًا&#x27;, &#x27;%d يوم&#x27;],
	    M : [&#x27;أقل من شهر&#x27;, &#x27;شهر واحد&#x27;, [&#x27;شهران&#x27;, &#x27;شهرين&#x27;], &#x27;%d أشهر&#x27;, &#x27;%d شهرا&#x27;, &#x27;%d شهر&#x27;],
	    y : [&#x27;أقل من عام&#x27;, &#x27;عام واحد&#x27;, [&#x27;عامان&#x27;, &#x27;عامين&#x27;], &#x27;%d أعوام&#x27;, &#x27;%d عامًا&#x27;, &#x27;%d عام&#x27;]
	}, pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	}, months = [
	    &#x27;يناير&#x27;,
	    &#x27;فبراير&#x27;,
	    &#x27;مارس&#x27;,
	    &#x27;أبريل&#x27;,
	    &#x27;مايو&#x27;,
	    &#x27;يونيو&#x27;,
	    &#x27;يوليو&#x27;,
	    &#x27;أغسطس&#x27;,
	    &#x27;سبتمبر&#x27;,
	    &#x27;أكتوبر&#x27;,
	    &#x27;نوفمبر&#x27;,
	    &#x27;ديسمبر&#x27;
	];

	var ar = moment.defineLocale(&#x27;ar&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;D/\u200FM/\u200FYYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return &#x27;م&#x27; === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ص&#x27;;
	        } else {
	            return &#x27;م&#x27;;
	        }
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم عند الساعة] LT&#x27;,
	        nextDay: &#x27;[غدًا عند الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس عند الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;بعد %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : pluralize(&#x27;s&#x27;),
	        ss : pluralize(&#x27;s&#x27;),
	        m : pluralize(&#x27;m&#x27;),
	        mm : pluralize(&#x27;m&#x27;),
	        h : pluralize(&#x27;h&#x27;),
	        hh : pluralize(&#x27;h&#x27;),
	        d : pluralize(&#x27;d&#x27;),
	        dd : pluralize(&#x27;d&#x27;),
	        M : pluralize(&#x27;M&#x27;),
	        MM : pluralize(&#x27;M&#x27;),
	        y : pluralize(&#x27;y&#x27;),
	        yy : pluralize(&#x27;y&#x27;)
	    },
	    preparse: function (string) {
	        return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ar;

	})));


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arDz = moment.defineLocale(&#x27;ar-dz&#x27;, {
	    months : &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;أح_إث_ثلا_أر_خم_جم_سب&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 4  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arDz;

	})));


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arKw = moment.defineLocale(&#x27;ar-kw&#x27;, {
	    months : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arKw;

	})));


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;1&#x27;,
	    &#x27;2&#x27;: &#x27;2&#x27;,
	    &#x27;3&#x27;: &#x27;3&#x27;,
	    &#x27;4&#x27;: &#x27;4&#x27;,
	    &#x27;5&#x27;: &#x27;5&#x27;,
	    &#x27;6&#x27;: &#x27;6&#x27;,
	    &#x27;7&#x27;: &#x27;7&#x27;,
	    &#x27;8&#x27;: &#x27;8&#x27;,
	    &#x27;9&#x27;: &#x27;9&#x27;,
	    &#x27;0&#x27;: &#x27;0&#x27;
	}, pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 &gt;= 3 &amp;&amp; n % 100 &lt;= 10 ? 3 : n % 100 &gt;= 11 ? 4 : 5;
	}, plurals = {
	    s : [&#x27;أقل من ثانية&#x27;, &#x27;ثانية واحدة&#x27;, [&#x27;ثانيتان&#x27;, &#x27;ثانيتين&#x27;], &#x27;%d ثوان&#x27;, &#x27;%d ثانية&#x27;, &#x27;%d ثانية&#x27;],
	    m : [&#x27;أقل من دقيقة&#x27;, &#x27;دقيقة واحدة&#x27;, [&#x27;دقيقتان&#x27;, &#x27;دقيقتين&#x27;], &#x27;%d دقائق&#x27;, &#x27;%d دقيقة&#x27;, &#x27;%d دقيقة&#x27;],
	    h : [&#x27;أقل من ساعة&#x27;, &#x27;ساعة واحدة&#x27;, [&#x27;ساعتان&#x27;, &#x27;ساعتين&#x27;], &#x27;%d ساعات&#x27;, &#x27;%d ساعة&#x27;, &#x27;%d ساعة&#x27;],
	    d : [&#x27;أقل من يوم&#x27;, &#x27;يوم واحد&#x27;, [&#x27;يومان&#x27;, &#x27;يومين&#x27;], &#x27;%d أيام&#x27;, &#x27;%d يومًا&#x27;, &#x27;%d يوم&#x27;],
	    M : [&#x27;أقل من شهر&#x27;, &#x27;شهر واحد&#x27;, [&#x27;شهران&#x27;, &#x27;شهرين&#x27;], &#x27;%d أشهر&#x27;, &#x27;%d شهرا&#x27;, &#x27;%d شهر&#x27;],
	    y : [&#x27;أقل من عام&#x27;, &#x27;عام واحد&#x27;, [&#x27;عامان&#x27;, &#x27;عامين&#x27;], &#x27;%d أعوام&#x27;, &#x27;%d عامًا&#x27;, &#x27;%d عام&#x27;]
	}, pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	}, months = [
	    &#x27;يناير&#x27;,
	    &#x27;فبراير&#x27;,
	    &#x27;مارس&#x27;,
	    &#x27;أبريل&#x27;,
	    &#x27;مايو&#x27;,
	    &#x27;يونيو&#x27;,
	    &#x27;يوليو&#x27;,
	    &#x27;أغسطس&#x27;,
	    &#x27;سبتمبر&#x27;,
	    &#x27;أكتوبر&#x27;,
	    &#x27;نوفمبر&#x27;,
	    &#x27;ديسمبر&#x27;
	];

	var arLy = moment.defineLocale(&#x27;ar-ly&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;D/\u200FM/\u200FYYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return &#x27;م&#x27; === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ص&#x27;;
	        } else {
	            return &#x27;م&#x27;;
	        }
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم عند الساعة] LT&#x27;,
	        nextDay: &#x27;[غدًا عند الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس عند الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;بعد %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : pluralize(&#x27;s&#x27;),
	        ss : pluralize(&#x27;s&#x27;),
	        m : pluralize(&#x27;m&#x27;),
	        mm : pluralize(&#x27;m&#x27;),
	        h : pluralize(&#x27;h&#x27;),
	        hh : pluralize(&#x27;h&#x27;),
	        d : pluralize(&#x27;d&#x27;),
	        dd : pluralize(&#x27;d&#x27;),
	        M : pluralize(&#x27;M&#x27;),
	        MM : pluralize(&#x27;M&#x27;),
	        y : pluralize(&#x27;y&#x27;),
	        yy : pluralize(&#x27;y&#x27;)
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arLy;

	})));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arMa = moment.defineLocale(&#x27;ar-ma&#x27;, {
	    months : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arMa;

	})));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;١&#x27;,
	    &#x27;2&#x27;: &#x27;٢&#x27;,
	    &#x27;3&#x27;: &#x27;٣&#x27;,
	    &#x27;4&#x27;: &#x27;٤&#x27;,
	    &#x27;5&#x27;: &#x27;٥&#x27;,
	    &#x27;6&#x27;: &#x27;٦&#x27;,
	    &#x27;7&#x27;: &#x27;٧&#x27;,
	    &#x27;8&#x27;: &#x27;٨&#x27;,
	    &#x27;9&#x27;: &#x27;٩&#x27;,
	    &#x27;0&#x27;: &#x27;٠&#x27;
	}, numberMap = {
	    &#x27;١&#x27;: &#x27;1&#x27;,
	    &#x27;٢&#x27;: &#x27;2&#x27;,
	    &#x27;٣&#x27;: &#x27;3&#x27;,
	    &#x27;٤&#x27;: &#x27;4&#x27;,
	    &#x27;٥&#x27;: &#x27;5&#x27;,
	    &#x27;٦&#x27;: &#x27;6&#x27;,
	    &#x27;٧&#x27;: &#x27;7&#x27;,
	    &#x27;٨&#x27;: &#x27;8&#x27;,
	    &#x27;٩&#x27;: &#x27;9&#x27;,
	    &#x27;٠&#x27;: &#x27;0&#x27;
	};

	var arSa = moment.defineLocale(&#x27;ar-sa&#x27;, {
	    months : &#x27;يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return &#x27;م&#x27; === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ص&#x27;;
	        } else {
	            return &#x27;م&#x27;;
	        }
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arSa;

	})));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arTn = moment.defineLocale(&#x27;ar-tn&#x27;, {
	    months: &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;في %s&#x27;,
	        past: &#x27;منذ %s&#x27;,
	        s: &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m: &#x27;دقيقة&#x27;,
	        mm: &#x27;%d دقائق&#x27;,
	        h: &#x27;ساعة&#x27;,
	        hh: &#x27;%d ساعات&#x27;,
	        d: &#x27;يوم&#x27;,
	        dd: &#x27;%d أيام&#x27;,
	        M: &#x27;شهر&#x27;,
	        MM: &#x27;%d أشهر&#x27;,
	        y: &#x27;سنة&#x27;,
	        yy: &#x27;%d سنوات&#x27;
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return arTn;

	})));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes = {
	    1: &#x27;-inci&#x27;,
	    5: &#x27;-inci&#x27;,
	    8: &#x27;-inci&#x27;,
	    70: &#x27;-inci&#x27;,
	    80: &#x27;-inci&#x27;,
	    2: &#x27;-nci&#x27;,
	    7: &#x27;-nci&#x27;,
	    20: &#x27;-nci&#x27;,
	    50: &#x27;-nci&#x27;,
	    3: &#x27;-üncü&#x27;,
	    4: &#x27;-üncü&#x27;,
	    100: &#x27;-üncü&#x27;,
	    6: &#x27;-ncı&#x27;,
	    9: &#x27;-uncu&#x27;,
	    10: &#x27;-uncu&#x27;,
	    30: &#x27;-uncu&#x27;,
	    60: &#x27;-ıncı&#x27;,
	    90: &#x27;-ıncı&#x27;
	};

	var az = moment.defineLocale(&#x27;az&#x27;, {
	    months : &#x27;yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Bz_BE_ÇA_Çə_CA_Cü_Şə&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[bugün saat] LT&#x27;,
	        nextDay : &#x27;[sabah saat] LT&#x27;,
	        nextWeek : &#x27;[gələn həftə] dddd [saat] LT&#x27;,
	        lastDay : &#x27;[dünən] LT&#x27;,
	        lastWeek : &#x27;[keçən həftə] dddd [saat] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s sonra&#x27;,
	        past : &#x27;%s əvvəl&#x27;,
	        s : &#x27;birneçə saniyyə&#x27;,
	        ss : &#x27;%d saniyə&#x27;,
	        m : &#x27;bir dəqiqə&#x27;,
	        mm : &#x27;%d dəqiqə&#x27;,
	        h : &#x27;bir saat&#x27;,
	        hh : &#x27;%d saat&#x27;,
	        d : &#x27;bir gün&#x27;,
	        dd : &#x27;%d gün&#x27;,
	        M : &#x27;bir ay&#x27;,
	        MM : &#x27;%d ay&#x27;,
	        y : &#x27;bir il&#x27;,
	        yy : &#x27;%d il&#x27;
	    },
	    meridiemParse: /gecə|səhər|gündüz|axşam/,
	    isPM : function (input) {
	        return /^(gündüz|axşam)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;gecə&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;səhər&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;gündüz&#x27;;
	        } else {
	            return &#x27;axşam&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + &#x27;-ıncı&#x27;;
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number &gt;= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return az;

	})));


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(word, num) {
	    var forms = word.split(&#x27;_&#x27;);
	    return num % 10 === 1 &amp;&amp; num % 100 !== 11 ? forms[0] : (num % 10 &gt;= 2 &amp;&amp; num % 10 &lt;= 4 &amp;&amp; (num % 100 &lt; 10 || num % 100 &gt;= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        &#x27;ss&#x27;: withoutSuffix ? &#x27;секунда_секунды_секунд&#x27; : &#x27;секунду_секунды_секунд&#x27;,
	        &#x27;mm&#x27;: withoutSuffix ? &#x27;хвіліна_хвіліны_хвілін&#x27; : &#x27;хвіліну_хвіліны_хвілін&#x27;,
	        &#x27;hh&#x27;: withoutSuffix ? &#x27;гадзіна_гадзіны_гадзін&#x27; : &#x27;гадзіну_гадзіны_гадзін&#x27;,
	        &#x27;dd&#x27;: &#x27;дзень_дні_дзён&#x27;,
	        &#x27;MM&#x27;: &#x27;месяц_месяцы_месяцаў&#x27;,
	        &#x27;yy&#x27;: &#x27;год_гады_гадоў&#x27;
	    };
	    if (key === &#x27;m&#x27;) {
	        return withoutSuffix ? &#x27;хвіліна&#x27; : &#x27;хвіліну&#x27;;
	    }
	    else if (key === &#x27;h&#x27;) {
	        return withoutSuffix ? &#x27;гадзіна&#x27; : &#x27;гадзіну&#x27;;
	    }
	    else {
	        return number + &#x27; &#x27; + plural(format[key], +number);
	    }
	}

	var be = moment.defineLocale(&#x27;be&#x27;, {
	    months : {
	        format: &#x27;студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж&#x27;.split(&#x27;_&#x27;),
	    weekdays : {
	        format: &#x27;нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота&#x27;.split(&#x27;_&#x27;),
	        isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
	    },
	    weekdaysShort : &#x27;нд_пн_ат_ср_чц_пт_сб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нд_пн_ат_ср_чц_пт_сб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY г.&#x27;,
	        LLL : &#x27;D MMMM YYYY г., HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY г., HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Сёння ў] LT&#x27;,
	        nextDay: &#x27;[Заўтра ў] LT&#x27;,
	        lastDay: &#x27;[Учора ў] LT&#x27;,
	        nextWeek: function () {
	            return &#x27;[У] dddd [ў] LT&#x27;;
	        },
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return &#x27;[У мінулую] dddd [ў] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                    return &#x27;[У мінулы] dddd [ў] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;праз %s&#x27;,
	        past : &#x27;%s таму&#x27;,
	        s : &#x27;некалькі секунд&#x27;,
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithPlural,
	        hh : relativeTimeWithPlural,
	        d : &#x27;дзень&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;месяц&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;год&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночы|раніцы|дня|вечара/,
	    isPM : function (input) {
	        return /^(дня|вечара)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ночы&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;раніцы&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;дня&#x27;;
	        } else {
	            return &#x27;вечара&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;M&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return (number % 10 === 2 || number % 10 === 3) &amp;&amp; (number % 100 !== 12 &amp;&amp; number % 100 !== 13) ? number + &#x27;-і&#x27; : number + &#x27;-ы&#x27;;
	            case &#x27;D&#x27;:
	                return number + &#x27;-га&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return be;

	})));


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var bg = moment.defineLocale(&#x27;bg&#x27;, {
	    months : &#x27;януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;неделя_понеделник_вторник_сряда_четвъртък_петък_събота&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;нед_пон_вто_сря_чет_пет_съб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нд_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;D.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Днес в] LT&#x27;,
	        nextDay : &#x27;[Утре в] LT&#x27;,
	        nextWeek : &#x27;dddd [в] LT&#x27;,
	        lastDay : &#x27;[Вчера в] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return &#x27;[В изминалата] dddd [в] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[В изминалия] dddd [в] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;след %s&#x27;,
	        past : &#x27;преди %s&#x27;,
	        s : &#x27;няколко секунди&#x27;,
	        ss : &#x27;%d секунди&#x27;,
	        m : &#x27;минута&#x27;,
	        mm : &#x27;%d минути&#x27;,
	        h : &#x27;час&#x27;,
	        hh : &#x27;%d часа&#x27;,
	        d : &#x27;ден&#x27;,
	        dd : &#x27;%d дни&#x27;,
	        M : &#x27;месец&#x27;,
	        MM : &#x27;%d месеца&#x27;,
	        y : &#x27;година&#x27;,
	        yy : &#x27;%d години&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + &#x27;-ев&#x27;;
	        } else if (last2Digits === 0) {
	            return number + &#x27;-ен&#x27;;
	        } else if (last2Digits &gt; 10 &amp;&amp; last2Digits &lt; 20) {
	            return number + &#x27;-ти&#x27;;
	        } else if (lastDigit === 1) {
	            return number + &#x27;-ви&#x27;;
	        } else if (lastDigit === 2) {
	            return number + &#x27;-ри&#x27;;
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + &#x27;-ми&#x27;;
	        } else {
	            return number + &#x27;-ти&#x27;;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bg;

	})));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var bm = moment.defineLocale(&#x27;bm&#x27;, {
	    months : &#x27;Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ka_Nt_Ta_Ar_Al_Ju_Si&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;MMMM [tile] D [san] YYYY&#x27;,
	        LLL : &#x27;MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm&#x27;,
	        LLLL : &#x27;dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Bi lɛrɛ] LT&#x27;,
	        nextDay : &#x27;[Sini lɛrɛ] LT&#x27;,
	        nextWeek : &#x27;dddd [don lɛrɛ] LT&#x27;,
	        lastDay : &#x27;[Kunu lɛrɛ] LT&#x27;,
	        lastWeek : &#x27;dddd [tɛmɛnen lɛrɛ] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s kɔnɔ&#x27;,
	        past : &#x27;a bɛ %s bɔ&#x27;,
	        s : &#x27;sanga dama dama&#x27;,
	        ss : &#x27;sekondi %d&#x27;,
	        m : &#x27;miniti kelen&#x27;,
	        mm : &#x27;miniti %d&#x27;,
	        h : &#x27;lɛrɛ kelen&#x27;,
	        hh : &#x27;lɛrɛ %d&#x27;,
	        d : &#x27;tile kelen&#x27;,
	        dd : &#x27;tile %d&#x27;,
	        M : &#x27;kalo kelen&#x27;,
	        MM : &#x27;kalo %d&#x27;,
	        y : &#x27;san kelen&#x27;,
	        yy : &#x27;san %d&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return bm;

	})));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;১&#x27;,
	    &#x27;2&#x27;: &#x27;২&#x27;,
	    &#x27;3&#x27;: &#x27;৩&#x27;,
	    &#x27;4&#x27;: &#x27;৪&#x27;,
	    &#x27;5&#x27;: &#x27;৫&#x27;,
	    &#x27;6&#x27;: &#x27;৬&#x27;,
	    &#x27;7&#x27;: &#x27;৭&#x27;,
	    &#x27;8&#x27;: &#x27;৮&#x27;,
	    &#x27;9&#x27;: &#x27;৯&#x27;,
	    &#x27;0&#x27;: &#x27;০&#x27;
	},
	numberMap = {
	    &#x27;১&#x27;: &#x27;1&#x27;,
	    &#x27;২&#x27;: &#x27;2&#x27;,
	    &#x27;৩&#x27;: &#x27;3&#x27;,
	    &#x27;৪&#x27;: &#x27;4&#x27;,
	    &#x27;৫&#x27;: &#x27;5&#x27;,
	    &#x27;৬&#x27;: &#x27;6&#x27;,
	    &#x27;৭&#x27;: &#x27;7&#x27;,
	    &#x27;৮&#x27;: &#x27;8&#x27;,
	    &#x27;৯&#x27;: &#x27;9&#x27;,
	    &#x27;০&#x27;: &#x27;0&#x27;
	};

	var bn = moment.defineLocale(&#x27;bn&#x27;, {
	    months : &#x27;জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm সময়&#x27;,
	        LTS : &#x27;A h:mm:ss সময়&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm সময়&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm সময়&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[আজ] LT&#x27;,
	        nextDay : &#x27;[আগামীকাল] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[গতকাল] LT&#x27;,
	        lastWeek : &#x27;[গত] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s পরে&#x27;,
	        past : &#x27;%s আগে&#x27;,
	        s : &#x27;কয়েক সেকেন্ড&#x27;,
	        ss : &#x27;%d সেকেন্ড&#x27;,
	        m : &#x27;এক মিনিট&#x27;,
	        mm : &#x27;%d মিনিট&#x27;,
	        h : &#x27;এক ঘন্টা&#x27;,
	        hh : &#x27;%d ঘন্টা&#x27;,
	        d : &#x27;এক দিন&#x27;,
	        dd : &#x27;%d দিন&#x27;,
	        M : &#x27;এক মাস&#x27;,
	        MM : &#x27;%d মাস&#x27;,
	        y : &#x27;এক বছর&#x27;,
	        yy : &#x27;%d বছর&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === &#x27;রাত&#x27; &amp;&amp; hour &gt;= 4) ||
	                (meridiem === &#x27;দুপুর&#x27; &amp;&amp; hour &lt; 5) ||
	                meridiem === &#x27;বিকাল&#x27;) {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;রাত&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;সকাল&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;দুপুর&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;বিকাল&#x27;;
	        } else {
	            return &#x27;রাত&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bn;

	})));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;༡&#x27;,
	    &#x27;2&#x27;: &#x27;༢&#x27;,
	    &#x27;3&#x27;: &#x27;༣&#x27;,
	    &#x27;4&#x27;: &#x27;༤&#x27;,
	    &#x27;5&#x27;: &#x27;༥&#x27;,
	    &#x27;6&#x27;: &#x27;༦&#x27;,
	    &#x27;7&#x27;: &#x27;༧&#x27;,
	    &#x27;8&#x27;: &#x27;༨&#x27;,
	    &#x27;9&#x27;: &#x27;༩&#x27;,
	    &#x27;0&#x27;: &#x27;༠&#x27;
	},
	numberMap = {
	    &#x27;༡&#x27;: &#x27;1&#x27;,
	    &#x27;༢&#x27;: &#x27;2&#x27;,
	    &#x27;༣&#x27;: &#x27;3&#x27;,
	    &#x27;༤&#x27;: &#x27;4&#x27;,
	    &#x27;༥&#x27;: &#x27;5&#x27;,
	    &#x27;༦&#x27;: &#x27;6&#x27;,
	    &#x27;༧&#x27;: &#x27;7&#x27;,
	    &#x27;༨&#x27;: &#x27;8&#x27;,
	    &#x27;༩&#x27;: &#x27;9&#x27;,
	    &#x27;༠&#x27;: &#x27;0&#x27;
	};

	var bo = moment.defineLocale(&#x27;bo&#x27;, {
	    months : &#x27;ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[དི་རིང] LT&#x27;,
	        nextDay : &#x27;[སང་ཉིན] LT&#x27;,
	        nextWeek : &#x27;[བདུན་ཕྲག་རྗེས་མ], LT&#x27;,
	        lastDay : &#x27;[ཁ་སང] LT&#x27;,
	        lastWeek : &#x27;[བདུན་ཕྲག་མཐའ་མ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ལ་&#x27;,
	        past : &#x27;%s སྔན་ལ&#x27;,
	        s : &#x27;ལམ་སང&#x27;,
	        ss : &#x27;%d སྐར་ཆ།&#x27;,
	        m : &#x27;སྐར་མ་གཅིག&#x27;,
	        mm : &#x27;%d སྐར་མ&#x27;,
	        h : &#x27;ཆུ་ཚོད་གཅིག&#x27;,
	        hh : &#x27;%d ཆུ་ཚོད&#x27;,
	        d : &#x27;ཉིན་གཅིག&#x27;,
	        dd : &#x27;%d ཉིན་&#x27;,
	        M : &#x27;ཟླ་བ་གཅིག&#x27;,
	        MM : &#x27;%d ཟླ་བ&#x27;,
	        y : &#x27;ལོ་གཅིག&#x27;,
	        yy : &#x27;%d ལོ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === &#x27;མཚན་མོ&#x27; &amp;&amp; hour &gt;= 4) ||
	                (meridiem === &#x27;ཉིན་གུང&#x27; &amp;&amp; hour &lt; 5) ||
	                meridiem === &#x27;དགོང་དག&#x27;) {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;མཚན་མོ&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ཞོགས་ཀས&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ཉིན་གུང&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;དགོང་དག&#x27;;
	        } else {
	            return &#x27;མཚན་མོ&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bo;

	})));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function relativeTimeWithMutation(number, withoutSuffix, key) {
	    var format = {
	        &#x27;mm&#x27;: &#x27;munutenn&#x27;,
	        &#x27;MM&#x27;: &#x27;miz&#x27;,
	        &#x27;dd&#x27;: &#x27;devezh&#x27;
	    };
	    return number + &#x27; &#x27; + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
	    switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + &#x27; bloaz&#x27;;
	        default:
	            return number + &#x27; vloaz&#x27;;
	    }
	}
	function lastNumber(number) {
	    if (number &gt; 9) {
	        return lastNumber(number % 10);
	    }
	    return number;
	}
	function mutation(text, number) {
	    if (number === 2) {
	        return softMutation(text);
	    }
	    return text;
	}
	function softMutation(text) {
	    var mutationTable = {
	        &#x27;m&#x27;: &#x27;v&#x27;,
	        &#x27;b&#x27;: &#x27;v&#x27;,
	        &#x27;d&#x27;: &#x27;z&#x27;
	    };
	    if (mutationTable[text.charAt(0)] === undefined) {
	        return text;
	    }
	    return mutationTable[text.charAt(0)] + text.substring(1);
	}

	var br = moment.defineLocale(&#x27;br&#x27;, {
	    months : &#x27;Genver_C\&#x27;hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Gen_C\&#x27;hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sul_Lun_Meurzh_Merc\&#x27;her_Yaou_Gwener_Sadorn&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sul_Lun_Meu_Mer_Yao_Gwe_Sad&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Lu_Me_Mer_Ya_Gw_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h[e]mm A&#x27;,
	        LTS : &#x27;h[e]mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [a viz] MMMM YYYY&#x27;,
	        LLL : &#x27;D [a viz] MMMM YYYY h[e]mm A&#x27;,
	        LLLL : &#x27;dddd, D [a viz] MMMM YYYY h[e]mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Hiziv da] LT&#x27;,
	        nextDay : &#x27;[Warc\&#x27;hoazh da] LT&#x27;,
	        nextWeek : &#x27;dddd [da] LT&#x27;,
	        lastDay : &#x27;[Dec\&#x27;h da] LT&#x27;,
	        lastWeek : &#x27;dddd [paset da] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;a-benn %s&#x27;,
	        past : &#x27;%s \&#x27;zo&#x27;,
	        s : &#x27;un nebeud segondennoù&#x27;,
	        ss : &#x27;%d eilenn&#x27;,
	        m : &#x27;ur vunutenn&#x27;,
	        mm : relativeTimeWithMutation,
	        h : &#x27;un eur&#x27;,
	        hh : &#x27;%d eur&#x27;,
	        d : &#x27;un devezh&#x27;,
	        dd : relativeTimeWithMutation,
	        M : &#x27;ur miz&#x27;,
	        MM : relativeTimeWithMutation,
	        y : &#x27;ur bloaz&#x27;,
	        yy : specialMutationForYears
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
	    ordinal : function (number) {
	        var output = (number === 1) ? &#x27;añ&#x27; : &#x27;vet&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return br;

	})));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function translate(number, withoutSuffix, key) {
	    var result = number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;ss&#x27;:
	            if (number === 1) {
	                result += &#x27;sekunda&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;sekunde&#x27;;
	            } else {
	                result += &#x27;sekundi&#x27;;
	            }
	            return result;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;jedna minuta&#x27; : &#x27;jedne minute&#x27;;
	        case &#x27;mm&#x27;:
	            if (number === 1) {
	                result += &#x27;minuta&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;minute&#x27;;
	            } else {
	                result += &#x27;minuta&#x27;;
	            }
	            return result;
	        case &#x27;h&#x27;:
	            return withoutSuffix ? &#x27;jedan sat&#x27; : &#x27;jednog sata&#x27;;
	        case &#x27;hh&#x27;:
	            if (number === 1) {
	                result += &#x27;sat&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;sata&#x27;;
	            } else {
	                result += &#x27;sati&#x27;;
	            }
	            return result;
	        case &#x27;dd&#x27;:
	            if (number === 1) {
	                result += &#x27;dan&#x27;;
	            } else {
	                result += &#x27;dana&#x27;;
	            }
	            return result;
	        case &#x27;MM&#x27;:
	            if (number === 1) {
	                result += &#x27;mjesec&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;mjeseca&#x27;;
	            } else {
	                result += &#x27;mjeseci&#x27;;
	            }
	            return result;
	        case &#x27;yy&#x27;:
	            if (number === 1) {
	                result += &#x27;godina&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;godine&#x27;;
	            } else {
	                result += &#x27;godina&#x27;;
	            }
	            return result;
	    }
	}

	var bs = moment.defineLocale(&#x27;bs&#x27;, {
	    months : &#x27;januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ned._pon._uto._sri._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[danas u] LT&#x27;,
	        nextDay  : &#x27;[sutra u] LT&#x27;,
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedjelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [srijedu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[jučer u] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return &#x27;[prošlu] dddd [u] LT&#x27;;
	                case 6:
	                    return &#x27;[prošle] [subote] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[prošli] dddd [u] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;prije %s&#x27;,
	        s      : &#x27;par sekundi&#x27;,
	        ss     : translate,
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translate,
	        M      : &#x27;mjesec&#x27;,
	        MM     : translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bs;

	})));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ca = moment.defineLocale(&#x27;ca&#x27;, {
	    months : {
	        standalone: &#x27;gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;de gener_de febrer_de març_d\&#x27;abril_de maig_de juny_de juliol_d\&#x27;agost_de setembre_d\&#x27;octubre_de novembre_de desembre&#x27;.split(&#x27;_&#x27;),
	        isFormat: /D[oD]?(\s)+MMMM/
	    },
	    monthsShort : &#x27;gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dg._dl._dt._dc._dj._dv._ds.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;dg_dl_dt_dc_dj_dv_ds&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM [de] YYYY&#x27;,
	        ll : &#x27;D MMM YYYY&#x27;,
	        LLL : &#x27;D MMMM [de] YYYY [a les] H:mm&#x27;,
	        lll : &#x27;D MMM YYYY, H:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM [de] YYYY [a les] H:mm&#x27;,
	        llll : &#x27;ddd D MMM YYYY, H:mm&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[avui a &#x27; + ((this.hours() !== 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[demà a &#x27; + ((this.hours() !== 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a &#x27; + ((this.hours() !== 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ahir a &#x27; + ((this.hours() !== 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [passat a &#x27; + ((this.hours() !== 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;d\&#x27;aquí %s&#x27;,
	        past : &#x27;fa %s&#x27;,
	        s : &#x27;uns segons&#x27;,
	        ss : &#x27;%d segons&#x27;,
	        m : &#x27;un minut&#x27;,
	        mm : &#x27;%d minuts&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d hores&#x27;,
	        d : &#x27;un dia&#x27;,
	        dd : &#x27;%d dies&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d mesos&#x27;,
	        y : &#x27;un any&#x27;,
	        yy : &#x27;%d anys&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
	    ordinal : function (number, period) {
	        var output = (number === 1) ? &#x27;r&#x27; :
	            (number === 2) ? &#x27;n&#x27; :
	            (number === 3) ? &#x27;r&#x27; :
	            (number === 4) ? &#x27;t&#x27; : &#x27;è&#x27;;
	        if (period === &#x27;w&#x27; || period === &#x27;W&#x27;) {
	            output = &#x27;a&#x27;;
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ca;

	})));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months = &#x27;leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec&#x27;.split(&#x27;_&#x27;),
	    monthsShort = &#x27;led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro&#x27;.split(&#x27;_&#x27;);
	function plural(n) {
	    return (n &gt; 1) &amp;&amp; (n &lt; 5) &amp;&amp; (~~(n / 10) !== 1);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? &#x27;pár sekund&#x27; : &#x27;pár sekundami&#x27;;
	        case &#x27;ss&#x27;: // 9 seconds / in 9 seconds / 9 seconds ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;sekundy&#x27; : &#x27;sekund&#x27;);
	            } else {
	                return result + &#x27;sekundami&#x27;;
	            }
	            break;
	        case &#x27;m&#x27;:  // a minute / in a minute / a minute ago
	            return withoutSuffix ? &#x27;minuta&#x27; : (isFuture ? &#x27;minutu&#x27; : &#x27;minutou&#x27;);
	        case &#x27;mm&#x27;: // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;minuty&#x27; : &#x27;minut&#x27;);
	            } else {
	                return result + &#x27;minutami&#x27;;
	            }
	            break;
	        case &#x27;h&#x27;:  // an hour / in an hour / an hour ago
	            return withoutSuffix ? &#x27;hodina&#x27; : (isFuture ? &#x27;hodinu&#x27; : &#x27;hodinou&#x27;);
	        case &#x27;hh&#x27;: // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;hodiny&#x27; : &#x27;hodin&#x27;);
	            } else {
	                return result + &#x27;hodinami&#x27;;
	            }
	            break;
	        case &#x27;d&#x27;:  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? &#x27;den&#x27; : &#x27;dnem&#x27;;
	        case &#x27;dd&#x27;: // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;dny&#x27; : &#x27;dní&#x27;);
	            } else {
	                return result + &#x27;dny&#x27;;
	            }
	            break;
	        case &#x27;M&#x27;:  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? &#x27;měsíc&#x27; : &#x27;měsícem&#x27;;
	        case &#x27;MM&#x27;: // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;měsíce&#x27; : &#x27;měsíců&#x27;);
	            } else {
	                return result + &#x27;měsíci&#x27;;
	            }
	            break;
	        case &#x27;y&#x27;:  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? &#x27;rok&#x27; : &#x27;rokem&#x27;;
	        case &#x27;yy&#x27;: // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;roky&#x27; : &#x27;let&#x27;);
	            } else {
	                return result + &#x27;lety&#x27;;
	            }
	            break;
	    }
	}

	var cs = moment.defineLocale(&#x27;cs&#x27;, {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParse : (function (months, monthsShort) {
	        var i, _monthsParse = [];
	        for (i = 0; i &lt; 12; i++) {
	            // use custom parser to solve problem with July (červenec)
	            _monthsParse[i] = new RegExp(&#x27;^&#x27; + months[i] + &#x27;$|^&#x27; + monthsShort[i] + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        return _monthsParse;
	    }(months, monthsShort)),
	    shortMonthsParse : (function (monthsShort) {
	        var i, _shortMonthsParse = [];
	        for (i = 0; i &lt; 12; i++) {
	            _shortMonthsParse[i] = new RegExp(&#x27;^&#x27; + monthsShort[i] + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        return _shortMonthsParse;
	    }(monthsShort)),
	    longMonthsParse : (function (months) {
	        var i, _longMonthsParse = [];
	        for (i = 0; i &lt; 12; i++) {
	            _longMonthsParse[i] = new RegExp(&#x27;^&#x27; + months[i] + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        return _longMonthsParse;
	    }(months)),
	    weekdays : &#x27;neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ne_po_út_st_čt_pá_so&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_út_st_čt_pá_so&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY H:mm&#x27;,
	        l : &#x27;D. M. YYYY&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[dnes v] LT&#x27;,
	        nextDay: &#x27;[zítra v] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[v neděli v] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[v] dddd [v] LT&#x27;;
	                case 3:
	                    return &#x27;[ve středu v] LT&#x27;;
	                case 4:
	                    return &#x27;[ve čtvrtek v] LT&#x27;;
	                case 5:
	                    return &#x27;[v pátek v] LT&#x27;;
	                case 6:
	                    return &#x27;[v sobotu v] LT&#x27;;
	            }
	        },
	        lastDay: &#x27;[včera v] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[minulou neděli v] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[minulé] dddd [v] LT&#x27;;
	                case 3:
	                    return &#x27;[minulou středu v] LT&#x27;;
	                case 4:
	                case 5:
	                    return &#x27;[minulý] dddd [v] LT&#x27;;
	                case 6:
	                    return &#x27;[minulou sobotu v] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past : &#x27;před %s&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cs;

	})));


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var cv = moment.defineLocale(&#x27;cv&#x27;, {
	    months : &#x27;кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;выр_тун_ытл_юн_кӗҫ_эрн_шӑм&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;вр_тн_ыт_юн_кҫ_эр_шм&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]&#x27;,
	        LLL : &#x27;YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm&#x27;,
	        LLLL : &#x27;dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Паян] LT [сехетре]&#x27;,
	        nextDay: &#x27;[Ыран] LT [сехетре]&#x27;,
	        lastDay: &#x27;[Ӗнер] LT [сехетре]&#x27;,
	        nextWeek: &#x27;[Ҫитес] dddd LT [сехетре]&#x27;,
	        lastWeek: &#x27;[Иртнӗ] dddd LT [сехетре]&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (output) {
	            var affix = /сехет$/i.exec(output) ? &#x27;рен&#x27; : /ҫул$/i.exec(output) ? &#x27;тан&#x27; : &#x27;ран&#x27;;
	            return output + affix;
	        },
	        past : &#x27;%s каялла&#x27;,
	        s : &#x27;пӗр-ик ҫеккунт&#x27;,
	        ss : &#x27;%d ҫеккунт&#x27;,
	        m : &#x27;пӗр минут&#x27;,
	        mm : &#x27;%d минут&#x27;,
	        h : &#x27;пӗр сехет&#x27;,
	        hh : &#x27;%d сехет&#x27;,
	        d : &#x27;пӗр кун&#x27;,
	        dd : &#x27;%d кун&#x27;,
	        M : &#x27;пӗр уйӑх&#x27;,
	        MM : &#x27;%d уйӑх&#x27;,
	        y : &#x27;пӗр ҫул&#x27;,
	        yy : &#x27;%d ҫул&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
	    ordinal : &#x27;%d-мӗш&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return cv;

	})));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var cy = moment.defineLocale(&#x27;cy&#x27;, {
	    months: &#x27;Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;Sul_Llun_Maw_Mer_Iau_Gwe_Sad&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;Su_Ll_Ma_Me_Ia_Gw_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    // time formats are the same as en-gb
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[Heddiw am] LT&#x27;,
	        nextDay: &#x27;[Yfory am] LT&#x27;,
	        nextWeek: &#x27;dddd [am] LT&#x27;,
	        lastDay: &#x27;[Ddoe am] LT&#x27;,
	        lastWeek: &#x27;dddd [diwethaf am] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;mewn %s&#x27;,
	        past: &#x27;%s yn ôl&#x27;,
	        s: &#x27;ychydig eiliadau&#x27;,
	        ss: &#x27;%d eiliad&#x27;,
	        m: &#x27;munud&#x27;,
	        mm: &#x27;%d munud&#x27;,
	        h: &#x27;awr&#x27;,
	        hh: &#x27;%d awr&#x27;,
	        d: &#x27;diwrnod&#x27;,
	        dd: &#x27;%d diwrnod&#x27;,
	        M: &#x27;mis&#x27;,
	        MM: &#x27;%d mis&#x27;,
	        y: &#x27;blwyddyn&#x27;,
	        yy: &#x27;%d flynedd&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	    ordinal: function (number) {
	        var b = number,
	            output = &#x27;&#x27;,
	            lookup = [
	                &#x27;&#x27;, &#x27;af&#x27;, &#x27;il&#x27;, &#x27;ydd&#x27;, &#x27;ydd&#x27;, &#x27;ed&#x27;, &#x27;ed&#x27;, &#x27;ed&#x27;, &#x27;fed&#x27;, &#x27;fed&#x27;, &#x27;fed&#x27;, // 1af to 10fed
	                &#x27;eg&#x27;, &#x27;fed&#x27;, &#x27;eg&#x27;, &#x27;eg&#x27;, &#x27;fed&#x27;, &#x27;eg&#x27;, &#x27;eg&#x27;, &#x27;fed&#x27;, &#x27;eg&#x27;, &#x27;fed&#x27; // 11eg to 20fed
	            ];
	        if (b &gt; 20) {
	            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                output = &#x27;fed&#x27;; // not 30ain, 70ain or 90ain
	            } else {
	                output = &#x27;ain&#x27;;
	            }
	        } else if (b &gt; 0) {
	            output = lookup[b];
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cy;

	})));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var da = moment.defineLocale(&#x27;da&#x27;, {
	    months : &#x27;januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;søn_man_tir_ons_tor_fre_lør&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;sø_ma_ti_on_to_fr_lø&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd [d.] D. MMMM YYYY [kl.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[i dag kl.] LT&#x27;,
	        nextDay : &#x27;[i morgen kl.] LT&#x27;,
	        nextWeek : &#x27;på dddd [kl.] LT&#x27;,
	        lastDay : &#x27;[i går kl.] LT&#x27;,
	        lastWeek : &#x27;[i] dddd[s kl.] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;%s siden&#x27;,
	        s : &#x27;få sekunder&#x27;,
	        ss : &#x27;%d sekunder&#x27;,
	        m : &#x27;et minut&#x27;,
	        mm : &#x27;%d minutter&#x27;,
	        h : &#x27;en time&#x27;,
	        hh : &#x27;%d timer&#x27;,
	        d : &#x27;en dag&#x27;,
	        dd : &#x27;%d dage&#x27;,
	        M : &#x27;en måned&#x27;,
	        MM : &#x27;%d måneder&#x27;,
	        y : &#x27;et år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return da;

	})));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        &#x27;m&#x27;: [&#x27;eine Minute&#x27;, &#x27;einer Minute&#x27;],
	        &#x27;h&#x27;: [&#x27;eine Stunde&#x27;, &#x27;einer Stunde&#x27;],
	        &#x27;d&#x27;: [&#x27;ein Tag&#x27;, &#x27;einem Tag&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; Tage&#x27;, number + &#x27; Tagen&#x27;],
	        &#x27;M&#x27;: [&#x27;ein Monat&#x27;, &#x27;einem Monat&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; Monate&#x27;, number + &#x27; Monaten&#x27;],
	        &#x27;y&#x27;: [&#x27;ein Jahr&#x27;, &#x27;einem Jahr&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; Jahre&#x27;, number + &#x27; Jahren&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var de = moment.defineLocale(&#x27;de&#x27;, {
	    months : &#x27;Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;So._Mo._Di._Mi._Do._Fr._Sa.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[heute um] LT [Uhr]&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[morgen um] LT [Uhr]&#x27;,
	        nextWeek: &#x27;dddd [um] LT [Uhr]&#x27;,
	        lastDay: &#x27;[gestern um] LT [Uhr]&#x27;,
	        lastWeek: &#x27;[letzten] dddd [um] LT [Uhr]&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;vor %s&#x27;,
	        s : &#x27;ein paar Sekunden&#x27;,
	        ss : &#x27;%d Sekunden&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minuten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stunden&#x27;,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return de;

	})));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        &#x27;m&#x27;: [&#x27;eine Minute&#x27;, &#x27;einer Minute&#x27;],
	        &#x27;h&#x27;: [&#x27;eine Stunde&#x27;, &#x27;einer Stunde&#x27;],
	        &#x27;d&#x27;: [&#x27;ein Tag&#x27;, &#x27;einem Tag&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; Tage&#x27;, number + &#x27; Tagen&#x27;],
	        &#x27;M&#x27;: [&#x27;ein Monat&#x27;, &#x27;einem Monat&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; Monate&#x27;, number + &#x27; Monaten&#x27;],
	        &#x27;y&#x27;: [&#x27;ein Jahr&#x27;, &#x27;einem Jahr&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; Jahre&#x27;, number + &#x27; Jahren&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deAt = moment.defineLocale(&#x27;de-at&#x27;, {
	    months : &#x27;Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;So._Mo._Di._Mi._Do._Fr._Sa.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[heute um] LT [Uhr]&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[morgen um] LT [Uhr]&#x27;,
	        nextWeek: &#x27;dddd [um] LT [Uhr]&#x27;,
	        lastDay: &#x27;[gestern um] LT [Uhr]&#x27;,
	        lastWeek: &#x27;[letzten] dddd [um] LT [Uhr]&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;vor %s&#x27;,
	        s : &#x27;ein paar Sekunden&#x27;,
	        ss : &#x27;%d Sekunden&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minuten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stunden&#x27;,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deAt;

	})));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        &#x27;m&#x27;: [&#x27;eine Minute&#x27;, &#x27;einer Minute&#x27;],
	        &#x27;h&#x27;: [&#x27;eine Stunde&#x27;, &#x27;einer Stunde&#x27;],
	        &#x27;d&#x27;: [&#x27;ein Tag&#x27;, &#x27;einem Tag&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; Tage&#x27;, number + &#x27; Tagen&#x27;],
	        &#x27;M&#x27;: [&#x27;ein Monat&#x27;, &#x27;einem Monat&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; Monate&#x27;, number + &#x27; Monaten&#x27;],
	        &#x27;y&#x27;: [&#x27;ein Jahr&#x27;, &#x27;einem Jahr&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; Jahre&#x27;, number + &#x27; Jahren&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deCh = moment.defineLocale(&#x27;de-ch&#x27;, {
	    months : &#x27;Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[heute um] LT [Uhr]&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[morgen um] LT [Uhr]&#x27;,
	        nextWeek: &#x27;dddd [um] LT [Uhr]&#x27;,
	        lastDay: &#x27;[gestern um] LT [Uhr]&#x27;,
	        lastWeek: &#x27;[letzten] dddd [um] LT [Uhr]&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;vor %s&#x27;,
	        s : &#x27;ein paar Sekunden&#x27;,
	        ss : &#x27;%d Sekunden&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minuten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stunden&#x27;,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deCh;

	})));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months = [
	    &#x27;ޖެނުއަރީ&#x27;,
	    &#x27;ފެބްރުއަރީ&#x27;,
	    &#x27;މާރިޗު&#x27;,
	    &#x27;އޭޕްރީލު&#x27;,
	    &#x27;މޭ&#x27;,
	    &#x27;ޖޫން&#x27;,
	    &#x27;ޖުލައި&#x27;,
	    &#x27;އޯގަސްޓު&#x27;,
	    &#x27;ސެޕްޓެމްބަރު&#x27;,
	    &#x27;އޮކްޓޯބަރު&#x27;,
	    &#x27;ނޮވެމްބަރު&#x27;,
	    &#x27;ޑިސެމްބަރު&#x27;
	], weekdays = [
	    &#x27;އާދިއްތަ&#x27;,
	    &#x27;ހޯމަ&#x27;,
	    &#x27;އަންގާރަ&#x27;,
	    &#x27;ބުދަ&#x27;,
	    &#x27;ބުރާސްފަތި&#x27;,
	    &#x27;ހުކުރު&#x27;,
	    &#x27;ހޮނިހިރު&#x27;
	];

	var dv = moment.defineLocale(&#x27;dv&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : weekdays,
	    weekdaysShort : weekdays,
	    weekdaysMin : &#x27;އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {

	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;D/M/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /މކ|މފ/,
	    isPM : function (input) {
	        return &#x27;މފ&#x27; === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;މކ&#x27;;
	        } else {
	            return &#x27;މފ&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[މިއަދު] LT&#x27;,
	        nextDay : &#x27;[މާދަމާ] LT&#x27;,
	        nextWeek : &#x27;dddd LT&#x27;,
	        lastDay : &#x27;[އިއްޔެ] LT&#x27;,
	        lastWeek : &#x27;[ފާއިތުވި] dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ތެރޭގައި %s&#x27;,
	        past : &#x27;ކުރިން %s&#x27;,
	        s : &#x27;ސިކުންތުކޮޅެއް&#x27;,
	        ss : &#x27;d% ސިކުންތު&#x27;,
	        m : &#x27;މިނިޓެއް&#x27;,
	        mm : &#x27;މިނިޓު %d&#x27;,
	        h : &#x27;ގަޑިއިރެއް&#x27;,
	        hh : &#x27;ގަޑިއިރު %d&#x27;,
	        d : &#x27;ދުވަހެއް&#x27;,
	        dd : &#x27;ދުވަސް %d&#x27;,
	        M : &#x27;މަހެއް&#x27;,
	        MM : &#x27;މަސް %d&#x27;,
	        y : &#x27;އަހަރެއް&#x27;,
	        yy : &#x27;އަހަރު %d&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 7,  // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return dv;

	})));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === &#x27;[object Function]&#x27;;
	}


	var el = moment.defineLocale(&#x27;el&#x27;, {
	    monthsNominativeEl : &#x27;Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος&#x27;.split(&#x27;_&#x27;),
	    monthsGenitiveEl : &#x27;Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου&#x27;.split(&#x27;_&#x27;),
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return this._monthsNominativeEl;
	        } else if (typeof format === &#x27;string&#x27; &amp;&amp; /D/.test(format.substring(0, format.indexOf(&#x27;MMMM&#x27;)))) { // if there is a day number before &#x27;MMMM&#x27;
	            return this._monthsGenitiveEl[momentToFormat.month()];
	        } else {
	            return this._monthsNominativeEl[momentToFormat.month()];
	        }
	    },
	    monthsShort : &#x27;Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Κυ_Δε_Τρ_Τε_Πε_Πα_Σα&#x27;.split(&#x27;_&#x27;),
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;μμ&#x27; : &#x27;ΜΜ&#x27;;
	        } else {
	            return isLower ? &#x27;πμ&#x27; : &#x27;ΠΜ&#x27;;
	        }
	    },
	    isPM : function (input) {
	        return ((input + &#x27;&#x27;).toLowerCase()[0] === &#x27;μ&#x27;);
	    },
	    meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendarEl : {
	        sameDay : &#x27;[Σήμερα {}] LT&#x27;,
	        nextDay : &#x27;[Αύριο {}] LT&#x27;,
	        nextWeek : &#x27;dddd [{}] LT&#x27;,
	        lastDay : &#x27;[Χθες {}] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 6:
	                    return &#x27;[το προηγούμενο] dddd [{}] LT&#x27;;
	                default:
	                    return &#x27;[την προηγούμενη] dddd [{}] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    calendar : function (key, mom) {
	        var output = this._calendarEl[key],
	            hours = mom &amp;&amp; mom.hours();
	        if (isFunction(output)) {
	            output = output.apply(mom);
	        }
	        return output.replace(&#x27;{}&#x27;, (hours % 12 === 1 ? &#x27;στη&#x27; : &#x27;στις&#x27;));
	    },
	    relativeTime : {
	        future : &#x27;σε %s&#x27;,
	        past : &#x27;%s πριν&#x27;,
	        s : &#x27;λίγα δευτερόλεπτα&#x27;,
	        ss : &#x27;%d δευτερόλεπτα&#x27;,
	        m : &#x27;ένα λεπτό&#x27;,
	        mm : &#x27;%d λεπτά&#x27;,
	        h : &#x27;μία ώρα&#x27;,
	        hh : &#x27;%d ώρες&#x27;,
	        d : &#x27;μία μέρα&#x27;,
	        dd : &#x27;%d μέρες&#x27;,
	        M : &#x27;ένας μήνας&#x27;,
	        MM : &#x27;%d μήνες&#x27;,
	        y : &#x27;ένας χρόνος&#x27;,
	        yy : &#x27;%d χρόνια&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}η/,
	    ordinal: &#x27;%dη&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4st is the first week of the year.
	    }
	});

	return el;

	})));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enAu = moment.defineLocale(&#x27;en-au&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enAu;

	})));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enCa = moment.defineLocale(&#x27;en-ca&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;MMMM D, YYYY&#x27;,
	        LLL : &#x27;MMMM D, YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, MMMM D, YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    }
	});

	return enCa;

	})));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enGb = moment.defineLocale(&#x27;en-gb&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enGb;

	})));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enIe = moment.defineLocale(&#x27;en-ie&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enIe;

	})));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enIl = moment.defineLocale(&#x27;en-il&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    }
	});

	return enIl;

	})));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enNz = moment.defineLocale(&#x27;en-nz&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enNz;

	})));


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var eo = moment.defineLocale(&#x27;eo&#x27;, {
	    months : &#x27;januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim_lun_mard_merk_ĵaŭ_ven_sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_ĵa_ve_sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;D[-a de] MMMM, YYYY&#x27;,
	        LLL : &#x27;D[-a de] MMMM, YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, [la] D[-a de] MMMM, YYYY HH:mm&#x27;
	    },
	    meridiemParse: /[ap]\.t\.m/i,
	    isPM: function (input) {
	        return input.charAt(0).toLowerCase() === &#x27;p&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;p.t.m.&#x27; : &#x27;P.T.M.&#x27;;
	        } else {
	            return isLower ? &#x27;a.t.m.&#x27; : &#x27;A.T.M.&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hodiaŭ je] LT&#x27;,
	        nextDay : &#x27;[Morgaŭ je] LT&#x27;,
	        nextWeek : &#x27;dddd [je] LT&#x27;,
	        lastDay : &#x27;[Hieraŭ je] LT&#x27;,
	        lastWeek : &#x27;[pasinta] dddd [je] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;post %s&#x27;,
	        past : &#x27;antaŭ %s&#x27;,
	        s : &#x27;sekundoj&#x27;,
	        ss : &#x27;%d sekundoj&#x27;,
	        m : &#x27;minuto&#x27;,
	        mm : &#x27;%d minutoj&#x27;,
	        h : &#x27;horo&#x27;,
	        hh : &#x27;%d horoj&#x27;,
	        d : &#x27;tago&#x27;,//ne &#x27;diurno&#x27;, ĉar estas uzita por proksimumo
	        dd : &#x27;%d tagoj&#x27;,
	        M : &#x27;monato&#x27;,
	        MM : &#x27;%d monatoj&#x27;,
	        y : &#x27;jaro&#x27;,
	        yy : &#x27;%d jaroj&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}a/,
	    ordinal : &#x27;%da&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eo;

	})));


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortDot = &#x27;ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.&#x27;.split(&#x27;_&#x27;),
	    monthsShort = &#x27;ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic&#x27;.split(&#x27;_&#x27;);

	var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	var es = moment.defineLocale(&#x27;es&#x27;, {
	    months : &#x27;enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsRegex : monthsRegex,
	    monthsShortRegex : monthsRegex,
	    monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
	    monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	    weekdays : &#x27;domingo_lunes_martes_miércoles_jueves_viernes_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mié._jue._vie._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mi_ju_vi_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoy a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañana a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ayer a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [pasado a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;en %s&#x27;,
	        past : &#x27;hace %s&#x27;,
	        s : &#x27;unos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un año&#x27;,
	        yy : &#x27;%d años&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return es;

	})));


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortDot = &#x27;ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.&#x27;.split(&#x27;_&#x27;),
	    monthsShort = &#x27;ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic&#x27;.split(&#x27;_&#x27;);

	var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	var esDo = moment.defineLocale(&#x27;es-do&#x27;, {
	    months : &#x27;enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
	    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
	    monthsParse: monthsParse,
	    longMonthsParse: monthsParse,
	    shortMonthsParse: monthsParse,
	    weekdays : &#x27;domingo_lunes_martes_miércoles_jueves_viernes_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mié._jue._vie._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mi_ju_vi_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoy a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañana a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ayer a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [pasado a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;en %s&#x27;,
	        past : &#x27;hace %s&#x27;,
	        s : &#x27;unos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un año&#x27;,
	        yy : &#x27;%d años&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return esDo;

	})));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortDot = &#x27;ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.&#x27;.split(&#x27;_&#x27;),
	    monthsShort = &#x27;ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic&#x27;.split(&#x27;_&#x27;);

	var esUs = moment.defineLocale(&#x27;es-us&#x27;, {
	    months : &#x27;enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : &#x27;domingo_lunes_martes_miércoles_jueves_viernes_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mié._jue._vie._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mi_ju_vi_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;MM/DD/YYYY&#x27;,
	        LL : &#x27;MMMM [de] D [de] YYYY&#x27;,
	        LLL : &#x27;MMMM [de] D [de] YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, MMMM [de] D [de] YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoy a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañana a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ayer a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [pasado a la&#x27; + ((this.hours() !== 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;en %s&#x27;,
	        past : &#x27;hace %s&#x27;,
	        s : &#x27;unos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un año&#x27;,
	        yy : &#x27;%d años&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return esUs;

	})));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        &#x27;s&#x27; : [&#x27;mõne sekundi&#x27;, &#x27;mõni sekund&#x27;, &#x27;paar sekundit&#x27;],
	        &#x27;ss&#x27;: [number + &#x27;sekundi&#x27;, number + &#x27;sekundit&#x27;],
	        &#x27;m&#x27; : [&#x27;ühe minuti&#x27;, &#x27;üks minut&#x27;],
	        &#x27;mm&#x27;: [number + &#x27; minuti&#x27;, number + &#x27; minutit&#x27;],
	        &#x27;h&#x27; : [&#x27;ühe tunni&#x27;, &#x27;tund aega&#x27;, &#x27;üks tund&#x27;],
	        &#x27;hh&#x27;: [number + &#x27; tunni&#x27;, number + &#x27; tundi&#x27;],
	        &#x27;d&#x27; : [&#x27;ühe päeva&#x27;, &#x27;üks päev&#x27;],
	        &#x27;M&#x27; : [&#x27;kuu aja&#x27;, &#x27;kuu aega&#x27;, &#x27;üks kuu&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; kuu&#x27;, number + &#x27; kuud&#x27;],
	        &#x27;y&#x27; : [&#x27;ühe aasta&#x27;, &#x27;aasta&#x27;, &#x27;üks aasta&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; aasta&#x27;, number + &#x27; aastat&#x27;]
	    };
	    if (withoutSuffix) {
	        return format[key][2] ? format[key][2] : format[key][1];
	    }
	    return isFuture ? format[key][0] : format[key][1];
	}

	var et = moment.defineLocale(&#x27;et&#x27;, {
	    months        : &#x27;jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember&#x27;.split(&#x27;_&#x27;),
	    monthsShort   : &#x27;jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets&#x27;.split(&#x27;_&#x27;),
	    weekdays      : &#x27;pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;P_E_T_K_N_R_L&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin   : &#x27;P_E_T_K_N_R_L&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT   : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L    : &#x27;DD.MM.YYYY&#x27;,
	        LL   : &#x27;D. MMMM YYYY&#x27;,
	        LLL  : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[Täna,] LT&#x27;,
	        nextDay  : &#x27;[Homme,] LT&#x27;,
	        nextWeek : &#x27;[Järgmine] dddd LT&#x27;,
	        lastDay  : &#x27;[Eile,] LT&#x27;,
	        lastWeek : &#x27;[Eelmine] dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s pärast&#x27;,
	        past   : &#x27;%s tagasi&#x27;,
	        s      : processRelativeTime,
	        ss     : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : &#x27;%d päeva&#x27;,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return et;

	})));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var eu = moment.defineLocale(&#x27;eu&#x27;, {
	    months : &#x27;urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ig._al._ar._az._og._ol._lr.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ig_al_ar_az_og_ol_lr&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;YYYY[ko] MMMM[ren] D[a]&#x27;,
	        LLL : &#x27;YYYY[ko] MMMM[ren] D[a] HH:mm&#x27;,
	        LLLL : &#x27;dddd, YYYY[ko] MMMM[ren] D[a] HH:mm&#x27;,
	        l : &#x27;YYYY-M-D&#x27;,
	        ll : &#x27;YYYY[ko] MMM D[a]&#x27;,
	        lll : &#x27;YYYY[ko] MMM D[a] HH:mm&#x27;,
	        llll : &#x27;ddd, YYYY[ko] MMM D[a] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[gaur] LT[etan]&#x27;,
	        nextDay : &#x27;[bihar] LT[etan]&#x27;,
	        nextWeek : &#x27;dddd LT[etan]&#x27;,
	        lastDay : &#x27;[atzo] LT[etan]&#x27;,
	        lastWeek : &#x27;[aurreko] dddd LT[etan]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s barru&#x27;,
	        past : &#x27;duela %s&#x27;,
	        s : &#x27;segundo batzuk&#x27;,
	        ss : &#x27;%d segundo&#x27;,
	        m : &#x27;minutu bat&#x27;,
	        mm : &#x27;%d minutu&#x27;,
	        h : &#x27;ordu bat&#x27;,
	        hh : &#x27;%d ordu&#x27;,
	        d : &#x27;egun bat&#x27;,
	        dd : &#x27;%d egun&#x27;,
	        M : &#x27;hilabete bat&#x27;,
	        MM : &#x27;%d hilabete&#x27;,
	        y : &#x27;urte bat&#x27;,
	        yy : &#x27;%d urte&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eu;

	})));


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;۱&#x27;,
	    &#x27;2&#x27;: &#x27;۲&#x27;,
	    &#x27;3&#x27;: &#x27;۳&#x27;,
	    &#x27;4&#x27;: &#x27;۴&#x27;,
	    &#x27;5&#x27;: &#x27;۵&#x27;,
	    &#x27;6&#x27;: &#x27;۶&#x27;,
	    &#x27;7&#x27;: &#x27;۷&#x27;,
	    &#x27;8&#x27;: &#x27;۸&#x27;,
	    &#x27;9&#x27;: &#x27;۹&#x27;,
	    &#x27;0&#x27;: &#x27;۰&#x27;
	}, numberMap = {
	    &#x27;۱&#x27;: &#x27;1&#x27;,
	    &#x27;۲&#x27;: &#x27;2&#x27;,
	    &#x27;۳&#x27;: &#x27;3&#x27;,
	    &#x27;۴&#x27;: &#x27;4&#x27;,
	    &#x27;۵&#x27;: &#x27;5&#x27;,
	    &#x27;۶&#x27;: &#x27;6&#x27;,
	    &#x27;۷&#x27;: &#x27;7&#x27;,
	    &#x27;۸&#x27;: &#x27;8&#x27;,
	    &#x27;۹&#x27;: &#x27;9&#x27;,
	    &#x27;۰&#x27;: &#x27;0&#x27;
	};

	var fa = moment.defineLocale(&#x27;fa&#x27;, {
	    months : &#x27;ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ی_د_س_چ_پ_ج_ش&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /قبل از ظهر|بعد از ظهر/,
	    isPM: function (input) {
	        return /بعد از ظهر/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;قبل از ظهر&#x27;;
	        } else {
	            return &#x27;بعد از ظهر&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[امروز ساعت] LT&#x27;,
	        nextDay : &#x27;[فردا ساعت] LT&#x27;,
	        nextWeek : &#x27;dddd [ساعت] LT&#x27;,
	        lastDay : &#x27;[دیروز ساعت] LT&#x27;,
	        lastWeek : &#x27;dddd [پیش] [ساعت] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;در %s&#x27;,
	        past : &#x27;%s پیش&#x27;,
	        s : &#x27;چند ثانیه&#x27;,
	        ss : &#x27;ثانیه d%&#x27;,
	        m : &#x27;یک دقیقه&#x27;,
	        mm : &#x27;%d دقیقه&#x27;,
	        h : &#x27;یک ساعت&#x27;,
	        hh : &#x27;%d ساعت&#x27;,
	        d : &#x27;یک روز&#x27;,
	        dd : &#x27;%d روز&#x27;,
	        M : &#x27;یک ماه&#x27;,
	        MM : &#x27;%d ماه&#x27;,
	        y : &#x27;یک سال&#x27;,
	        yy : &#x27;%d سال&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[۰-۹]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}م/,
	    ordinal : &#x27;%dم&#x27;,
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return fa;

	})));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var numbersPast = &#x27;nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän&#x27;.split(&#x27; &#x27;),
	    numbersFuture = [
	        &#x27;nolla&#x27;, &#x27;yhden&#x27;, &#x27;kahden&#x27;, &#x27;kolmen&#x27;, &#x27;neljän&#x27;, &#x27;viiden&#x27;, &#x27;kuuden&#x27;,
	        numbersPast[7], numbersPast[8], numbersPast[9]
	    ];
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = &#x27;&#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return isFuture ? &#x27;muutaman sekunnin&#x27; : &#x27;muutama sekunti&#x27;;
	        case &#x27;ss&#x27;:
	            return isFuture ? &#x27;sekunnin&#x27; : &#x27;sekuntia&#x27;;
	        case &#x27;m&#x27;:
	            return isFuture ? &#x27;minuutin&#x27; : &#x27;minuutti&#x27;;
	        case &#x27;mm&#x27;:
	            result = isFuture ? &#x27;minuutin&#x27; : &#x27;minuuttia&#x27;;
	            break;
	        case &#x27;h&#x27;:
	            return isFuture ? &#x27;tunnin&#x27; : &#x27;tunti&#x27;;
	        case &#x27;hh&#x27;:
	            result = isFuture ? &#x27;tunnin&#x27; : &#x27;tuntia&#x27;;
	            break;
	        case &#x27;d&#x27;:
	            return isFuture ? &#x27;päivän&#x27; : &#x27;päivä&#x27;;
	        case &#x27;dd&#x27;:
	            result = isFuture ? &#x27;päivän&#x27; : &#x27;päivää&#x27;;
	            break;
	        case &#x27;M&#x27;:
	            return isFuture ? &#x27;kuukauden&#x27; : &#x27;kuukausi&#x27;;
	        case &#x27;MM&#x27;:
	            result = isFuture ? &#x27;kuukauden&#x27; : &#x27;kuukautta&#x27;;
	            break;
	        case &#x27;y&#x27;:
	            return isFuture ? &#x27;vuoden&#x27; : &#x27;vuosi&#x27;;
	        case &#x27;yy&#x27;:
	            result = isFuture ? &#x27;vuoden&#x27; : &#x27;vuotta&#x27;;
	            break;
	    }
	    result = verbalNumber(number, isFuture) + &#x27; &#x27; + result;
	    return result;
	}
	function verbalNumber(number, isFuture) {
	    return number &lt; 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}

	var fi = moment.defineLocale(&#x27;fi&#x27;, {
	    months : &#x27;tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;su_ma_ti_ke_to_pe_la&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;su_ma_ti_ke_to_pe_la&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;Do MMMM[ta] YYYY&#x27;,
	        LLL : &#x27;Do MMMM[ta] YYYY, [klo] HH.mm&#x27;,
	        LLLL : &#x27;dddd, Do MMMM[ta] YYYY, [klo] HH.mm&#x27;,
	        l : &#x27;D.M.YYYY&#x27;,
	        ll : &#x27;Do MMM YYYY&#x27;,
	        lll : &#x27;Do MMM YYYY, [klo] HH.mm&#x27;,
	        llll : &#x27;ddd, Do MMM YYYY, [klo] HH.mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[tänään] [klo] LT&#x27;,
	        nextDay : &#x27;[huomenna] [klo] LT&#x27;,
	        nextWeek : &#x27;dddd [klo] LT&#x27;,
	        lastDay : &#x27;[eilen] [klo] LT&#x27;,
	        lastWeek : &#x27;[viime] dddd[na] [klo] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s päästä&#x27;,
	        past : &#x27;%s sitten&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fi;

	})));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var fo = moment.defineLocale(&#x27;fo&#x27;, {
	    months : &#x27;januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sun_mán_týs_mik_hós_frí_ley&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;su_má_tý_mi_hó_fr_le&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM, YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Í dag kl.] LT&#x27;,
	        nextDay : &#x27;[Í morgin kl.] LT&#x27;,
	        nextWeek : &#x27;dddd [kl.] LT&#x27;,
	        lastDay : &#x27;[Í gjár kl.] LT&#x27;,
	        lastWeek : &#x27;[síðstu] dddd [kl] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;um %s&#x27;,
	        past : &#x27;%s síðani&#x27;,
	        s : &#x27;fá sekund&#x27;,
	        ss : &#x27;%d sekundir&#x27;,
	        m : &#x27;ein minutt&#x27;,
	        mm : &#x27;%d minuttir&#x27;,
	        h : &#x27;ein tími&#x27;,
	        hh : &#x27;%d tímar&#x27;,
	        d : &#x27;ein dagur&#x27;,
	        dd : &#x27;%d dagar&#x27;,
	        M : &#x27;ein mánaði&#x27;,
	        MM : &#x27;%d mánaðir&#x27;,
	        y : &#x27;eitt ár&#x27;,
	        yy : &#x27;%d ár&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fo;

	})));


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var fr = moment.defineLocale(&#x27;fr&#x27;, {
	    months : &#x27;janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim._lun._mar._mer._jeu._ven._sam.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_je_ve_sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Aujourd’hui à] LT&#x27;,
	        nextDay : &#x27;[Demain à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[Hier à] LT&#x27;,
	        lastWeek : &#x27;dddd [dernier à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dans %s&#x27;,
	        past : &#x27;il y a %s&#x27;,
	        s : &#x27;quelques secondes&#x27;,
	        ss : &#x27;%d secondes&#x27;,
	        m : &#x27;une minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;une heure&#x27;,
	        hh : &#x27;%d heures&#x27;,
	        d : &#x27;un jour&#x27;,
	        dd : &#x27;%d jours&#x27;,
	        M : &#x27;un mois&#x27;,
	        MM : &#x27;%d mois&#x27;,
	        y : &#x27;un an&#x27;,
	        yy : &#x27;%d ans&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // TODO: Return &#x27;e&#x27; when day of month &gt; 1. Move this case inside
	            // block for masculine words below.
	            // See https://github.com/moment/moment/issues/3375
	            case &#x27;D&#x27;:
	                return number + (number === 1 ? &#x27;er&#x27; : &#x27;&#x27;);

	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	                return number + (number === 1 ? &#x27;er&#x27; : &#x27;e&#x27;);

	            // Words with feminine grammatical gender: semaine
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + (number === 1 ? &#x27;re&#x27; : &#x27;e&#x27;);
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fr;

	})));


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var frCa = moment.defineLocale(&#x27;fr-ca&#x27;, {
	    months : &#x27;janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim._lun._mar._mer._jeu._ven._sam.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_je_ve_sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Aujourd’hui à] LT&#x27;,
	        nextDay : &#x27;[Demain à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[Hier à] LT&#x27;,
	        lastWeek : &#x27;dddd [dernier à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dans %s&#x27;,
	        past : &#x27;il y a %s&#x27;,
	        s : &#x27;quelques secondes&#x27;,
	        ss : &#x27;%d secondes&#x27;,
	        m : &#x27;une minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;une heure&#x27;,
	        hh : &#x27;%d heures&#x27;,
	        d : &#x27;un jour&#x27;,
	        dd : &#x27;%d jours&#x27;,
	        M : &#x27;un mois&#x27;,
	        MM : &#x27;%d mois&#x27;,
	        y : &#x27;un an&#x27;,
	        yy : &#x27;%d ans&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	                return number + (number === 1 ? &#x27;er&#x27; : &#x27;e&#x27;);

	            // Words with feminine grammatical gender: semaine
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + (number === 1 ? &#x27;re&#x27; : &#x27;e&#x27;);
	        }
	    }
	});

	return frCa;

	})));


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var frCh = moment.defineLocale(&#x27;fr-ch&#x27;, {
	    months : &#x27;janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim._lun._mar._mer._jeu._ven._sam.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_je_ve_sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Aujourd’hui à] LT&#x27;,
	        nextDay : &#x27;[Demain à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[Hier à] LT&#x27;,
	        lastWeek : &#x27;dddd [dernier à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dans %s&#x27;,
	        past : &#x27;il y a %s&#x27;,
	        s : &#x27;quelques secondes&#x27;,
	        ss : &#x27;%d secondes&#x27;,
	        m : &#x27;une minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;une heure&#x27;,
	        hh : &#x27;%d heures&#x27;,
	        d : &#x27;un jour&#x27;,
	        dd : &#x27;%d jours&#x27;,
	        M : &#x27;un mois&#x27;,
	        MM : &#x27;%d mois&#x27;,
	        y : &#x27;un an&#x27;,
	        yy : &#x27;%d ans&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	                return number + (number === 1 ? &#x27;er&#x27; : &#x27;e&#x27;);

	            // Words with feminine grammatical gender: semaine
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + (number === 1 ? &#x27;re&#x27; : &#x27;e&#x27;);
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return frCh;

	})));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortWithDots = &#x27;jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.&#x27;.split(&#x27;_&#x27;),
	    monthsShortWithoutDots = &#x27;jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des&#x27;.split(&#x27;_&#x27;);

	var fy = moment.defineLocale(&#x27;fy&#x27;, {
	    months : &#x27;jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : &#x27;snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;si._mo._ti._wo._to._fr._so.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Si_Mo_Ti_Wo_To_Fr_So&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[hjoed om] LT&#x27;,
	        nextDay: &#x27;[moarn om] LT&#x27;,
	        nextWeek: &#x27;dddd [om] LT&#x27;,
	        lastDay: &#x27;[juster om] LT&#x27;,
	        lastWeek: &#x27;[ôfrûne] dddd [om] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;oer %s&#x27;,
	        past : &#x27;%s lyn&#x27;,
	        s : &#x27;in pear sekonden&#x27;,
	        ss : &#x27;%d sekonden&#x27;,
	        m : &#x27;ien minút&#x27;,
	        mm : &#x27;%d minuten&#x27;,
	        h : &#x27;ien oere&#x27;,
	        hh : &#x27;%d oeren&#x27;,
	        d : &#x27;ien dei&#x27;,
	        dd : &#x27;%d dagen&#x27;,
	        M : &#x27;ien moanne&#x27;,
	        MM : &#x27;%d moannen&#x27;,
	        y : &#x27;ien jier&#x27;,
	        yy : &#x27;%d jierren&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number &gt;= 20) ? &#x27;ste&#x27; : &#x27;de&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fy;

	})));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months = [
	    &#x27;Am Faoilleach&#x27;, &#x27;An Gearran&#x27;, &#x27;Am Màrt&#x27;, &#x27;An Giblean&#x27;, &#x27;An Cèitean&#x27;, &#x27;An t-Ògmhios&#x27;, &#x27;An t-Iuchar&#x27;, &#x27;An Lùnastal&#x27;, &#x27;An t-Sultain&#x27;, &#x27;An Dàmhair&#x27;, &#x27;An t-Samhain&#x27;, &#x27;An Dùbhlachd&#x27;
	];

	var monthsShort = [&#x27;Faoi&#x27;, &#x27;Gear&#x27;, &#x27;Màrt&#x27;, &#x27;Gibl&#x27;, &#x27;Cèit&#x27;, &#x27;Ògmh&#x27;, &#x27;Iuch&#x27;, &#x27;Lùn&#x27;, &#x27;Sult&#x27;, &#x27;Dàmh&#x27;, &#x27;Samh&#x27;, &#x27;Dùbh&#x27;];

	var weekdays = [&#x27;Didòmhnaich&#x27;, &#x27;Diluain&#x27;, &#x27;Dimàirt&#x27;, &#x27;Diciadain&#x27;, &#x27;Diardaoin&#x27;, &#x27;Dihaoine&#x27;, &#x27;Disathairne&#x27;];

	var weekdaysShort = [&#x27;Did&#x27;, &#x27;Dil&#x27;, &#x27;Dim&#x27;, &#x27;Dic&#x27;, &#x27;Dia&#x27;, &#x27;Dih&#x27;, &#x27;Dis&#x27;];

	var weekdaysMin = [&#x27;Dò&#x27;, &#x27;Lu&#x27;, &#x27;Mà&#x27;, &#x27;Ci&#x27;, &#x27;Ar&#x27;, &#x27;Ha&#x27;, &#x27;Sa&#x27;];

	var gd = moment.defineLocale(&#x27;gd&#x27;, {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParseExact : true,
	    weekdays : weekdays,
	    weekdaysShort : weekdaysShort,
	    weekdaysMin : weekdaysMin,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[An-diugh aig] LT&#x27;,
	        nextDay : &#x27;[A-màireach aig] LT&#x27;,
	        nextWeek : &#x27;dddd [aig] LT&#x27;,
	        lastDay : &#x27;[An-dè aig] LT&#x27;,
	        lastWeek : &#x27;dddd [seo chaidh] [aig] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ann an %s&#x27;,
	        past : &#x27;bho chionn %s&#x27;,
	        s : &#x27;beagan diogan&#x27;,
	        ss : &#x27;%d diogan&#x27;,
	        m : &#x27;mionaid&#x27;,
	        mm : &#x27;%d mionaidean&#x27;,
	        h : &#x27;uair&#x27;,
	        hh : &#x27;%d uairean&#x27;,
	        d : &#x27;latha&#x27;,
	        dd : &#x27;%d latha&#x27;,
	        M : &#x27;mìos&#x27;,
	        MM : &#x27;%d mìosan&#x27;,
	        y : &#x27;bliadhna&#x27;,
	        yy : &#x27;%d bliadhna&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
	    ordinal : function (number) {
	        var output = number === 1 ? &#x27;d&#x27; : number % 10 === 2 ? &#x27;na&#x27; : &#x27;mh&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gd;

	})));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var gl = moment.defineLocale(&#x27;gl&#x27;, {
	    months : &#x27;xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;domingo_luns_martes_mércores_xoves_venres_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mér._xov._ven._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mé_xo_ve_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoxe &#x27; + ((this.hours() !== 1) ? &#x27;ás&#x27; : &#x27;á&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañá &#x27; + ((this.hours() !== 1) ? &#x27;ás&#x27; : &#x27;á&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [&#x27; + ((this.hours() !== 1) ? &#x27;ás&#x27; : &#x27;a&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[onte &#x27; + ((this.hours() !== 1) ? &#x27;á&#x27; : &#x27;a&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[o] dddd [pasado &#x27; + ((this.hours() !== 1) ? &#x27;ás&#x27; : &#x27;a&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (str) {
	            if (str.indexOf(&#x27;un&#x27;) === 0) {
	                return &#x27;n&#x27; + str;
	            }
	            return &#x27;en &#x27; + str;
	        },
	        past : &#x27;hai %s&#x27;,
	        s : &#x27;uns segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;unha hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un ano&#x27;,
	        yy : &#x27;%d anos&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gl;

	})));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        &#x27;s&#x27;: [&#x27;thodde secondanim&#x27;, &#x27;thodde second&#x27;],
	        &#x27;ss&#x27;: [number + &#x27; secondanim&#x27;, number + &#x27; second&#x27;],
	        &#x27;m&#x27;: [&#x27;eka mintan&#x27;, &#x27;ek minute&#x27;],
	        &#x27;mm&#x27;: [number + &#x27; mintanim&#x27;, number + &#x27; mintam&#x27;],
	        &#x27;h&#x27;: [&#x27;eka horan&#x27;, &#x27;ek hor&#x27;],
	        &#x27;hh&#x27;: [number + &#x27; horanim&#x27;, number + &#x27; hor&#x27;],
	        &#x27;d&#x27;: [&#x27;eka disan&#x27;, &#x27;ek dis&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; disanim&#x27;, number + &#x27; dis&#x27;],
	        &#x27;M&#x27;: [&#x27;eka mhoinean&#x27;, &#x27;ek mhoino&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; mhoineanim&#x27;, number + &#x27; mhoine&#x27;],
	        &#x27;y&#x27;: [&#x27;eka vorsan&#x27;, &#x27;ek voros&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; vorsanim&#x27;, number + &#x27; vorsam&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var gomLatn = moment.defineLocale(&#x27;gom-latn&#x27;, {
	    months : &#x27;Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\&#x27;var&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ait._Som._Mon._Bud._Bre._Suk._Son.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ai_Sm_Mo_Bu_Br_Su_Sn&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;A h:mm [vazta]&#x27;,
	        LTS : &#x27;A h:mm:ss [vazta]&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY A h:mm [vazta]&#x27;,
	        LLLL : &#x27;dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]&#x27;,
	        llll: &#x27;ddd, D MMM YYYY, A h:mm [vazta]&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Aiz] LT&#x27;,
	        nextDay: &#x27;[Faleam] LT&#x27;,
	        nextWeek: &#x27;[Ieta to] dddd[,] LT&#x27;,
	        lastDay: &#x27;[Kal] LT&#x27;,
	        lastWeek: &#x27;[Fatlo] dddd[,] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s&#x27;,
	        past : &#x27;%s adim&#x27;,
	        s : processRelativeTime,
	        ss : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // the ordinal &#x27;er&#x27; only applies to day of the month
	            case &#x27;D&#x27;:
	                return number + &#x27;er&#x27;;
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    },
	    meridiemParse: /rati|sokalli|donparam|sanje/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;rati&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;sokalli&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;donparam&#x27;) {
	            return hour &gt; 12 ? hour : hour + 12;
	        } else if (meridiem === &#x27;sanje&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;rati&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;sokalli&#x27;;
	        } else if (hour &lt; 16) {
	            return &#x27;donparam&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;sanje&#x27;;
	        } else {
	            return &#x27;rati&#x27;;
	        }
	    }
	});

	return gomLatn;

	})));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	        &#x27;1&#x27;: &#x27;૧&#x27;,
	        &#x27;2&#x27;: &#x27;૨&#x27;,
	        &#x27;3&#x27;: &#x27;૩&#x27;,
	        &#x27;4&#x27;: &#x27;૪&#x27;,
	        &#x27;5&#x27;: &#x27;૫&#x27;,
	        &#x27;6&#x27;: &#x27;૬&#x27;,
	        &#x27;7&#x27;: &#x27;૭&#x27;,
	        &#x27;8&#x27;: &#x27;૮&#x27;,
	        &#x27;9&#x27;: &#x27;૯&#x27;,
	        &#x27;0&#x27;: &#x27;૦&#x27;
	    },
	    numberMap = {
	        &#x27;૧&#x27;: &#x27;1&#x27;,
	        &#x27;૨&#x27;: &#x27;2&#x27;,
	        &#x27;૩&#x27;: &#x27;3&#x27;,
	        &#x27;૪&#x27;: &#x27;4&#x27;,
	        &#x27;૫&#x27;: &#x27;5&#x27;,
	        &#x27;૬&#x27;: &#x27;6&#x27;,
	        &#x27;૭&#x27;: &#x27;7&#x27;,
	        &#x27;૮&#x27;: &#x27;8&#x27;,
	        &#x27;૯&#x27;: &#x27;9&#x27;,
	        &#x27;૦&#x27;: &#x27;0&#x27;
	    };

	var gu = moment.defineLocale(&#x27;gu&#x27;, {
	    months: &#x27;જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays: &#x27;રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ર_સો_મં_બુ_ગુ_શુ_શ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;A h:mm વાગ્યે&#x27;,
	        LTS: &#x27;A h:mm:ss વાગ્યે&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY, A h:mm વાગ્યે&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY, A h:mm વાગ્યે&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[આજ] LT&#x27;,
	        nextDay: &#x27;[કાલે] LT&#x27;,
	        nextWeek: &#x27;dddd, LT&#x27;,
	        lastDay: &#x27;[ગઇકાલે] LT&#x27;,
	        lastWeek: &#x27;[પાછલા] dddd, LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;%s મા&#x27;,
	        past: &#x27;%s પેહલા&#x27;,
	        s: &#x27;અમુક પળો&#x27;,
	        ss: &#x27;%d સેકંડ&#x27;,
	        m: &#x27;એક મિનિટ&#x27;,
	        mm: &#x27;%d મિનિટ&#x27;,
	        h: &#x27;એક કલાક&#x27;,
	        hh: &#x27;%d કલાક&#x27;,
	        d: &#x27;એક દિવસ&#x27;,
	        dd: &#x27;%d દિવસ&#x27;,
	        M: &#x27;એક મહિનો&#x27;,
	        MM: &#x27;%d મહિનો&#x27;,
	        y: &#x27;એક વર્ષ&#x27;,
	        yy: &#x27;%d વર્ષ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a &#x27;Pahar&#x27; it is not used as rigidly in modern Gujarati.
	    meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;રાત&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;સવાર&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;બપોર&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else if (meridiem === &#x27;સાંજ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;રાત&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;સવાર&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;બપોર&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;સાંજ&#x27;;
	        } else {
	            return &#x27;રાત&#x27;;
	        }
	    },
	    week: {
	        dow: 0, // Sunday is the first day of the week.
	        doy: 6 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return gu;

	})));


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var he = moment.defineLocale(&#x27;he&#x27;, {
	    months : &#x27;ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;א_ב_ג_ד_ה_ו_ש&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [ב]MMMM YYYY&#x27;,
	        LLL : &#x27;D [ב]MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D [ב]MMMM YYYY HH:mm&#x27;,
	        l : &#x27;D/M/YYYY&#x27;,
	        ll : &#x27;D MMM YYYY&#x27;,
	        lll : &#x27;D MMM YYYY HH:mm&#x27;,
	        llll : &#x27;ddd, D MMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[היום ב־]LT&#x27;,
	        nextDay : &#x27;[מחר ב־]LT&#x27;,
	        nextWeek : &#x27;dddd [בשעה] LT&#x27;,
	        lastDay : &#x27;[אתמול ב־]LT&#x27;,
	        lastWeek : &#x27;[ביום] dddd [האחרון בשעה] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;בעוד %s&#x27;,
	        past : &#x27;לפני %s&#x27;,
	        s : &#x27;מספר שניות&#x27;,
	        ss : &#x27;%d שניות&#x27;,
	        m : &#x27;דקה&#x27;,
	        mm : &#x27;%d דקות&#x27;,
	        h : &#x27;שעה&#x27;,
	        hh : function (number) {
	            if (number === 2) {
	                return &#x27;שעתיים&#x27;;
	            }
	            return number + &#x27; שעות&#x27;;
	        },
	        d : &#x27;יום&#x27;,
	        dd : function (number) {
	            if (number === 2) {
	                return &#x27;יומיים&#x27;;
	            }
	            return number + &#x27; ימים&#x27;;
	        },
	        M : &#x27;חודש&#x27;,
	        MM : function (number) {
	            if (number === 2) {
	                return &#x27;חודשיים&#x27;;
	            }
	            return number + &#x27; חודשים&#x27;;
	        },
	        y : &#x27;שנה&#x27;,
	        yy : function (number) {
	            if (number === 2) {
	                return &#x27;שנתיים&#x27;;
	            } else if (number % 10 === 0 &amp;&amp; number !== 10) {
	                return number + &#x27; שנה&#x27;;
	            }
	            return number + &#x27; שנים&#x27;;
	        }
	    },
	    meridiemParse: /אחה&quot;צ|לפנה&quot;צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
	    isPM : function (input) {
	        return /^(אחה&quot;צ|אחרי הצהריים|בערב)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 5) {
	            return &#x27;לפנות בוקר&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;בבוקר&#x27;;
	        } else if (hour &lt; 12) {
	            return isLower ? &#x27;לפנה&quot;צ&#x27; : &#x27;לפני הצהריים&#x27;;
	        } else if (hour &lt; 18) {
	            return isLower ? &#x27;אחה&quot;צ&#x27; : &#x27;אחרי הצהריים&#x27;;
	        } else {
	            return &#x27;בערב&#x27;;
	        }
	    }
	});

	return he;

	})));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;१&#x27;,
	    &#x27;2&#x27;: &#x27;२&#x27;,
	    &#x27;3&#x27;: &#x27;३&#x27;,
	    &#x27;4&#x27;: &#x27;४&#x27;,
	    &#x27;5&#x27;: &#x27;५&#x27;,
	    &#x27;6&#x27;: &#x27;६&#x27;,
	    &#x27;7&#x27;: &#x27;७&#x27;,
	    &#x27;8&#x27;: &#x27;८&#x27;,
	    &#x27;9&#x27;: &#x27;९&#x27;,
	    &#x27;0&#x27;: &#x27;०&#x27;
	},
	numberMap = {
	    &#x27;१&#x27;: &#x27;1&#x27;,
	    &#x27;२&#x27;: &#x27;2&#x27;,
	    &#x27;३&#x27;: &#x27;3&#x27;,
	    &#x27;४&#x27;: &#x27;4&#x27;,
	    &#x27;५&#x27;: &#x27;5&#x27;,
	    &#x27;६&#x27;: &#x27;6&#x27;,
	    &#x27;७&#x27;: &#x27;7&#x27;,
	    &#x27;८&#x27;: &#x27;8&#x27;,
	    &#x27;९&#x27;: &#x27;9&#x27;,
	    &#x27;०&#x27;: &#x27;0&#x27;
	};

	var hi = moment.defineLocale(&#x27;hi&#x27;, {
	    months : &#x27;जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;र_सो_मं_बु_गु_शु_श&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm बजे&#x27;,
	        LTS : &#x27;A h:mm:ss बजे&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm बजे&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm बजे&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[आज] LT&#x27;,
	        nextDay : &#x27;[कल] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[कल] LT&#x27;,
	        lastWeek : &#x27;[पिछले] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s में&#x27;,
	        past : &#x27;%s पहले&#x27;,
	        s : &#x27;कुछ ही क्षण&#x27;,
	        ss : &#x27;%d सेकंड&#x27;,
	        m : &#x27;एक मिनट&#x27;,
	        mm : &#x27;%d मिनट&#x27;,
	        h : &#x27;एक घंटा&#x27;,
	        hh : &#x27;%d घंटे&#x27;,
	        d : &#x27;एक दिन&#x27;,
	        dd : &#x27;%d दिन&#x27;,
	        M : &#x27;एक महीने&#x27;,
	        MM : &#x27;%d महीने&#x27;,
	        y : &#x27;एक वर्ष&#x27;,
	        yy : &#x27;%d वर्ष&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a &#x27;Pahar&#x27; it is not used as rigidly in modern Hindi.
	    meridiemParse: /रात|सुबह|दोपहर|शाम/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;रात&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;सुबह&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;दोपहर&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else if (meridiem === &#x27;शाम&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;रात&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;सुबह&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;दोपहर&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;शाम&#x27;;
	        } else {
	            return &#x27;रात&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hi;

	})));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function translate(number, withoutSuffix, key) {
	    var result = number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;ss&#x27;:
	            if (number === 1) {
	                result += &#x27;sekunda&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;sekunde&#x27;;
	            } else {
	                result += &#x27;sekundi&#x27;;
	            }
	            return result;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;jedna minuta&#x27; : &#x27;jedne minute&#x27;;
	        case &#x27;mm&#x27;:
	            if (number === 1) {
	                result += &#x27;minuta&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;minute&#x27;;
	            } else {
	                result += &#x27;minuta&#x27;;
	            }
	            return result;
	        case &#x27;h&#x27;:
	            return withoutSuffix ? &#x27;jedan sat&#x27; : &#x27;jednog sata&#x27;;
	        case &#x27;hh&#x27;:
	            if (number === 1) {
	                result += &#x27;sat&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;sata&#x27;;
	            } else {
	                result += &#x27;sati&#x27;;
	            }
	            return result;
	        case &#x27;dd&#x27;:
	            if (number === 1) {
	                result += &#x27;dan&#x27;;
	            } else {
	                result += &#x27;dana&#x27;;
	            }
	            return result;
	        case &#x27;MM&#x27;:
	            if (number === 1) {
	                result += &#x27;mjesec&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;mjeseca&#x27;;
	            } else {
	                result += &#x27;mjeseci&#x27;;
	            }
	            return result;
	        case &#x27;yy&#x27;:
	            if (number === 1) {
	                result += &#x27;godina&#x27;;
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += &#x27;godine&#x27;;
	            } else {
	                result += &#x27;godina&#x27;;
	            }
	            return result;
	    }
	}

	var hr = moment.defineLocale(&#x27;hr&#x27;, {
	    months : {
	        format: &#x27;siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ned._pon._uto._sri._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[danas u] LT&#x27;,
	        nextDay  : &#x27;[sutra u] LT&#x27;,
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedjelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [srijedu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[jučer u] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return &#x27;[prošlu] dddd [u] LT&#x27;;
	                case 6:
	                    return &#x27;[prošle] [subote] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[prošli] dddd [u] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;prije %s&#x27;,
	        s      : &#x27;par sekundi&#x27;,
	        ss     : translate,
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translate,
	        M      : &#x27;mjesec&#x27;,
	        MM     : translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hr;

	})));


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var weekEndings = &#x27;vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton&#x27;.split(&#x27; &#x27;);
	function translate(number, withoutSuffix, key, isFuture) {
	    var num = number;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return (isFuture || withoutSuffix) ? &#x27;néhány másodperc&#x27; : &#x27;néhány másodperce&#x27;;
	        case &#x27;ss&#x27;:
	            return num + (isFuture || withoutSuffix) ? &#x27; másodperc&#x27; : &#x27; másodperce&#x27;;
	        case &#x27;m&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; perc&#x27; : &#x27; perce&#x27;);
	        case &#x27;mm&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; perc&#x27; : &#x27; perce&#x27;);
	        case &#x27;h&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; óra&#x27; : &#x27; órája&#x27;);
	        case &#x27;hh&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; óra&#x27; : &#x27; órája&#x27;);
	        case &#x27;d&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; nap&#x27; : &#x27; napja&#x27;);
	        case &#x27;dd&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; nap&#x27; : &#x27; napja&#x27;);
	        case &#x27;M&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; hónap&#x27; : &#x27; hónapja&#x27;);
	        case &#x27;MM&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; hónap&#x27; : &#x27; hónapja&#x27;);
	        case &#x27;y&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; év&#x27; : &#x27; éve&#x27;);
	        case &#x27;yy&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; év&#x27; : &#x27; éve&#x27;);
	    }
	    return &#x27;&#x27;;
	}
	function week(isFuture) {
	    return (isFuture ? &#x27;&#x27; : &#x27;[múlt] &#x27;) + &#x27;[&#x27; + weekEndings[this.day()] + &#x27;] LT[-kor]&#x27;;
	}

	var hu = moment.defineLocale(&#x27;hu&#x27;, {
	    months : &#x27;január_február_március_április_május_június_július_augusztus_szeptember_október_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;vas_hét_kedd_sze_csüt_pén_szo&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;v_h_k_sze_cs_p_szo&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;YYYY.MM.DD.&#x27;,
	        LL : &#x27;YYYY. MMMM D.&#x27;,
	        LLL : &#x27;YYYY. MMMM D. H:mm&#x27;,
	        LLLL : &#x27;YYYY. MMMM D., dddd H:mm&#x27;
	    },
	    meridiemParse: /de|du/i,
	    isPM: function (input) {
	        return input.charAt(1).toLowerCase() === &#x27;u&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 12) {
	            return isLower === true ? &#x27;de&#x27; : &#x27;DE&#x27;;
	        } else {
	            return isLower === true ? &#x27;du&#x27; : &#x27;DU&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[ma] LT[-kor]&#x27;,
	        nextDay : &#x27;[holnap] LT[-kor]&#x27;,
	        nextWeek : function () {
	            return week.call(this, true);
	        },
	        lastDay : &#x27;[tegnap] LT[-kor]&#x27;,
	        lastWeek : function () {
	            return week.call(this, false);
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s múlva&#x27;,
	        past : &#x27;%s&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return hu;

	})));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var hyAm = moment.defineLocale(&#x27;hy-am&#x27;, {
	    months : {
	        format: &#x27;հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY թ.&#x27;,
	        LLL : &#x27;D MMMM YYYY թ., HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY թ., HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[այսօր] LT&#x27;,
	        nextDay: &#x27;[վաղը] LT&#x27;,
	        lastDay: &#x27;[երեկ] LT&#x27;,
	        nextWeek: function () {
	            return &#x27;dddd [օրը ժամը] LT&#x27;;
	        },
	        lastWeek: function () {
	            return &#x27;[անցած] dddd [օրը ժամը] LT&#x27;;
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s հետո&#x27;,
	        past : &#x27;%s առաջ&#x27;,
	        s : &#x27;մի քանի վայրկյան&#x27;,
	        ss : &#x27;%d վայրկյան&#x27;,
	        m : &#x27;րոպե&#x27;,
	        mm : &#x27;%d րոպե&#x27;,
	        h : &#x27;ժամ&#x27;,
	        hh : &#x27;%d ժամ&#x27;,
	        d : &#x27;օր&#x27;,
	        dd : &#x27;%d օր&#x27;,
	        M : &#x27;ամիս&#x27;,
	        MM : &#x27;%d ամիս&#x27;,
	        y : &#x27;տարի&#x27;,
	        yy : &#x27;%d տարի&#x27;
	    },
	    meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	    isPM: function (input) {
	        return /^(ցերեկվա|երեկոյան)$/.test(input);
	    },
	    meridiem : function (hour) {
	        if (hour &lt; 4) {
	            return &#x27;գիշերվա&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;առավոտվա&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ցերեկվա&#x27;;
	        } else {
	            return &#x27;երեկոյան&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;DDD&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	            case &#x27;DDDo&#x27;:
	                if (number === 1) {
	                    return number + &#x27;-ին&#x27;;
	                }
	                return number + &#x27;-րդ&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hyAm;

	})));


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var id = moment.defineLocale(&#x27;id&#x27;, {
	    months : &#x27;Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Min_Sen_Sel_Rab_Kam_Jum_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Mg_Sn_Sl_Rb_Km_Jm_Sb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /pagi|siang|sore|malam/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;pagi&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;siang&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;sore&#x27; || meridiem === &#x27;malam&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;pagi&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;siang&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;sore&#x27;;
	        } else {
	            return &#x27;malam&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hari ini pukul] LT&#x27;,
	        nextDay : &#x27;[Besok pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kemarin pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [lalu pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dalam %s&#x27;,
	        past : &#x27;%s yang lalu&#x27;,
	        s : &#x27;beberapa detik&#x27;,
	        ss : &#x27;%d detik&#x27;,
	        m : &#x27;semenit&#x27;,
	        mm : &#x27;%d menit&#x27;,
	        h : &#x27;sejam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sehari&#x27;,
	        dd : &#x27;%d hari&#x27;,
	        M : &#x27;sebulan&#x27;,
	        MM : &#x27;%d bulan&#x27;,
	        y : &#x27;setahun&#x27;,
	        yy : &#x27;%d tahun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return id;

	})));


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(n) {
	    if (n % 100 === 11) {
	        return true;
	    } else if (n % 10 === 1) {
	        return false;
	    }
	    return true;
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return withoutSuffix || isFuture ? &#x27;nokkrar sekúndur&#x27; : &#x27;nokkrum sekúndum&#x27;;
	        case &#x27;ss&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;sekúndur&#x27; : &#x27;sekúndum&#x27;);
	            }
	            return result + &#x27;sekúnda&#x27;;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;mínúta&#x27; : &#x27;mínútu&#x27;;
	        case &#x27;mm&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;mínútur&#x27; : &#x27;mínútum&#x27;);
	            } else if (withoutSuffix) {
	                return result + &#x27;mínúta&#x27;;
	            }
	            return result + &#x27;mínútu&#x27;;
	        case &#x27;hh&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;klukkustundir&#x27; : &#x27;klukkustundum&#x27;);
	            }
	            return result + &#x27;klukkustund&#x27;;
	        case &#x27;d&#x27;:
	            if (withoutSuffix) {
	                return &#x27;dagur&#x27;;
	            }
	            return isFuture ? &#x27;dag&#x27; : &#x27;degi&#x27;;
	        case &#x27;dd&#x27;:
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + &#x27;dagar&#x27;;
	                }
	                return result + (isFuture ? &#x27;daga&#x27; : &#x27;dögum&#x27;);
	            } else if (withoutSuffix) {
	                return result + &#x27;dagur&#x27;;
	            }
	            return result + (isFuture ? &#x27;dag&#x27; : &#x27;degi&#x27;);
	        case &#x27;M&#x27;:
	            if (withoutSuffix) {
	                return &#x27;mánuður&#x27;;
	            }
	            return isFuture ? &#x27;mánuð&#x27; : &#x27;mánuði&#x27;;
	        case &#x27;MM&#x27;:
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + &#x27;mánuðir&#x27;;
	                }
	                return result + (isFuture ? &#x27;mánuði&#x27; : &#x27;mánuðum&#x27;);
	            } else if (withoutSuffix) {
	                return result + &#x27;mánuður&#x27;;
	            }
	            return result + (isFuture ? &#x27;mánuð&#x27; : &#x27;mánuði&#x27;);
	        case &#x27;y&#x27;:
	            return withoutSuffix || isFuture ? &#x27;ár&#x27; : &#x27;ári&#x27;;
	        case &#x27;yy&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;ár&#x27; : &#x27;árum&#x27;);
	            }
	            return result + (withoutSuffix || isFuture ? &#x27;ár&#x27; : &#x27;ári&#x27;);
	    }
	}

	var is = moment.defineLocale(&#x27;is&#x27;, {
	    months : &#x27;janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sun_mán_þri_mið_fim_fös_lau&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Má_Þr_Mi_Fi_Fö_La&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY [kl.] H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY [kl.] H:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[í dag kl.] LT&#x27;,
	        nextDay : &#x27;[á morgun kl.] LT&#x27;,
	        nextWeek : &#x27;dddd [kl.] LT&#x27;,
	        lastDay : &#x27;[í gær kl.] LT&#x27;,
	        lastWeek : &#x27;[síðasta] dddd [kl.] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;eftir %s&#x27;,
	        past : &#x27;fyrir %s síðan&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : &#x27;klukkustund&#x27;,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return is;

	})));


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var it = moment.defineLocale(&#x27;it&#x27;, {
	    months : &#x27;gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom_lun_mar_mer_gio_ven_sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_me_gi_ve_sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Oggi alle] LT&#x27;,
	        nextDay: &#x27;[Domani alle] LT&#x27;,
	        nextWeek: &#x27;dddd [alle] LT&#x27;,
	        lastDay: &#x27;[Ieri alle] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[la scorsa] dddd [alle] LT&#x27;;
	                default:
	                    return &#x27;[lo scorso] dddd [alle] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (s) {
	            return ((/^[0-9].+$/).test(s) ? &#x27;tra&#x27; : &#x27;in&#x27;) + &#x27; &#x27; + s;
	        },
	        past : &#x27;%s fa&#x27;,
	        s : &#x27;alcuni secondi&#x27;,
	        ss : &#x27;%d secondi&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minuti&#x27;,
	        h : &#x27;un\&#x27;ora&#x27;,
	        hh : &#x27;%d ore&#x27;,
	        d : &#x27;un giorno&#x27;,
	        dd : &#x27;%d giorni&#x27;,
	        M : &#x27;un mese&#x27;,
	        MM : &#x27;%d mesi&#x27;,
	        y : &#x27;un anno&#x27;,
	        yy : &#x27;%d anni&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal: &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return it;

	})));


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ja = moment.defineLocale(&#x27;ja&#x27;, {
	    months : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;日_月_火_水_木_金_土&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_月_火_水_木_金_土&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        LLLL : &#x27;YYYY年M月D日 HH:mm dddd&#x27;,
	        l : &#x27;YYYY/MM/DD&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日 HH:mm dddd&#x27;
	    },
	    meridiemParse: /午前|午後/i,
	    isPM : function (input) {
	        return input === &#x27;午後&#x27;;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;午前&#x27;;
	        } else {
	            return &#x27;午後&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今日] LT&#x27;,
	        nextDay : &#x27;[明日] LT&#x27;,
	        nextWeek : &#x27;[来週]dddd LT&#x27;,
	        lastDay : &#x27;[昨日] LT&#x27;,
	        lastWeek : &#x27;[前週]dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}日/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;日&#x27;;
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s後&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;数秒&#x27;,
	        ss : &#x27;%d秒&#x27;,
	        m : &#x27;1分&#x27;,
	        mm : &#x27;%d分&#x27;,
	        h : &#x27;1時間&#x27;,
	        hh : &#x27;%d時間&#x27;,
	        d : &#x27;1日&#x27;,
	        dd : &#x27;%d日&#x27;,
	        M : &#x27;1ヶ月&#x27;,
	        MM : &#x27;%dヶ月&#x27;,
	        y : &#x27;1年&#x27;,
	        yy : &#x27;%d年&#x27;
	    }
	});

	return ja;

	})));


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var jv = moment.defineLocale(&#x27;jv&#x27;, {
	    months : &#x27;Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Min_Sen_Sel_Reb_Kem_Jem_Sep&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Mg_Sn_Sl_Rb_Km_Jm_Sp&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /enjing|siyang|sonten|ndalu/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;enjing&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;siyang&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;sonten&#x27; || meridiem === &#x27;ndalu&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;enjing&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;siyang&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;sonten&#x27;;
	        } else {
	            return &#x27;ndalu&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Dinten puniko pukul] LT&#x27;,
	        nextDay : &#x27;[Mbenjang pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kala wingi pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [kepengker pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;wonten ing %s&#x27;,
	        past : &#x27;%s ingkang kepengker&#x27;,
	        s : &#x27;sawetawis detik&#x27;,
	        ss : &#x27;%d detik&#x27;,
	        m : &#x27;setunggal menit&#x27;,
	        mm : &#x27;%d menit&#x27;,
	        h : &#x27;setunggal jam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sedinten&#x27;,
	        dd : &#x27;%d dinten&#x27;,
	        M : &#x27;sewulan&#x27;,
	        MM : &#x27;%d wulan&#x27;,
	        y : &#x27;setaun&#x27;,
	        yy : &#x27;%d taun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return jv;

	})));


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ka = moment.defineLocale(&#x27;ka&#x27;, {
	    months : {
	        standalone: &#x27;იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ&#x27;.split(&#x27;_&#x27;),
	    weekdays : {
	        standalone: &#x27;კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს&#x27;.split(&#x27;_&#x27;),
	        isFormat: /(წინა|შემდეგ)/
	    },
	    weekdaysShort : &#x27;კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;კვ_ორ_სა_ოთ_ხუ_პა_შა&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[დღეს] LT[-ზე]&#x27;,
	        nextDay : &#x27;[ხვალ] LT[-ზე]&#x27;,
	        lastDay : &#x27;[გუშინ] LT[-ზე]&#x27;,
	        nextWeek : &#x27;[შემდეგ] dddd LT[-ზე]&#x27;,
	        lastWeek : &#x27;[წინა] dddd LT-ზე&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (s) {
	            return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                s.replace(/ი$/, &#x27;ში&#x27;) :
	                s + &#x27;ში&#x27;;
	        },
	        past : function (s) {
	            if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                return s.replace(/(ი|ე)$/, &#x27;ის უკან&#x27;);
	            }
	            if ((/წელი/).test(s)) {
	                return s.replace(/წელი$/, &#x27;წლის უკან&#x27;);
	            }
	        },
	        s : &#x27;რამდენიმე წამი&#x27;,
	        ss : &#x27;%d წამი&#x27;,
	        m : &#x27;წუთი&#x27;,
	        mm : &#x27;%d წუთი&#x27;,
	        h : &#x27;საათი&#x27;,
	        hh : &#x27;%d საათი&#x27;,
	        d : &#x27;დღე&#x27;,
	        dd : &#x27;%d დღე&#x27;,
	        M : &#x27;თვე&#x27;,
	        MM : &#x27;%d თვე&#x27;,
	        y : &#x27;წელი&#x27;,
	        yy : &#x27;%d წელი&#x27;
	    },
	    dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	    ordinal : function (number) {
	        if (number === 0) {
	            return number;
	        }
	        if (number === 1) {
	            return number + &#x27;-ლი&#x27;;
	        }
	        if ((number &lt; 20) || (number &lt;= 100 &amp;&amp; (number % 20 === 0)) || (number % 100 === 0)) {
	            return &#x27;მე-&#x27; + number;
	        }
	        return number + &#x27;-ე&#x27;;
	    },
	    week : {
	        dow : 1,
	        doy : 7
	    }
	});

	return ka;

	})));


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes = {
	    0: &#x27;-ші&#x27;,
	    1: &#x27;-ші&#x27;,
	    2: &#x27;-ші&#x27;,
	    3: &#x27;-ші&#x27;,
	    4: &#x27;-ші&#x27;,
	    5: &#x27;-ші&#x27;,
	    6: &#x27;-шы&#x27;,
	    7: &#x27;-ші&#x27;,
	    8: &#x27;-ші&#x27;,
	    9: &#x27;-шы&#x27;,
	    10: &#x27;-шы&#x27;,
	    20: &#x27;-шы&#x27;,
	    30: &#x27;-шы&#x27;,
	    40: &#x27;-шы&#x27;,
	    50: &#x27;-ші&#x27;,
	    60: &#x27;-шы&#x27;,
	    70: &#x27;-ші&#x27;,
	    80: &#x27;-ші&#x27;,
	    90: &#x27;-шы&#x27;,
	    100: &#x27;-ші&#x27;
	};

	var kk = moment.defineLocale(&#x27;kk&#x27;, {
	    months : &#x27;қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;жек_дүй_сей_сәр_бей_жұм_сен&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;жк_дй_сй_ср_бй_жм_сн&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Бүгін сағат] LT&#x27;,
	        nextDay : &#x27;[Ертең сағат] LT&#x27;,
	        nextWeek : &#x27;dddd [сағат] LT&#x27;,
	        lastDay : &#x27;[Кеше сағат] LT&#x27;,
	        lastWeek : &#x27;[Өткен аптаның] dddd [сағат] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ішінде&#x27;,
	        past : &#x27;%s бұрын&#x27;,
	        s : &#x27;бірнеше секунд&#x27;,
	        ss : &#x27;%d секунд&#x27;,
	        m : &#x27;бір минут&#x27;,
	        mm : &#x27;%d минут&#x27;,
	        h : &#x27;бір сағат&#x27;,
	        hh : &#x27;%d сағат&#x27;,
	        d : &#x27;бір күн&#x27;,
	        dd : &#x27;%d күн&#x27;,
	        M : &#x27;бір ай&#x27;,
	        MM : &#x27;%d ай&#x27;,
	        y : &#x27;бір жыл&#x27;,
	        yy : &#x27;%d жыл&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number &gt;= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kk;

	})));


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var km = moment.defineLocale(&#x27;km&#x27;, {
	    months: &#x27;មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[ថ្ងៃនេះ ម៉ោង] LT&#x27;,
	        nextDay: &#x27;[ស្អែក ម៉ោង] LT&#x27;,
	        nextWeek: &#x27;dddd [ម៉ោង] LT&#x27;,
	        lastDay: &#x27;[ម្សិលមិញ ម៉ោង] LT&#x27;,
	        lastWeek: &#x27;dddd [សប្តាហ៍មុន] [ម៉ោង] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;%sទៀត&#x27;,
	        past: &#x27;%sមុន&#x27;,
	        s: &#x27;ប៉ុន្មានវិនាទី&#x27;,
	        ss: &#x27;%d វិនាទី&#x27;,
	        m: &#x27;មួយនាទី&#x27;,
	        mm: &#x27;%d នាទី&#x27;,
	        h: &#x27;មួយម៉ោង&#x27;,
	        hh: &#x27;%d ម៉ោង&#x27;,
	        d: &#x27;មួយថ្ងៃ&#x27;,
	        dd: &#x27;%d ថ្ងៃ&#x27;,
	        M: &#x27;មួយខែ&#x27;,
	        MM: &#x27;%d ខែ&#x27;,
	        y: &#x27;មួយឆ្នាំ&#x27;,
	        yy: &#x27;%d ឆ្នាំ&#x27;
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return km;

	})));


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;೧&#x27;,
	    &#x27;2&#x27;: &#x27;೨&#x27;,
	    &#x27;3&#x27;: &#x27;೩&#x27;,
	    &#x27;4&#x27;: &#x27;೪&#x27;,
	    &#x27;5&#x27;: &#x27;೫&#x27;,
	    &#x27;6&#x27;: &#x27;೬&#x27;,
	    &#x27;7&#x27;: &#x27;೭&#x27;,
	    &#x27;8&#x27;: &#x27;೮&#x27;,
	    &#x27;9&#x27;: &#x27;೯&#x27;,
	    &#x27;0&#x27;: &#x27;೦&#x27;
	},
	numberMap = {
	    &#x27;೧&#x27;: &#x27;1&#x27;,
	    &#x27;೨&#x27;: &#x27;2&#x27;,
	    &#x27;೩&#x27;: &#x27;3&#x27;,
	    &#x27;೪&#x27;: &#x27;4&#x27;,
	    &#x27;೫&#x27;: &#x27;5&#x27;,
	    &#x27;೬&#x27;: &#x27;6&#x27;,
	    &#x27;೭&#x27;: &#x27;7&#x27;,
	    &#x27;೮&#x27;: &#x27;8&#x27;,
	    &#x27;೯&#x27;: &#x27;9&#x27;,
	    &#x27;೦&#x27;: &#x27;0&#x27;
	};

	var kn = moment.defineLocale(&#x27;kn&#x27;, {
	    months : &#x27;ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[ಇಂದು] LT&#x27;,
	        nextDay : &#x27;[ನಾಳೆ] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[ನಿನ್ನೆ] LT&#x27;,
	        lastWeek : &#x27;[ಕೊನೆಯ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ನಂತರ&#x27;,
	        past : &#x27;%s ಹಿಂದೆ&#x27;,
	        s : &#x27;ಕೆಲವು ಕ್ಷಣಗಳು&#x27;,
	        ss : &#x27;%d ಸೆಕೆಂಡುಗಳು&#x27;,
	        m : &#x27;ಒಂದು ನಿಮಿಷ&#x27;,
	        mm : &#x27;%d ನಿಮಿಷ&#x27;,
	        h : &#x27;ಒಂದು ಗಂಟೆ&#x27;,
	        hh : &#x27;%d ಗಂಟೆ&#x27;,
	        d : &#x27;ಒಂದು ದಿನ&#x27;,
	        dd : &#x27;%d ದಿನ&#x27;,
	        M : &#x27;ಒಂದು ತಿಂಗಳು&#x27;,
	        MM : &#x27;%d ತಿಂಗಳು&#x27;,
	        y : &#x27;ಒಂದು ವರ್ಷ&#x27;,
	        yy : &#x27;%d ವರ್ಷ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;ರಾತ್ರಿ&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;ಬೆಳಿಗ್ಗೆ&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;ಮಧ್ಯಾಹ್ನ&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else if (meridiem === &#x27;ಸಂಜೆ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ರಾತ್ರಿ&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ಬೆಳಿಗ್ಗೆ&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ಮಧ್ಯಾಹ್ನ&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;ಸಂಜೆ&#x27;;
	        } else {
	            return &#x27;ರಾತ್ರಿ&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
	    ordinal : function (number) {
	        return number + &#x27;ನೇ&#x27;;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kn;

	})));


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ko = moment.defineLocale(&#x27;ko&#x27;, {
	    months : &#x27;1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;일요일_월요일_화요일_수요일_목요일_금요일_토요일&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;일_월_화_수_목_금_토&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;일_월_화_수_목_금_토&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;YYYY.MM.DD.&#x27;,
	        LL : &#x27;YYYY년 MMMM D일&#x27;,
	        LLL : &#x27;YYYY년 MMMM D일 A h:mm&#x27;,
	        LLLL : &#x27;YYYY년 MMMM D일 dddd A h:mm&#x27;,
	        l : &#x27;YYYY.MM.DD.&#x27;,
	        ll : &#x27;YYYY년 MMMM D일&#x27;,
	        lll : &#x27;YYYY년 MMMM D일 A h:mm&#x27;,
	        llll : &#x27;YYYY년 MMMM D일 dddd A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;오늘 LT&#x27;,
	        nextDay : &#x27;내일 LT&#x27;,
	        nextWeek : &#x27;dddd LT&#x27;,
	        lastDay : &#x27;어제 LT&#x27;,
	        lastWeek : &#x27;지난주 dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s 후&#x27;,
	        past : &#x27;%s 전&#x27;,
	        s : &#x27;몇 초&#x27;,
	        ss : &#x27;%d초&#x27;,
	        m : &#x27;1분&#x27;,
	        mm : &#x27;%d분&#x27;,
	        h : &#x27;한 시간&#x27;,
	        hh : &#x27;%d시간&#x27;,
	        d : &#x27;하루&#x27;,
	        dd : &#x27;%d일&#x27;,
	        M : &#x27;한 달&#x27;,
	        MM : &#x27;%d달&#x27;,
	        y : &#x27;일 년&#x27;,
	        yy : &#x27;%d년&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(일|월|주)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;일&#x27;;
	            case &#x27;M&#x27;:
	                return number + &#x27;월&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;주&#x27;;
	            default:
	                return number;
	        }
	    },
	    meridiemParse : /오전|오후/,
	    isPM : function (token) {
	        return token === &#x27;오후&#x27;;
	    },
	    meridiem : function (hour, minute, isUpper) {
	        return hour &lt; 12 ? &#x27;오전&#x27; : &#x27;오후&#x27;;
	    }
	});

	return ko;

	})));


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes = {
	    0: &#x27;-чү&#x27;,
	    1: &#x27;-чи&#x27;,
	    2: &#x27;-чи&#x27;,
	    3: &#x27;-чү&#x27;,
	    4: &#x27;-чү&#x27;,
	    5: &#x27;-чи&#x27;,
	    6: &#x27;-чы&#x27;,
	    7: &#x27;-чи&#x27;,
	    8: &#x27;-чи&#x27;,
	    9: &#x27;-чу&#x27;,
	    10: &#x27;-чу&#x27;,
	    20: &#x27;-чы&#x27;,
	    30: &#x27;-чу&#x27;,
	    40: &#x27;-чы&#x27;,
	    50: &#x27;-чү&#x27;,
	    60: &#x27;-чы&#x27;,
	    70: &#x27;-чи&#x27;,
	    80: &#x27;-чи&#x27;,
	    90: &#x27;-чу&#x27;,
	    100: &#x27;-чү&#x27;
	};

	var ky = moment.defineLocale(&#x27;ky&#x27;, {
	    months : &#x27;январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Жек_Дүй_Шей_Шар_Бей_Жум_Ише&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Жк_Дй_Шй_Шр_Бй_Жм_Иш&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Бүгүн саат] LT&#x27;,
	        nextDay : &#x27;[Эртең саат] LT&#x27;,
	        nextWeek : &#x27;dddd [саат] LT&#x27;,
	        lastDay : &#x27;[Кече саат] LT&#x27;,
	        lastWeek : &#x27;[Өткен аптанын] dddd [күнү] [саат] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ичинде&#x27;,
	        past : &#x27;%s мурун&#x27;,
	        s : &#x27;бирнече секунд&#x27;,
	        ss : &#x27;%d секунд&#x27;,
	        m : &#x27;бир мүнөт&#x27;,
	        mm : &#x27;%d мүнөт&#x27;,
	        h : &#x27;бир саат&#x27;,
	        hh : &#x27;%d саат&#x27;,
	        d : &#x27;бир күн&#x27;,
	        dd : &#x27;%d күн&#x27;,
	        M : &#x27;бир ай&#x27;,
	        MM : &#x27;%d ай&#x27;,
	        y : &#x27;бир жыл&#x27;,
	        yy : &#x27;%d жыл&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number &gt;= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ky;

	})));


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        &#x27;m&#x27;: [&#x27;eng Minutt&#x27;, &#x27;enger Minutt&#x27;],
	        &#x27;h&#x27;: [&#x27;eng Stonn&#x27;, &#x27;enger Stonn&#x27;],
	        &#x27;d&#x27;: [&#x27;een Dag&#x27;, &#x27;engem Dag&#x27;],
	        &#x27;M&#x27;: [&#x27;ee Mount&#x27;, &#x27;engem Mount&#x27;],
	        &#x27;y&#x27;: [&#x27;ee Joer&#x27;, &#x27;engem Joer&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
	    var number = string.substr(0, string.indexOf(&#x27; &#x27;));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return &#x27;a &#x27; + string;
	    }
	    return &#x27;an &#x27; + string;
	}
	function processPastTime(string) {
	    var number = string.substr(0, string.indexOf(&#x27; &#x27;));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return &#x27;viru &#x27; + string;
	    }
	    return &#x27;virun &#x27; + string;
	}
	/**
	 * Returns true if the word before the given number loses the &#x27;-n&#x27; ending.
	 * e.g. &#x27;an 10 Deeg&#x27; but &#x27;a 5 Deeg&#x27;
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
	    number = parseInt(number, 10);
	    if (isNaN(number)) {
	        return false;
	    }
	    if (number &lt; 0) {
	        // Negative Number --&gt; always true
	        return true;
	    } else if (number &lt; 10) {
	        // Only 1 digit
	        if (4 &lt;= number &amp;&amp; number &lt;= 7) {
	            return true;
	        }
	        return false;
	    } else if (number &lt; 100) {
	        // 2 digits
	        var lastDigit = number % 10, firstDigit = number / 10;
	        if (lastDigit === 0) {
	            return eifelerRegelAppliesToNumber(firstDigit);
	        }
	        return eifelerRegelAppliesToNumber(lastDigit);
	    } else if (number &lt; 10000) {
	        // 3 or 4 digits --&gt; recursively check first digit
	        while (number &gt;= 10) {
	            number = number / 10;
	        }
	        return eifelerRegelAppliesToNumber(number);
	    } else {
	        // Anything larger than 4 digits: recursively check first n-3 digits
	        number = number / 1000;
	        return eifelerRegelAppliesToNumber(number);
	    }
	}

	var lb = moment.defineLocale(&#x27;lb&#x27;, {
	    months: &#x27;Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays: &#x27;Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;So._Mé._Dë._Më._Do._Fr._Sa.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;So_Mé_Dë_Më_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm [Auer]&#x27;,
	        LTS: &#x27;H:mm:ss [Auer]&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm [Auer]&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm [Auer]&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[Haut um] LT&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[Muer um] LT&#x27;,
	        nextWeek: &#x27;dddd [um] LT&#x27;,
	        lastDay: &#x27;[Gëschter um] LT&#x27;,
	        lastWeek: function () {
	            // Different date string for &#x27;Dënschdeg&#x27; (Tuesday) and &#x27;Donneschdeg&#x27; (Thursday) due to phonological rule
	            switch (this.day()) {
	                case 2:
	                case 4:
	                    return &#x27;[Leschten] dddd [um] LT&#x27;;
	                default:
	                    return &#x27;[Leschte] dddd [um] LT&#x27;;
	            }
	        }
	    },
	    relativeTime : {
	        future : processFutureTime,
	        past : processPastTime,
	        s : &#x27;e puer Sekonnen&#x27;,
	        ss : &#x27;%d Sekonnen&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minutten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stonnen&#x27;,
	        d : processRelativeTime,
	        dd : &#x27;%d Deeg&#x27;,
	        M : processRelativeTime,
	        MM : &#x27;%d Méint&#x27;,
	        y : processRelativeTime,
	        yy : &#x27;%d Joer&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal: &#x27;%d.&#x27;,
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lb;

	})));


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var lo = moment.defineLocale(&#x27;lo&#x27;, {
	    months : &#x27;ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;ວັນdddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
	    isPM: function (input) {
	        return input === &#x27;ຕອນແລງ&#x27;;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ຕອນເຊົ້າ&#x27;;
	        } else {
	            return &#x27;ຕອນແລງ&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[ມື້ນີ້ເວລາ] LT&#x27;,
	        nextDay : &#x27;[ມື້ອື່ນເວລາ] LT&#x27;,
	        nextWeek : &#x27;[ວັນ]dddd[ໜ້າເວລາ] LT&#x27;,
	        lastDay : &#x27;[ມື້ວານນີ້ເວລາ] LT&#x27;,
	        lastWeek : &#x27;[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ອີກ %s&#x27;,
	        past : &#x27;%sຜ່ານມາ&#x27;,
	        s : &#x27;ບໍ່ເທົ່າໃດວິນາທີ&#x27;,
	        ss : &#x27;%d ວິນາທີ&#x27; ,
	        m : &#x27;1 ນາທີ&#x27;,
	        mm : &#x27;%d ນາທີ&#x27;,
	        h : &#x27;1 ຊົ່ວໂມງ&#x27;,
	        hh : &#x27;%d ຊົ່ວໂມງ&#x27;,
	        d : &#x27;1 ມື້&#x27;,
	        dd : &#x27;%d ມື້&#x27;,
	        M : &#x27;1 ເດືອນ&#x27;,
	        MM : &#x27;%d ເດືອນ&#x27;,
	        y : &#x27;1 ປີ&#x27;,
	        yy : &#x27;%d ປີ&#x27;
	    },
	    dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
	    ordinal : function (number) {
	        return &#x27;ທີ່&#x27; + number;
	    }
	});

	return lo;

	})));


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var units = {
	    &#x27;ss&#x27; : &#x27;sekundė_sekundžių_sekundes&#x27;,
	    &#x27;m&#x27; : &#x27;minutė_minutės_minutę&#x27;,
	    &#x27;mm&#x27;: &#x27;minutės_minučių_minutes&#x27;,
	    &#x27;h&#x27; : &#x27;valanda_valandos_valandą&#x27;,
	    &#x27;hh&#x27;: &#x27;valandos_valandų_valandas&#x27;,
	    &#x27;d&#x27; : &#x27;diena_dienos_dieną&#x27;,
	    &#x27;dd&#x27;: &#x27;dienos_dienų_dienas&#x27;,
	    &#x27;M&#x27; : &#x27;mėnuo_mėnesio_mėnesį&#x27;,
	    &#x27;MM&#x27;: &#x27;mėnesiai_mėnesių_mėnesius&#x27;,
	    &#x27;y&#x27; : &#x27;metai_metų_metus&#x27;,
	    &#x27;yy&#x27;: &#x27;metai_metų_metus&#x27;
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
	    if (withoutSuffix) {
	        return &#x27;kelios sekundės&#x27;;
	    } else {
	        return isFuture ? &#x27;kelių sekundžių&#x27; : &#x27;kelias sekundes&#x27;;
	    }
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
	    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
	    return number % 10 === 0 || (number &gt; 10 &amp;&amp; number &lt; 20);
	}
	function forms(key) {
	    return units[key].split(&#x27;_&#x27;);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + &#x27; &#x27;;
	    if (number === 1) {
	        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	    } else if (withoutSuffix) {
	        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	    } else {
	        if (isFuture) {
	            return result + forms(key)[1];
	        } else {
	            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	        }
	    }
	}
	var lt = moment.defineLocale(&#x27;lt&#x27;, {
	    months : {
	        format: &#x27;sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis&#x27;.split(&#x27;_&#x27;),
	        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	    },
	    monthsShort : &#x27;sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd&#x27;.split(&#x27;_&#x27;),
	    weekdays : {
	        format: &#x27;sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis&#x27;.split(&#x27;_&#x27;),
	        isFormat: /dddd HH:mm/
	    },
	    weekdaysShort : &#x27;Sek_Pir_Ant_Tre_Ket_Pen_Šeš&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;S_P_A_T_K_Pn_Š&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;YYYY [m.] MMMM D [d.]&#x27;,
	        LLL : &#x27;YYYY [m.] MMMM D [d.], HH:mm [val.]&#x27;,
	        LLLL : &#x27;YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]&#x27;,
	        l : &#x27;YYYY-MM-DD&#x27;,
	        ll : &#x27;YYYY [m.] MMMM D [d.]&#x27;,
	        lll : &#x27;YYYY [m.] MMMM D [d.], HH:mm [val.]&#x27;,
	        llll : &#x27;YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Šiandien] LT&#x27;,
	        nextDay : &#x27;[Rytoj] LT&#x27;,
	        nextWeek : &#x27;dddd LT&#x27;,
	        lastDay : &#x27;[Vakar] LT&#x27;,
	        lastWeek : &#x27;[Praėjusį] dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;po %s&#x27;,
	        past : &#x27;prieš %s&#x27;,
	        s : translateSeconds,
	        ss : translate,
	        m : translateSingular,
	        mm : translate,
	        h : translateSingular,
	        hh : translate,
	        d : translateSingular,
	        dd : translate,
	        M : translateSingular,
	        MM : translate,
	        y : translateSingular,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
	    ordinal : function (number) {
	        return number + &#x27;-oji&#x27;;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lt;

	})));


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var units = {
	    &#x27;ss&#x27;: &#x27;sekundes_sekundēm_sekunde_sekundes&#x27;.split(&#x27;_&#x27;),
	    &#x27;m&#x27;: &#x27;minūtes_minūtēm_minūte_minūtes&#x27;.split(&#x27;_&#x27;),
	    &#x27;mm&#x27;: &#x27;minūtes_minūtēm_minūte_minūtes&#x27;.split(&#x27;_&#x27;),
	    &#x27;h&#x27;: &#x27;stundas_stundām_stunda_stundas&#x27;.split(&#x27;_&#x27;),
	    &#x27;hh&#x27;: &#x27;stundas_stundām_stunda_stundas&#x27;.split(&#x27;_&#x27;),
	    &#x27;d&#x27;: &#x27;dienas_dienām_diena_dienas&#x27;.split(&#x27;_&#x27;),
	    &#x27;dd&#x27;: &#x27;dienas_dienām_diena_dienas&#x27;.split(&#x27;_&#x27;),
	    &#x27;M&#x27;: &#x27;mēneša_mēnešiem_mēnesis_mēneši&#x27;.split(&#x27;_&#x27;),
	    &#x27;MM&#x27;: &#x27;mēneša_mēnešiem_mēnesis_mēneši&#x27;.split(&#x27;_&#x27;),
	    &#x27;y&#x27;: &#x27;gada_gadiem_gads_gadi&#x27;.split(&#x27;_&#x27;),
	    &#x27;yy&#x27;: &#x27;gada_gadiem_gads_gadi&#x27;.split(&#x27;_&#x27;)
	};
	/**
	 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	 */
	function format(forms, number, withoutSuffix) {
	    if (withoutSuffix) {
	        // E.g. &quot;21 minūte&quot;, &quot;3 minūtes&quot;.
	        return number % 10 === 1 &amp;&amp; number % 100 !== 11 ? forms[2] : forms[3];
	    } else {
	        // E.g. &quot;21 minūtes&quot; as in &quot;pēc 21 minūtes&quot;.
	        // E.g. &quot;3 minūtēm&quot; as in &quot;pēc 3 minūtēm&quot;.
	        return number % 10 === 1 &amp;&amp; number % 100 !== 11 ? forms[0] : forms[1];
	    }
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    return number + &#x27; &#x27; + format(units[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
	    return format(units[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
	    return withoutSuffix ? &#x27;dažas sekundes&#x27; : &#x27;dažām sekundēm&#x27;;
	}

	var lv = moment.defineLocale(&#x27;lv&#x27;, {
	    months : &#x27;janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sv_P_O_T_C_Pk_S&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Sv_P_O_T_C_Pk_S&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY.&#x27;,
	        LL : &#x27;YYYY. [gada] D. MMMM&#x27;,
	        LLL : &#x27;YYYY. [gada] D. MMMM, HH:mm&#x27;,
	        LLLL : &#x27;YYYY. [gada] D. MMMM, dddd, HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Šodien pulksten] LT&#x27;,
	        nextDay : &#x27;[Rīt pulksten] LT&#x27;,
	        nextWeek : &#x27;dddd [pulksten] LT&#x27;,
	        lastDay : &#x27;[Vakar pulksten] LT&#x27;,
	        lastWeek : &#x27;[Pagājušā] dddd [pulksten] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;pēc %s&#x27;,
	        past : &#x27;pirms %s&#x27;,
	        s : relativeSeconds,
	        ss : relativeTimeWithPlural,
	        m : relativeTimeWithSingular,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithSingular,
	        hh : relativeTimeWithPlural,
	        d : relativeTimeWithSingular,
	        dd : relativeTimeWithPlural,
	        M : relativeTimeWithSingular,
	        MM : relativeTimeWithPlural,
	        y : relativeTimeWithSingular,
	        yy : relativeTimeWithPlural
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lv;

	})));


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var translator = {
	    words: { //Different grammatical cases
	        ss: [&#x27;sekund&#x27;, &#x27;sekunda&#x27;, &#x27;sekundi&#x27;],
	        m: [&#x27;jedan minut&#x27;, &#x27;jednog minuta&#x27;],
	        mm: [&#x27;minut&#x27;, &#x27;minuta&#x27;, &#x27;minuta&#x27;],
	        h: [&#x27;jedan sat&#x27;, &#x27;jednog sata&#x27;],
	        hh: [&#x27;sat&#x27;, &#x27;sata&#x27;, &#x27;sati&#x27;],
	        dd: [&#x27;dan&#x27;, &#x27;dana&#x27;, &#x27;dana&#x27;],
	        MM: [&#x27;mjesec&#x27;, &#x27;mjeseca&#x27;, &#x27;mjeseci&#x27;],
	        yy: [&#x27;godina&#x27;, &#x27;godine&#x27;, &#x27;godina&#x27;]
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number &gt;= 2 &amp;&amp; number &lt;= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + &#x27; &#x27; + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var me = moment.defineLocale(&#x27;me&#x27;, {
	    months: &#x27;januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays: &#x27;nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;ned._pon._uto._sri._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[danas u] LT&#x27;,
	        nextDay: &#x27;[sjutra u] LT&#x27;,

	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedjelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [srijedu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[juče u] LT&#x27;,
	        lastWeek : function () {
	            var lastWeekDays = [
	                &#x27;[prošle] [nedjelje] [u] LT&#x27;,
	                &#x27;[prošlog] [ponedjeljka] [u] LT&#x27;,
	                &#x27;[prošlog] [utorka] [u] LT&#x27;,
	                &#x27;[prošle] [srijede] [u] LT&#x27;,
	                &#x27;[prošlog] [četvrtka] [u] LT&#x27;,
	                &#x27;[prošlog] [petka] [u] LT&#x27;,
	                &#x27;[prošle] [subote] [u] LT&#x27;
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;prije %s&#x27;,
	        s      : &#x27;nekoliko sekundi&#x27;,
	        ss     : translator.translate,
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translator.translate,
	        M      : &#x27;mjesec&#x27;,
	        MM     : translator.translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return me;

	})));


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var mi = moment.defineLocale(&#x27;mi&#x27;, {
	    months: &#x27;Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki&#x27;.split(&#x27;_&#x27;),
	    monthsRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsStrictRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortStrictRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	    weekdays: &#x27;Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;Ta_Ma_Tū_We_Tāi_Pa_Hā&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;Ta_Ma_Tū_We_Tāi_Pa_Hā&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY [i] HH:mm&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY [i] HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[i teie mahana, i] LT&#x27;,
	        nextDay: &#x27;[apopo i] LT&#x27;,
	        nextWeek: &#x27;dddd [i] LT&#x27;,
	        lastDay: &#x27;[inanahi i] LT&#x27;,
	        lastWeek: &#x27;dddd [whakamutunga i] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;i roto i %s&#x27;,
	        past: &#x27;%s i mua&#x27;,
	        s: &#x27;te hēkona ruarua&#x27;,
	        ss: &#x27;%d hēkona&#x27;,
	        m: &#x27;he meneti&#x27;,
	        mm: &#x27;%d meneti&#x27;,
	        h: &#x27;te haora&#x27;,
	        hh: &#x27;%d haora&#x27;,
	        d: &#x27;he ra&#x27;,
	        dd: &#x27;%d ra&#x27;,
	        M: &#x27;he marama&#x27;,
	        MM: &#x27;%d marama&#x27;,
	        y: &#x27;he tau&#x27;,
	        yy: &#x27;%d tau&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal: &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return mi;

	})));


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var mk = moment.defineLocale(&#x27;mk&#x27;, {
	    months : &#x27;јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;недела_понеделник_вторник_среда_четврток_петок_сабота&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;нед_пон_вто_сре_чет_пет_саб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нe_пo_вт_ср_че_пе_сa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;D.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Денес во] LT&#x27;,
	        nextDay : &#x27;[Утре во] LT&#x27;,
	        nextWeek : &#x27;[Во] dddd [во] LT&#x27;,
	        lastDay : &#x27;[Вчера во] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return &#x27;[Изминатата] dddd [во] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[Изминатиот] dddd [во] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;после %s&#x27;,
	        past : &#x27;пред %s&#x27;,
	        s : &#x27;неколку секунди&#x27;,
	        ss : &#x27;%d секунди&#x27;,
	        m : &#x27;минута&#x27;,
	        mm : &#x27;%d минути&#x27;,
	        h : &#x27;час&#x27;,
	        hh : &#x27;%d часа&#x27;,
	        d : &#x27;ден&#x27;,
	        dd : &#x27;%d дена&#x27;,
	        M : &#x27;месец&#x27;,
	        MM : &#x27;%d месеци&#x27;,
	        y : &#x27;година&#x27;,
	        yy : &#x27;%d години&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + &#x27;-ев&#x27;;
	        } else if (last2Digits === 0) {
	            return number + &#x27;-ен&#x27;;
	        } else if (last2Digits &gt; 10 &amp;&amp; last2Digits &lt; 20) {
	            return number + &#x27;-ти&#x27;;
	        } else if (lastDigit === 1) {
	            return number + &#x27;-ви&#x27;;
	        } else if (lastDigit === 2) {
	            return number + &#x27;-ри&#x27;;
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + &#x27;-ми&#x27;;
	        } else {
	            return number + &#x27;-ти&#x27;;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mk;

	})));


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ml = moment.defineLocale(&#x27;ml&#x27;, {
	    months : &#x27;ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm -നു&#x27;,
	        LTS : &#x27;A h:mm:ss -നു&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm -നു&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm -നു&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[ഇന്ന്] LT&#x27;,
	        nextDay : &#x27;[നാളെ] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[ഇന്നലെ] LT&#x27;,
	        lastWeek : &#x27;[കഴിഞ്ഞ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s കഴിഞ്ഞ്&#x27;,
	        past : &#x27;%s മുൻപ്&#x27;,
	        s : &#x27;അൽപ നിമിഷങ്ങൾ&#x27;,
	        ss : &#x27;%d സെക്കൻഡ്&#x27;,
	        m : &#x27;ഒരു മിനിറ്റ്&#x27;,
	        mm : &#x27;%d മിനിറ്റ്&#x27;,
	        h : &#x27;ഒരു മണിക്കൂർ&#x27;,
	        hh : &#x27;%d മണിക്കൂർ&#x27;,
	        d : &#x27;ഒരു ദിവസം&#x27;,
	        dd : &#x27;%d ദിവസം&#x27;,
	        M : &#x27;ഒരു മാസം&#x27;,
	        MM : &#x27;%d മാസം&#x27;,
	        y : &#x27;ഒരു വർഷം&#x27;,
	        yy : &#x27;%d വർഷം&#x27;
	    },
	    meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === &#x27;രാത്രി&#x27; &amp;&amp; hour &gt;= 4) ||
	                meridiem === &#x27;ഉച്ച കഴിഞ്ഞ്&#x27; ||
	                meridiem === &#x27;വൈകുന്നേരം&#x27;) {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;രാത്രി&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;രാവിലെ&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ഉച്ച കഴിഞ്ഞ്&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;വൈകുന്നേരം&#x27;;
	        } else {
	            return &#x27;രാത്രി&#x27;;
	        }
	    }
	});

	return ml;

	})));


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;१&#x27;,
	    &#x27;2&#x27;: &#x27;२&#x27;,
	    &#x27;3&#x27;: &#x27;३&#x27;,
	    &#x27;4&#x27;: &#x27;४&#x27;,
	    &#x27;5&#x27;: &#x27;५&#x27;,
	    &#x27;6&#x27;: &#x27;६&#x27;,
	    &#x27;7&#x27;: &#x27;७&#x27;,
	    &#x27;8&#x27;: &#x27;८&#x27;,
	    &#x27;9&#x27;: &#x27;९&#x27;,
	    &#x27;0&#x27;: &#x27;०&#x27;
	},
	numberMap = {
	    &#x27;१&#x27;: &#x27;1&#x27;,
	    &#x27;२&#x27;: &#x27;2&#x27;,
	    &#x27;३&#x27;: &#x27;3&#x27;,
	    &#x27;४&#x27;: &#x27;4&#x27;,
	    &#x27;५&#x27;: &#x27;5&#x27;,
	    &#x27;६&#x27;: &#x27;6&#x27;,
	    &#x27;७&#x27;: &#x27;7&#x27;,
	    &#x27;८&#x27;: &#x27;8&#x27;,
	    &#x27;९&#x27;: &#x27;9&#x27;,
	    &#x27;०&#x27;: &#x27;0&#x27;
	};

	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
	    var output = &#x27;&#x27;;
	    if (withoutSuffix) {
	        switch (string) {
	            case &#x27;s&#x27;: output = &#x27;काही सेकंद&#x27;; break;
	            case &#x27;ss&#x27;: output = &#x27;%d सेकंद&#x27;; break;
	            case &#x27;m&#x27;: output = &#x27;एक मिनिट&#x27;; break;
	            case &#x27;mm&#x27;: output = &#x27;%d मिनिटे&#x27;; break;
	            case &#x27;h&#x27;: output = &#x27;एक तास&#x27;; break;
	            case &#x27;hh&#x27;: output = &#x27;%d तास&#x27;; break;
	            case &#x27;d&#x27;: output = &#x27;एक दिवस&#x27;; break;
	            case &#x27;dd&#x27;: output = &#x27;%d दिवस&#x27;; break;
	            case &#x27;M&#x27;: output = &#x27;एक महिना&#x27;; break;
	            case &#x27;MM&#x27;: output = &#x27;%d महिने&#x27;; break;
	            case &#x27;y&#x27;: output = &#x27;एक वर्ष&#x27;; break;
	            case &#x27;yy&#x27;: output = &#x27;%d वर्षे&#x27;; break;
	        }
	    }
	    else {
	        switch (string) {
	            case &#x27;s&#x27;: output = &#x27;काही सेकंदां&#x27;; break;
	            case &#x27;ss&#x27;: output = &#x27;%d सेकंदां&#x27;; break;
	            case &#x27;m&#x27;: output = &#x27;एका मिनिटा&#x27;; break;
	            case &#x27;mm&#x27;: output = &#x27;%d मिनिटां&#x27;; break;
	            case &#x27;h&#x27;: output = &#x27;एका तासा&#x27;; break;
	            case &#x27;hh&#x27;: output = &#x27;%d तासां&#x27;; break;
	            case &#x27;d&#x27;: output = &#x27;एका दिवसा&#x27;; break;
	            case &#x27;dd&#x27;: output = &#x27;%d दिवसां&#x27;; break;
	            case &#x27;M&#x27;: output = &#x27;एका महिन्या&#x27;; break;
	            case &#x27;MM&#x27;: output = &#x27;%d महिन्यां&#x27;; break;
	            case &#x27;y&#x27;: output = &#x27;एका वर्षा&#x27;; break;
	            case &#x27;yy&#x27;: output = &#x27;%d वर्षां&#x27;; break;
	        }
	    }
	    return output.replace(/%d/i, number);
	}

	var mr = moment.defineLocale(&#x27;mr&#x27;, {
	    months : &#x27;जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;र_सो_मं_बु_गु_शु_श&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm वाजता&#x27;,
	        LTS : &#x27;A h:mm:ss वाजता&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm वाजता&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm वाजता&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[आज] LT&#x27;,
	        nextDay : &#x27;[उद्या] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[काल] LT&#x27;,
	        lastWeek: &#x27;[मागील] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future: &#x27;%sमध्ये&#x27;,
	        past: &#x27;%sपूर्वी&#x27;,
	        s: relativeTimeMr,
	        ss: relativeTimeMr,
	        m: relativeTimeMr,
	        mm: relativeTimeMr,
	        h: relativeTimeMr,
	        hh: relativeTimeMr,
	        d: relativeTimeMr,
	        dd: relativeTimeMr,
	        M: relativeTimeMr,
	        MM: relativeTimeMr,
	        y: relativeTimeMr,
	        yy: relativeTimeMr
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;रात्री&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;सकाळी&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;दुपारी&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else if (meridiem === &#x27;सायंकाळी&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;रात्री&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;सकाळी&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;दुपारी&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;सायंकाळी&#x27;;
	        } else {
	            return &#x27;रात्री&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mr;

	})));


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ms = moment.defineLocale(&#x27;ms&#x27;, {
	    months : &#x27;Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ahd_Isn_Sel_Rab_Kha_Jum_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ah_Is_Sl_Rb_Km_Jm_Sb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;pagi&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;tengahari&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;petang&#x27; || meridiem === &#x27;malam&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;pagi&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;tengahari&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;petang&#x27;;
	        } else {
	            return &#x27;malam&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hari ini pukul] LT&#x27;,
	        nextDay : &#x27;[Esok pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kelmarin pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [lepas pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dalam %s&#x27;,
	        past : &#x27;%s yang lepas&#x27;,
	        s : &#x27;beberapa saat&#x27;,
	        ss : &#x27;%d saat&#x27;,
	        m : &#x27;seminit&#x27;,
	        mm : &#x27;%d minit&#x27;,
	        h : &#x27;sejam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sehari&#x27;,
	        dd : &#x27;%d hari&#x27;,
	        M : &#x27;sebulan&#x27;,
	        MM : &#x27;%d bulan&#x27;,
	        y : &#x27;setahun&#x27;,
	        yy : &#x27;%d tahun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ms;

	})));


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var msMy = moment.defineLocale(&#x27;ms-my&#x27;, {
	    months : &#x27;Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ahd_Isn_Sel_Rab_Kha_Jum_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ah_Is_Sl_Rb_Km_Jm_Sb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;pagi&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;tengahari&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;petang&#x27; || meridiem === &#x27;malam&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;pagi&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;tengahari&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;petang&#x27;;
	        } else {
	            return &#x27;malam&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hari ini pukul] LT&#x27;,
	        nextDay : &#x27;[Esok pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kelmarin pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [lepas pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dalam %s&#x27;,
	        past : &#x27;%s yang lepas&#x27;,
	        s : &#x27;beberapa saat&#x27;,
	        ss : &#x27;%d saat&#x27;,
	        m : &#x27;seminit&#x27;,
	        mm : &#x27;%d minit&#x27;,
	        h : &#x27;sejam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sehari&#x27;,
	        dd : &#x27;%d hari&#x27;,
	        M : &#x27;sebulan&#x27;,
	        MM : &#x27;%d bulan&#x27;,
	        y : &#x27;setahun&#x27;,
	        yy : &#x27;%d tahun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return msMy;

	})));


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var mt = moment.defineLocale(&#x27;mt&#x27;, {
	    months : &#x27;Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ħa_Tn_Tl_Er_Ħa_Ġi_Si&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Illum fil-]LT&#x27;,
	        nextDay : &#x27;[Għada fil-]LT&#x27;,
	        nextWeek : &#x27;dddd [fil-]LT&#x27;,
	        lastDay : &#x27;[Il-bieraħ fil-]LT&#x27;,
	        lastWeek : &#x27;dddd [li għadda] [fil-]LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;f’ %s&#x27;,
	        past : &#x27;%s ilu&#x27;,
	        s : &#x27;ftit sekondi&#x27;,
	        ss : &#x27;%d sekondi&#x27;,
	        m : &#x27;minuta&#x27;,
	        mm : &#x27;%d minuti&#x27;,
	        h : &#x27;siegħa&#x27;,
	        hh : &#x27;%d siegħat&#x27;,
	        d : &#x27;ġurnata&#x27;,
	        dd : &#x27;%d ġranet&#x27;,
	        M : &#x27;xahar&#x27;,
	        MM : &#x27;%d xhur&#x27;,
	        y : &#x27;sena&#x27;,
	        yy : &#x27;%d sni&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal: &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return mt;

	})));


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;၁&#x27;,
	    &#x27;2&#x27;: &#x27;၂&#x27;,
	    &#x27;3&#x27;: &#x27;၃&#x27;,
	    &#x27;4&#x27;: &#x27;၄&#x27;,
	    &#x27;5&#x27;: &#x27;၅&#x27;,
	    &#x27;6&#x27;: &#x27;၆&#x27;,
	    &#x27;7&#x27;: &#x27;၇&#x27;,
	    &#x27;8&#x27;: &#x27;၈&#x27;,
	    &#x27;9&#x27;: &#x27;၉&#x27;,
	    &#x27;0&#x27;: &#x27;၀&#x27;
	}, numberMap = {
	    &#x27;၁&#x27;: &#x27;1&#x27;,
	    &#x27;၂&#x27;: &#x27;2&#x27;,
	    &#x27;၃&#x27;: &#x27;3&#x27;,
	    &#x27;၄&#x27;: &#x27;4&#x27;,
	    &#x27;၅&#x27;: &#x27;5&#x27;,
	    &#x27;၆&#x27;: &#x27;6&#x27;,
	    &#x27;၇&#x27;: &#x27;7&#x27;,
	    &#x27;၈&#x27;: &#x27;8&#x27;,
	    &#x27;၉&#x27;: &#x27;9&#x27;,
	    &#x27;၀&#x27;: &#x27;0&#x27;
	};

	var my = moment.defineLocale(&#x27;my&#x27;, {
	    months: &#x27;ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ&#x27;.split(&#x27;_&#x27;),

	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[ယနေ.] LT [မှာ]&#x27;,
	        nextDay: &#x27;[မနက်ဖြန်] LT [မှာ]&#x27;,
	        nextWeek: &#x27;dddd LT [မှာ]&#x27;,
	        lastDay: &#x27;[မနေ.က] LT [မှာ]&#x27;,
	        lastWeek: &#x27;[ပြီးခဲ့သော] dddd LT [မှာ]&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;လာမည့် %s မှာ&#x27;,
	        past: &#x27;လွန်ခဲ့သော %s က&#x27;,
	        s: &#x27;စက္ကန်.အနည်းငယ်&#x27;,
	        ss : &#x27;%d စက္ကန့်&#x27;,
	        m: &#x27;တစ်မိနစ်&#x27;,
	        mm: &#x27;%d မိနစ်&#x27;,
	        h: &#x27;တစ်နာရီ&#x27;,
	        hh: &#x27;%d နာရီ&#x27;,
	        d: &#x27;တစ်ရက်&#x27;,
	        dd: &#x27;%d ရက်&#x27;,
	        M: &#x27;တစ်လ&#x27;,
	        MM: &#x27;%d လ&#x27;,
	        y: &#x27;တစ်နှစ်&#x27;,
	        yy: &#x27;%d နှစ်&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return my;

	})));


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var nb = moment.defineLocale(&#x27;nb&#x27;, {
	    months : &#x27;januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sø._ma._ti._on._to._fr._lø.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;sø_ma_ti_on_to_fr_lø&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY [kl.] HH:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY [kl.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[i dag kl.] LT&#x27;,
	        nextDay: &#x27;[i morgen kl.] LT&#x27;,
	        nextWeek: &#x27;dddd [kl.] LT&#x27;,
	        lastDay: &#x27;[i går kl.] LT&#x27;,
	        lastWeek: &#x27;[forrige] dddd [kl.] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;%s siden&#x27;,
	        s : &#x27;noen sekunder&#x27;,
	        ss : &#x27;%d sekunder&#x27;,
	        m : &#x27;ett minutt&#x27;,
	        mm : &#x27;%d minutter&#x27;,
	        h : &#x27;en time&#x27;,
	        hh : &#x27;%d timer&#x27;,
	        d : &#x27;en dag&#x27;,
	        dd : &#x27;%d dager&#x27;,
	        M : &#x27;en måned&#x27;,
	        MM : &#x27;%d måneder&#x27;,
	        y : &#x27;ett år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nb;

	})));


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;१&#x27;,
	    &#x27;2&#x27;: &#x27;२&#x27;,
	    &#x27;3&#x27;: &#x27;३&#x27;,
	    &#x27;4&#x27;: &#x27;४&#x27;,
	    &#x27;5&#x27;: &#x27;५&#x27;,
	    &#x27;6&#x27;: &#x27;६&#x27;,
	    &#x27;7&#x27;: &#x27;७&#x27;,
	    &#x27;8&#x27;: &#x27;८&#x27;,
	    &#x27;9&#x27;: &#x27;९&#x27;,
	    &#x27;0&#x27;: &#x27;०&#x27;
	},
	numberMap = {
	    &#x27;१&#x27;: &#x27;1&#x27;,
	    &#x27;२&#x27;: &#x27;2&#x27;,
	    &#x27;३&#x27;: &#x27;3&#x27;,
	    &#x27;४&#x27;: &#x27;4&#x27;,
	    &#x27;५&#x27;: &#x27;5&#x27;,
	    &#x27;६&#x27;: &#x27;6&#x27;,
	    &#x27;७&#x27;: &#x27;7&#x27;,
	    &#x27;८&#x27;: &#x27;8&#x27;,
	    &#x27;९&#x27;: &#x27;9&#x27;,
	    &#x27;०&#x27;: &#x27;0&#x27;
	};

	var ne = moment.defineLocale(&#x27;ne&#x27;, {
	    months : &#x27;जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;आ._सो._मं._बु._बि._शु._श.&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;Aको h:mm बजे&#x27;,
	        LTS : &#x27;Aको h:mm:ss बजे&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, Aको h:mm बजे&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, Aको h:mm बजे&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;राति&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;बिहान&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;दिउँसो&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else if (meridiem === &#x27;साँझ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 3) {
	            return &#x27;राति&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;बिहान&#x27;;
	        } else if (hour &lt; 16) {
	            return &#x27;दिउँसो&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;साँझ&#x27;;
	        } else {
	            return &#x27;राति&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[आज] LT&#x27;,
	        nextDay : &#x27;[भोलि] LT&#x27;,
	        nextWeek : &#x27;[आउँदो] dddd[,] LT&#x27;,
	        lastDay : &#x27;[हिजो] LT&#x27;,
	        lastWeek : &#x27;[गएको] dddd[,] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%sमा&#x27;,
	        past : &#x27;%s अगाडि&#x27;,
	        s : &#x27;केही क्षण&#x27;,
	        ss : &#x27;%d सेकेण्ड&#x27;,
	        m : &#x27;एक मिनेट&#x27;,
	        mm : &#x27;%d मिनेट&#x27;,
	        h : &#x27;एक घण्टा&#x27;,
	        hh : &#x27;%d घण्टा&#x27;,
	        d : &#x27;एक दिन&#x27;,
	        dd : &#x27;%d दिन&#x27;,
	        M : &#x27;एक महिना&#x27;,
	        MM : &#x27;%d महिना&#x27;,
	        y : &#x27;एक बर्ष&#x27;,
	        yy : &#x27;%d बर्ष&#x27;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ne;

	})));


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortWithDots = &#x27;jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsShortWithoutDots = &#x27;jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;);

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nl = moment.defineLocale(&#x27;nl&#x27;, {
	    months : &#x27;januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : &#x27;zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;zo._ma._di._wo._do._vr._za.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;zo_ma_di_wo_do_vr_za&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[vandaag om] LT&#x27;,
	        nextDay: &#x27;[morgen om] LT&#x27;,
	        nextWeek: &#x27;dddd [om] LT&#x27;,
	        lastDay: &#x27;[gisteren om] LT&#x27;,
	        lastWeek: &#x27;[afgelopen] dddd [om] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;over %s&#x27;,
	        past : &#x27;%s geleden&#x27;,
	        s : &#x27;een paar seconden&#x27;,
	        ss : &#x27;%d seconden&#x27;,
	        m : &#x27;één minuut&#x27;,
	        mm : &#x27;%d minuten&#x27;,
	        h : &#x27;één uur&#x27;,
	        hh : &#x27;%d uur&#x27;,
	        d : &#x27;één dag&#x27;,
	        dd : &#x27;%d dagen&#x27;,
	        M : &#x27;één maand&#x27;,
	        MM : &#x27;%d maanden&#x27;,
	        y : &#x27;één jaar&#x27;,
	        yy : &#x27;%d jaar&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number &gt;= 20) ? &#x27;ste&#x27; : &#x27;de&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nl;

	})));


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortWithDots = &#x27;jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsShortWithoutDots = &#x27;jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;);

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nlBe = moment.defineLocale(&#x27;nl-be&#x27;, {
	    months : &#x27;januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : &#x27;zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;zo._ma._di._wo._do._vr._za.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;zo_ma_di_wo_do_vr_za&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[vandaag om] LT&#x27;,
	        nextDay: &#x27;[morgen om] LT&#x27;,
	        nextWeek: &#x27;dddd [om] LT&#x27;,
	        lastDay: &#x27;[gisteren om] LT&#x27;,
	        lastWeek: &#x27;[afgelopen] dddd [om] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;over %s&#x27;,
	        past : &#x27;%s geleden&#x27;,
	        s : &#x27;een paar seconden&#x27;,
	        ss : &#x27;%d seconden&#x27;,
	        m : &#x27;één minuut&#x27;,
	        mm : &#x27;%d minuten&#x27;,
	        h : &#x27;één uur&#x27;,
	        hh : &#x27;%d uur&#x27;,
	        d : &#x27;één dag&#x27;,
	        dd : &#x27;%d dagen&#x27;,
	        M : &#x27;één maand&#x27;,
	        MM : &#x27;%d maanden&#x27;,
	        y : &#x27;één jaar&#x27;,
	        yy : &#x27;%d jaar&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number &gt;= 20) ? &#x27;ste&#x27; : &#x27;de&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nlBe;

	})));


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var nn = moment.defineLocale(&#x27;nn&#x27;, {
	    months : &#x27;januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sun_mån_tys_ons_tor_fre_lau&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;su_må_ty_on_to_fr_lø&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY [kl.] H:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY [kl.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[I dag klokka] LT&#x27;,
	        nextDay: &#x27;[I morgon klokka] LT&#x27;,
	        nextWeek: &#x27;dddd [klokka] LT&#x27;,
	        lastDay: &#x27;[I går klokka] LT&#x27;,
	        lastWeek: &#x27;[Føregåande] dddd [klokka] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;%s sidan&#x27;,
	        s : &#x27;nokre sekund&#x27;,
	        ss : &#x27;%d sekund&#x27;,
	        m : &#x27;eit minutt&#x27;,
	        mm : &#x27;%d minutt&#x27;,
	        h : &#x27;ein time&#x27;,
	        hh : &#x27;%d timar&#x27;,
	        d : &#x27;ein dag&#x27;,
	        dd : &#x27;%d dagar&#x27;,
	        M : &#x27;ein månad&#x27;,
	        MM : &#x27;%d månader&#x27;,
	        y : &#x27;eit år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nn;

	})));


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;੧&#x27;,
	    &#x27;2&#x27;: &#x27;੨&#x27;,
	    &#x27;3&#x27;: &#x27;੩&#x27;,
	    &#x27;4&#x27;: &#x27;੪&#x27;,
	    &#x27;5&#x27;: &#x27;੫&#x27;,
	    &#x27;6&#x27;: &#x27;੬&#x27;,
	    &#x27;7&#x27;: &#x27;੭&#x27;,
	    &#x27;8&#x27;: &#x27;੮&#x27;,
	    &#x27;9&#x27;: &#x27;੯&#x27;,
	    &#x27;0&#x27;: &#x27;੦&#x27;
	},
	numberMap = {
	    &#x27;੧&#x27;: &#x27;1&#x27;,
	    &#x27;੨&#x27;: &#x27;2&#x27;,
	    &#x27;੩&#x27;: &#x27;3&#x27;,
	    &#x27;੪&#x27;: &#x27;4&#x27;,
	    &#x27;੫&#x27;: &#x27;5&#x27;,
	    &#x27;੬&#x27;: &#x27;6&#x27;,
	    &#x27;੭&#x27;: &#x27;7&#x27;,
	    &#x27;੮&#x27;: &#x27;8&#x27;,
	    &#x27;੯&#x27;: &#x27;9&#x27;,
	    &#x27;੦&#x27;: &#x27;0&#x27;
	};

	var paIn = moment.defineLocale(&#x27;pa-in&#x27;, {
	    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	    months : &#x27;ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm ਵਜੇ&#x27;,
	        LTS : &#x27;A h:mm:ss ਵਜੇ&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm ਵਜੇ&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm ਵਜੇ&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[ਅਜ] LT&#x27;,
	        nextDay : &#x27;[ਕਲ] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[ਕਲ] LT&#x27;,
	        lastWeek : &#x27;[ਪਿਛਲੇ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ਵਿੱਚ&#x27;,
	        past : &#x27;%s ਪਿਛਲੇ&#x27;,
	        s : &#x27;ਕੁਝ ਸਕਿੰਟ&#x27;,
	        ss : &#x27;%d ਸਕਿੰਟ&#x27;,
	        m : &#x27;ਇਕ ਮਿੰਟ&#x27;,
	        mm : &#x27;%d ਮਿੰਟ&#x27;,
	        h : &#x27;ਇੱਕ ਘੰਟਾ&#x27;,
	        hh : &#x27;%d ਘੰਟੇ&#x27;,
	        d : &#x27;ਇੱਕ ਦਿਨ&#x27;,
	        dd : &#x27;%d ਦਿਨ&#x27;,
	        M : &#x27;ਇੱਕ ਮਹੀਨਾ&#x27;,
	        MM : &#x27;%d ਮਹੀਨੇ&#x27;,
	        y : &#x27;ਇੱਕ ਸਾਲ&#x27;,
	        yy : &#x27;%d ਸਾਲ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a &#x27;Pahar&#x27; it is not used as rigidly in modern Punjabi.
	    meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;ਰਾਤ&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;ਸਵੇਰ&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;ਦੁਪਹਿਰ&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else if (meridiem === &#x27;ਸ਼ਾਮ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ਰਾਤ&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ਸਵੇਰ&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ਦੁਪਹਿਰ&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;ਸ਼ਾਮ&#x27;;
	        } else {
	            return &#x27;ਰਾਤ&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return paIn;

	})));


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsNominative = &#x27;styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień&#x27;.split(&#x27;_&#x27;),
	    monthsSubjective = &#x27;stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia&#x27;.split(&#x27;_&#x27;);
	function plural(n) {
	    return (n % 10 &lt; 5) &amp;&amp; (n % 10 &gt; 1) &amp;&amp; ((~~(n / 10) % 10) !== 1);
	}
	function translate(number, withoutSuffix, key) {
	    var result = number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;ss&#x27;:
	            return result + (plural(number) ? &#x27;sekundy&#x27; : &#x27;sekund&#x27;);
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;minuta&#x27; : &#x27;minutę&#x27;;
	        case &#x27;mm&#x27;:
	            return result + (plural(number) ? &#x27;minuty&#x27; : &#x27;minut&#x27;);
	        case &#x27;h&#x27;:
	            return withoutSuffix  ? &#x27;godzina&#x27;  : &#x27;godzinę&#x27;;
	        case &#x27;hh&#x27;:
	            return result + (plural(number) ? &#x27;godziny&#x27; : &#x27;godzin&#x27;);
	        case &#x27;MM&#x27;:
	            return result + (plural(number) ? &#x27;miesiące&#x27; : &#x27;miesięcy&#x27;);
	        case &#x27;yy&#x27;:
	            return result + (plural(number) ? &#x27;lata&#x27; : &#x27;lat&#x27;);
	    }
	}

	var pl = moment.defineLocale(&#x27;pl&#x27;, {
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return monthsNominative;
	        } else if (format === &#x27;&#x27;) {
	            // Hack: if format empty we know this is used to generate
	            // RegExp by moment. Give then back both valid forms of months
	            // in RegExp ready format.
	            return &#x27;(&#x27; + monthsSubjective[momentToFormat.month()] + &#x27;|&#x27; + monthsNominative[momentToFormat.month()] + &#x27;)&#x27;;
	        } else if (/D MMMM/.test(format)) {
	            return monthsSubjective[momentToFormat.month()];
	        } else {
	            return monthsNominative[momentToFormat.month()];
	        }
	    },
	    monthsShort : &#x27;sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ndz_pon_wt_śr_czw_pt_sob&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Nd_Pn_Wt_Śr_Cz_Pt_So&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Dziś o] LT&#x27;,
	        nextDay: &#x27;[Jutro o] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[W niedzielę o] LT&#x27;;

	                case 2:
	                    return &#x27;[We wtorek o] LT&#x27;;

	                case 3:
	                    return &#x27;[W środę o] LT&#x27;;

	                case 6:
	                    return &#x27;[W sobotę o] LT&#x27;;

	                default:
	                    return &#x27;[W] dddd [o] LT&#x27;;
	            }
	        },
	        lastDay: &#x27;[Wczoraj o] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[W zeszłą niedzielę o] LT&#x27;;
	                case 3:
	                    return &#x27;[W zeszłą środę o] LT&#x27;;
	                case 6:
	                    return &#x27;[W zeszłą sobotę o] LT&#x27;;
	                default:
	                    return &#x27;[W zeszły] dddd [o] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past : &#x27;%s temu&#x27;,
	        s : &#x27;kilka sekund&#x27;,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : &#x27;1 dzień&#x27;,
	        dd : &#x27;%d dni&#x27;,
	        M : &#x27;miesiąc&#x27;,
	        MM : translate,
	        y : &#x27;rok&#x27;,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pl;

	})));


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var pt = moment.defineLocale(&#x27;pt&#x27;, {
	    months : &#x27;janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dom_Seg_Ter_Qua_Qui_Sex_Sáb&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Do_2ª_3ª_4ª_5ª_6ª_Sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Hoje às] LT&#x27;,
	        nextDay: &#x27;[Amanhã às] LT&#x27;,
	        nextWeek: &#x27;dddd [às] LT&#x27;,
	        lastDay: &#x27;[Ontem às] LT&#x27;,
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                &#x27;[Último] dddd [às] LT&#x27; : // Saturday + Sunday
	                &#x27;[Última] dddd [às] LT&#x27;; // Monday - Friday
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;em %s&#x27;,
	        past : &#x27;há %s&#x27;,
	        s : &#x27;segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;um minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;uma hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;um dia&#x27;,
	        dd : &#x27;%d dias&#x27;,
	        M : &#x27;um mês&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;um ano&#x27;,
	        yy : &#x27;%d anos&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pt;

	})));


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ptBr = moment.defineLocale(&#x27;pt-br&#x27;, {
	    months : &#x27;janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dom_Seg_Ter_Qua_Qui_Sex_Sáb&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Do_2ª_3ª_4ª_5ª_6ª_Sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY [às] HH:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY [às] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Hoje às] LT&#x27;,
	        nextDay: &#x27;[Amanhã às] LT&#x27;,
	        nextWeek: &#x27;dddd [às] LT&#x27;,
	        lastDay: &#x27;[Ontem às] LT&#x27;,
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                &#x27;[Último] dddd [às] LT&#x27; : // Saturday + Sunday
	                &#x27;[Última] dddd [às] LT&#x27;; // Monday - Friday
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;em %s&#x27;,
	        past : &#x27;há %s&#x27;,
	        s : &#x27;poucos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;um minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;uma hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;um dia&#x27;,
	        dd : &#x27;%d dias&#x27;,
	        M : &#x27;um mês&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;um ano&#x27;,
	        yy : &#x27;%d anos&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;
	});

	return ptBr;

	})));


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	            &#x27;ss&#x27;: &#x27;secunde&#x27;,
	            &#x27;mm&#x27;: &#x27;minute&#x27;,
	            &#x27;hh&#x27;: &#x27;ore&#x27;,
	            &#x27;dd&#x27;: &#x27;zile&#x27;,
	            &#x27;MM&#x27;: &#x27;luni&#x27;,
	            &#x27;yy&#x27;: &#x27;ani&#x27;
	        },
	        separator = &#x27; &#x27;;
	    if (number % 100 &gt;= 20 || (number &gt;= 100 &amp;&amp; number % 100 === 0)) {
	        separator = &#x27; de &#x27;;
	    }
	    return number + separator + format[key];
	}

	var ro = moment.defineLocale(&#x27;ro&#x27;, {
	    months : &#x27;ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;duminică_luni_marți_miercuri_joi_vineri_sâmbătă&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dum_Lun_Mar_Mie_Joi_Vin_Sâm&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Du_Lu_Ma_Mi_Jo_Vi_Sâ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[azi la] LT&#x27;,
	        nextDay: &#x27;[mâine la] LT&#x27;,
	        nextWeek: &#x27;dddd [la] LT&#x27;,
	        lastDay: &#x27;[ieri la] LT&#x27;,
	        lastWeek: &#x27;[fosta] dddd [la] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;peste %s&#x27;,
	        past : &#x27;%s în urmă&#x27;,
	        s : &#x27;câteva secunde&#x27;,
	        ss : relativeTimeWithPlural,
	        m : &#x27;un minut&#x27;,
	        mm : relativeTimeWithPlural,
	        h : &#x27;o oră&#x27;,
	        hh : relativeTimeWithPlural,
	        d : &#x27;o zi&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;o lună&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;un an&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ro;

	})));


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(word, num) {
	    var forms = word.split(&#x27;_&#x27;);
	    return num % 10 === 1 &amp;&amp; num % 100 !== 11 ? forms[0] : (num % 10 &gt;= 2 &amp;&amp; num % 10 &lt;= 4 &amp;&amp; (num % 100 &lt; 10 || num % 100 &gt;= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        &#x27;ss&#x27;: withoutSuffix ? &#x27;секунда_секунды_секунд&#x27; : &#x27;секунду_секунды_секунд&#x27;,
	        &#x27;mm&#x27;: withoutSuffix ? &#x27;минута_минуты_минут&#x27; : &#x27;минуту_минуты_минут&#x27;,
	        &#x27;hh&#x27;: &#x27;час_часа_часов&#x27;,
	        &#x27;dd&#x27;: &#x27;день_дня_дней&#x27;,
	        &#x27;MM&#x27;: &#x27;месяц_месяца_месяцев&#x27;,
	        &#x27;yy&#x27;: &#x27;год_года_лет&#x27;
	    };
	    if (key === &#x27;m&#x27;) {
	        return withoutSuffix ? &#x27;минута&#x27; : &#x27;минуту&#x27;;
	    }
	    else {
	        return number + &#x27; &#x27; + plural(format[key], +number);
	    }
	}
	var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

	// http://new.gramota.ru/spravka/rules/139-prop : § 103
	// Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	var ru = moment.defineLocale(&#x27;ru&#x27;, {
	    months : {
	        format: &#x27;января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : {
	        // по CLDR именно &quot;июл.&quot; и &quot;июн.&quot;, но какой смысл менять букву на точку ?
	        format: &#x27;янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.&#x27;.split(&#x27;_&#x27;)
	    },
	    weekdays : {
	        standalone: &#x27;воскресенье_понедельник_вторник_среда_четверг_пятница_суббота&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу&#x27;.split(&#x27;_&#x27;),
	        isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
	    },
	    weekdaysShort : &#x27;вс_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;вс_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
	    monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // копия предыдущего
	    monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // полные названия с падежами
	    monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

	    // Выражение, которое соотвествует только сокращённым формам
	    monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY г.&#x27;,
	        LLL : &#x27;D MMMM YYYY г., H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY г., H:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Сегодня в] LT&#x27;,
	        nextDay: &#x27;[Завтра в] LT&#x27;,
	        lastDay: &#x27;[Вчера в] LT&#x27;,
	        nextWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return &#x27;[В следующее] dddd [в] LT&#x27;;
	                    case 1:
	                    case 2:
	                    case 4:
	                        return &#x27;[В следующий] dddd [в] LT&#x27;;
	                    case 3:
	                    case 5:
	                    case 6:
	                        return &#x27;[В следующую] dddd [в] LT&#x27;;
	                }
	            } else {
	                if (this.day() === 2) {
	                    return &#x27;[Во] dddd [в] LT&#x27;;
	                } else {
	                    return &#x27;[В] dddd [в] LT&#x27;;
	                }
	            }
	        },
	        lastWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return &#x27;[В прошлое] dddd [в] LT&#x27;;
	                    case 1:
	                    case 2:
	                    case 4:
	                        return &#x27;[В прошлый] dddd [в] LT&#x27;;
	                    case 3:
	                    case 5:
	                    case 6:
	                        return &#x27;[В прошлую] dddd [в] LT&#x27;;
	                }
	            } else {
	                if (this.day() === 2) {
	                    return &#x27;[Во] dddd [в] LT&#x27;;
	                } else {
	                    return &#x27;[В] dddd [в] LT&#x27;;
	                }
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;через %s&#x27;,
	        past : &#x27;%s назад&#x27;,
	        s : &#x27;несколько секунд&#x27;,
	        ss : relativeTimeWithPlural,
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : &#x27;час&#x27;,
	        hh : relativeTimeWithPlural,
	        d : &#x27;день&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;месяц&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;год&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночи|утра|дня|вечера/i,
	    isPM : function (input) {
	        return /^(дня|вечера)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ночи&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;утра&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;дня&#x27;;
	        } else {
	            return &#x27;вечера&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;M&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;-й&#x27;;
	            case &#x27;D&#x27;:
	                return number + &#x27;-го&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;-я&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ru;

	})));


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months = [
	    &#x27;جنوري&#x27;,
	    &#x27;فيبروري&#x27;,
	    &#x27;مارچ&#x27;,
	    &#x27;اپريل&#x27;,
	    &#x27;مئي&#x27;,
	    &#x27;جون&#x27;,
	    &#x27;جولاءِ&#x27;,
	    &#x27;آگسٽ&#x27;,
	    &#x27;سيپٽمبر&#x27;,
	    &#x27;آڪٽوبر&#x27;,
	    &#x27;نومبر&#x27;,
	    &#x27;ڊسمبر&#x27;
	];
	var days = [
	    &#x27;آچر&#x27;,
	    &#x27;سومر&#x27;,
	    &#x27;اڱارو&#x27;,
	    &#x27;اربع&#x27;,
	    &#x27;خميس&#x27;,
	    &#x27;جمع&#x27;,
	    &#x27;ڇنڇر&#x27;
	];

	var sd = moment.defineLocale(&#x27;sd&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd، D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /صبح|شام/,
	    isPM : function (input) {
	        return &#x27;شام&#x27; === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;صبح&#x27;;
	        }
	        return &#x27;شام&#x27;;
	    },
	    calendar : {
	        sameDay : &#x27;[اڄ] LT&#x27;,
	        nextDay : &#x27;[سڀاڻي] LT&#x27;,
	        nextWeek : &#x27;dddd [اڳين هفتي تي] LT&#x27;,
	        lastDay : &#x27;[ڪالهه] LT&#x27;,
	        lastWeek : &#x27;[گزريل هفتي] dddd [تي] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s پوء&#x27;,
	        past : &#x27;%s اڳ&#x27;,
	        s : &#x27;چند سيڪنڊ&#x27;,
	        ss : &#x27;%d سيڪنڊ&#x27;,
	        m : &#x27;هڪ منٽ&#x27;,
	        mm : &#x27;%d منٽ&#x27;,
	        h : &#x27;هڪ ڪلاڪ&#x27;,
	        hh : &#x27;%d ڪلاڪ&#x27;,
	        d : &#x27;هڪ ڏينهن&#x27;,
	        dd : &#x27;%d ڏينهن&#x27;,
	        M : &#x27;هڪ مهينو&#x27;,
	        MM : &#x27;%d مهينا&#x27;,
	        y : &#x27;هڪ سال&#x27;,
	        yy : &#x27;%d سال&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sd;

	})));


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var se = moment.defineLocale(&#x27;se&#x27;, {
	    months : &#x27;ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sotn_vuos_maŋ_gask_duor_bear_láv&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;s_v_m_g_d_b_L&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;MMMM D. [b.] YYYY&#x27;,
	        LLL : &#x27;MMMM D. [b.] YYYY [ti.] HH:mm&#x27;,
	        LLLL : &#x27;dddd, MMMM D. [b.] YYYY [ti.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[otne ti] LT&#x27;,
	        nextDay: &#x27;[ihttin ti] LT&#x27;,
	        nextWeek: &#x27;dddd [ti] LT&#x27;,
	        lastDay: &#x27;[ikte ti] LT&#x27;,
	        lastWeek: &#x27;[ovddit] dddd [ti] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s geažes&#x27;,
	        past : &#x27;maŋit %s&#x27;,
	        s : &#x27;moadde sekunddat&#x27;,
	        ss: &#x27;%d sekunddat&#x27;,
	        m : &#x27;okta minuhta&#x27;,
	        mm : &#x27;%d minuhtat&#x27;,
	        h : &#x27;okta diimmu&#x27;,
	        hh : &#x27;%d diimmut&#x27;,
	        d : &#x27;okta beaivi&#x27;,
	        dd : &#x27;%d beaivvit&#x27;,
	        M : &#x27;okta mánnu&#x27;,
	        MM : &#x27;%d mánut&#x27;,
	        y : &#x27;okta jahki&#x27;,
	        yy : &#x27;%d jagit&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return se;

	})));


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	/*jshint -W100*/
	var si = moment.defineLocale(&#x27;si&#x27;, {
	    months : &#x27;ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ඉ_ස_අ_බ_බ්‍ර_සි_සෙ&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;a h:mm&#x27;,
	        LTS : &#x27;a h:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY MMMM D&#x27;,
	        LLL : &#x27;YYYY MMMM D, a h:mm&#x27;,
	        LLLL : &#x27;YYYY MMMM D [වැනි] dddd, a h:mm:ss&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[අද] LT[ට]&#x27;,
	        nextDay : &#x27;[හෙට] LT[ට]&#x27;,
	        nextWeek : &#x27;dddd LT[ට]&#x27;,
	        lastDay : &#x27;[ඊයේ] LT[ට]&#x27;,
	        lastWeek : &#x27;[පසුගිය] dddd LT[ට]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%sකින්&#x27;,
	        past : &#x27;%sකට පෙර&#x27;,
	        s : &#x27;තත්පර කිහිපය&#x27;,
	        ss : &#x27;තත්පර %d&#x27;,
	        m : &#x27;මිනිත්තුව&#x27;,
	        mm : &#x27;මිනිත්තු %d&#x27;,
	        h : &#x27;පැය&#x27;,
	        hh : &#x27;පැය %d&#x27;,
	        d : &#x27;දිනය&#x27;,
	        dd : &#x27;දින %d&#x27;,
	        M : &#x27;මාසය&#x27;,
	        MM : &#x27;මාස %d&#x27;,
	        y : &#x27;වසර&#x27;,
	        yy : &#x27;වසර %d&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
	    ordinal : function (number) {
	        return number + &#x27; වැනි&#x27;;
	    },
	    meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
	    isPM : function (input) {
	        return input === &#x27;ප.ව.&#x27; || input === &#x27;පස් වරු&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;ප.ව.&#x27; : &#x27;පස් වරු&#x27;;
	        } else {
	            return isLower ? &#x27;පෙ.ව.&#x27; : &#x27;පෙර වරු&#x27;;
	        }
	    }
	});

	return si;

	})));


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months = &#x27;január_február_marec_apríl_máj_jún_júl_august_september_október_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort = &#x27;jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;);
	function plural(n) {
	    return (n &gt; 1) &amp;&amp; (n &lt; 5);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? &#x27;pár sekúnd&#x27; : &#x27;pár sekundami&#x27;;
	        case &#x27;ss&#x27;: // 9 seconds / in 9 seconds / 9 seconds ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;sekundy&#x27; : &#x27;sekúnd&#x27;);
	            } else {
	                return result + &#x27;sekundami&#x27;;
	            }
	            break;
	        case &#x27;m&#x27;:  // a minute / in a minute / a minute ago
	            return withoutSuffix ? &#x27;minúta&#x27; : (isFuture ? &#x27;minútu&#x27; : &#x27;minútou&#x27;);
	        case &#x27;mm&#x27;: // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;minúty&#x27; : &#x27;minút&#x27;);
	            } else {
	                return result + &#x27;minútami&#x27;;
	            }
	            break;
	        case &#x27;h&#x27;:  // an hour / in an hour / an hour ago
	            return withoutSuffix ? &#x27;hodina&#x27; : (isFuture ? &#x27;hodinu&#x27; : &#x27;hodinou&#x27;);
	        case &#x27;hh&#x27;: // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;hodiny&#x27; : &#x27;hodín&#x27;);
	            } else {
	                return result + &#x27;hodinami&#x27;;
	            }
	            break;
	        case &#x27;d&#x27;:  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? &#x27;deň&#x27; : &#x27;dňom&#x27;;
	        case &#x27;dd&#x27;: // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;dni&#x27; : &#x27;dní&#x27;);
	            } else {
	                return result + &#x27;dňami&#x27;;
	            }
	            break;
	        case &#x27;M&#x27;:  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? &#x27;mesiac&#x27; : &#x27;mesiacom&#x27;;
	        case &#x27;MM&#x27;: // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;mesiace&#x27; : &#x27;mesiacov&#x27;);
	            } else {
	                return result + &#x27;mesiacmi&#x27;;
	            }
	            break;
	        case &#x27;y&#x27;:  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? &#x27;rok&#x27; : &#x27;rokom&#x27;;
	        case &#x27;yy&#x27;: // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;roky&#x27; : &#x27;rokov&#x27;);
	            } else {
	                return result + &#x27;rokmi&#x27;;
	            }
	            break;
	    }
	}

	var sk = moment.defineLocale(&#x27;sk&#x27;, {
	    months : months,
	    monthsShort : monthsShort,
	    weekdays : &#x27;nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ne_po_ut_st_št_pi_so&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_ut_st_št_pi_so&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[dnes o] LT&#x27;,
	        nextDay: &#x27;[zajtra o] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[v nedeľu o] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[v] dddd [o] LT&#x27;;
	                case 3:
	                    return &#x27;[v stredu o] LT&#x27;;
	                case 4:
	                    return &#x27;[vo štvrtok o] LT&#x27;;
	                case 5:
	                    return &#x27;[v piatok o] LT&#x27;;
	                case 6:
	                    return &#x27;[v sobotu o] LT&#x27;;
	            }
	        },
	        lastDay: &#x27;[včera o] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[minulú nedeľu o] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[minulý] dddd [o] LT&#x27;;
	                case 3:
	                    return &#x27;[minulú stredu o] LT&#x27;;
	                case 4:
	                case 5:
	                    return &#x27;[minulý] dddd [o] LT&#x27;;
	                case 6:
	                    return &#x27;[minulú sobotu o] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past : &#x27;pred %s&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sk;

	})));


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var result = number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return withoutSuffix || isFuture ? &#x27;nekaj sekund&#x27; : &#x27;nekaj sekundami&#x27;;
	        case &#x27;ss&#x27;:
	            if (number === 1) {
	                result += withoutSuffix ? &#x27;sekundo&#x27; : &#x27;sekundi&#x27;;
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? &#x27;sekundi&#x27; : &#x27;sekundah&#x27;;
	            } else if (number &lt; 5) {
	                result += withoutSuffix || isFuture ? &#x27;sekunde&#x27; : &#x27;sekundah&#x27;;
	            } else {
	                result += withoutSuffix || isFuture ? &#x27;sekund&#x27; : &#x27;sekund&#x27;;
	            }
	            return result;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;ena minuta&#x27; : &#x27;eno minuto&#x27;;
	        case &#x27;mm&#x27;:
	            if (number === 1) {
	                result += withoutSuffix ? &#x27;minuta&#x27; : &#x27;minuto&#x27;;
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? &#x27;minuti&#x27; : &#x27;minutama&#x27;;
	            } else if (number &lt; 5) {
	                result += withoutSuffix || isFuture ? &#x27;minute&#x27; : &#x27;minutami&#x27;;
	            } else {
	                result += withoutSuffix || isFuture ? &#x27;minut&#x27; : &#x27;minutami&#x27;;
	            }
	            return result;
	        case &#x27;h&#x27;:
	            return withoutSuffix ? &#x27;ena ura&#x27; : &#x27;eno uro&#x27;;
	        case &#x27;hh&#x27;:
	            if (number === 1) {
	                result += withoutSuffix ? &#x27;ura&#x27; : &#x27;uro&#x27;;
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? &#x27;uri&#x27; : &#x27;urama&#x27;;
	            } else if (number &lt; 5) {
	                result += withoutSuffix || isFuture ? &#x27;ure&#x27; : &#x27;urami&#x27;;
	            } else {
	                result += withoutSuffix || isFuture ? &#x27;ur&#x27; : &#x27;urami&#x27;;
	            }
	            return result;
	        case &#x27;d&#x27;:
	            return withoutSuffix || isFuture ? &#x27;en dan&#x27; : &#x27;enim dnem&#x27;;
	        case &#x27;dd&#x27;:
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? &#x27;dan&#x27; : &#x27;dnem&#x27;;
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? &#x27;dni&#x27; : &#x27;dnevoma&#x27;;
	            } else {
	                result += withoutSuffix || isFuture ? &#x27;dni&#x27; : &#x27;dnevi&#x27;;
	            }
	            return result;
	        case &#x27;M&#x27;:
	            return withoutSuffix || isFuture ? &#x27;en mesec&#x27; : &#x27;enim mesecem&#x27;;
	        case &#x27;MM&#x27;:
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? &#x27;mesec&#x27; : &#x27;mesecem&#x27;;
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? &#x27;meseca&#x27; : &#x27;mesecema&#x27;;
	            } else if (number &lt; 5) {
	                result += withoutSuffix || isFuture ? &#x27;mesece&#x27; : &#x27;meseci&#x27;;
	            } else {
	                result += withoutSuffix || isFuture ? &#x27;mesecev&#x27; : &#x27;meseci&#x27;;
	            }
	            return result;
	        case &#x27;y&#x27;:
	            return withoutSuffix || isFuture ? &#x27;eno leto&#x27; : &#x27;enim letom&#x27;;
	        case &#x27;yy&#x27;:
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? &#x27;leto&#x27; : &#x27;letom&#x27;;
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? &#x27;leti&#x27; : &#x27;letoma&#x27;;
	            } else if (number &lt; 5) {
	                result += withoutSuffix || isFuture ? &#x27;leta&#x27; : &#x27;leti&#x27;;
	            } else {
	                result += withoutSuffix || isFuture ? &#x27;let&#x27; : &#x27;leti&#x27;;
	            }
	            return result;
	    }
	}

	var sl = moment.defineLocale(&#x27;sl&#x27;, {
	    months : &#x27;januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ned._pon._tor._sre._čet._pet._sob.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_to_sr_če_pe_so&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[danes ob] LT&#x27;,
	        nextDay  : &#x27;[jutri ob] LT&#x27;,

	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[v] [nedeljo] [ob] LT&#x27;;
	                case 3:
	                    return &#x27;[v] [sredo] [ob] LT&#x27;;
	                case 6:
	                    return &#x27;[v] [soboto] [ob] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[v] dddd [ob] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[včeraj ob] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[prejšnjo] [nedeljo] [ob] LT&#x27;;
	                case 3:
	                    return &#x27;[prejšnjo] [sredo] [ob] LT&#x27;;
	                case 6:
	                    return &#x27;[prejšnjo] [soboto] [ob] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[prejšnji] dddd [ob] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;čez %s&#x27;,
	        past   : &#x27;pred %s&#x27;,
	        s      : processRelativeTime,
	        ss     : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : processRelativeTime,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sl;

	})));


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var sq = moment.defineLocale(&#x27;sq&#x27;, {
	    months : &#x27;Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Die_Hën_Mar_Mër_Enj_Pre_Sht&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;D_H_Ma_Më_E_P_Sh&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    meridiemParse: /PD|MD/,
	    isPM: function (input) {
	        return input.charAt(0) === &#x27;M&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        return hours &lt; 12 ? &#x27;PD&#x27; : &#x27;MD&#x27;;
	    },
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Sot në] LT&#x27;,
	        nextDay : &#x27;[Nesër në] LT&#x27;,
	        nextWeek : &#x27;dddd [në] LT&#x27;,
	        lastDay : &#x27;[Dje në] LT&#x27;,
	        lastWeek : &#x27;dddd [e kaluar në] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;në %s&#x27;,
	        past : &#x27;%s më parë&#x27;,
	        s : &#x27;disa sekonda&#x27;,
	        ss : &#x27;%d sekonda&#x27;,
	        m : &#x27;një minutë&#x27;,
	        mm : &#x27;%d minuta&#x27;,
	        h : &#x27;një orë&#x27;,
	        hh : &#x27;%d orë&#x27;,
	        d : &#x27;një ditë&#x27;,
	        dd : &#x27;%d ditë&#x27;,
	        M : &#x27;një muaj&#x27;,
	        MM : &#x27;%d muaj&#x27;,
	        y : &#x27;një vit&#x27;,
	        yy : &#x27;%d vite&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sq;

	})));


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var translator = {
	    words: { //Different grammatical cases
	        ss: [&#x27;sekunda&#x27;, &#x27;sekunde&#x27;, &#x27;sekundi&#x27;],
	        m: [&#x27;jedan minut&#x27;, &#x27;jedne minute&#x27;],
	        mm: [&#x27;minut&#x27;, &#x27;minute&#x27;, &#x27;minuta&#x27;],
	        h: [&#x27;jedan sat&#x27;, &#x27;jednog sata&#x27;],
	        hh: [&#x27;sat&#x27;, &#x27;sata&#x27;, &#x27;sati&#x27;],
	        dd: [&#x27;dan&#x27;, &#x27;dana&#x27;, &#x27;dana&#x27;],
	        MM: [&#x27;mesec&#x27;, &#x27;meseca&#x27;, &#x27;meseci&#x27;],
	        yy: [&#x27;godina&#x27;, &#x27;godine&#x27;, &#x27;godina&#x27;]
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number &gt;= 2 &amp;&amp; number &lt;= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + &#x27; &#x27; + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var sr = moment.defineLocale(&#x27;sr&#x27;, {
	    months: &#x27;januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays: &#x27;nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;ned._pon._uto._sre._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[danas u] LT&#x27;,
	        nextDay: &#x27;[sutra u] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [sredu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[juče u] LT&#x27;,
	        lastWeek : function () {
	            var lastWeekDays = [
	                &#x27;[prošle] [nedelje] [u] LT&#x27;,
	                &#x27;[prošlog] [ponedeljka] [u] LT&#x27;,
	                &#x27;[prošlog] [utorka] [u] LT&#x27;,
	                &#x27;[prošle] [srede] [u] LT&#x27;,
	                &#x27;[prošlog] [četvrtka] [u] LT&#x27;,
	                &#x27;[prošlog] [petka] [u] LT&#x27;,
	                &#x27;[prošle] [subote] [u] LT&#x27;
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;pre %s&#x27;,
	        s      : &#x27;nekoliko sekundi&#x27;,
	        ss     : translator.translate,
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translator.translate,
	        M      : &#x27;mesec&#x27;,
	        MM     : translator.translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sr;

	})));


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var translator = {
	    words: { //Different grammatical cases
	        ss: [&#x27;секунда&#x27;, &#x27;секунде&#x27;, &#x27;секунди&#x27;],
	        m: [&#x27;један минут&#x27;, &#x27;једне минуте&#x27;],
	        mm: [&#x27;минут&#x27;, &#x27;минуте&#x27;, &#x27;минута&#x27;],
	        h: [&#x27;један сат&#x27;, &#x27;једног сата&#x27;],
	        hh: [&#x27;сат&#x27;, &#x27;сата&#x27;, &#x27;сати&#x27;],
	        dd: [&#x27;дан&#x27;, &#x27;дана&#x27;, &#x27;дана&#x27;],
	        MM: [&#x27;месец&#x27;, &#x27;месеца&#x27;, &#x27;месеци&#x27;],
	        yy: [&#x27;година&#x27;, &#x27;године&#x27;, &#x27;година&#x27;]
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number &gt;= 2 &amp;&amp; number &lt;= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + &#x27; &#x27; + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var srCyrl = moment.defineLocale(&#x27;sr-cyrl&#x27;, {
	    months: &#x27;јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays: &#x27;недеља_понедељак_уторак_среда_четвртак_петак_субота&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;нед._пон._уто._сре._чет._пет._суб.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;не_по_ут_ср_че_пе_су&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[данас у] LT&#x27;,
	        nextDay: &#x27;[сутра у] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[у] [недељу] [у] LT&#x27;;
	                case 3:
	                    return &#x27;[у] [среду] [у] LT&#x27;;
	                case 6:
	                    return &#x27;[у] [суботу] [у] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[у] dddd [у] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[јуче у] LT&#x27;,
	        lastWeek : function () {
	            var lastWeekDays = [
	                &#x27;[прошле] [недеље] [у] LT&#x27;,
	                &#x27;[прошлог] [понедељка] [у] LT&#x27;,
	                &#x27;[прошлог] [уторка] [у] LT&#x27;,
	                &#x27;[прошле] [среде] [у] LT&#x27;,
	                &#x27;[прошлог] [четвртка] [у] LT&#x27;,
	                &#x27;[прошлог] [петка] [у] LT&#x27;,
	                &#x27;[прошле] [суботе] [у] LT&#x27;
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;за %s&#x27;,
	        past   : &#x27;пре %s&#x27;,
	        s      : &#x27;неколико секунди&#x27;,
	        ss     : translator.translate,
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : &#x27;дан&#x27;,
	        dd     : translator.translate,
	        M      : &#x27;месец&#x27;,
	        MM     : translator.translate,
	        y      : &#x27;годину&#x27;,
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return srCyrl;

	})));


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ss = moment.defineLocale(&#x27;ss&#x27;, {
	    months : &quot;Bhimbidvwane_Indlovana_Indlov&#x27;lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni&quot;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Lis_Umb_Lsb_Les_Lsi_Lsh_Umg&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Li_Us_Lb_Lt_Ls_Lh_Ug&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Namuhla nga] LT&#x27;,
	        nextDay : &#x27;[Kusasa nga] LT&#x27;,
	        nextWeek : &#x27;dddd [nga] LT&#x27;,
	        lastDay : &#x27;[Itolo nga] LT&#x27;,
	        lastWeek : &#x27;dddd [leliphelile] [nga] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;nga %s&#x27;,
	        past : &#x27;wenteka nga %s&#x27;,
	        s : &#x27;emizuzwana lomcane&#x27;,
	        ss : &#x27;%d mzuzwana&#x27;,
	        m : &#x27;umzuzu&#x27;,
	        mm : &#x27;%d emizuzu&#x27;,
	        h : &#x27;lihora&#x27;,
	        hh : &#x27;%d emahora&#x27;,
	        d : &#x27;lilanga&#x27;,
	        dd : &#x27;%d emalanga&#x27;,
	        M : &#x27;inyanga&#x27;,
	        MM : &#x27;%d tinyanga&#x27;,
	        y : &#x27;umnyaka&#x27;,
	        yy : &#x27;%d iminyaka&#x27;
	    },
	    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;ekuseni&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;emini&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;entsambama&#x27;;
	        } else {
	            return &#x27;ebusuku&#x27;;
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;ekuseni&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;emini&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;entsambama&#x27; || meridiem === &#x27;ebusuku&#x27;) {
	            if (hour === 0) {
	                return 0;
	            }
	            return hour + 12;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : &#x27;%d&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ss;

	})));


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var sv = moment.defineLocale(&#x27;sv&#x27;, {
	    months : &#x27;januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sön_mån_tis_ons_tor_fre_lör&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;sö_må_ti_on_to_fr_lö&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [kl.] HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY [kl.] HH:mm&#x27;,
	        lll : &#x27;D MMM YYYY HH:mm&#x27;,
	        llll : &#x27;ddd D MMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Idag] LT&#x27;,
	        nextDay: &#x27;[Imorgon] LT&#x27;,
	        lastDay: &#x27;[Igår] LT&#x27;,
	        nextWeek: &#x27;[På] dddd LT&#x27;,
	        lastWeek: &#x27;[I] dddd[s] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;för %s sedan&#x27;,
	        s : &#x27;några sekunder&#x27;,
	        ss : &#x27;%d sekunder&#x27;,
	        m : &#x27;en minut&#x27;,
	        mm : &#x27;%d minuter&#x27;,
	        h : &#x27;en timme&#x27;,
	        hh : &#x27;%d timmar&#x27;,
	        d : &#x27;en dag&#x27;,
	        dd : &#x27;%d dagar&#x27;,
	        M : &#x27;en månad&#x27;,
	        MM : &#x27;%d månader&#x27;,
	        y : &#x27;ett år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;e&#x27; :
	            (b === 1) ? &#x27;a&#x27; :
	            (b === 2) ? &#x27;a&#x27; :
	            (b === 3) ? &#x27;e&#x27; : &#x27;e&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sv;

	})));


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var sw = moment.defineLocale(&#x27;sw&#x27;, {
	    months : &#x27;Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;J2_J3_J4_J5_Al_Ij_J1&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[leo saa] LT&#x27;,
	        nextDay : &#x27;[kesho saa] LT&#x27;,
	        nextWeek : &#x27;[wiki ijayo] dddd [saat] LT&#x27;,
	        lastDay : &#x27;[jana] LT&#x27;,
	        lastWeek : &#x27;[wiki iliyopita] dddd [saat] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s baadaye&#x27;,
	        past : &#x27;tokea %s&#x27;,
	        s : &#x27;hivi punde&#x27;,
	        ss : &#x27;sekunde %d&#x27;,
	        m : &#x27;dakika moja&#x27;,
	        mm : &#x27;dakika %d&#x27;,
	        h : &#x27;saa limoja&#x27;,
	        hh : &#x27;masaa %d&#x27;,
	        d : &#x27;siku moja&#x27;,
	        dd : &#x27;masiku %d&#x27;,
	        M : &#x27;mwezi mmoja&#x27;,
	        MM : &#x27;miezi %d&#x27;,
	        y : &#x27;mwaka mmoja&#x27;,
	        yy : &#x27;miaka %d&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sw;

	})));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap = {
	    &#x27;1&#x27;: &#x27;௧&#x27;,
	    &#x27;2&#x27;: &#x27;௨&#x27;,
	    &#x27;3&#x27;: &#x27;௩&#x27;,
	    &#x27;4&#x27;: &#x27;௪&#x27;,
	    &#x27;5&#x27;: &#x27;௫&#x27;,
	    &#x27;6&#x27;: &#x27;௬&#x27;,
	    &#x27;7&#x27;: &#x27;௭&#x27;,
	    &#x27;8&#x27;: &#x27;௮&#x27;,
	    &#x27;9&#x27;: &#x27;௯&#x27;,
	    &#x27;0&#x27;: &#x27;௦&#x27;
	}, numberMap = {
	    &#x27;௧&#x27;: &#x27;1&#x27;,
	    &#x27;௨&#x27;: &#x27;2&#x27;,
	    &#x27;௩&#x27;: &#x27;3&#x27;,
	    &#x27;௪&#x27;: &#x27;4&#x27;,
	    &#x27;௫&#x27;: &#x27;5&#x27;,
	    &#x27;௬&#x27;: &#x27;6&#x27;,
	    &#x27;௭&#x27;: &#x27;7&#x27;,
	    &#x27;௮&#x27;: &#x27;8&#x27;,
	    &#x27;௯&#x27;: &#x27;9&#x27;,
	    &#x27;௦&#x27;: &#x27;0&#x27;
	};

	var ta = moment.defineLocale(&#x27;ta&#x27;, {
	    months : &#x27;ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ஞா_தி_செ_பு_வி_வெ_ச&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[இன்று] LT&#x27;,
	        nextDay : &#x27;[நாளை] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[நேற்று] LT&#x27;,
	        lastWeek : &#x27;[கடந்த வாரம்] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s இல்&#x27;,
	        past : &#x27;%s முன்&#x27;,
	        s : &#x27;ஒரு சில விநாடிகள்&#x27;,
	        ss : &#x27;%d விநாடிகள்&#x27;,
	        m : &#x27;ஒரு நிமிடம்&#x27;,
	        mm : &#x27;%d நிமிடங்கள்&#x27;,
	        h : &#x27;ஒரு மணி நேரம்&#x27;,
	        hh : &#x27;%d மணி நேரம்&#x27;,
	        d : &#x27;ஒரு நாள்&#x27;,
	        dd : &#x27;%d நாட்கள்&#x27;,
	        M : &#x27;ஒரு மாதம்&#x27;,
	        MM : &#x27;%d மாதங்கள்&#x27;,
	        y : &#x27;ஒரு வருடம்&#x27;,
	        yy : &#x27;%d ஆண்டுகள்&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}வது/,
	    ordinal : function (number) {
	        return number + &#x27;வது&#x27;;
	    },
	    preparse: function (string) {
	        return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // refer http://ta.wikipedia.org/s/1er1
	    meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 2) {
	            return &#x27; யாமம்&#x27;;
	        } else if (hour &lt; 6) {
	            return &#x27; வைகறை&#x27;;  // வைகறை
	        } else if (hour &lt; 10) {
	            return &#x27; காலை&#x27;; // காலை
	        } else if (hour &lt; 14) {
	            return &#x27; நண்பகல்&#x27;; // நண்பகல்
	        } else if (hour &lt; 18) {
	            return &#x27; எற்பாடு&#x27;; // எற்பாடு
	        } else if (hour &lt; 22) {
	            return &#x27; மாலை&#x27;; // மாலை
	        } else {
	            return &#x27; யாமம்&#x27;;
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;யாமம்&#x27;) {
	            return hour &lt; 2 ? hour : hour + 12;
	        } else if (meridiem === &#x27;வைகறை&#x27; || meridiem === &#x27;காலை&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;நண்பகல்&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else {
	            return hour + 12;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ta;

	})));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var te = moment.defineLocale(&#x27;te&#x27;, {
	    months : &#x27;జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ఆ_సో_మం_బు_గు_శు_శ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[నేడు] LT&#x27;,
	        nextDay : &#x27;[రేపు] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[నిన్న] LT&#x27;,
	        lastWeek : &#x27;[గత] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s లో&#x27;,
	        past : &#x27;%s క్రితం&#x27;,
	        s : &#x27;కొన్ని క్షణాలు&#x27;,
	        ss : &#x27;%d సెకన్లు&#x27;,
	        m : &#x27;ఒక నిమిషం&#x27;,
	        mm : &#x27;%d నిమిషాలు&#x27;,
	        h : &#x27;ఒక గంట&#x27;,
	        hh : &#x27;%d గంటలు&#x27;,
	        d : &#x27;ఒక రోజు&#x27;,
	        dd : &#x27;%d రోజులు&#x27;,
	        M : &#x27;ఒక నెల&#x27;,
	        MM : &#x27;%d నెలలు&#x27;,
	        y : &#x27;ఒక సంవత్సరం&#x27;,
	        yy : &#x27;%d సంవత్సరాలు&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}వ/,
	    ordinal : &#x27;%dవ&#x27;,
	    meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;రాత్రి&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;ఉదయం&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;మధ్యాహ్నం&#x27;) {
	            return hour &gt;= 10 ? hour : hour + 12;
	        } else if (meridiem === &#x27;సాయంత్రం&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;రాత్రి&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ఉదయం&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;మధ్యాహ్నం&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;సాయంత్రం&#x27;;
	        } else {
	            return &#x27;రాత్రి&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return te;

	})));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tet = moment.defineLocale(&#x27;tet&#x27;, {
	    months : &#x27;Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dom_Seg_Ters_Kua_Kint_Sest_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Do_Seg_Te_Ku_Ki_Ses_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Ohin iha] LT&#x27;,
	        nextDay: &#x27;[Aban iha] LT&#x27;,
	        nextWeek: &#x27;dddd [iha] LT&#x27;,
	        lastDay: &#x27;[Horiseik iha] LT&#x27;,
	        lastWeek: &#x27;dddd [semana kotuk] [iha] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;iha %s&#x27;,
	        past : &#x27;%s liuba&#x27;,
	        s : &#x27;minutu balun&#x27;,
	        ss : &#x27;minutu %d&#x27;,
	        m : &#x27;minutu ida&#x27;,
	        mm : &#x27;minutu %d&#x27;,
	        h : &#x27;oras ida&#x27;,
	        hh : &#x27;oras %d&#x27;,
	        d : &#x27;loron ida&#x27;,
	        dd : &#x27;loron %d&#x27;,
	        M : &#x27;fulan ida&#x27;,
	        MM : &#x27;fulan %d&#x27;,
	        y : &#x27;tinan ida&#x27;,
	        yy : &#x27;tinan %d&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tet;

	})));


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes = {
	    0: &#x27;-ум&#x27;,
	    1: &#x27;-ум&#x27;,
	    2: &#x27;-юм&#x27;,
	    3: &#x27;-юм&#x27;,
	    4: &#x27;-ум&#x27;,
	    5: &#x27;-ум&#x27;,
	    6: &#x27;-ум&#x27;,
	    7: &#x27;-ум&#x27;,
	    8: &#x27;-ум&#x27;,
	    9: &#x27;-ум&#x27;,
	    10: &#x27;-ум&#x27;,
	    12: &#x27;-ум&#x27;,
	    13: &#x27;-ум&#x27;,
	    20: &#x27;-ум&#x27;,
	    30: &#x27;-юм&#x27;,
	    40: &#x27;-ум&#x27;,
	    50: &#x27;-ум&#x27;,
	    60: &#x27;-ум&#x27;,
	    70: &#x27;-ум&#x27;,
	    80: &#x27;-ум&#x27;,
	    90: &#x27;-ум&#x27;,
	    100: &#x27;-ум&#x27;
	};

	var tg = moment.defineLocale(&#x27;tg&#x27;, {
	    months : &#x27;январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;яшб_дшб_сшб_чшб_пшб_ҷум_шнб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;яш_дш_сш_чш_пш_ҷм_шб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Имрӯз соати] LT&#x27;,
	        nextDay : &#x27;[Пагоҳ соати] LT&#x27;,
	        lastDay : &#x27;[Дирӯз соати] LT&#x27;,
	        nextWeek : &#x27;dddd[и] [ҳафтаи оянда соати] LT&#x27;,
	        lastWeek : &#x27;dddd[и] [ҳафтаи гузашта соати] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;баъди %s&#x27;,
	        past : &#x27;%s пеш&#x27;,
	        s : &#x27;якчанд сония&#x27;,
	        m : &#x27;як дақиқа&#x27;,
	        mm : &#x27;%d дақиқа&#x27;,
	        h : &#x27;як соат&#x27;,
	        hh : &#x27;%d соат&#x27;,
	        d : &#x27;як рӯз&#x27;,
	        dd : &#x27;%d рӯз&#x27;,
	        M : &#x27;як моҳ&#x27;,
	        MM : &#x27;%d моҳ&#x27;,
	        y : &#x27;як сол&#x27;,
	        yy : &#x27;%d сол&#x27;
	    },
	    meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;шаб&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem === &#x27;субҳ&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;рӯз&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;бегоҳ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;шаб&#x27;;
	        } else if (hour &lt; 11) {
	            return &#x27;субҳ&#x27;;
	        } else if (hour &lt; 16) {
	            return &#x27;рӯз&#x27;;
	        } else if (hour &lt; 19) {
	            return &#x27;бегоҳ&#x27;;
	        } else {
	            return &#x27;шаб&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
	    ordinal: function (number) {
	        var a = number % 10,
	            b = number &gt;= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1th is the first week of the year.
	    }
	});

	return tg;

	})));


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var th = moment.defineLocale(&#x27;th&#x27;, {
	    months : &#x27;มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์&#x27;.split(&#x27;_&#x27;), // yes, three characters difference
	    weekdaysMin : &#x27;อา._จ._อ._พ._พฤ._ศ._ส.&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY เวลา H:mm&#x27;,
	        LLLL : &#x27;วันddddที่ D MMMM YYYY เวลา H:mm&#x27;
	    },
	    meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	    isPM: function (input) {
	        return input === &#x27;หลังเที่ยง&#x27;;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ก่อนเที่ยง&#x27;;
	        } else {
	            return &#x27;หลังเที่ยง&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[วันนี้ เวลา] LT&#x27;,
	        nextDay : &#x27;[พรุ่งนี้ เวลา] LT&#x27;,
	        nextWeek : &#x27;dddd[หน้า เวลา] LT&#x27;,
	        lastDay : &#x27;[เมื่อวานนี้ เวลา] LT&#x27;,
	        lastWeek : &#x27;[วัน]dddd[ที่แล้ว เวลา] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;อีก %s&#x27;,
	        past : &#x27;%sที่แล้ว&#x27;,
	        s : &#x27;ไม่กี่วินาที&#x27;,
	        ss : &#x27;%d วินาที&#x27;,
	        m : &#x27;1 นาที&#x27;,
	        mm : &#x27;%d นาที&#x27;,
	        h : &#x27;1 ชั่วโมง&#x27;,
	        hh : &#x27;%d ชั่วโมง&#x27;,
	        d : &#x27;1 วัน&#x27;,
	        dd : &#x27;%d วัน&#x27;,
	        M : &#x27;1 เดือน&#x27;,
	        MM : &#x27;%d เดือน&#x27;,
	        y : &#x27;1 ปี&#x27;,
	        yy : &#x27;%d ปี&#x27;
	    }
	});

	return th;

	})));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tlPh = moment.defineLocale(&#x27;tl-ph&#x27;, {
	    months : &#x27;Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Lin_Lun_Mar_Miy_Huw_Biy_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Li_Lu_Ma_Mi_Hu_Bi_Sab&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;MM/D/YYYY&#x27;,
	        LL : &#x27;MMMM D, YYYY&#x27;,
	        LLL : &#x27;MMMM D, YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, MMMM DD, YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;LT [ngayong araw]&#x27;,
	        nextDay: &#x27;[Bukas ng] LT&#x27;,
	        nextWeek: &#x27;LT [sa susunod na] dddd&#x27;,
	        lastDay: &#x27;LT [kahapon]&#x27;,
	        lastWeek: &#x27;LT [noong nakaraang] dddd&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;sa loob ng %s&#x27;,
	        past : &#x27;%s ang nakalipas&#x27;,
	        s : &#x27;ilang segundo&#x27;,
	        ss : &#x27;%d segundo&#x27;,
	        m : &#x27;isang minuto&#x27;,
	        mm : &#x27;%d minuto&#x27;,
	        h : &#x27;isang oras&#x27;,
	        hh : &#x27;%d oras&#x27;,
	        d : &#x27;isang araw&#x27;,
	        dd : &#x27;%d araw&#x27;,
	        M : &#x27;isang buwan&#x27;,
	        MM : &#x27;%d buwan&#x27;,
	        y : &#x27;isang taon&#x27;,
	        yy : &#x27;%d taon&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlPh;

	})));


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var numbersNouns = &#x27;pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut&#x27;.split(&#x27;_&#x27;);

	function translateFuture(output) {
	    var time = output;
	    time = (output.indexOf(&#x27;jaj&#x27;) !== -1) ?
	    time.slice(0, -3) + &#x27;leS&#x27; :
	    (output.indexOf(&#x27;jar&#x27;) !== -1) ?
	    time.slice(0, -3) + &#x27;waQ&#x27; :
	    (output.indexOf(&#x27;DIS&#x27;) !== -1) ?
	    time.slice(0, -3) + &#x27;nem&#x27; :
	    time + &#x27; pIq&#x27;;
	    return time;
	}

	function translatePast(output) {
	    var time = output;
	    time = (output.indexOf(&#x27;jaj&#x27;) !== -1) ?
	    time.slice(0, -3) + &#x27;Hu’&#x27; :
	    (output.indexOf(&#x27;jar&#x27;) !== -1) ?
	    time.slice(0, -3) + &#x27;wen&#x27; :
	    (output.indexOf(&#x27;DIS&#x27;) !== -1) ?
	    time.slice(0, -3) + &#x27;ben&#x27; :
	    time + &#x27; ret&#x27;;
	    return time;
	}

	function translate(number, withoutSuffix, string, isFuture) {
	    var numberNoun = numberAsNoun(number);
	    switch (string) {
	        case &#x27;ss&#x27;:
	            return numberNoun + &#x27; lup&#x27;;
	        case &#x27;mm&#x27;:
	            return numberNoun + &#x27; tup&#x27;;
	        case &#x27;hh&#x27;:
	            return numberNoun + &#x27; rep&#x27;;
	        case &#x27;dd&#x27;:
	            return numberNoun + &#x27; jaj&#x27;;
	        case &#x27;MM&#x27;:
	            return numberNoun + &#x27; jar&#x27;;
	        case &#x27;yy&#x27;:
	            return numberNoun + &#x27; DIS&#x27;;
	    }
	}

	function numberAsNoun(number) {
	    var hundred = Math.floor((number % 1000) / 100),
	    ten = Math.floor((number % 100) / 10),
	    one = number % 10,
	    word = &#x27;&#x27;;
	    if (hundred &gt; 0) {
	        word += numbersNouns[hundred] + &#x27;vatlh&#x27;;
	    }
	    if (ten &gt; 0) {
	        word += ((word !== &#x27;&#x27;) ? &#x27; &#x27; : &#x27;&#x27;) + numbersNouns[ten] + &#x27;maH&#x27;;
	    }
	    if (one &gt; 0) {
	        word += ((word !== &#x27;&#x27;) ? &#x27; &#x27; : &#x27;&#x27;) + numbersNouns[one];
	    }
	    return (word === &#x27;&#x27;) ? &#x27;pagh&#x27; : word;
	}

	var tlh = moment.defineLocale(&#x27;tlh&#x27;, {
	    months : &#x27;tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[DaHjaj] LT&#x27;,
	        nextDay: &#x27;[wa’leS] LT&#x27;,
	        nextWeek: &#x27;LLL&#x27;,
	        lastDay: &#x27;[wa’Hu’] LT&#x27;,
	        lastWeek: &#x27;LLL&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : translateFuture,
	        past : translatePast,
	        s : &#x27;puS lup&#x27;,
	        ss : translate,
	        m : &#x27;wa’ tup&#x27;,
	        mm : translate,
	        h : &#x27;wa’ rep&#x27;,
	        hh : translate,
	        d : &#x27;wa’ jaj&#x27;,
	        dd : translate,
	        M : &#x27;wa’ jar&#x27;,
	        MM : translate,
	        y : &#x27;wa’ DIS&#x27;,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlh;

	})));


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;

	var suffixes = {
	    1: &#x27;\&#x27;inci&#x27;,
	    5: &#x27;\&#x27;inci&#x27;,
	    8: &#x27;\&#x27;inci&#x27;,
	    70: &#x27;\&#x27;inci&#x27;,
	    80: &#x27;\&#x27;inci&#x27;,
	    2: &#x27;\&#x27;nci&#x27;,
	    7: &#x27;\&#x27;nci&#x27;,
	    20: &#x27;\&#x27;nci&#x27;,
	    50: &#x27;\&#x27;nci&#x27;,
	    3: &#x27;\&#x27;üncü&#x27;,
	    4: &#x27;\&#x27;üncü&#x27;,
	    100: &#x27;\&#x27;üncü&#x27;,
	    6: &#x27;\&#x27;ncı&#x27;,
	    9: &#x27;\&#x27;uncu&#x27;,
	    10: &#x27;\&#x27;uncu&#x27;,
	    30: &#x27;\&#x27;uncu&#x27;,
	    60: &#x27;\&#x27;ıncı&#x27;,
	    90: &#x27;\&#x27;ıncı&#x27;
	};

	var tr = moment.defineLocale(&#x27;tr&#x27;, {
	    months : &#x27;Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Paz_Pts_Sal_Çar_Per_Cum_Cts&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Pz_Pt_Sa_Ça_Pe_Cu_Ct&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[bugün saat] LT&#x27;,
	        nextDay : &#x27;[yarın saat] LT&#x27;,
	        nextWeek : &#x27;[gelecek] dddd [saat] LT&#x27;,
	        lastDay : &#x27;[dün] LT&#x27;,
	        lastWeek : &#x27;[geçen] dddd [saat] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s sonra&#x27;,
	        past : &#x27;%s önce&#x27;,
	        s : &#x27;birkaç saniye&#x27;,
	        ss : &#x27;%d saniye&#x27;,
	        m : &#x27;bir dakika&#x27;,
	        mm : &#x27;%d dakika&#x27;,
	        h : &#x27;bir saat&#x27;,
	        hh : &#x27;%d saat&#x27;,
	        d : &#x27;bir gün&#x27;,
	        dd : &#x27;%d gün&#x27;,
	        M : &#x27;bir ay&#x27;,
	        MM : &#x27;%d ay&#x27;,
	        y : &#x27;bir yıl&#x27;,
	        yy : &#x27;%d yıl&#x27;
	    },
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;Do&#x27;:
	            case &#x27;DD&#x27;:
	                return number;
	            default:
	                if (number === 0) {  // special case for zero
	                    return number + &#x27;\&#x27;ıncı&#x27;;
	                }
	                var a = number % 10,
	                    b = number % 100 - a,
	                    c = number &gt;= 100 ? 100 : null;
	                return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tr;

	})));


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	var tzl = moment.defineLocale(&#x27;tzl&#x27;, {
	    months : &#x27;Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Súl_Lún_Mai_Már_Xhú_Vié_Sát&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Sú_Lú_Ma_Má_Xh_Vi_Sá&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM [dallas] YYYY&#x27;,
	        LLL : &#x27;D. MMMM [dallas] YYYY HH.mm&#x27;,
	        LLLL : &#x27;dddd, [li] D. MMMM [dallas] YYYY HH.mm&#x27;
	    },
	    meridiemParse: /d\&#x27;o|d\&#x27;a/i,
	    isPM : function (input) {
	        return &#x27;d\&#x27;o&#x27; === input.toLowerCase();
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;d\&#x27;o&#x27; : &#x27;D\&#x27;O&#x27;;
	        } else {
	            return isLower ? &#x27;d\&#x27;a&#x27; : &#x27;D\&#x27;A&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[oxhi à] LT&#x27;,
	        nextDay : &#x27;[demà à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[ieiri à] LT&#x27;,
	        lastWeek : &#x27;[sür el] dddd [lasteu à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;osprei %s&#x27;,
	        past : &#x27;ja%s&#x27;,
	        s : processRelativeTime,
	        ss : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        &#x27;s&#x27;: [&#x27;viensas secunds&#x27;, &#x27;\&#x27;iensas secunds&#x27;],
	        &#x27;ss&#x27;: [number + &#x27; secunds&#x27;, &#x27;&#x27; + number + &#x27; secunds&#x27;],
	        &#x27;m&#x27;: [&#x27;\&#x27;n míut&#x27;, &#x27;\&#x27;iens míut&#x27;],
	        &#x27;mm&#x27;: [number + &#x27; míuts&#x27;, &#x27;&#x27; + number + &#x27; míuts&#x27;],
	        &#x27;h&#x27;: [&#x27;\&#x27;n þora&#x27;, &#x27;\&#x27;iensa þora&#x27;],
	        &#x27;hh&#x27;: [number + &#x27; þoras&#x27;, &#x27;&#x27; + number + &#x27; þoras&#x27;],
	        &#x27;d&#x27;: [&#x27;\&#x27;n ziua&#x27;, &#x27;\&#x27;iensa ziua&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; ziuas&#x27;, &#x27;&#x27; + number + &#x27; ziuas&#x27;],
	        &#x27;M&#x27;: [&#x27;\&#x27;n mes&#x27;, &#x27;\&#x27;iens mes&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; mesen&#x27;, &#x27;&#x27; + number + &#x27; mesen&#x27;],
	        &#x27;y&#x27;: [&#x27;\&#x27;n ar&#x27;, &#x27;\&#x27;iens ar&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; ars&#x27;, &#x27;&#x27; + number + &#x27; ars&#x27;]
	    };
	    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}

	return tzl;

	})));


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tzm = moment.defineLocale(&#x27;tzm&#x27;, {
	    months : &#x27;ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[ⴰⵙⴷⵅ ⴴ] LT&#x27;,
	        nextDay: &#x27;[ⴰⵙⴽⴰ ⴴ] LT&#x27;,
	        nextWeek: &#x27;dddd [ⴴ] LT&#x27;,
	        lastDay: &#x27;[ⴰⵚⴰⵏⵜ ⴴ] LT&#x27;,
	        lastWeek: &#x27;dddd [ⴴ] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s&#x27;,
	        past : &#x27;ⵢⴰⵏ %s&#x27;,
	        s : &#x27;ⵉⵎⵉⴽ&#x27;,
	        ss : &#x27;%d ⵉⵎⵉⴽ&#x27;,
	        m : &#x27;ⵎⵉⵏⵓⴺ&#x27;,
	        mm : &#x27;%d ⵎⵉⵏⵓⴺ&#x27;,
	        h : &#x27;ⵙⴰⵄⴰ&#x27;,
	        hh : &#x27;%d ⵜⴰⵙⵙⴰⵄⵉⵏ&#x27;,
	        d : &#x27;ⴰⵙⵙ&#x27;,
	        dd : &#x27;%d oⵙⵙⴰⵏ&#x27;,
	        M : &#x27;ⴰⵢoⵓⵔ&#x27;,
	        MM : &#x27;%d ⵉⵢⵢⵉⵔⵏ&#x27;,
	        y : &#x27;ⴰⵙⴳⴰⵙ&#x27;,
	        yy : &#x27;%d ⵉⵙⴳⴰⵙⵏ&#x27;
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzm;

	})));


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tzmLatn = moment.defineLocale(&#x27;tzm-latn&#x27;, {
	    months : &#x27;innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[asdkh g] LT&#x27;,
	        nextDay: &#x27;[aska g] LT&#x27;,
	        nextWeek: &#x27;dddd [g] LT&#x27;,
	        lastDay: &#x27;[assant g] LT&#x27;,
	        lastWeek: &#x27;dddd [g] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dadkh s yan %s&#x27;,
	        past : &#x27;yan %s&#x27;,
	        s : &#x27;imik&#x27;,
	        ss : &#x27;%d imik&#x27;,
	        m : &#x27;minuḍ&#x27;,
	        mm : &#x27;%d minuḍ&#x27;,
	        h : &#x27;saɛa&#x27;,
	        hh : &#x27;%d tassaɛin&#x27;,
	        d : &#x27;ass&#x27;,
	        dd : &#x27;%d ossan&#x27;,
	        M : &#x27;ayowr&#x27;,
	        MM : &#x27;%d iyyirn&#x27;,
	        y : &#x27;asgas&#x27;,
	        yy : &#x27;%d isgasn&#x27;
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzmLatn;

	})));


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js language configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ugCn = moment.defineLocale(&#x27;ug-cn&#x27;, {
	    months: &#x27;يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر&#x27;.split(
	        &#x27;_&#x27;
	    ),
	    monthsShort: &#x27;يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر&#x27;.split(
	        &#x27;_&#x27;
	    ),
	    weekdays: &#x27;يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە&#x27;.split(
	        &#x27;_&#x27;
	    ),
	    weekdaysShort: &#x27;يە_دۈ_سە_چا_پە_جۈ_شە&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;يە_دۈ_سە_چا_پە_جۈ_شە&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;YYYY-MM-DD&#x27;,
	        LL: &#x27;YYYY-يىلىM-ئاينىڭD-كۈنى&#x27;,
	        LLL: &#x27;YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm&#x27;,
	        LLLL: &#x27;dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm&#x27;
	    },
	    meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (
	            meridiem === &#x27;يېرىم كېچە&#x27; ||
	            meridiem === &#x27;سەھەر&#x27; ||
	            meridiem === &#x27;چۈشتىن بۇرۇن&#x27;
	        ) {
	            return hour;
	        } else if (meridiem === &#x27;چۈشتىن كېيىن&#x27; || meridiem === &#x27;كەچ&#x27;) {
	            return hour + 12;
	        } else {
	            return hour &gt;= 11 ? hour : hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;يېرىم كېچە&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;سەھەر&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;چۈشتىن بۇرۇن&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;چۈش&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;چۈشتىن كېيىن&#x27;;
	        } else {
	            return &#x27;كەچ&#x27;;
	        }
	    },
	    calendar: {
	        sameDay: &#x27;[بۈگۈن سائەت] LT&#x27;,
	        nextDay: &#x27;[ئەتە سائەت] LT&#x27;,
	        nextWeek: &#x27;[كېلەركى] dddd [سائەت] LT&#x27;,
	        lastDay: &#x27;[تۆنۈگۈن] LT&#x27;,
	        lastWeek: &#x27;[ئالدىنقى] dddd [سائەت] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;%s كېيىن&#x27;,
	        past: &#x27;%s بۇرۇن&#x27;,
	        s: &#x27;نەچچە سېكونت&#x27;,
	        ss: &#x27;%d سېكونت&#x27;,
	        m: &#x27;بىر مىنۇت&#x27;,
	        mm: &#x27;%d مىنۇت&#x27;,
	        h: &#x27;بىر سائەت&#x27;,
	        hh: &#x27;%d سائەت&#x27;,
	        d: &#x27;بىر كۈن&#x27;,
	        dd: &#x27;%d كۈن&#x27;,
	        M: &#x27;بىر ئاي&#x27;,
	        MM: &#x27;%d ئاي&#x27;,
	        y: &#x27;بىر يىل&#x27;,
	        yy: &#x27;%d يىل&#x27;
	    },

	    dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;-كۈنى&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;-ھەپتە&#x27;;
	            default:
	                return number;
	        }
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week: {
	        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	        dow: 1, // Monday is the first day of the week.
	        doy: 7 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ugCn;

	})));


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(word, num) {
	    var forms = word.split(&#x27;_&#x27;);
	    return num % 10 === 1 &amp;&amp; num % 100 !== 11 ? forms[0] : (num % 10 &gt;= 2 &amp;&amp; num % 10 &lt;= 4 &amp;&amp; (num % 100 &lt; 10 || num % 100 &gt;= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        &#x27;ss&#x27;: withoutSuffix ? &#x27;секунда_секунди_секунд&#x27; : &#x27;секунду_секунди_секунд&#x27;,
	        &#x27;mm&#x27;: withoutSuffix ? &#x27;хвилина_хвилини_хвилин&#x27; : &#x27;хвилину_хвилини_хвилин&#x27;,
	        &#x27;hh&#x27;: withoutSuffix ? &#x27;година_години_годин&#x27; : &#x27;годину_години_годин&#x27;,
	        &#x27;dd&#x27;: &#x27;день_дні_днів&#x27;,
	        &#x27;MM&#x27;: &#x27;місяць_місяці_місяців&#x27;,
	        &#x27;yy&#x27;: &#x27;рік_роки_років&#x27;
	    };
	    if (key === &#x27;m&#x27;) {
	        return withoutSuffix ? &#x27;хвилина&#x27; : &#x27;хвилину&#x27;;
	    }
	    else if (key === &#x27;h&#x27;) {
	        return withoutSuffix ? &#x27;година&#x27; : &#x27;годину&#x27;;
	    }
	    else {
	        return number + &#x27; &#x27; + plural(format[key], +number);
	    }
	}
	function weekdaysCaseReplace(m, format) {
	    var weekdays = {
	        &#x27;nominative&#x27;: &#x27;неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота&#x27;.split(&#x27;_&#x27;),
	        &#x27;accusative&#x27;: &#x27;неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу&#x27;.split(&#x27;_&#x27;),
	        &#x27;genitive&#x27;: &#x27;неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи&#x27;.split(&#x27;_&#x27;)
	    };

	    if (!m) {
	        return weekdays[&#x27;nominative&#x27;];
	    }

	    var nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	        &#x27;accusative&#x27; :
	        ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	            &#x27;genitive&#x27; :
	            &#x27;nominative&#x27;);
	    return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
	    return function () {
	        return str + &#x27;о&#x27; + (this.hours() === 11 ? &#x27;б&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	    };
	}

	var uk = moment.defineLocale(&#x27;uk&#x27;, {
	    months : {
	        &#x27;format&#x27;: &#x27;січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня&#x27;.split(&#x27;_&#x27;),
	        &#x27;standalone&#x27;: &#x27;січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд&#x27;.split(&#x27;_&#x27;),
	    weekdays : weekdaysCaseReplace,
	    weekdaysShort : &#x27;нд_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нд_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY р.&#x27;,
	        LLL : &#x27;D MMMM YYYY р., HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY р., HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: processHoursFunction(&#x27;[Сьогодні &#x27;),
	        nextDay: processHoursFunction(&#x27;[Завтра &#x27;),
	        lastDay: processHoursFunction(&#x27;[Вчора &#x27;),
	        nextWeek: processHoursFunction(&#x27;[У] dddd [&#x27;),
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction(&#x27;[Минулої] dddd [&#x27;).call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction(&#x27;[Минулого] dddd [&#x27;).call(this);
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;за %s&#x27;,
	        past : &#x27;%s тому&#x27;,
	        s : &#x27;декілька секунд&#x27;,
	        ss : relativeTimeWithPlural,
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : &#x27;годину&#x27;,
	        hh : relativeTimeWithPlural,
	        d : &#x27;день&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;місяць&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;рік&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	    meridiemParse: /ночі|ранку|дня|вечора/,
	    isPM: function (input) {
	        return /^(дня|вечора)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ночі&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;ранку&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;дня&#x27;;
	        } else {
	            return &#x27;вечора&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;M&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;-й&#x27;;
	            case &#x27;D&#x27;:
	                return number + &#x27;-го&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uk;

	})));


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months = [
	    &#x27;جنوری&#x27;,
	    &#x27;فروری&#x27;,
	    &#x27;مارچ&#x27;,
	    &#x27;اپریل&#x27;,
	    &#x27;مئی&#x27;,
	    &#x27;جون&#x27;,
	    &#x27;جولائی&#x27;,
	    &#x27;اگست&#x27;,
	    &#x27;ستمبر&#x27;,
	    &#x27;اکتوبر&#x27;,
	    &#x27;نومبر&#x27;,
	    &#x27;دسمبر&#x27;
	];
	var days = [
	    &#x27;اتوار&#x27;,
	    &#x27;پیر&#x27;,
	    &#x27;منگل&#x27;,
	    &#x27;بدھ&#x27;,
	    &#x27;جمعرات&#x27;,
	    &#x27;جمعہ&#x27;,
	    &#x27;ہفتہ&#x27;
	];

	var ur = moment.defineLocale(&#x27;ur&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd، D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /صبح|شام/,
	    isPM : function (input) {
	        return &#x27;شام&#x27; === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;صبح&#x27;;
	        }
	        return &#x27;شام&#x27;;
	    },
	    calendar : {
	        sameDay : &#x27;[آج بوقت] LT&#x27;,
	        nextDay : &#x27;[کل بوقت] LT&#x27;,
	        nextWeek : &#x27;dddd [بوقت] LT&#x27;,
	        lastDay : &#x27;[گذشتہ روز بوقت] LT&#x27;,
	        lastWeek : &#x27;[گذشتہ] dddd [بوقت] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s بعد&#x27;,
	        past : &#x27;%s قبل&#x27;,
	        s : &#x27;چند سیکنڈ&#x27;,
	        ss : &#x27;%d سیکنڈ&#x27;,
	        m : &#x27;ایک منٹ&#x27;,
	        mm : &#x27;%d منٹ&#x27;,
	        h : &#x27;ایک گھنٹہ&#x27;,
	        hh : &#x27;%d گھنٹے&#x27;,
	        d : &#x27;ایک دن&#x27;,
	        dd : &#x27;%d دن&#x27;,
	        M : &#x27;ایک ماہ&#x27;,
	        MM : &#x27;%d ماہ&#x27;,
	        y : &#x27;ایک سال&#x27;,
	        yy : &#x27;%d سال&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ur;

	})));


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var uz = moment.defineLocale(&#x27;uz&#x27;, {
	    months : &#x27;январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Якш_Душ_Сеш_Чор_Пай_Жум_Шан&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Як_Ду_Се_Чо_Па_Жу_Ша&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;D MMMM YYYY, dddd HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Бугун соат] LT [да]&#x27;,
	        nextDay : &#x27;[Эртага] LT [да]&#x27;,
	        nextWeek : &#x27;dddd [куни соат] LT [да]&#x27;,
	        lastDay : &#x27;[Кеча соат] LT [да]&#x27;,
	        lastWeek : &#x27;[Утган] dddd [куни соат] LT [да]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;Якин %s ичида&#x27;,
	        past : &#x27;Бир неча %s олдин&#x27;,
	        s : &#x27;фурсат&#x27;,
	        ss : &#x27;%d фурсат&#x27;,
	        m : &#x27;бир дакика&#x27;,
	        mm : &#x27;%d дакика&#x27;,
	        h : &#x27;бир соат&#x27;,
	        hh : &#x27;%d соат&#x27;,
	        d : &#x27;бир кун&#x27;,
	        dd : &#x27;%d кун&#x27;,
	        M : &#x27;бир ой&#x27;,
	        MM : &#x27;%d ой&#x27;,
	        y : &#x27;бир йил&#x27;,
	        yy : &#x27;%d йил&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return uz;

	})));


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var uzLatn = moment.defineLocale(&#x27;uz-latn&#x27;, {
	    months : &#x27;Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Yak_Dush_Sesh_Chor_Pay_Jum_Shan&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ya_Du_Se_Cho_Pa_Ju_Sha&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;D MMMM YYYY, dddd HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Bugun soat] LT [da]&#x27;,
	        nextDay : &#x27;[Ertaga] LT [da]&#x27;,
	        nextWeek : &#x27;dddd [kuni soat] LT [da]&#x27;,
	        lastDay : &#x27;[Kecha soat] LT [da]&#x27;,
	        lastWeek : &#x27;[O\&#x27;tgan] dddd [kuni soat] LT [da]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;Yaqin %s ichida&#x27;,
	        past : &#x27;Bir necha %s oldin&#x27;,
	        s : &#x27;soniya&#x27;,
	        ss : &#x27;%d soniya&#x27;,
	        m : &#x27;bir daqiqa&#x27;,
	        mm : &#x27;%d daqiqa&#x27;,
	        h : &#x27;bir soat&#x27;,
	        hh : &#x27;%d soat&#x27;,
	        d : &#x27;bir kun&#x27;,
	        dd : &#x27;%d kun&#x27;,
	        M : &#x27;bir oy&#x27;,
	        MM : &#x27;%d oy&#x27;,
	        y : &#x27;bir yil&#x27;,
	        yy : &#x27;%d yil&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uzLatn;

	})));


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var vi = moment.defineLocale(&#x27;vi&#x27;, {
	    months : &#x27;tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;CN_T2_T3_T4_T5_T6_T7&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;CN_T2_T3_T4_T5_T6_T7&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    meridiemParse: /sa|ch/i,
	    isPM : function (input) {
	        return /^ch$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 12) {
	            return isLower ? &#x27;sa&#x27; : &#x27;SA&#x27;;
	        } else {
	            return isLower ? &#x27;ch&#x27; : &#x27;CH&#x27;;
	        }
	    },
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM [năm] YYYY&#x27;,
	        LLL : &#x27;D MMMM [năm] YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM [năm] YYYY HH:mm&#x27;,
	        l : &#x27;DD/M/YYYY&#x27;,
	        ll : &#x27;D MMM YYYY&#x27;,
	        lll : &#x27;D MMM YYYY HH:mm&#x27;,
	        llll : &#x27;ddd, D MMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Hôm nay lúc] LT&#x27;,
	        nextDay: &#x27;[Ngày mai lúc] LT&#x27;,
	        nextWeek: &#x27;dddd [tuần tới lúc] LT&#x27;,
	        lastDay: &#x27;[Hôm qua lúc] LT&#x27;,
	        lastWeek: &#x27;dddd [tuần rồi lúc] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s tới&#x27;,
	        past : &#x27;%s trước&#x27;,
	        s : &#x27;vài giây&#x27;,
	        ss : &#x27;%d giây&#x27; ,
	        m : &#x27;một phút&#x27;,
	        mm : &#x27;%d phút&#x27;,
	        h : &#x27;một giờ&#x27;,
	        hh : &#x27;%d giờ&#x27;,
	        d : &#x27;một ngày&#x27;,
	        dd : &#x27;%d ngày&#x27;,
	        M : &#x27;một tháng&#x27;,
	        MM : &#x27;%d tháng&#x27;,
	        y : &#x27;một năm&#x27;,
	        yy : &#x27;%d năm&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return vi;

	})));


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var xPseudo = moment.defineLocale(&#x27;x-pseudo&#x27;, {
	    months : &#x27;J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[T~ódá~ý át] LT&#x27;,
	        nextDay : &#x27;[T~ómó~rró~w át] LT&#x27;,
	        nextWeek : &#x27;dddd [át] LT&#x27;,
	        lastDay : &#x27;[Ý~ést~érdá~ý át] LT&#x27;,
	        lastWeek : &#x27;[L~ást] dddd [át] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;í~ñ %s&#x27;,
	        past : &#x27;%s á~gó&#x27;,
	        s : &#x27;á ~féw ~sécó~ñds&#x27;,
	        ss : &#x27;%d s~écóñ~ds&#x27;,
	        m : &#x27;á ~míñ~úté&#x27;,
	        mm : &#x27;%d m~íñú~tés&#x27;,
	        h : &#x27;á~ñ hó~úr&#x27;,
	        hh : &#x27;%d h~óúrs&#x27;,
	        d : &#x27;á ~dáý&#x27;,
	        dd : &#x27;%d d~áýs&#x27;,
	        M : &#x27;á ~móñ~th&#x27;,
	        MM : &#x27;%d m~óñt~hs&#x27;,
	        y : &#x27;á ~ýéár&#x27;,
	        yy : &#x27;%d ý~éárs&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? &#x27;th&#x27; :
	            (b === 1) ? &#x27;st&#x27; :
	            (b === 2) ? &#x27;nd&#x27; :
	            (b === 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return xPseudo;

	})));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var yo = moment.defineLocale(&#x27;yo&#x27;, {
	    months : &#x27;Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Ònì ni] LT&#x27;,
	        nextDay : &#x27;[Ọ̀la ni] LT&#x27;,
	        nextWeek : &#x27;dddd [Ọsẹ̀ tón\&#x27;bọ] [ni] LT&#x27;,
	        lastDay : &#x27;[Àna ni] LT&#x27;,
	        lastWeek : &#x27;dddd [Ọsẹ̀ tólọ́] [ni] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ní %s&#x27;,
	        past : &#x27;%s kọjá&#x27;,
	        s : &#x27;ìsẹjú aayá die&#x27;,
	        ss :&#x27;aayá %d&#x27;,
	        m : &#x27;ìsẹjú kan&#x27;,
	        mm : &#x27;ìsẹjú %d&#x27;,
	        h : &#x27;wákati kan&#x27;,
	        hh : &#x27;wákati %d&#x27;,
	        d : &#x27;ọjọ́ kan&#x27;,
	        dd : &#x27;ọjọ́ %d&#x27;,
	        M : &#x27;osù kan&#x27;,
	        MM : &#x27;osù %d&#x27;,
	        y : &#x27;ọdún kan&#x27;,
	        yy : &#x27;ọdún %d&#x27;
	    },
	    dayOfMonthOrdinalParse : /ọjọ́\s\d{1,2}/,
	    ordinal : &#x27;ọjọ́ %d&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return yo;

	})));


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var zhCn = moment.defineLocale(&#x27;zh-cn&#x27;, {
	    months : &#x27;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;星期日_星期一_星期二_星期三_星期四_星期五_星期六&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;周日_周一_周二_周三_周四_周五_周六&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_一_二_三_四_五_六&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日Ah点mm分&#x27;,
	        LLLL : &#x27;YYYY年M月D日ddddAh点mm分&#x27;,
	        l : &#x27;YYYY/M/D&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日dddd HH:mm&#x27;
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;凌晨&#x27; || meridiem === &#x27;早上&#x27; ||
	                meridiem === &#x27;上午&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;下午&#x27; || meridiem === &#x27;晚上&#x27;) {
	            return hour + 12;
	        } else {
	            // &#x27;中午&#x27;
	            return hour &gt;= 11 ? hour : hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;凌晨&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;早上&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;上午&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;中午&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;下午&#x27;;
	        } else {
	            return &#x27;晚上&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今天]LT&#x27;,
	        nextDay : &#x27;[明天]LT&#x27;,
	        nextWeek : &#x27;[下]ddddLT&#x27;,
	        lastDay : &#x27;[昨天]LT&#x27;,
	        lastWeek : &#x27;[上]ddddLT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;日&#x27;;
	            case &#x27;M&#x27;:
	                return number + &#x27;月&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;周&#x27;;
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s内&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;几秒&#x27;,
	        ss : &#x27;%d 秒&#x27;,
	        m : &#x27;1 分钟&#x27;,
	        mm : &#x27;%d 分钟&#x27;,
	        h : &#x27;1 小时&#x27;,
	        hh : &#x27;%d 小时&#x27;,
	        d : &#x27;1 天&#x27;,
	        dd : &#x27;%d 天&#x27;,
	        M : &#x27;1 个月&#x27;,
	        MM : &#x27;%d 个月&#x27;,
	        y : &#x27;1 年&#x27;,
	        yy : &#x27;%d 年&#x27;
	    },
	    week : {
	        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return zhCn;

	})));


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var zhHk = moment.defineLocale(&#x27;zh-hk&#x27;, {
	    months : &#x27;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;星期日_星期一_星期二_星期三_星期四_星期五_星期六&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;週日_週一_週二_週三_週四_週五_週六&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_一_二_三_四_五_六&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        LLLL : &#x27;YYYY年M月D日dddd HH:mm&#x27;,
	        l : &#x27;YYYY/M/D&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日dddd HH:mm&#x27;
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;凌晨&#x27; || meridiem === &#x27;早上&#x27; || meridiem === &#x27;上午&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;中午&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;下午&#x27; || meridiem === &#x27;晚上&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;凌晨&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;早上&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;上午&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;中午&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;下午&#x27;;
	        } else {
	            return &#x27;晚上&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今天]LT&#x27;,
	        nextDay : &#x27;[明天]LT&#x27;,
	        nextWeek : &#x27;[下]ddddLT&#x27;,
	        lastDay : &#x27;[昨天]LT&#x27;,
	        lastWeek : &#x27;[上]ddddLT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27; :
	            case &#x27;D&#x27; :
	            case &#x27;DDD&#x27; :
	                return number + &#x27;日&#x27;;
	            case &#x27;M&#x27; :
	                return number + &#x27;月&#x27;;
	            case &#x27;w&#x27; :
	            case &#x27;W&#x27; :
	                return number + &#x27;週&#x27;;
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s內&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;幾秒&#x27;,
	        ss : &#x27;%d 秒&#x27;,
	        m : &#x27;1 分鐘&#x27;,
	        mm : &#x27;%d 分鐘&#x27;,
	        h : &#x27;1 小時&#x27;,
	        hh : &#x27;%d 小時&#x27;,
	        d : &#x27;1 天&#x27;,
	        dd : &#x27;%d 天&#x27;,
	        M : &#x27;1 個月&#x27;,
	        MM : &#x27;%d 個月&#x27;,
	        y : &#x27;1 年&#x27;,
	        yy : &#x27;%d 年&#x27;
	    }
	});

	return zhHk;

	})));


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define === &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var zhTw = moment.defineLocale(&#x27;zh-tw&#x27;, {
	    months : &#x27;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;星期日_星期一_星期二_星期三_星期四_星期五_星期六&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;週日_週一_週二_週三_週四_週五_週六&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_一_二_三_四_五_六&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        LLLL : &#x27;YYYY年M月D日dddd HH:mm&#x27;,
	        l : &#x27;YYYY/M/D&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日dddd HH:mm&#x27;
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === &#x27;凌晨&#x27; || meridiem === &#x27;早上&#x27; || meridiem === &#x27;上午&#x27;) {
	            return hour;
	        } else if (meridiem === &#x27;中午&#x27;) {
	            return hour &gt;= 11 ? hour : hour + 12;
	        } else if (meridiem === &#x27;下午&#x27; || meridiem === &#x27;晚上&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;凌晨&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;早上&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;上午&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;中午&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;下午&#x27;;
	        } else {
	            return &#x27;晚上&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今天]LT&#x27;,
	        nextDay : &#x27;[明天]LT&#x27;,
	        nextWeek : &#x27;[下]ddddLT&#x27;,
	        lastDay : &#x27;[昨天]LT&#x27;,
	        lastWeek : &#x27;[上]ddddLT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27; :
	            case &#x27;D&#x27; :
	            case &#x27;DDD&#x27; :
	                return number + &#x27;日&#x27;;
	            case &#x27;M&#x27; :
	                return number + &#x27;月&#x27;;
	            case &#x27;w&#x27; :
	            case &#x27;W&#x27; :
	                return number + &#x27;週&#x27;;
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s內&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;幾秒&#x27;,
	        ss : &#x27;%d 秒&#x27;,
	        m : &#x27;1 分鐘&#x27;,
	        mm : &#x27;%d 分鐘&#x27;,
	        h : &#x27;1 小時&#x27;,
	        hh : &#x27;%d 小時&#x27;,
	        d : &#x27;1 天&#x27;,
	        dd : &#x27;%d 天&#x27;,
	        M : &#x27;1 個月&#x27;,
	        MM : &#x27;%d 個月&#x27;,
	        y : &#x27;1 年&#x27;,
	        yy : &#x27;%d 年&#x27;
	    }
	});

	return zhTw;

	})));


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var elements = __webpack_require__(48);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;bar&#x27;, {
		hover: {
			mode: &#x27;label&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;category&#x27;,

				// Specific to Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// offset settings
				offset: true,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}],

			yAxes: [{
				type: &#x27;linear&#x27;
			}]
		}
	});

	defaults._set(&#x27;horizontalBar&#x27;, {
		hover: {
			mode: &#x27;index&#x27;,
			axis: &#x27;y&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;linear&#x27;,
				position: &#x27;bottom&#x27;
			}],

			yAxes: [{
				position: &#x27;left&#x27;,
				type: &#x27;category&#x27;,

				// Specific to Horizontal Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// offset settings
				offset: true,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}]
		},

		elements: {
			rectangle: {
				borderSkipped: &#x27;left&#x27;
			}
		},

		tooltips: {
			callbacks: {
				title: function(item, data) {
					// Pick first xLabel for now
					var title = &#x27;&#x27;;

					if (item.length &gt; 0) {
						if (item[0].yLabel) {
							title = item[0].yLabel;
						} else if (data.labels.length &gt; 0 &amp;&amp; item[0].index &lt; data.labels.length) {
							title = data.labels[item[0].index];
						}
					}

					return title;
				},

				label: function(item, data) {
					var datasetLabel = data.datasets[item.datasetIndex].label || &#x27;&#x27;;
					return datasetLabel + &#x27;: &#x27; + item.xLabel;
				}
			},
			mode: &#x27;index&#x27;,
			axis: &#x27;y&#x27;
		}
	});

	/**
	 * Computes the &quot;optimal&quot; sample size to maintain bars equally sized while preventing overlap.
	 * @private
	 */
	function computeMinSampleSize(scale, pixels) {
		var min = scale.isHorizontal() ? scale.width : scale.height;
		var ticks = scale.getTicks();
		var prev, curr, i, ilen;

		for (i = 1, ilen = pixels.length; i &lt; ilen; ++i) {
			min = Math.min(min, pixels[i] - pixels[i - 1]);
		}

		for (i = 0, ilen = ticks.length; i &lt; ilen; ++i) {
			curr = scale.getPixelForTick(i);
			min = i &gt; 0 ? Math.min(min, curr - prev) : min;
			prev = curr;
		}

		return min;
	}

	/**
	 * Computes an &quot;ideal&quot; category based on the absolute bar thickness or, if undefined or null,
	 * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
	 * mode currently always generates bars equally sized (until we introduce scriptable options?).
	 * @private
	 */
	function computeFitCategoryTraits(index, ruler, options) {
		var thickness = options.barThickness;
		var count = ruler.stackCount;
		var curr = ruler.pixels[index];
		var size, ratio;

		if (helpers.isNullOrUndef(thickness)) {
			size = ruler.min * options.categoryPercentage;
			ratio = options.barPercentage;
		} else {
			// When bar thickness is enforced, category and bar percentages are ignored.
			// Note(SB): we could add support for relative bar thickness (e.g. barThickness: &#x27;50%&#x27;)
			// and deprecate barPercentage since this value is ignored when thickness is absolute.
			size = thickness * count;
			ratio = 1;
		}

		return {
			chunk: size / count,
			ratio: ratio,
			start: curr - (size / 2)
		};
	}

	/**
	 * Computes an &quot;optimal&quot; category that globally arranges bars side by side (no gap when
	 * percentage options are 1), based on the previous and following categories. This mode
	 * generates bars with different widths when data are not evenly spaced.
	 * @private
	 */
	function computeFlexCategoryTraits(index, ruler, options) {
		var pixels = ruler.pixels;
		var curr = pixels[index];
		var prev = index &gt; 0 ? pixels[index - 1] : null;
		var next = index &lt; pixels.length - 1 ? pixels[index + 1] : null;
		var percent = options.categoryPercentage;
		var start, size;

		if (prev === null) {
			// first data: its size is double based on the next point or,
			// if it&#x27;s also the last data, we use the scale end extremity.
			prev = curr - (next === null ? ruler.end - curr : next - curr);
		}

		if (next === null) {
			// last data: its size is also double based on the previous point.
			next = curr + curr - prev;
		}

		start = curr - ((curr - prev) / 2) * percent;
		size = ((next - prev) / 2) * percent;

		return {
			chunk: size / ruler.stackCount,
			ratio: options.barPercentage,
			start: start
		};
	}

	module.exports = function(Chart) {

		Chart.controllers.bar = Chart.DatasetController.extend({

			dataElementType: elements.Rectangle,

			initialize: function() {
				var me = this;
				var meta;

				Chart.DatasetController.prototype.initialize.apply(me, arguments);

				meta = me.getMeta();
				meta.stack = me.getDataset().stack;
				meta.bar = true;
			},

			update: function(reset) {
				var me = this;
				var rects = me.getMeta().data;
				var i, ilen;

				me._ruler = me.getRuler();

				for (i = 0, ilen = rects.length; i &lt; ilen; ++i) {
					me.updateElement(rects[i], i, reset);
				}
			},

			updateElement: function(rectangle, index, reset) {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var dataset = me.getDataset();
				var custom = rectangle.custom || {};
				var rectangleOptions = chart.options.elements.rectangle;

				rectangle._xScale = me.getScaleForId(meta.xAxisID);
				rectangle._yScale = me.getScaleForId(meta.yAxisID);
				rectangle._datasetIndex = me.index;
				rectangle._index = index;

				rectangle._model = {
					datasetLabel: dataset.label,
					label: chart.data.labels[index],
					borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
				};

				me.updateElementGeometry(rectangle, index, reset);

				rectangle.pivot();
			},

			/**
			 * @private
			 */
			updateElementGeometry: function(rectangle, index, reset) {
				var me = this;
				var model = rectangle._model;
				var vscale = me.getValueScale();
				var base = vscale.getBasePixel();
				var horizontal = vscale.isHorizontal();
				var ruler = me._ruler || me.getRuler();
				var vpixels = me.calculateBarValuePixels(me.index, index);
				var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

				model.horizontal = horizontal;
				model.base = reset ? base : vpixels.base;
				model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
				model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
				model.height = horizontal ? ipixels.size : undefined;
				model.width = horizontal ? undefined : ipixels.size;
			},

			/**
			 * @private
			 */
			getValueScaleId: function() {
				return this.getMeta().yAxisID;
			},

			/**
			 * @private
			 */
			getIndexScaleId: function() {
				return this.getMeta().xAxisID;
			},

			/**
			 * @private
			 */
			getValueScale: function() {
				return this.getScaleForId(this.getValueScaleId());
			},

			/**
			 * @private
			 */
			getIndexScale: function() {
				return this.getScaleForId(this.getIndexScaleId());
			},

			/**
			 * Returns the stacks based on groups and bar visibility.
			 * @param {Number} [last] - The dataset index
			 * @returns {Array} The stack list
			 * @private
			 */
			_getStacks: function(last) {
				var me = this;
				var chart = me.chart;
				var scale = me.getIndexScale();
				var stacked = scale.options.stacked;
				var ilen = last === undefined ? chart.data.datasets.length : last + 1;
				var stacks = [];
				var i, meta;

				for (i = 0; i &lt; ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					if (meta.bar &amp;&amp; chart.isDatasetVisible(i) &amp;&amp;
						(stacked === false ||
						(stacked === true &amp;&amp; stacks.indexOf(meta.stack) === -1) ||
						(stacked === undefined &amp;&amp; (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
						stacks.push(meta.stack);
					}
				}

				return stacks;
			},

			/**
			 * Returns the effective number of stacks based on groups and bar visibility.
			 * @private
			 */
			getStackCount: function() {
				return this._getStacks().length;
			},

			/**
			 * Returns the stack index for the given dataset based on groups and bar visibility.
			 * @param {Number} [datasetIndex] - The dataset index
			 * @param {String} [name] - The stack name to find
			 * @returns {Number} The stack index
			 * @private
			 */
			getStackIndex: function(datasetIndex, name) {
				var stacks = this._getStacks(datasetIndex);
				var index = (name !== undefined)
					? stacks.indexOf(name)
					: -1; // indexOf returns -1 if element is not present

				return (index === -1)
					? stacks.length - 1
					: index;
			},

			/**
			 * @private
			 */
			getRuler: function() {
				var me = this;
				var scale = me.getIndexScale();
				var stackCount = me.getStackCount();
				var datasetIndex = me.index;
				var isHorizontal = scale.isHorizontal();
				var start = isHorizontal ? scale.left : scale.top;
				var end = start + (isHorizontal ? scale.width : scale.height);
				var pixels = [];
				var i, ilen, min;

				for (i = 0, ilen = me.getMeta().data.length; i &lt; ilen; ++i) {
					pixels.push(scale.getPixelForValue(null, i, datasetIndex));
				}

				min = helpers.isNullOrUndef(scale.options.barThickness)
					? computeMinSampleSize(scale, pixels)
					: -1;

				return {
					min: min,
					pixels: pixels,
					start: start,
					end: end,
					stackCount: stackCount,
					scale: scale
				};
			},

			/**
			 * Note: pixel values are not clamped to the scale area.
			 * @private
			 */
			calculateBarValuePixels: function(datasetIndex, index) {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var scale = me.getValueScale();
				var datasets = chart.data.datasets;
				var value = scale.getRightValue(datasets[datasetIndex].data[index]);
				var stacked = scale.options.stacked;
				var stack = meta.stack;
				var start = 0;
				var i, imeta, ivalue, base, head, size;

				if (stacked || (stacked === undefined &amp;&amp; stack !== undefined)) {
					for (i = 0; i &lt; datasetIndex; ++i) {
						imeta = chart.getDatasetMeta(i);

						if (imeta.bar &amp;&amp;
							imeta.stack === stack &amp;&amp;
							imeta.controller.getValueScaleId() === scale.id &amp;&amp;
							chart.isDatasetVisible(i)) {

							ivalue = scale.getRightValue(datasets[i].data[index]);
							if ((value &lt; 0 &amp;&amp; ivalue &lt; 0) || (value &gt;= 0 &amp;&amp; ivalue &gt; 0)) {
								start += ivalue;
							}
						}
					}
				}

				base = scale.getPixelForValue(start);
				head = scale.getPixelForValue(start + value);
				size = (head - base) / 2;

				return {
					size: size,
					base: base,
					head: head,
					center: head + size / 2
				};
			},

			/**
			 * @private
			 */
			calculateBarIndexPixels: function(datasetIndex, index, ruler) {
				var me = this;
				var options = ruler.scale.options;
				var range = options.barThickness === &#x27;flex&#x27;
					? computeFlexCategoryTraits(index, ruler, options)
					: computeFitCategoryTraits(index, ruler, options);

				var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
				var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
				var size = Math.min(
					helpers.valueOrDefault(options.maxBarThickness, Infinity),
					range.chunk * range.ratio);

				return {
					base: center - size / 2,
					head: center + size / 2,
					center: center,
					size: size
				};
			},

			draw: function() {
				var me = this;
				var chart = me.chart;
				var scale = me.getValueScale();
				var rects = me.getMeta().data;
				var dataset = me.getDataset();
				var ilen = rects.length;
				var i = 0;

				helpers.canvas.clipArea(chart.ctx, chart.chartArea);

				for (; i &lt; ilen; ++i) {
					if (!isNaN(scale.getRightValue(dataset.data[i]))) {
						rects[i].draw();
					}
				}

				helpers.canvas.unclipArea(chart.ctx);
			},

			setHoverStyle: function(rectangle) {
				var dataset = this.chart.data.datasets[rectangle._datasetIndex];
				var index = rectangle._index;
				var custom = rectangle.custom || {};
				var model = rectangle._model;

				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(rectangle) {
				var dataset = this.chart.data.datasets[rectangle._datasetIndex];
				var index = rectangle._index;
				var custom = rectangle.custom || {};
				var model = rectangle._model;
				var rectangleElementOptions = this.chart.options.elements.rectangle;

				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
			}
		});

		Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
			/**
			 * @private
			 */
			getValueScaleId: function() {
				return this.getMeta().xAxisID;
			},

			/**
			 * @private
			 */
			getIndexScaleId: function() {
				return this.getMeta().yAxisID;
			}
		});
	};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var elements = __webpack_require__(48);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;bubble&#x27;, {
		hover: {
			mode: &#x27;single&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;linear&#x27;, // bubble should probably use a linear scale by default
				position: &#x27;bottom&#x27;,
				id: &#x27;x-axis-0&#x27; // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: &#x27;linear&#x27;,
				position: &#x27;left&#x27;,
				id: &#x27;y-axis-0&#x27;
			}]
		},

		tooltips: {
			callbacks: {
				title: function() {
					// Title doesn&#x27;t make sense for scatter since we format the data as a point
					return &#x27;&#x27;;
				},
				label: function(item, data) {
					var datasetLabel = data.datasets[item.datasetIndex].label || &#x27;&#x27;;
					var dataPoint = data.datasets[item.datasetIndex].data[item.index];
					return datasetLabel + &#x27;: (&#x27; + item.xLabel + &#x27;, &#x27; + item.yLabel + &#x27;, &#x27; + dataPoint.r + &#x27;)&#x27;;
				}
			}
		}
	});


	module.exports = function(Chart) {

		Chart.controllers.bubble = Chart.DatasetController.extend({
			/**
			 * @protected
			 */
			dataElementType: elements.Point,

			/**
			 * @protected
			 */
			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var points = meta.data;

				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				});
			},

			/**
			 * @protected
			 */
			updateElement: function(point, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var custom = point.custom || {};
				var xScale = me.getScaleForId(meta.xAxisID);
				var yScale = me.getScaleForId(meta.yAxisID);
				var options = me._resolveElementOptions(point, index);
				var data = me.getDataset().data[index];
				var dsIndex = me.index;

				var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === &#x27;object&#x27; ? data : NaN, index, dsIndex);
				var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

				point._xScale = xScale;
				point._yScale = yScale;
				point._options = options;
				point._datasetIndex = dsIndex;
				point._index = index;
				point._model = {
					backgroundColor: options.backgroundColor,
					borderColor: options.borderColor,
					borderWidth: options.borderWidth,
					hitRadius: options.hitRadius,
					pointStyle: options.pointStyle,
					radius: reset ? 0 : options.radius,
					skip: custom.skip || isNaN(x) || isNaN(y),
					x: x,
					y: y,
				};

				point.pivot();
			},

			/**
			 * @protected
			 */
			setHoverStyle: function(point) {
				var model = point._model;
				var options = point._options;

				model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
				model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
				model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
				model.radius = options.radius + options.hoverRadius;
			},

			/**
			 * @protected
			 */
			removeHoverStyle: function(point) {
				var model = point._model;
				var options = point._options;

				model.backgroundColor = options.backgroundColor;
				model.borderColor = options.borderColor;
				model.borderWidth = options.borderWidth;
				model.radius = options.radius;
			},

			/**
			 * @private
			 */
			_resolveElementOptions: function(point, index) {
				var me = this;
				var chart = me.chart;
				var datasets = chart.data.datasets;
				var dataset = datasets[me.index];
				var custom = point.custom || {};
				var options = chart.options.elements.point;
				var resolve = helpers.options.resolve;
				var data = dataset.data[index];
				var values = {};
				var i, ilen, key;

				// Scriptable options
				var context = {
					chart: chart,
					dataIndex: index,
					dataset: dataset,
					datasetIndex: me.index
				};

				var keys = [
					&#x27;backgroundColor&#x27;,
					&#x27;borderColor&#x27;,
					&#x27;borderWidth&#x27;,
					&#x27;hoverBackgroundColor&#x27;,
					&#x27;hoverBorderColor&#x27;,
					&#x27;hoverBorderWidth&#x27;,
					&#x27;hoverRadius&#x27;,
					&#x27;hitRadius&#x27;,
					&#x27;pointStyle&#x27;
				];

				for (i = 0, ilen = keys.length; i &lt; ilen; ++i) {
					key = keys[i];
					values[key] = resolve([
						custom[key],
						dataset[key],
						options[key]
					], context, index);
				}

				// Custom radius resolution
				values.radius = resolve([
					custom.radius,
					data ? data.r : undefined,
					dataset.radius,
					options.radius
				], context, index);

				return values;
			}
		});
	};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var elements = __webpack_require__(48);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;doughnut&#x27;, {
		animation: {
			// Boolean - Whether we animate the rotation of the Doughnut
			animateRotate: true,
			// Boolean - Whether we animate scaling the Doughnut from the centre
			animateScale: false
		},
		hover: {
			mode: &#x27;single&#x27;
		},
		legendCallback: function(chart) {
			var text = [];
			text.push(&#x27;&lt;ul class=&quot;&#x27; + chart.id + &#x27;-legend&quot;&gt;&#x27;);

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i &lt; datasets[0].data.length; ++i) {
					text.push(&#x27;&lt;li&gt;&lt;span style=&quot;background-color:&#x27; + datasets[0].backgroundColor[i] + &#x27;&quot;&gt;&lt;/span&gt;&#x27;);
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push(&#x27;&lt;/li&gt;&#x27;);
				}
			}

			text.push(&#x27;&lt;/ul&gt;&#x27;);
			return text.join(&#x27;&#x27;);
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length &amp;&amp; data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc &amp;&amp; arc.custom || {};
							var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;

				for (i = 0, ilen = (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					// toggle visibility of index if exists
					if (meta.data[index]) {
						meta.data[index].hidden = !meta.data[index].hidden;
					}
				}

				chart.update();
			}
		},

		// The percentage of the chart that we cut out of the middle.
		cutoutPercentage: 50,

		// The rotation of the chart, where the first data arc begins.
		rotation: Math.PI * -0.5,

		// The total circumference of the chart.
		circumference: Math.PI * 2.0,

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return &#x27;&#x27;;
				},
				label: function(tooltipItem, data) {
					var dataLabel = data.labels[tooltipItem.index];
					var value = &#x27;: &#x27; + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

					if (helpers.isArray(dataLabel)) {
						// show value on first line of multiline label
						// need to clone because we are changing the value
						dataLabel = dataLabel.slice();
						dataLabel[0] += value;
					} else {
						dataLabel += value;
					}

					return dataLabel;
				}
			}
		}
	});

	defaults._set(&#x27;pie&#x27;, helpers.clone(defaults.doughnut));
	defaults._set(&#x27;pie&#x27;, {
		cutoutPercentage: 0
	});

	module.exports = function(Chart) {

		Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

			dataElementType: elements.Arc,

			linkScales: helpers.noop,

			// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
			getRingIndex: function(datasetIndex) {
				var ringIndex = 0;

				for (var j = 0; j &lt; datasetIndex; ++j) {
					if (this.chart.isDatasetVisible(j)) {
						++ringIndex;
					}
				}

				return ringIndex;
			},

			update: function(reset) {
				var me = this;
				var chart = me.chart;
				var chartArea = chart.chartArea;
				var opts = chart.options;
				var arcOpts = opts.elements.arc;
				var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
				var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
				var minSize = Math.min(availableWidth, availableHeight);
				var offset = {x: 0, y: 0};
				var meta = me.getMeta();
				var cutoutPercentage = opts.cutoutPercentage;
				var circumference = opts.circumference;

				// If the chart&#x27;s circumference isn&#x27;t a full circle, calculate minSize as a ratio of the width/height of the arc
				if (circumference &lt; Math.PI * 2.0) {
					var startAngle = opts.rotation % (Math.PI * 2.0);
					startAngle += Math.PI * 2.0 * (startAngle &gt;= Math.PI ? -1 : startAngle &lt; -Math.PI ? 1 : 0);
					var endAngle = startAngle + circumference;
					var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
					var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
					var contains0 = (startAngle &lt;= 0 &amp;&amp; endAngle &gt;= 0) || (startAngle &lt;= Math.PI * 2.0 &amp;&amp; Math.PI * 2.0 &lt;= endAngle);
					var contains90 = (startAngle &lt;= Math.PI * 0.5 &amp;&amp; Math.PI * 0.5 &lt;= endAngle) || (startAngle &lt;= Math.PI * 2.5 &amp;&amp; Math.PI * 2.5 &lt;= endAngle);
					var contains180 = (startAngle &lt;= -Math.PI &amp;&amp; -Math.PI &lt;= endAngle) || (startAngle &lt;= Math.PI &amp;&amp; Math.PI &lt;= endAngle);
					var contains270 = (startAngle &lt;= -Math.PI * 0.5 &amp;&amp; -Math.PI * 0.5 &lt;= endAngle) || (startAngle &lt;= Math.PI * 1.5 &amp;&amp; Math.PI * 1.5 &lt;= endAngle);
					var cutout = cutoutPercentage / 100.0;
					var min = {x: contains180 ? -1 : Math.min(start.x * (start.x &lt; 0 ? 1 : cutout), end.x * (end.x &lt; 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y &lt; 0 ? 1 : cutout), end.y * (end.y &lt; 0 ? 1 : cutout))};
					var max = {x: contains0 ? 1 : Math.max(start.x * (start.x &gt; 0 ? 1 : cutout), end.x * (end.x &gt; 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y &gt; 0 ? 1 : cutout), end.y * (end.y &gt; 0 ? 1 : cutout))};
					var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
					minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
					offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
				}

				chart.borderWidth = me.getMaxBorderWidth(meta.data);
				chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
				chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
				chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
				chart.offsetX = offset.x * chart.outerRadius;
				chart.offsetY = offset.y * chart.outerRadius;

				meta.total = me.calculateTotal();

				me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
				me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},

			updateElement: function(arc, index, reset) {
				var me = this;
				var chart = me.chart;
				var chartArea = chart.chartArea;
				var opts = chart.options;
				var animationOpts = opts.animation;
				var centerX = (chartArea.left + chartArea.right) / 2;
				var centerY = (chartArea.top + chartArea.bottom) / 2;
				var startAngle = opts.rotation; // non reset case handled later
				var endAngle = opts.rotation; // non reset case handled later
				var dataset = me.getDataset();
				var circumference = reset &amp;&amp; animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
				var innerRadius = reset &amp;&amp; animationOpts.animateScale ? 0 : me.innerRadius;
				var outerRadius = reset &amp;&amp; animationOpts.animateScale ? 0 : me.outerRadius;
				var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,

					// Desired view properties
					_model: {
						x: centerX + chart.offsetX,
						y: centerY + chart.offsetY,
						startAngle: startAngle,
						endAngle: endAngle,
						circumference: circumference,
						outerRadius: outerRadius,
						innerRadius: innerRadius,
						label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
					}
				});

				var model = arc._model;
				// Resets the visual styles
				this.removeHoverStyle(arc);

				// Set correct angles if not resetting
				if (!reset || !animationOpts.animateRotate) {
					if (index === 0) {
						model.startAngle = opts.rotation;
					} else {
						model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
					}

					model.endAngle = model.startAngle + model.circumference;
				}

				arc.pivot();
			},

			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},

			calculateTotal: function() {
				var dataset = this.getDataset();
				var meta = this.getMeta();
				var total = 0;
				var value;

				helpers.each(meta.data, function(element, index) {
					value = dataset.data[index];
					if (!isNaN(value) &amp;&amp; !element.hidden) {
						total += Math.abs(value);
					}
				});

				/* if (total === 0) {
					total = NaN;
				}*/

				return total;
			},

			calculateCircumference: function(value) {
				var total = this.getMeta().total;
				if (total &gt; 0 &amp;&amp; !isNaN(value)) {
					return (Math.PI * 2.0) * (Math.abs(value) / total);
				}
				return 0;
			},

			// gets the max border or hover width to properly scale pie charts
			getMaxBorderWidth: function(arcs) {
				var max = 0;
				var index = this.index;
				var length = arcs.length;
				var borderWidth;
				var hoverWidth;

				for (var i = 0; i &lt; length; i++) {
					borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
					hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

					max = borderWidth &gt; max ? borderWidth : max;
					max = hoverWidth &gt; max ? hoverWidth : max;
				}
				return max;
			}
		});
	};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var elements = __webpack_require__(48);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;line&#x27;, {
		showLines: true,
		spanGaps: false,

		hover: {
			mode: &#x27;label&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;category&#x27;,
				id: &#x27;x-axis-0&#x27;
			}],
			yAxes: [{
				type: &#x27;linear&#x27;,
				id: &#x27;y-axis-0&#x27;
			}]
		}
	});

	module.exports = function(Chart) {

		function lineEnabled(dataset, options) {
			return helpers.valueOrDefault(dataset.showLine, options.showLines);
		}

		Chart.controllers.line = Chart.DatasetController.extend({

			datasetElementType: elements.Line,

			dataElementType: elements.Point,

			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var line = meta.dataset;
				var points = meta.data || [];
				var options = me.chart.options;
				var lineElementOptions = options.elements.line;
				var scale = me.getScaleForId(meta.yAxisID);
				var i, ilen, custom;
				var dataset = me.getDataset();
				var showLine = lineEnabled(dataset, options);

				// Update Line
				if (showLine) {
					custom = line.custom || {};

					// Compatibility: If the properties are defined with only the old name, use those values
					if ((dataset.tension !== undefined) &amp;&amp; (dataset.lineTension === undefined)) {
						dataset.lineTension = dataset.tension;
					}

					// Utility
					line._scale = scale;
					line._datasetIndex = me.index;
					// Data
					line._children = points;
					// Model
					line._model = {
						// Appearance
						// The default behavior of lines is to break at null values, according
						// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
						// This option gives lines the ability to span gaps
						spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
						fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
						steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
						cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
					};

					line.pivot();
				}

				// Update Points
				for (i = 0, ilen = points.length; i &lt; ilen; ++i) {
					me.updateElement(points[i], i, reset);
				}

				if (showLine &amp;&amp; line._model.tension !== 0) {
					me.updateBezierControlPoints();
				}

				// Now pivot the point for animation
				for (i = 0, ilen = points.length; i &lt; ilen; ++i) {
					points[i].pivot();
				}
			},

			getPointBackgroundColor: function(point, index) {
				var backgroundColor = this.chart.options.elements.point.backgroundColor;
				var dataset = this.getDataset();
				var custom = point.custom || {};

				if (custom.backgroundColor) {
					backgroundColor = custom.backgroundColor;
				} else if (dataset.pointBackgroundColor) {
					backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
				} else if (dataset.backgroundColor) {
					backgroundColor = dataset.backgroundColor;
				}

				return backgroundColor;
			},

			getPointBorderColor: function(point, index) {
				var borderColor = this.chart.options.elements.point.borderColor;
				var dataset = this.getDataset();
				var custom = point.custom || {};

				if (custom.borderColor) {
					borderColor = custom.borderColor;
				} else if (dataset.pointBorderColor) {
					borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
				} else if (dataset.borderColor) {
					borderColor = dataset.borderColor;
				}

				return borderColor;
			},

			getPointBorderWidth: function(point, index) {
				var borderWidth = this.chart.options.elements.point.borderWidth;
				var dataset = this.getDataset();
				var custom = point.custom || {};

				if (!isNaN(custom.borderWidth)) {
					borderWidth = custom.borderWidth;
				} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
					borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
				} else if (!isNaN(dataset.borderWidth)) {
					borderWidth = dataset.borderWidth;
				}

				return borderWidth;
			},

			updateElement: function(point, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var custom = point.custom || {};
				var dataset = me.getDataset();
				var datasetIndex = me.index;
				var value = dataset.data[index];
				var yScale = me.getScaleForId(meta.yAxisID);
				var xScale = me.getScaleForId(meta.xAxisID);
				var pointOptions = me.chart.options.elements.point;
				var x, y;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) &amp;&amp; (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}
				if ((dataset.hitRadius !== undefined) &amp;&amp; (dataset.pointHitRadius === undefined)) {
					dataset.pointHitRadius = dataset.hitRadius;
				}

				x = xScale.getPixelForValue(typeof value === &#x27;object&#x27; ? value : NaN, index, datasetIndex);
				y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

				// Utility
				point._xScale = xScale;
				point._yScale = yScale;
				point._datasetIndex = datasetIndex;
				point._index = index;

				// Desired view properties
				point._model = {
					x: x,
					y: y,
					skip: custom.skip || isNaN(x) || isNaN(y),
					// Appearance
					radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
					pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
					backgroundColor: me.getPointBackgroundColor(point, index),
					borderColor: me.getPointBorderColor(point, index),
					borderWidth: me.getPointBorderWidth(point, index),
					tension: meta.dataset._model ? meta.dataset._model.tension : 0,
					steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
					// Tooltip
					hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
				};
			},

			calculatePointY: function(value, index, datasetIndex) {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				var sumPos = 0;
				var sumNeg = 0;
				var i, ds, dsMeta;

				if (yScale.options.stacked) {
					for (i = 0; i &lt; datasetIndex; i++) {
						ds = chart.data.datasets[i];
						dsMeta = chart.getDatasetMeta(i);
						if (dsMeta.type === &#x27;line&#x27; &amp;&amp; dsMeta.yAxisID === yScale.id &amp;&amp; chart.isDatasetVisible(i)) {
							var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
							if (stackedRightValue &lt; 0) {
								sumNeg += stackedRightValue || 0;
							} else {
								sumPos += stackedRightValue || 0;
							}
						}
					}

					var rightValue = Number(yScale.getRightValue(value));
					if (rightValue &lt; 0) {
						return yScale.getPixelForValue(sumNeg + rightValue);
					}
					return yScale.getPixelForValue(sumPos + rightValue);
				}

				return yScale.getPixelForValue(value);
			},

			updateBezierControlPoints: function() {
				var me = this;
				var meta = me.getMeta();
				var area = me.chart.chartArea;
				var points = (meta.data || []);
				var i, ilen, point, model, controlPoints;

				// Only consider points that are drawn in case the spanGaps option is used
				if (meta.dataset._model.spanGaps) {
					points = points.filter(function(pt) {
						return !pt._model.skip;
					});
				}

				function capControlPoint(pt, min, max) {
					return Math.max(Math.min(pt, max), min);
				}

				if (meta.dataset._model.cubicInterpolationMode === &#x27;monotone&#x27;) {
					helpers.splineCurveMonotone(points);
				} else {
					for (i = 0, ilen = points.length; i &lt; ilen; ++i) {
						point = points[i];
						model = point._model;
						controlPoints = helpers.splineCurve(
							helpers.previousItem(points, i)._model,
							model,
							helpers.nextItem(points, i)._model,
							meta.dataset._model.tension
						);
						model.controlPointPreviousX = controlPoints.previous.x;
						model.controlPointPreviousY = controlPoints.previous.y;
						model.controlPointNextX = controlPoints.next.x;
						model.controlPointNextY = controlPoints.next.y;
					}
				}

				if (me.chart.options.elements.line.capBezierPoints) {
					for (i = 0, ilen = points.length; i &lt; ilen; ++i) {
						model = points[i]._model;
						model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
						model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
						model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
						model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
					}
				}
			},

			draw: function() {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var points = meta.data || [];
				var area = chart.chartArea;
				var ilen = points.length;
				var i = 0;

				helpers.canvas.clipArea(chart.ctx, area);

				if (lineEnabled(me.getDataset(), chart.options)) {
					meta.dataset.draw();
				}

				helpers.canvas.unclipArea(chart.ctx);

				// Draw the points
				for (; i &lt; ilen; ++i) {
					points[i].draw(area);
				}
			},

			setHoverStyle: function(point) {
				// Point
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var index = point._index;
				var custom = point.custom || {};
				var model = point._model;

				model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(point) {
				var me = this;
				var dataset = me.chart.data.datasets[point._datasetIndex];
				var index = point._index;
				var custom = point.custom || {};
				var model = point._model;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) &amp;&amp; (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}

				model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
				model.backgroundColor = me.getPointBackgroundColor(point, index);
				model.borderColor = me.getPointBorderColor(point, index);
				model.borderWidth = me.getPointBorderWidth(point, index);
			}
		});
	};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var elements = __webpack_require__(48);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;polarArea&#x27;, {
		scale: {
			type: &#x27;radialLinear&#x27;,
			angleLines: {
				display: false
			},
			gridLines: {
				circular: true
			},
			pointLabels: {
				display: false
			},
			ticks: {
				beginAtZero: true
			}
		},

		// Boolean - Whether to animate the rotation of the chart
		animation: {
			animateRotate: true,
			animateScale: true
		},

		startAngle: -0.5 * Math.PI,
		legendCallback: function(chart) {
			var text = [];
			text.push(&#x27;&lt;ul class=&quot;&#x27; + chart.id + &#x27;-legend&quot;&gt;&#x27;);

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i &lt; datasets[0].data.length; ++i) {
					text.push(&#x27;&lt;li&gt;&lt;span style=&quot;background-color:&#x27; + datasets[0].backgroundColor[i] + &#x27;&quot;&gt;&lt;/span&gt;&#x27;);
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push(&#x27;&lt;/li&gt;&#x27;);
				}
			}

			text.push(&#x27;&lt;/ul&gt;&#x27;);
			return text.join(&#x27;&#x27;);
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length &amp;&amp; data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc.custom || {};
							var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;

				for (i = 0, ilen = (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					meta.data[index].hidden = !meta.data[index].hidden;
				}

				chart.update();
			}
		},

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return &#x27;&#x27;;
				},
				label: function(item, data) {
					return data.labels[item.index] + &#x27;: &#x27; + item.yLabel;
				}
			}
		}
	});

	module.exports = function(Chart) {

		Chart.controllers.polarArea = Chart.DatasetController.extend({

			dataElementType: elements.Arc,

			linkScales: helpers.noop,

			update: function(reset) {
				var me = this;
				var chart = me.chart;
				var chartArea = chart.chartArea;
				var meta = me.getMeta();
				var opts = chart.options;
				var arcOpts = opts.elements.arc;
				var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
				chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
				chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
				chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

				me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
				me.innerRadius = me.outerRadius - chart.radiusLength;

				meta.count = me.countVisibleElements();

				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},

			updateElement: function(arc, index, reset) {
				var me = this;
				var chart = me.chart;
				var dataset = me.getDataset();
				var opts = chart.options;
				var animationOpts = opts.animation;
				var scale = chart.scale;
				var labels = chart.data.labels;

				var circumference = me.calculateCircumference(dataset.data[index]);
				var centerX = scale.xCenter;
				var centerY = scale.yCenter;

				// If there is NaN data before us, we need to calculate the starting angle correctly.
				// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
				var visibleCount = 0;
				var meta = me.getMeta();
				for (var i = 0; i &lt; index; ++i) {
					if (!isNaN(dataset.data[i]) &amp;&amp; !meta.data[i].hidden) {
						++visibleCount;
					}
				}

				// var negHalfPI = -0.5 * Math.PI;
				var datasetStartAngle = opts.startAngle;
				var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
				var startAngle = datasetStartAngle + (circumference * visibleCount);
				var endAngle = startAngle + (arc.hidden ? 0 : circumference);

				var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,

					// Desired view properties
					_model: {
						x: centerX,
						y: centerY,
						innerRadius: 0,
						outerRadius: reset ? resetRadius : distance,
						startAngle: reset &amp;&amp; animationOpts.animateRotate ? datasetStartAngle : startAngle,
						endAngle: reset &amp;&amp; animationOpts.animateRotate ? datasetStartAngle : endAngle,
						label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
					}
				});

				// Apply border and fill style
				me.removeHoverStyle(arc);

				arc.pivot();
			},

			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},

			countVisibleElements: function() {
				var dataset = this.getDataset();
				var meta = this.getMeta();
				var count = 0;

				helpers.each(meta.data, function(element, index) {
					if (!isNaN(dataset.data[index]) &amp;&amp; !element.hidden) {
						count++;
					}
				});

				return count;
			},

			calculateCircumference: function(value) {
				var count = this.getMeta().count;
				if (count &gt; 0 &amp;&amp; !isNaN(value)) {
					return (2 * Math.PI) / count;
				}
				return 0;
			}
		});
	};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var elements = __webpack_require__(48);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;radar&#x27;, {
		scale: {
			type: &#x27;radialLinear&#x27;
		},
		elements: {
			line: {
				tension: 0 // no bezier in radar
			}
		}
	});

	module.exports = function(Chart) {

		Chart.controllers.radar = Chart.DatasetController.extend({

			datasetElementType: elements.Line,

			dataElementType: elements.Point,

			linkScales: helpers.noop,

			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var line = meta.dataset;
				var points = meta.data;
				var custom = line.custom || {};
				var dataset = me.getDataset();
				var lineElementOptions = me.chart.options.elements.line;
				var scale = me.chart.scale;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.tension !== undefined) &amp;&amp; (dataset.lineTension === undefined)) {
					dataset.lineTension = dataset.tension;
				}

				helpers.extend(meta.dataset, {
					// Utility
					_datasetIndex: me.index,
					_scale: scale,
					// Data
					_children: points,
					_loop: true,
					// Model
					_model: {
						// Appearance
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
					}
				});

				meta.dataset.pivot();

				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				}, me);

				// Update bezier control points
				me.updateBezierControlPoints();
			},
			updateElement: function(point, index, reset) {
				var me = this;
				var custom = point.custom || {};
				var dataset = me.getDataset();
				var scale = me.chart.scale;
				var pointElementOptions = me.chart.options.elements.point;
				var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) &amp;&amp; (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}
				if ((dataset.hitRadius !== undefined) &amp;&amp; (dataset.pointHitRadius === undefined)) {
					dataset.pointHitRadius = dataset.hitRadius;
				}

				helpers.extend(point, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,

					// Desired view properties
					_model: {
						x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
						y: reset ? scale.yCenter : pointPosition.y,

						// Appearance
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
						radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
						borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
						pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

						// Tooltip
						hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
					}
				});

				point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
			},
			updateBezierControlPoints: function() {
				var chartArea = this.chart.chartArea;
				var meta = this.getMeta();

				helpers.each(meta.data, function(point, index) {
					var model = point._model;
					var controlPoints = helpers.splineCurve(
						helpers.previousItem(meta.data, index, true)._model,
						model,
						helpers.nextItem(meta.data, index, true)._model,
						model.tension
					);

					// Prevent the bezier going outside of the bounds of the graph
					model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
					model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

					model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
					model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

					// Now pivot the point for animation
					point.pivot();
				});
			},

			setHoverStyle: function(point) {
				// Point
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var custom = point.custom || {};
				var index = point._index;
				var model = point._model;

				model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(point) {
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var custom = point.custom || {};
				var index = point._index;
				var model = point._model;
				var pointElementOptions = this.chart.options.elements.point;

				model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
			}
		});
	};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);

	defaults._set(&#x27;scatter&#x27;, {
		hover: {
			mode: &#x27;single&#x27;
		},

		scales: {
			xAxes: [{
				id: &#x27;x-axis-1&#x27;,    // need an ID so datasets can reference the scale
				type: &#x27;linear&#x27;,    // scatter should not use a category axis
				position: &#x27;bottom&#x27;
			}],
			yAxes: [{
				id: &#x27;y-axis-1&#x27;,
				type: &#x27;linear&#x27;,
				position: &#x27;left&#x27;
			}]
		},

		showLines: false,

		tooltips: {
			callbacks: {
				title: function() {
					return &#x27;&#x27;;     // doesn&#x27;t make sense for scatter since data are formatted as a point
				},
				label: function(item) {
					return &#x27;(&#x27; + item.xLabel + &#x27;, &#x27; + item.yLabel + &#x27;)&#x27;;
				}
			}
		}
	});

	module.exports = function(Chart) {

		// Scatter charts use line controllers
		Chart.controllers.scatter = Chart.controllers.line;

	};


/***/ }),
/* 204 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {

		Chart.Bar = function(context, config) {
			config.type = &#x27;bar&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 205 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {

		Chart.Bubble = function(context, config) {
			config.type = &#x27;bubble&#x27;;
			return new Chart(context, config);
		};

	};


/***/ }),
/* 206 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {

		Chart.Doughnut = function(context, config) {
			config.type = &#x27;doughnut&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 207 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {

		Chart.Line = function(context, config) {
			config.type = &#x27;line&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 208 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {

		Chart.PolarArea = function(context, config) {
			config.type = &#x27;polarArea&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 209 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {

		Chart.Radar = function(context, config) {
			config.type = &#x27;radar&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 210 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports = function(Chart) {
		Chart.Scatter = function(context, config) {
			config.type = &#x27;scatter&#x27;;
			return new Chart(context, config);
		};
	};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	module.exports = {};
	module.exports.filler = __webpack_require__(212);
	module.exports.legend = __webpack_require__(213);
	module.exports.title = __webpack_require__(214);


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Plugin based on discussion from the following Chart.js issues:
	 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
	 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
	 */

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var elements = __webpack_require__(48);
	var helpers = __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		plugins: {
			filler: {
				propagate: true
			}
		}
	});

	var mappers = {
		dataset: function(source) {
			var index = source.fill;
			var chart = source.chart;
			var meta = chart.getDatasetMeta(index);
			var visible = meta &amp;&amp; chart.isDatasetVisible(index);
			var points = (visible &amp;&amp; meta.dataset._children) || [];
			var length = points.length || 0;

			return !length ? null : function(point, i) {
				return (i &lt; length &amp;&amp; points[i]._view) || null;
			};
		},

		boundary: function(source) {
			var boundary = source.boundary;
			var x = boundary ? boundary.x : null;
			var y = boundary ? boundary.y : null;

			return function(point) {
				return {
					x: x === null ? point.x : x,
					y: y === null ? point.y : y,
				};
			};
		}
	};

	// @todo if (fill[0] === &#x27;#&#x27;)
	function decodeFill(el, index, count) {
		var model = el._model || {};
		var fill = model.fill;
		var target;

		if (fill === undefined) {
			fill = !!model.backgroundColor;
		}

		if (fill === false || fill === null) {
			return false;
		}

		if (fill === true) {
			return &#x27;origin&#x27;;
		}

		target = parseFloat(fill, 10);
		if (isFinite(target) &amp;&amp; Math.floor(target) === target) {
			if (fill[0] === &#x27;-&#x27; || fill[0] === &#x27;+&#x27;) {
				target = index + target;
			}

			if (target === index || target &lt; 0 || target &gt;= count) {
				return false;
			}

			return target;
		}

		switch (fill) {
		// compatibility
		case &#x27;bottom&#x27;:
			return &#x27;start&#x27;;
		case &#x27;top&#x27;:
			return &#x27;end&#x27;;
		case &#x27;zero&#x27;:
			return &#x27;origin&#x27;;
		// supported boundaries
		case &#x27;origin&#x27;:
		case &#x27;start&#x27;:
		case &#x27;end&#x27;:
			return fill;
		// invalid fill values
		default:
			return false;
		}
	}

	function computeBoundary(source) {
		var model = source.el._model || {};
		var scale = source.el._scale || {};
		var fill = source.fill;
		var target = null;
		var horizontal;

		if (isFinite(fill)) {
			return null;
		}

		// Backward compatibility: until v3, we still need to support boundary values set on
		// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
		// controllers might still use it (e.g. the Smith chart).

		if (fill === &#x27;start&#x27;) {
			target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
		} else if (fill === &#x27;end&#x27;) {
			target = model.scaleTop === undefined ? scale.top : model.scaleTop;
		} else if (model.scaleZero !== undefined) {
			target = model.scaleZero;
		} else if (scale.getBasePosition) {
			target = scale.getBasePosition();
		} else if (scale.getBasePixel) {
			target = scale.getBasePixel();
		}

		if (target !== undefined &amp;&amp; target !== null) {
			if (target.x !== undefined &amp;&amp; target.y !== undefined) {
				return target;
			}

			if (typeof target === &#x27;number&#x27; &amp;&amp; isFinite(target)) {
				horizontal = scale.isHorizontal();
				return {
					x: horizontal ? target : null,
					y: horizontal ? null : target
				};
			}
		}

		return null;
	}

	function resolveTarget(sources, index, propagate) {
		var source = sources[index];
		var fill = source.fill;
		var visited = [index];
		var target;

		if (!propagate) {
			return fill;
		}

		while (fill !== false &amp;&amp; visited.indexOf(fill) === -1) {
			if (!isFinite(fill)) {
				return fill;
			}

			target = sources[fill];
			if (!target) {
				return false;
			}

			if (target.visible) {
				return fill;
			}

			visited.push(fill);
			fill = target.fill;
		}

		return false;
	}

	function createMapper(source) {
		var fill = source.fill;
		var type = &#x27;dataset&#x27;;

		if (fill === false) {
			return null;
		}

		if (!isFinite(fill)) {
			type = &#x27;boundary&#x27;;
		}

		return mappers[type](source);
	}

	function isDrawable(point) {
		return point &amp;&amp; !point.skip;
	}

	function drawArea(ctx, curve0, curve1, len0, len1) {
		var i;

		if (!len0 || !len1) {
			return;
		}

		// building first area curve (normal)
		ctx.moveTo(curve0[0].x, curve0[0].y);
		for (i = 1; i &lt; len0; ++i) {
			helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
		}

		// joining the two area curves
		ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

		// building opposite area curve (reverse)
		for (i = len1 - 1; i &gt; 0; --i) {
			helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
		}
	}

	function doFill(ctx, points, mapper, view, color, loop) {
		var count = points.length;
		var span = view.spanGaps;
		var curve0 = [];
		var curve1 = [];
		var len0 = 0;
		var len1 = 0;
		var i, ilen, index, p0, p1, d0, d1;

		ctx.beginPath();

		for (i = 0, ilen = (count + !!loop); i &lt; ilen; ++i) {
			index = i % count;
			p0 = points[index]._view;
			p1 = mapper(p0, index, view);
			d0 = isDrawable(p0);
			d1 = isDrawable(p1);

			if (d0 &amp;&amp; d1) {
				len0 = curve0.push(p0);
				len1 = curve1.push(p1);
			} else if (len0 &amp;&amp; len1) {
				if (!span) {
					drawArea(ctx, curve0, curve1, len0, len1);
					len0 = len1 = 0;
					curve0 = [];
					curve1 = [];
				} else {
					if (d0) {
						curve0.push(p0);
					}
					if (d1) {
						curve1.push(p1);
					}
				}
			}
		}

		drawArea(ctx, curve0, curve1, len0, len1);

		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();
	}

	module.exports = {
		id: &#x27;filler&#x27;,

		afterDatasetsUpdate: function(chart, options) {
			var count = (chart.data.datasets || []).length;
			var propagate = options.propagate;
			var sources = [];
			var meta, i, el, source;

			for (i = 0; i &lt; count; ++i) {
				meta = chart.getDatasetMeta(i);
				el = meta.dataset;
				source = null;

				if (el &amp;&amp; el._model &amp;&amp; el instanceof elements.Line) {
					source = {
						visible: chart.isDatasetVisible(i),
						fill: decodeFill(el, i, count),
						chart: chart,
						el: el
					};
				}

				meta.$filler = source;
				sources.push(source);
			}

			for (i = 0; i &lt; count; ++i) {
				source = sources[i];
				if (!source) {
					continue;
				}

				source.fill = resolveTarget(sources, i, propagate);
				source.boundary = computeBoundary(source);
				source.mapper = createMapper(source);
			}
		},

		beforeDatasetDraw: function(chart, args) {
			var meta = args.meta.$filler;
			if (!meta) {
				return;
			}

			var ctx = chart.ctx;
			var el = meta.el;
			var view = el._view;
			var points = el._children || [];
			var mapper = meta.mapper;
			var color = view.backgroundColor || defaults.global.defaultColor;

			if (mapper &amp;&amp; color &amp;&amp; points.length) {
				helpers.canvas.clipArea(ctx, chart.chartArea);
				doFill(ctx, points, mapper, view, color, el._loop);
				helpers.canvas.unclipArea(ctx);
			}
		}
	};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);
	var layouts = __webpack_require__(54);

	var noop = helpers.noop;

	defaults._set(&#x27;global&#x27;, {
		legend: {
			display: true,
			position: &#x27;top&#x27;,
			fullWidth: true,
			reverse: false,
			weight: 1000,

			// a callback that will handle
			onClick: function(e, legendItem) {
				var index = legendItem.datasetIndex;
				var ci = this.chart;
				var meta = ci.getDatasetMeta(index);

				// See controller.isDatasetVisible comment
				meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

				// We hid a dataset ... rerender the chart
				ci.update();
			},

			onHover: null,

			labels: {
				boxWidth: 40,
				padding: 10,
				// Generates labels shown in the legend
				// Valid properties to return:
				// text : text to display
				// fillStyle : fill of coloured box
				// strokeStyle: stroke of coloured box
				// hidden : if this legend item refers to a hidden item
				// lineCap : cap style for line
				// lineDash
				// lineDashOffset :
				// lineJoin :
				// lineWidth :
				generateLabels: function(chart) {
					var data = chart.data;
					return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
						return {
							text: dataset.label,
							fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
							hidden: !chart.isDatasetVisible(i),
							lineCap: dataset.borderCapStyle,
							lineDash: dataset.borderDash,
							lineDashOffset: dataset.borderDashOffset,
							lineJoin: dataset.borderJoinStyle,
							lineWidth: dataset.borderWidth,
							strokeStyle: dataset.borderColor,
							pointStyle: dataset.pointStyle,

							// Below is extra data used for toggling the datasets
							datasetIndex: i
						};
					}, this) : [];
				}
			}
		},

		legendCallback: function(chart) {
			var text = [];
			text.push(&#x27;&lt;ul class=&quot;&#x27; + chart.id + &#x27;-legend&quot;&gt;&#x27;);
			for (var i = 0; i &lt; chart.data.datasets.length; i++) {
				text.push(&#x27;&lt;li&gt;&lt;span style=&quot;background-color:&#x27; + chart.data.datasets[i].backgroundColor + &#x27;&quot;&gt;&lt;/span&gt;&#x27;);
				if (chart.data.datasets[i].label) {
					text.push(chart.data.datasets[i].label);
				}
				text.push(&#x27;&lt;/li&gt;&#x27;);
			}
			text.push(&#x27;&lt;/ul&gt;&#x27;);
			return text.join(&#x27;&#x27;);
		}
	});

	/**
	 * Helper function to get the box width based on the usePointStyle option
	 * @param labelopts {Object} the label options on the legend
	 * @param fontSize {Number} the label font size
	 * @return {Number} width of the color box area
	 */
	function getBoxWidth(labelOpts, fontSize) {
		return labelOpts.usePointStyle ?
			fontSize * Math.SQRT2 :
			labelOpts.boxWidth;
	}

	/**
	 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
	 */
	var Legend = Element.extend({

		initialize: function(config) {
			helpers.extend(this, config);

			// Contains hit boxes for each dataset (in dataset order)
			this.legendHitBoxes = [];

			// Are we in doughnut mode which has a different data type
			this.doughnutMode = false;
		},

		// These methods are ordered by lifecycle. Utilities then follow.
		// Any function defined here is inherited by all legend types.
		// Any function can be extended by the legend type

		beforeUpdate: noop,
		update: function(maxWidth, maxHeight, margins) {
			var me = this;

			// Update Lifecycle - Probably don&#x27;t want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;
		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;

			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: function() {
			var me = this;
			var labelOpts = me.options.labels || {};
			var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

			if (labelOpts.filter) {
				legendItems = legendItems.filter(function(item) {
					return labelOpts.filter(item, me.chart.data);
				});
			}

			if (me.options.reverse) {
				legendItems.reverse();
			}

			me.legendItems = legendItems;
		},
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var display = opts.display;

			var ctx = me.ctx;

			var globalDefault = defaults.global;
			var valueOrDefault = helpers.valueOrDefault;
			var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
			var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
			var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
			var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

			// Reset hit boxes
			var hitboxes = me.legendHitBoxes = [];

			var minSize = me.minSize;
			var isHorizontal = me.isHorizontal();

			if (isHorizontal) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = display ? 10 : 0;
			} else {
				minSize.width = display ? 10 : 0;
				minSize.height = me.maxHeight; // fill all the height
			}

			// Increase sizes here
			if (display) {
				ctx.font = labelFont;

				if (isHorizontal) {
					// Labels

					// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
					var lineWidths = me.lineWidths = [0];
					var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;

					ctx.textAlign = &#x27;left&#x27;;
					ctx.textBaseline = &#x27;top&#x27;;

					helpers.each(me.legendItems, function(legendItem, i) {
						var boxWidth = getBoxWidth(labelOpts, fontSize);
						var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

						if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding &gt;= me.width) {
							totalHeight += fontSize + (labelOpts.padding);
							lineWidths[lineWidths.length] = me.left;
						}

						// Store the hitbox width and height here. Final position will be updated in &#x60;draw&#x60;
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: width,
							height: fontSize
						};

						lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
					});

					minSize.height += totalHeight;

				} else {
					var vPadding = labelOpts.padding;
					var columnWidths = me.columnWidths = [];
					var totalWidth = labelOpts.padding;
					var currentColWidth = 0;
					var currentColHeight = 0;
					var itemHeight = fontSize + vPadding;

					helpers.each(me.legendItems, function(legendItem, i) {
						var boxWidth = getBoxWidth(labelOpts, fontSize);
						var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

						// If too tall, go to new column
						if (currentColHeight + itemHeight &gt; minSize.height) {
							totalWidth += currentColWidth + labelOpts.padding;
							columnWidths.push(currentColWidth); // previous column width

							currentColWidth = 0;
							currentColHeight = 0;
						}

						// Get max width
						currentColWidth = Math.max(currentColWidth, itemWidth);
						currentColHeight += itemHeight;

						// Store the hitbox width and height here. Final position will be updated in &#x60;draw&#x60;
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: itemWidth,
							height: fontSize
						};
					});

					totalWidth += currentColWidth;
					columnWidths.push(currentColWidth);
					minSize.width += totalWidth;
				}
			}

			me.width = minSize.width;
			me.height = minSize.height;
		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function() {
			return this.options.position === &#x27;top&#x27; || this.options.position === &#x27;bottom&#x27;;
		},

		// Actually draw the legend on the canvas
		draw: function() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var globalDefault = defaults.global;
			var lineDefault = globalDefault.elements.line;
			var legendWidth = me.width;
			var lineWidths = me.lineWidths;

			if (opts.display) {
				var ctx = me.ctx;
				var valueOrDefault = helpers.valueOrDefault;
				var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
				var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
				var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
				var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
				var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
				var cursor;

				// Canvas setup
				ctx.textAlign = &#x27;left&#x27;;
				ctx.textBaseline = &#x27;middle&#x27;;
				ctx.lineWidth = 0.5;
				ctx.strokeStyle = fontColor; // for strikethrough effect
				ctx.fillStyle = fontColor; // render in correct colour
				ctx.font = labelFont;

				var boxWidth = getBoxWidth(labelOpts, fontSize);
				var hitboxes = me.legendHitBoxes;

				// current position
				var drawLegendBox = function(x, y, legendItem) {
					if (isNaN(boxWidth) || boxWidth &lt;= 0) {
						return;
					}

					// Set the ctx for the box
					ctx.save();

					ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
					ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
					ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
					ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
					ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
					ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
					var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);

					if (ctx.setLineDash) {
						// IE 9 and 10 do not support line dash
						ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
					}

					if (opts.labels &amp;&amp; opts.labels.usePointStyle) {
						// Recalculate x and y for drawPoint() because its expecting
						// x and y to be center of figure (instead of top left)
						var radius = fontSize * Math.SQRT2 / 2;
						var offSet = radius / Math.SQRT2;
						var centerX = x + offSet;
						var centerY = y + offSet;

						// Draw pointStyle as legend symbol
						helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
					} else {
						// Draw box as legend symbol
						if (!isLineWidthZero) {
							ctx.strokeRect(x, y, boxWidth, fontSize);
						}
						ctx.fillRect(x, y, boxWidth, fontSize);
					}

					ctx.restore();
				};
				var fillText = function(x, y, legendItem, textWidth) {
					var halfFontSize = fontSize / 2;
					var xLeft = boxWidth + halfFontSize + x;
					var yMiddle = y + halfFontSize;

					ctx.fillText(legendItem.text, xLeft, yMiddle);

					if (legendItem.hidden) {
						// Strikethrough the text if hidden
						ctx.beginPath();
						ctx.lineWidth = 2;
						ctx.moveTo(xLeft, yMiddle);
						ctx.lineTo(xLeft + textWidth, yMiddle);
						ctx.stroke();
					}
				};

				// Horizontal
				var isHorizontal = me.isHorizontal();
				if (isHorizontal) {
					cursor = {
						x: me.left + ((legendWidth - lineWidths[0]) / 2),
						y: me.top + labelOpts.padding,
						line: 0
					};
				} else {
					cursor = {
						x: me.left + labelOpts.padding,
						y: me.top + labelOpts.padding,
						line: 0
					};
				}

				var itemHeight = fontSize + labelOpts.padding;
				helpers.each(me.legendItems, function(legendItem, i) {
					var textWidth = ctx.measureText(legendItem.text).width;
					var width = boxWidth + (fontSize / 2) + textWidth;
					var x = cursor.x;
					var y = cursor.y;

					if (isHorizontal) {
						if (x + width &gt;= legendWidth) {
							y = cursor.y += itemHeight;
							cursor.line++;
							x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
						}
					} else if (y + itemHeight &gt; me.bottom) {
						x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
						y = cursor.y = me.top + labelOpts.padding;
						cursor.line++;
					}

					drawLegendBox(x, y, legendItem);

					hitboxes[i].left = x;
					hitboxes[i].top = y;

					// Fill the actual label
					fillText(x, y, legendItem, textWidth);

					if (isHorizontal) {
						cursor.x += width + (labelOpts.padding);
					} else {
						cursor.y += itemHeight;
					}

				});
			}
		},

		/**
		 * Handle an event
		 * @private
		 * @param {IEvent} event - The event to handle
		 * @return {Boolean} true if a change occured
		 */
		handleEvent: function(e) {
			var me = this;
			var opts = me.options;
			var type = e.type === &#x27;mouseup&#x27; ? &#x27;click&#x27; : e.type;
			var changed = false;

			if (type === &#x27;mousemove&#x27;) {
				if (!opts.onHover) {
					return;
				}
			} else if (type === &#x27;click&#x27;) {
				if (!opts.onClick) {
					return;
				}
			} else {
				return;
			}

			// Chart event already has relative position in it
			var x = e.x;
			var y = e.y;

			if (x &gt;= me.left &amp;&amp; x &lt;= me.right &amp;&amp; y &gt;= me.top &amp;&amp; y &lt;= me.bottom) {
				// See if we are touching one of the dataset boxes
				var lh = me.legendHitBoxes;
				for (var i = 0; i &lt; lh.length; ++i) {
					var hitBox = lh[i];

					if (x &gt;= hitBox.left &amp;&amp; x &lt;= hitBox.left + hitBox.width &amp;&amp; y &gt;= hitBox.top &amp;&amp; y &lt;= hitBox.top + hitBox.height) {
						// Touching an element
						if (type === &#x27;click&#x27;) {
							// use e.native for backwards compatibility
							opts.onClick.call(me, e.native, me.legendItems[i]);
							changed = true;
							break;
						} else if (type === &#x27;mousemove&#x27;) {
							// use e.native for backwards compatibility
							opts.onHover.call(me, e.native, me.legendItems[i]);
							changed = true;
							break;
						}
					}
				}
			}

			return changed;
		}
	});

	function createNewLegendAndAttach(chart, legendOpts) {
		var legend = new Legend({
			ctx: chart.ctx,
			options: legendOpts,
			chart: chart
		});

		layouts.configure(chart, legend, legendOpts);
		layouts.addBox(chart, legend);
		chart.legend = legend;
	}

	module.exports = {
		id: &#x27;legend&#x27;,

		/**
		 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
		 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
		 * the plugin, which one will be re-exposed in the chart.js file.
		 * https://github.com/chartjs/Chart.js/pull/2640
		 * @private
		 */
		_element: Legend,

		beforeInit: function(chart) {
			var legendOpts = chart.options.legend;

			if (legendOpts) {
				createNewLegendAndAttach(chart, legendOpts);
			}
		},

		beforeUpdate: function(chart) {
			var legendOpts = chart.options.legend;
			var legend = chart.legend;

			if (legendOpts) {
				helpers.mergeIf(legendOpts, defaults.global.legend);

				if (legend) {
					layouts.configure(chart, legend, legendOpts);
					legend.options = legendOpts;
				} else {
					createNewLegendAndAttach(chart, legendOpts);
				}
			} else if (legend) {
				layouts.removeBox(chart, legend);
				delete chart.legend;
			}
		},

		afterEvent: function(chart, e) {
			var legend = chart.legend;
			if (legend) {
				legend.handleEvent(e);
			}
		}
	};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults = __webpack_require__(35);
	var Element = __webpack_require__(47);
	var helpers = __webpack_require__(36);
	var layouts = __webpack_require__(54);

	var noop = helpers.noop;

	defaults._set(&#x27;global&#x27;, {
		title: {
			display: false,
			fontStyle: &#x27;bold&#x27;,
			fullWidth: true,
			lineHeight: 1.2,
			padding: 10,
			position: &#x27;top&#x27;,
			text: &#x27;&#x27;,
			weight: 2000         // by default greater than legend (1000) to be above
		}
	});

	/**
	 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
	 */
	var Title = Element.extend({
		initialize: function(config) {
			var me = this;
			helpers.extend(me, config);

			// Contains hit boxes for each dataset (in dataset order)
			me.legendHitBoxes = [];
		},

		// These methods are ordered by lifecycle. Utilities then follow.

		beforeUpdate: noop,
		update: function(maxWidth, maxHeight, margins) {
			var me = this;

			// Update Lifecycle - Probably don&#x27;t want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;

		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;

			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: noop,
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function() {
			var me = this;
			var valueOrDefault = helpers.valueOrDefault;
			var opts = me.options;
			var display = opts.display;
			var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
			var minSize = me.minSize;
			var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
			var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
			var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;

			if (me.isHorizontal()) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = textSize;
			} else {
				minSize.width = textSize;
				minSize.height = me.maxHeight; // fill all the height
			}

			me.width = minSize.width;
			me.height = minSize.height;

		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function() {
			var pos = this.options.position;
			return pos === &#x27;top&#x27; || pos === &#x27;bottom&#x27;;
		},

		// Actually draw the title block on the canvas
		draw: function() {
			var me = this;
			var ctx = me.ctx;
			var valueOrDefault = helpers.valueOrDefault;
			var opts = me.options;
			var globalDefaults = defaults.global;

			if (opts.display) {
				var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
				var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
				var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
				var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
				var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
				var offset = lineHeight / 2 + opts.padding;
				var rotation = 0;
				var top = me.top;
				var left = me.left;
				var bottom = me.bottom;
				var right = me.right;
				var maxWidth, titleX, titleY;

				ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
				ctx.font = titleFont;

				// Horizontal
				if (me.isHorizontal()) {
					titleX = left + ((right - left) / 2); // midpoint of the width
					titleY = top + offset;
					maxWidth = right - left;
				} else {
					titleX = opts.position === &#x27;left&#x27; ? left + offset : right - offset;
					titleY = top + ((bottom - top) / 2);
					maxWidth = bottom - top;
					rotation = Math.PI * (opts.position === &#x27;left&#x27; ? -0.5 : 0.5);
				}

				ctx.save();
				ctx.translate(titleX, titleY);
				ctx.rotate(rotation);
				ctx.textAlign = &#x27;center&#x27;;
				ctx.textBaseline = &#x27;middle&#x27;;

				var text = opts.text;
				if (helpers.isArray(text)) {
					var y = 0;
					for (var i = 0; i &lt; text.length; ++i) {
						ctx.fillText(text[i], 0, y, maxWidth);
						y += lineHeight;
					}
				} else {
					ctx.fillText(text, 0, 0, maxWidth);
				}

				ctx.restore();
			}
		}
	});

	function createNewTitleBlockAndAttach(chart, titleOpts) {
		var title = new Title({
			ctx: chart.ctx,
			options: titleOpts,
			chart: chart
		});

		layouts.configure(chart, title, titleOpts);
		layouts.addBox(chart, title);
		chart.titleBlock = title;
	}

	module.exports = {
		id: &#x27;title&#x27;,

		/**
		 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
		 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
		 * the plugin, which one will be re-exposed in the chart.js file.
		 * https://github.com/chartjs/Chart.js/pull/2640
		 * @private
		 */
		_element: Title,

		beforeInit: function(chart) {
			var titleOpts = chart.options.title;

			if (titleOpts) {
				createNewTitleBlockAndAttach(chart, titleOpts);
			}
		},

		beforeUpdate: function(chart) {
			var titleOpts = chart.options.title;
			var titleBlock = chart.titleBlock;

			if (titleOpts) {
				helpers.mergeIf(titleOpts, defaults.global.title);

				if (titleBlock) {
					layouts.configure(chart, titleBlock, titleOpts);
					titleBlock.options = titleOpts;
				} else {
					createNewTitleBlockAndAttach(chart, titleOpts);
				}
			} else if (titleBlock) {
				layouts.removeBox(chart, titleBlock);
				delete chart.titleBlock;
			}
		}
	};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(216);

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ($(&#x27;.circular-progressbar&#x27;).length) {
	        enableCircularProgressbars();
	        // Check If Knob Is In Viewport
	        $(window).bind(&#x27;scroll load resize&#x27;, function () {
	            enableCircularProgressbars();
	        });
	    }
	});


	// Enable Circular Progressbars
	function enableCircularProgressbars() {

	    // Initialize Circular Progressbars
	    initCircularProgressbars();

	    $(&#x27;.circular-progressbar&#x27;).each(function () {
	        /* Knob Elements */
	        var knob = $(this).find(&#x27;.circular-progressbar-inner input&#x27;);
	        var knob_percent = knob.parents(&#x27;.circular-progressbar-inner&#x27;).find(&#x27;span.knob-percent&#x27;);

	        /* Knob Variables */
	        var value = knob.data(&#x27;value&#x27;);
	        var knob_val = knob.data(&#x27;value&#x27;);
	        var knob_animated = knob.hasClass(&#x27;knob-animated&#x27;);

	        // Animate Knob If In Viewport
	        if (isElementInViewport(knob) &amp;&amp; !knob_animated) {

	            knob.addClass(&#x27;knob-animated&#x27;);
	            $({startVal: 0}).animate({startVal: knob_val},
	                {
	                    duration: 1000,
	                    easing: &#x27;swing&#x27;,
	                    step: function () {
	                        knob.val(Math.ceil(this.startVal)).trigger(&#x27;change&#x27;);
	                        knob_percent.html(Math.ceil(this.startVal) + &#x27;&lt;span&gt;%&lt;/span&gt;&#x27;);
	                    }
	                }
	            );

	        }

	    });
	}

	// init Circular ProgressBars
	function initCircularProgressbars() {
	    $(&#x27;.circular-progressbar&gt;input&#x27;).each(function () {
	        var knob = $(this);
	        knob.wrap(&#x27;&lt;div class=&quot;circular-progressbar-inner&quot;&gt;&lt;/div&gt;&#x27;);
	        knob.parent().append(&#x27;&lt;span class=&quot;knob-percent&quot;&gt;&lt;/span&gt;&#x27;);

	        // Set the value
	        var value = $(this).val();
	        $(this).data(&#x27;value&#x27;, value);

	        var size = 120;
	        if ($(this).data(&#x27;size&#x27;)) {
	            size = $(this).data(&#x27;size&#x27;);
	        }
	        // Initialize Knob
	        $(this).knob({
	            min: 0,
	            max: 100,
	            width: size,
	            height: size,
	            readOnly: true,
	            displayInput: false
	        });

	        // Set The Start Value to 0
	        $(this).val(0).trigger(&#x27;change&#x27;);

	    });
	}


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(e){if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else{e(jQuery)}})(function(e){&quot;use strict&quot;;var t={},n=Math.max,r=Math.min;t.c={};t.c.d=e(document);t.c.t=function(e){return e.originalEvent.touches.length-1};t.o=function(){var n=this;this.o=null;this.$=null;this.i=null;this.g=null;this.v=null;this.cv=null;this.x=0;this.y=0;this.w=0;this.h=0;this.$c=null;this.c=null;this.t=0;this.isInit=false;this.fgColor=null;this.pColor=null;this.dH=null;this.cH=null;this.eH=null;this.rH=null;this.scale=1;this.relative=false;this.relativeWidth=false;this.relativeHeight=false;this.$div=null;this.run=function(){var t=function(e,t){var r;for(r in t){n.o[r]=t[r]}n._carve().init();n._configure()._draw()};if(this.$.data(&quot;kontroled&quot;))return;this.$.data(&quot;kontroled&quot;,true);this.extend();this.o=e.extend({min:this.$.data(&quot;min&quot;)!==undefined?this.$.data(&quot;min&quot;):0,max:this.$.data(&quot;max&quot;)!==undefined?this.$.data(&quot;max&quot;):100,stopper:true,readOnly:this.$.data(&quot;readonly&quot;)||this.$.attr(&quot;readonly&quot;)===&quot;readonly&quot;,cursor:this.$.data(&quot;cursor&quot;)===true&amp;&amp;30||this.$.data(&quot;cursor&quot;)||0,thickness:this.$.data(&quot;thickness&quot;)&amp;&amp;Math.max(Math.min(this.$.data(&quot;thickness&quot;),1),.01)||.35,lineCap:this.$.data(&quot;linecap&quot;)||&quot;butt&quot;,width:this.$.data(&quot;width&quot;)||200,height:this.$.data(&quot;height&quot;)||200,displayInput:this.$.data(&quot;displayinput&quot;)==null||this.$.data(&quot;displayinput&quot;),displayPrevious:this.$.data(&quot;displayprevious&quot;),fgColor:this.$.data(&quot;fgcolor&quot;)||&quot;#87CEEB&quot;,inputColor:this.$.data(&quot;inputcolor&quot;),font:this.$.data(&quot;font&quot;)||&quot;Arial&quot;,fontWeight:this.$.data(&quot;font-weight&quot;)||&quot;bold&quot;,inline:false,step:this.$.data(&quot;step&quot;)||1,rotation:this.$.data(&quot;rotation&quot;),draw:null,change:null,cancel:null,release:null,format:function(e){return e},parse:function(e){return parseFloat(e)}},this.o);this.o.flip=this.o.rotation===&quot;anticlockwise&quot;||this.o.rotation===&quot;acw&quot;;if(!this.o.inputColor){this.o.inputColor=this.o.fgColor}if(this.$.is(&quot;fieldset&quot;)){this.v={};this.i=this.$.find(&quot;input&quot;);this.i.each(function(t){var r=e(this);n.i[t]=r;n.v[t]=n.o.parse(r.val());r.bind(&quot;change blur&quot;,function(){var e={};e[t]=r.val();n.val(n._validate(e))})});this.$.find(&quot;legend&quot;).remove()}else{this.i=this.$;this.v=this.o.parse(this.$.val());this.v===&quot;&quot;&amp;&amp;(this.v=this.o.min);this.$.bind(&quot;change blur&quot;,function(){n.val(n._validate(n.o.parse(n.$.val())))})}!this.o.displayInput&amp;&amp;this.$.hide();this.$c=e(document.createElement(&quot;canvas&quot;)).attr({width:this.o.width,height:this.o.height});this.$div=e(&#x27;&lt;div style=&quot;&#x27;+(this.o.inline?&quot;display:inline;&quot;:&quot;&quot;)+&quot;width:&quot;+this.o.width+&quot;px;height:&quot;+this.o.height+&quot;px;&quot;+&#x27;&quot;&gt;&lt;/div&gt;&#x27;);this.$.wrap(this.$div).before(this.$c);this.$div=this.$.parent();if(typeof G_vmlCanvasManager!==&quot;undefined&quot;){G_vmlCanvasManager.initElement(this.$c[0])}this.c=this.$c[0].getContext?this.$c[0].getContext(&quot;2d&quot;):null;if(!this.c){throw{name:&quot;CanvasNotSupportedException&quot;,message:&quot;Canvas not supported. Please use excanvas on IE8.0.&quot;,toString:function(){return this.name+&quot;: &quot;+this.message}}}this.scale=(window.devicePixelRatio||1)/(this.c.webkitBackingStorePixelRatio||this.c.mozBackingStorePixelRatio||this.c.msBackingStorePixelRatio||this.c.oBackingStorePixelRatio||this.c.backingStorePixelRatio||1);this.relativeWidth=this.o.width%1!==0&amp;&amp;this.o.width.indexOf(&quot;%&quot;);this.relativeHeight=this.o.height%1!==0&amp;&amp;this.o.height.indexOf(&quot;%&quot;);this.relative=this.relativeWidth||this.relativeHeight;this._carve();if(this.v instanceof Object){this.cv={};this.copy(this.v,this.cv)}else{this.cv=this.v}this.$.bind(&quot;configure&quot;,t).parent().bind(&quot;configure&quot;,t);this._listen()._configure()._xy().init();this.isInit=true;this.$.val(this.o.format(this.v));this._draw();return this};this._carve=function(){if(this.relative){var e=this.relativeWidth?this.$div.parent().width()*parseInt(this.o.width)/100:this.$div.parent().width(),t=this.relativeHeight?this.$div.parent().height()*parseInt(this.o.height)/100:this.$div.parent().height();this.w=this.h=Math.min(e,t)}else{this.w=this.o.width;this.h=this.o.height}this.$div.css({width:this.w+&quot;px&quot;,height:this.h+&quot;px&quot;});this.$c.attr({width:this.w,height:this.h});if(this.scale!==1){this.$c[0].width=this.$c[0].width*this.scale;this.$c[0].height=this.$c[0].height*this.scale;this.$c.width(this.w);this.$c.height(this.h)}return this};this._draw=function(){var e=true;n.g=n.c;n.clear();n.dH&amp;&amp;(e=n.dH());e!==false&amp;&amp;n.draw()};this._touch=function(e){var r=function(e){var t=n.xy2val(e.originalEvent.touches[n.t].pageX,e.originalEvent.touches[n.t].pageY);if(t==n.cv)return;if(n.cH&amp;&amp;n.cH(t)===false)return;n.change(n._validate(t));n._draw()};this.t=t.c.t(e);r(e);t.c.d.bind(&quot;touchmove.k&quot;,r).bind(&quot;touchend.k&quot;,function(){t.c.d.unbind(&quot;touchmove.k touchend.k&quot;);n.val(n.cv)});return this};this._mouse=function(e){var r=function(e){var t=n.xy2val(e.pageX,e.pageY);if(t==n.cv)return;if(n.cH&amp;&amp;n.cH(t)===false)return;n.change(n._validate(t));n._draw()};r(e);t.c.d.bind(&quot;mousemove.k&quot;,r).bind(&quot;keyup.k&quot;,function(e){if(e.keyCode===27){t.c.d.unbind(&quot;mouseup.k mousemove.k keyup.k&quot;);if(n.eH&amp;&amp;n.eH()===false)return;n.cancel()}}).bind(&quot;mouseup.k&quot;,function(e){t.c.d.unbind(&quot;mousemove.k mouseup.k keyup.k&quot;);n.val(n.cv)});return this};this._xy=function(){var e=this.$c.offset();this.x=e.left;this.y=e.top;return this};this._listen=function(){if(!this.o.readOnly){this.$c.bind(&quot;mousedown&quot;,function(e){e.preventDefault();n._xy()._mouse(e)}).bind(&quot;touchstart&quot;,function(e){e.preventDefault();n._xy()._touch(e)});this.listen()}else{this.$.attr(&quot;readonly&quot;,&quot;readonly&quot;)}if(this.relative){e(window).resize(function(){n._carve().init();n._draw()})}return this};this._configure=function(){if(this.o.draw)this.dH=this.o.draw;if(this.o.change)this.cH=this.o.change;if(this.o.cancel)this.eH=this.o.cancel;if(this.o.release)this.rH=this.o.release;if(this.o.displayPrevious){this.pColor=this.h2rgba(this.o.fgColor,&quot;0.4&quot;);this.fgColor=this.h2rgba(this.o.fgColor,&quot;0.6&quot;)}else{this.fgColor=this.o.fgColor}return this};this._clear=function(){this.$c[0].width=this.$c[0].width};this._validate=function(e){var t=~~((e&lt;0?-.5:.5)+e/this.o.step)*this.o.step;return Math.round(t*100)/100};this.listen=function(){};this.extend=function(){};this.init=function(){};this.change=function(e){};this.val=function(e){};this.xy2val=function(e,t){};this.draw=function(){};this.clear=function(){this._clear()};this.h2rgba=function(e,t){var n;e=e.substring(1,7);n=[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)];return&quot;rgba(&quot;+n[0]+&quot;,&quot;+n[1]+&quot;,&quot;+n[2]+&quot;,&quot;+t+&quot;)&quot;};this.copy=function(e,t){for(var n in e){t[n]=e[n]}}};t.Dial=function(){t.o.call(this);this.startAngle=null;this.xy=null;this.radius=null;this.lineWidth=null;this.cursorExt=null;this.w2=null;this.PI2=2*Math.PI;this.extend=function(){this.o=e.extend({bgColor:this.$.data(&quot;bgcolor&quot;)||&quot;#EEEEEE&quot;,angleOffset:this.$.data(&quot;angleoffset&quot;)||0,angleArc:this.$.data(&quot;anglearc&quot;)||360,inline:true},this.o)};this.val=function(e,t){if(null!=e){e=this.o.parse(e);if(t!==false&amp;&amp;e!=this.v&amp;&amp;this.rH&amp;&amp;this.rH(e)===false){return}this.cv=this.o.stopper?n(r(e,this.o.max),this.o.min):e;this.v=this.cv;this.$.val(this.o.format(this.v));this._draw()}else{return this.v}};this.xy2val=function(e,t){var i,s;i=Math.atan2(e-(this.x+this.w2),-(t-this.y-this.w2))-this.angleOffset;if(this.o.flip){i=this.angleArc-i-this.PI2}if(this.angleArc!=this.PI2&amp;&amp;i&lt;0&amp;&amp;i&gt;-.5){i=0}else if(i&lt;0){i+=this.PI2}s=i*(this.o.max-this.o.min)/this.angleArc+this.o.min;this.o.stopper&amp;&amp;(s=n(r(s,this.o.max),this.o.min));return s};this.listen=function(){var t=this,i,s,o=function(e){e.preventDefault();var o=e.originalEvent,u=o.detail||o.wheelDeltaX,a=o.detail||o.wheelDeltaY,f=t._validate(t.o.parse(t.$.val()))+(u&gt;0||a&gt;0?t.o.step:u&lt;0||a&lt;0?-t.o.step:0);f=n(r(f,t.o.max),t.o.min);t.val(f,false);if(t.rH){clearTimeout(i);i=setTimeout(function(){t.rH(f);i=null},100);if(!s){s=setTimeout(function(){if(i)t.rH(f);s=null},200)}}},u,a,f=1,l={37:-t.o.step,38:t.o.step,39:t.o.step,40:-t.o.step};this.$.bind(&quot;keydown&quot;,function(i){var s=i.keyCode;if(s&gt;=96&amp;&amp;s&lt;=105){s=i.keyCode=s-48}u=parseInt(String.fromCharCode(s));if(isNaN(u)){s!==13&amp;&amp;s!==8&amp;&amp;s!==9&amp;&amp;s!==189&amp;&amp;(s!==190||t.$.val().match(/\./))&amp;&amp;i.preventDefault();if(e.inArray(s,[37,38,39,40])&gt;-1){i.preventDefault();var o=t.o.parse(t.$.val())+l[s]*f;t.o.stopper&amp;&amp;(o=n(r(o,t.o.max),t.o.min));t.change(t._validate(o));t._draw();a=window.setTimeout(function(){f*=2},30)}}}).bind(&quot;keyup&quot;,function(e){if(isNaN(u)){if(a){window.clearTimeout(a);a=null;f=1;t.val(t.$.val())}}else{t.$.val()&gt;t.o.max&amp;&amp;t.$.val(t.o.max)||t.$.val()&lt;t.o.min&amp;&amp;t.$.val(t.o.min)}});this.$c.bind(&quot;mousewheel DOMMouseScroll&quot;,o);this.$.bind(&quot;mousewheel DOMMouseScroll&quot;,o)};this.init=function(){if(this.v&lt;this.o.min||this.v&gt;this.o.max){this.v=this.o.min}this.$.val(this.v);this.w2=this.w/2;this.cursorExt=this.o.cursor/100;this.xy=this.w2*this.scale;this.lineWidth=this.xy*this.o.thickness;this.lineCap=this.o.lineCap;this.radius=this.xy-this.lineWidth/2;this.o.angleOffset&amp;&amp;(this.o.angleOffset=isNaN(this.o.angleOffset)?0:this.o.angleOffset);this.o.angleArc&amp;&amp;(this.o.angleArc=isNaN(this.o.angleArc)?this.PI2:this.o.angleArc);this.angleOffset=this.o.angleOffset*Math.PI/180;this.angleArc=this.o.angleArc*Math.PI/180;this.startAngle=1.5*Math.PI+this.angleOffset;this.endAngle=1.5*Math.PI+this.angleOffset+this.angleArc;var e=n(String(Math.abs(this.o.max)).length,String(Math.abs(this.o.min)).length,2)+2;this.o.displayInput&amp;&amp;this.i.css({width:(this.w/2+4&gt;&gt;0)+&quot;px&quot;,height:(this.w/3&gt;&gt;0)+&quot;px&quot;,position:&quot;absolute&quot;,&quot;vertical-align&quot;:&quot;middle&quot;,&quot;margin-top&quot;:(this.w/3&gt;&gt;0)+&quot;px&quot;,&quot;margin-left&quot;:&quot;-&quot;+(this.w*3/4+2&gt;&gt;0)+&quot;px&quot;,border:0,background:&quot;none&quot;,font:this.o.fontWeight+&quot; &quot;+(this.w/e&gt;&gt;0)+&quot;px &quot;+this.o.font,&quot;text-align&quot;:&quot;center&quot;,color:this.o.inputColor||this.o.fgColor,padding:&quot;0px&quot;,&quot;-webkit-appearance&quot;:&quot;none&quot;})||this.i.css({width:&quot;0px&quot;,visibility:&quot;hidden&quot;})};this.change=function(e){this.cv=e;this.$.val(this.o.format(e))};this.angle=function(e){return(e-this.o.min)*this.angleArc/(this.o.max-this.o.min)};this.arc=function(e){var t,n;e=this.angle(e);if(this.o.flip){t=this.endAngle+1e-5;n=t-e-1e-5}else{t=this.startAngle-1e-5;n=t+e+1e-5}this.o.cursor&amp;&amp;(t=n-this.cursorExt)&amp;&amp;(n=n+this.cursorExt);return{s:t,e:n,d:this.o.flip&amp;&amp;!this.o.cursor}};this.draw=function(){var e=this.g,t=this.arc(this.cv),n,r=1;e.lineWidth=this.lineWidth;e.lineCap=this.lineCap;if(this.o.bgColor!==&quot;none&quot;){e.beginPath();e.strokeStyle=this.o.bgColor;e.arc(this.xy,this.xy,this.radius,this.endAngle-1e-5,this.startAngle+1e-5,true);e.stroke()}if(this.o.displayPrevious){n=this.arc(this.v);e.beginPath();e.strokeStyle=this.pColor;e.arc(this.xy,this.xy,this.radius,n.s,n.e,n.d);e.stroke();r=this.cv==this.v}e.beginPath();e.strokeStyle=r?this.o.fgColor:this.fgColor;e.arc(this.xy,this.xy,this.radius,t.s,t.e,t.d);e.stroke()};this.cancel=function(){this.val(this.v)}};e.fn.dial=e.fn.knob=function(n){return this.each(function(){var r=new t.Dial;r.o=n;r.$=e(this);r.run()}).parent()}})

/***/ }),
/* 217 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ($(&#x27;.g-map&#x27;).length) {
	        $(&#x27;.g-map&#x27;).each(function (index, element) {
	            var map_selector = $(this).data(&#x27;id&#x27;),
	                mapAddress = $(this).data(&#x27;address&#x27;),
	                mapType = $(this).data(&#x27;maptype&#x27;),
	                zoomLvl = $(this).data(&#x27;zoomlvl&#x27;),
	                mapPin = $(this).data(&#x27;mapPin&#x27;);
	            
	            $(this).attr(&#x27;id&#x27;, map_selector);
	            mapRender(map_selector, mapAddress, mapType, zoomLvl,mapPin);
	        });
	    }
	    function mapRender(selector, address, type, zoom_lvl,mapPin) {
	        // Specify features and elements to define styles.
	        var styleArray = [{
	            featureType: &quot;all&quot;,
	            stylers: [{
	                saturation: -80
	            }]
	        }, {
	            featureType: &quot;road.arterial&quot;,
	            elementType: &quot;geometry&quot;,
	            stylers: [{
	                hue: &quot;#00ffee&quot;
	            }, {
	                saturation: 50
	            }]
	        }, {
	            featureType: &quot;poi.business&quot;,
	            elementType: &quot;labels&quot;,
	            stylers: [{
	                visibility: &quot;off&quot;
	            }]
	        }];
	        var map = new google.maps.Map(document.getElementById(selector), {
	            mapTypeId:type,
	            styles: styleArray,
	            scrollwheel: false,
	            draggable: false,
	            zoom: zoom_lvl,
	            mapTypeControl: false,
	        });

	        var map_pin = &quot;assets/img/basic/pin.png&quot;;

	        if(mapPin){
	            map_pin = mapPin;
	        }

	        var geocoder = new google.maps.Geocoder();
	        geocoder.geocode({
	                &#x27;address&#x27;: address
	            },
	            function (results, status) {
	                if (status === google.maps.GeocoderStatus.OK) {
	                    new google.maps.Marker({
	                        position: results[0].geometry.location,
	                        map: map,
	                        icon: map_pin
	                    });
	                    map.setCenter(results[0].geometry.location);
	                }
	            });
	    }
	});

/***/ }),
/* 218 */
/***/ (function(module, exports) {

	(function () {
	    &#x27;use strict&#x27;;
	    $(&quot;body&quot;).on(&quot;click&quot;, &quot;.closePromotions&quot;, function (e) {
	        e.preventDefault();
	        var $this = $(this);
	        $this.parent().slideUp();
	    });
	}());

/***/ }),
/* 219 */
/***/ (function(module, exports) {

	jQuery(document).ready(function ($) {
	    //set animation timing
	    var animationDelay = 2500,
	        //loading bar effect
	        barAnimationDelay = 3800,
	        barWaiting = barAnimationDelay - 3000, //3000 is the duration of the transition on the loading bar - set in the scss/css file
	        //letters effect
	        lettersDelay = 50,
	        //type effect
	        typeLettersDelay = 150,
	        selectionDuration = 500,
	        typeAnimationDelay = selectionDuration + 800,
	        //clip effect 
	        revealDuration = 600,
	        revealAnimationDelay = 1500;

	    initHeadline();


	    function initHeadline() {
	        //insert &lt;i&gt; element for each letter of a changing word
	        singleLetters($(&#x27;.cd-headline.letters&#x27;).find(&#x27;b&#x27;));
	        //initialise headline animation
	        animateHeadline($(&#x27;.cd-headline&#x27;));
	    }

	    function singleLetters($words) {
	        $words.each(function () {
	            var word = $(this),
	                letters = word.text().split(&#x27;&#x27;),
	                selected = word.hasClass(&#x27;is-visible&#x27;);
	            for (i in letters) {
	                if (word.parents(&#x27;.rotate-2&#x27;).length &gt; 0) letters[i] = &#x27;&lt;em&gt;&#x27; + letters[i] + &#x27;&lt;/em&gt;&#x27;;
	                letters[i] = (selected) ? &#x27;&lt;i class=&quot;in&quot;&gt;&#x27; + letters[i] + &#x27;&lt;/i&gt;&#x27; : &#x27;&lt;i&gt;&#x27; + letters[i] + &#x27;&lt;/i&gt;&#x27;;
	            }
	            var newLetters = letters.join(&#x27;&#x27;);
	            word.html(newLetters).css(&#x27;opacity&#x27;, 1);
	        });
	    }

	    function animateHeadline($headlines) {
	        var duration = animationDelay;
	        $headlines.each(function () {
	            var headline = $(this);

	            if (headline.hasClass(&#x27;loading-bar&#x27;)) {
	                duration = barAnimationDelay;
	                setTimeout(function () {
	                    headline.find(&#x27;.cd-words-wrapper&#x27;).addClass(&#x27;is-loading&#x27;)
	                }, barWaiting);
	            } else if (headline.hasClass(&#x27;clip&#x27;)) {
	                var spanWrapper = headline.find(&#x27;.cd-words-wrapper&#x27;),
	                    newWidth = spanWrapper.width() + 10;
	                spanWrapper.css(&#x27;width&#x27;, newWidth);
	            } else if (!headline.hasClass(&#x27;type&#x27;)) {
	                //assign to .cd-words-wrapper the width of its longest word
	                var words = headline.find(&#x27;.cd-words-wrapper b&#x27;),
	                    width = 0;
	                words.each(function () {
	                    var wordWidth = $(this).width();
	                    if (wordWidth &gt; width) width = wordWidth;
	                });
	                headline.find(&#x27;.cd-words-wrapper&#x27;).css(&#x27;width&#x27;, width);
	            }
	            //trigger animation
	            setTimeout(function () {
	                hideWord(headline.find(&#x27;.is-visible&#x27;).eq(0))
	            }, duration);
	        });
	    }

	    function hideWord($word) {
	        var nextWord = takeNext($word);

	        if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;type&#x27;)) {
	            var parentSpan = $word.parent(&#x27;.cd-words-wrapper&#x27;);
	            parentSpan.addClass(&#x27;selected&#x27;).removeClass(&#x27;waiting&#x27;);
	            setTimeout(function () {
	                parentSpan.removeClass(&#x27;selected&#x27;);
	                $word.removeClass(&#x27;is-visible&#x27;).addClass(&#x27;is-hidden&#x27;).children(&#x27;i&#x27;).removeClass(&#x27;in&#x27;).addClass(&#x27;out&#x27;);
	            }, selectionDuration);
	            setTimeout(function () {
	                showWord(nextWord, typeLettersDelay)
	            }, typeAnimationDelay);

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;letters&#x27;)) {
	            var bool = ($word.children(&#x27;i&#x27;).length &gt;= nextWord.children(&#x27;i&#x27;).length) ? true : false;
	            hideLetter($word.find(&#x27;i&#x27;).eq(0), $word, bool, lettersDelay);
	            showLetter(nextWord.find(&#x27;i&#x27;).eq(0), nextWord, bool, lettersDelay);

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;clip&#x27;)) {
	            $word.parents(&#x27;.cd-words-wrapper&#x27;).animate({width: &#x27;2px&#x27;}, revealDuration, function () {
	                switchWord($word, nextWord);
	                showWord(nextWord);
	            });

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;loading-bar&#x27;)) {
	            $word.parents(&#x27;.cd-words-wrapper&#x27;).removeClass(&#x27;is-loading&#x27;);
	            switchWord($word, nextWord);
	            setTimeout(function () {
	                hideWord(nextWord)
	            }, barAnimationDelay);
	            setTimeout(function () {
	                $word.parents(&#x27;.cd-words-wrapper&#x27;).addClass(&#x27;is-loading&#x27;)
	            }, barWaiting);

	        } else {
	            switchWord($word, nextWord);
	            setTimeout(function () {
	                hideWord(nextWord)
	            }, animationDelay);
	        }
	    }

	    function showWord($word, $duration) {
	        if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;type&#x27;)) {
	            showLetter($word.find(&#x27;i&#x27;).eq(0), $word, false, $duration);
	            $word.addClass(&#x27;is-visible&#x27;).removeClass(&#x27;is-hidden&#x27;);

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;clip&#x27;)) {
	            $word.parents(&#x27;.cd-words-wrapper&#x27;).animate({&#x27;width&#x27;: $word.width() + 10}, revealDuration, function () {
	                setTimeout(function () {
	                    hideWord($word)
	                }, revealAnimationDelay);
	            });
	        }
	    }

	    function hideLetter($letter, $word, $bool, $duration) {
	        $letter.removeClass(&#x27;in&#x27;).addClass(&#x27;out&#x27;);

	        if (!$letter.is(&#x27;:last-child&#x27;)) {
	            setTimeout(function () {
	                hideLetter($letter.next(), $word, $bool, $duration);
	            }, $duration);
	        } else if ($bool) {
	            setTimeout(function () {
	                hideWord(takeNext($word))
	            }, animationDelay);
	        }

	        if ($letter.is(&#x27;:last-child&#x27;) &amp;&amp; $(&#x27;html&#x27;).hasClass(&#x27;no-csstransitions&#x27;)) {
	            var nextWord = takeNext($word);
	            switchWord($word, nextWord);
	        }
	    }

	    function showLetter($letter, $word, $bool, $duration) {
	        $letter.addClass(&#x27;in&#x27;).removeClass(&#x27;out&#x27;);

	        if (!$letter.is(&#x27;:last-child&#x27;)) {
	            setTimeout(function () {
	                showLetter($letter.next(), $word, $bool, $duration);
	            }, $duration);
	        } else {
	            if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;type&#x27;)) {
	                setTimeout(function () {
	                    $word.parents(&#x27;.cd-words-wrapper&#x27;).addClass(&#x27;waiting&#x27;);
	                }, 200);
	            }
	            if (!$bool) {
	                setTimeout(function () {
	                    hideWord($word)
	                }, animationDelay)
	            }
	        }
	    }

	    function takeNext($word) {
	        return (!$word.is(&#x27;:last-child&#x27;)) ? $word.next() : $word.parent().children().eq(0);
	    }

	    function takePrev($word) {
	        return (!$word.is(&#x27;:first-child&#x27;)) ? $word.prev() : $word.parent().children().last();
	    }

	    function switchWord($oldWord, $newWord) {
	        $oldWord.removeClass(&#x27;is-visible&#x27;).addClass(&#x27;is-hidden&#x27;);
	        $newWord.removeClass(&#x27;is-hidden&#x27;).addClass(&#x27;is-visible&#x27;);
	    }
	});

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(221);

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    var xv_ww = $(window).width(),
	        xv_slideshow = true;

	    menuInit();

	    // Check If Counter In Viewport
	    $(window).on(&#x27;load resize&#x27;, function () {
	        menuInit();
	    });

	    function menuInit() {
	        xv_ww = $(window).width();
	        if ($(&#x27;.nav-offcanvas&#x27;).length) {
	            $(&#x27;.paper-nav-toggle&#x27;).removeClass(&#x27;dl-trigger&#x27;);
	        }

	        if (($(&#x27;.nav-offcanvas&#x27;).length &amp;&amp; xv_ww &lt;= 1030) || $(&#x27;.nav-offcanvas-desktop&#x27;).length) {
	            $(&#x27;body&#x27;).addClass(&#x27;sidebar-collapse&#x27;);
	            $(&#x27;.dl-menu&#x27;).addClass(&quot;dl-menuopen&quot;);
	            $(&#x27;.paper-nav-toggle&#x27;).removeClass(&#x27;dl-trigger&#x27;);
	            $(&#x27;.nav-offcanvas .paper_menu&#x27;).addClass(&#x27;main-sidebar shadow1 fixed offcanvas&#x27;);
	        } else {
	            $(&#x27;.nav-offcanvas .paper_menu&#x27;).removeClass(&#x27;main-sidebar shadow1 fixed offcanvas&#x27;);
	        }


	        if (xv_ww &lt;= 1030 || $(&#x27;.mini-nav&#x27;).length) {
	            $(&#x27;.responsive-menu&#x27;).removeClass(&#x27;xv-menuwrapper&#x27;).addClass(&#x27;dl-menuwrapper&#x27;);
	            $(&#x27;.user-avatar&#x27;).removeClass(&#x27;pull-right&#x27;);
	            $(&#x27;.lg-submenu&#x27;).addClass(&quot;dl-submenu&quot;);
	        } else {
	            $(&#x27;.responsive-menu&#x27;).removeClass(&#x27;dl-menuwrapper&#x27;).addClass(&#x27;xv-menuwrapper&#x27;);
	            $(&#x27;.lg-submenu&#x27;).removeClass(&quot;dl-submenu&quot;);
	            $(&#x27;.user-avatar&#x27;).addClass(&#x27;pull-right&#x27;);
	        }
	    }
	    $(&#x27;#dl-menu&#x27;).dlmenu({
	        animationClasses: {
	            classin: &#x27;dl-animate-in-2&#x27;,
	            classout: &#x27;dl-animate-out-2&#x27;
	        }
	    });
	});

/***/ }),
/* 221 */
/***/ (function(module, exports) {

	/**
	 * jquery.dlmenu.js v1.0.1
	 * http://www.codrops.com
	 */
	;(function ($, window, undefined) {

	    &#x27;use strict&#x27;;

	    // global
	    var Modernizr = window.Modernizr, $body = $(&#x27;body&#x27;);

	    $.DLMenu = function (options, element) {
	        this.$el = $(element);
	        this._init(options);
	    };

	    // the options
	    $.DLMenu.defaults = {
	        // classes for the animation effects
	        animationClasses: {classin: &#x27;dl-animate-in-1&#x27;, classout: &#x27;dl-animate-out-1&#x27;},
	        // callback: click a link that has a sub menu
	        // el is the link element (li); name is the level name
	        onLevelClick: function (el, name) {
	            return false;
	        },
	        // callback: click a link that does not have a sub menu
	        // el is the link element (li); ev is the event obj
	        onLinkClick: function (el, ev) {
	            return false;
	        }
	    };

	    $.DLMenu.prototype = {
	        _init: function (options) {

	            // options
	            this.options = $.extend(true, {}, $.DLMenu.defaults, options);
	            // cache some elements and initialize some variables
	            this._config();

	            var animEndEventNames = {
	                    &#x27;WebkitAnimation&#x27;: &#x27;webkitAnimationEnd&#x27;,
	                    &#x27;OAnimation&#x27;: &#x27;oAnimationEnd&#x27;,
	                    &#x27;msAnimation&#x27;: &#x27;MSAnimationEnd&#x27;,
	                    &#x27;animation&#x27;: &#x27;animationend&#x27;
	                },
	                transEndEventNames = {
	                    &#x27;WebkitTransition&#x27;: &#x27;webkitTransitionEnd&#x27;,
	                    &#x27;MozTransition&#x27;: &#x27;transitionend&#x27;,
	                    &#x27;OTransition&#x27;: &#x27;oTransitionEnd&#x27;,
	                    &#x27;msTransition&#x27;: &#x27;MSTransitionEnd&#x27;,
	                    &#x27;transition&#x27;: &#x27;transitionend&#x27;
	                };
	            // animation end event name
	            this.animEndEventName = animEndEventNames[Modernizr.prefixed(&#x27;animation&#x27;)] + &#x27;.dlmenu&#x27;;
	            // transition end event name
	            this.transEndEventName = transEndEventNames[Modernizr.prefixed(&#x27;transition&#x27;)] + &#x27;.dlmenu&#x27;,
	                // support for css animations and css transitions
	                this.supportAnimations = Modernizr.cssanimations,
	                this.supportTransitions = Modernizr.csstransitions;

	            this._initEvents();

	        },
	        _config: function () {
	            this.open = false;
	            this.$trigger = $(&#x27;.dl-trigger&#x27;);
	            this.$menu = this.$el.children(&#x27;ul.dl-menu&#x27;);
	            this.$menuitems = this.$menu.find(&#x27;li:not(.dl-back)&#x27;);
	            this.$el.find(&#x27;ul.dl-submenu,ul.lg-submenu&#x27;).prepend(&#x27;&lt;li class=&quot;dl-back&quot;&gt;&lt;a href=&quot;#&quot;&gt;back&lt;/a&gt;&lt;/li&gt;&#x27;);
	            this.$back = this.$menu.find(&#x27;li.dl-back&#x27;);
	        },
	        _initEvents: function () {

	            var self = this;

	            this.$trigger.on(&#x27;click.dlmenu&#x27;, function () {

	                if (self.open) {
	                    self._closeMenu();
	                }
	                else {
	                    self._openMenu();
	                }
	                return false;

	            });

	            this.$menuitems.on(&#x27;click.dlmenu&#x27;, function (event) {

	                if (!$(this).find(&#x27;a&#x27;).slice(0, 1).data(&#x27;toggle&#x27;)) {

	                    event.stopPropagation();
	                }

	                var $item = $(this),
	                    $submenu = $item.children(&#x27;ul.dl-submenu&#x27;);

	                if ($submenu.length &gt; 0) {

	                    var $flyin = $submenu.clone().css(&#x27;opacity&#x27;, 0).insertAfter(self.$menu),
	                        onAnimationEndFn = function () {
	                            self.$menu.off(self.animEndEventName).removeClass(self.options.animationClasses.classout).addClass(&#x27;dl-subview&#x27;);
	                            $item.addClass(&#x27;dl-subviewopen&#x27;).parents(&#x27;.dl-subviewopen:first&#x27;).removeClass(&#x27;dl-subviewopen&#x27;).addClass(&#x27;dl-subview&#x27;);
	                            $flyin.remove();
	                        };

	                    setTimeout(function () {
	                        $flyin.addClass(self.options.animationClasses.classin);
	                        self.$menu.addClass(self.options.animationClasses.classout);
	                        if (self.supportAnimations) {
	                            self.$menu.on(self.animEndEventName, onAnimationEndFn);
	                        }
	                        else {
	                            onAnimationEndFn.call();
	                        }

	                        self.options.onLevelClick($item, $item.children(&#x27;a:first&#x27;).text());
	                    });

	                    return false;

	                }
	                else {
	                    self.options.onLinkClick($item, event);
	                }

	            });

	            this.$back.on(&#x27;click.dlmenu&#x27;, function (event) {

	                var $this = $(this),
	                    $submenu = $this.parents(&#x27;ul.dl-submenu:first&#x27;),
	                    $item = $submenu.parent(),

	                    $flyin = $submenu.clone().insertAfter(self.$menu);

	                var onAnimationEndFn = function () {
	                    self.$menu.off(self.animEndEventName).removeClass(self.options.animationClasses.classin);
	                    $flyin.remove();
	                };

	                setTimeout(function () {
	                    $flyin.addClass(self.options.animationClasses.classout);
	                    self.$menu.addClass(self.options.animationClasses.classin);
	                    if (self.supportAnimations) {
	                        self.$menu.on(self.animEndEventName, onAnimationEndFn);
	                    }
	                    else {
	                        onAnimationEndFn.call();
	                    }

	                    $item.removeClass(&#x27;dl-subviewopen&#x27;);

	                    var $subview = $this.parents(&#x27;.dl-subview:first&#x27;);
	                    if ($subview.is(&#x27;li&#x27;)) {
	                        $subview.addClass(&#x27;dl-subviewopen&#x27;);
	                    }
	                    $subview.removeClass(&#x27;dl-subview&#x27;);
	                });

	                return false;

	            });

	        },
	        closeMenu: function () {
	            if (this.open) {
	                this._closeMenu();

	            }
	        },
	        _closeMenu: function () {
	            var self = this,
	                onTransitionEndFn = function () {
	                    self.$menu.off(self.transEndEventName);
	                    self._resetMenu();
	                };

	            this.$menu.removeClass(&#x27;dl-menuopen&#x27;);
	            this.$menu.addClass(&#x27;dl-menu-toggle&#x27;);
	            this.$trigger.removeClass(&#x27;dl-active&#x27;);

	            if (this.supportTransitions) {
	                this.$menu.on(this.transEndEventName, onTransitionEndFn);
	            }
	            else {
	                onTransitionEndFn.call();
	            }

	            this.open = false;
	        },
	        openMenu: function () {
	            if (!this.open) {
	                this._openMenu();
	            }
	        },
	        _openMenu: function () {
	            var self = this;
	            // clicking somewhere else makes the menu close
	            $body.off(&#x27;click&#x27;).on(&#x27;click.dlmenu&#x27;, function () {
	                self._closeMenu();
	            });
	            this.$menu.addClass(&#x27;dl-menuopen dl-menu-toggle&#x27;).on(this.transEndEventName, function () {
	                $(this).removeClass(&#x27;dl-menu-toggle&#x27;);
	            });
	            this.$trigger.addClass(&#x27;dl-active&#x27;);
	            this.open = true;
	        },
	        // resets the menu to its original state (first level of options)
	        _resetMenu: function () {
	            this.$menu.removeClass(&#x27;dl-subview&#x27;);
	            this.$menuitems.removeClass(&#x27;dl-subview dl-subviewopen&#x27;);
	        }
	    };

	    var logError = function (message) {
	        if (window.console) {
	            window.console.error(message);
	        }
	    };

	    $.fn.dlmenu = function (options) {
	        if (typeof options === &#x27;string&#x27;) {
	            var args = Array.prototype.slice.call(arguments, 1);
	            this.each(function () {
	                var instance = $.data(this, &#x27;dlmenu&#x27;);
	                if (!instance) {
	                    logError(&quot;cannot call methods on dlmenu prior to initialization; &quot; +
	                        &quot;attempted to call method &#x27;&quot; + options + &quot;&#x27;&quot;);
	                    return;
	                }
	                if (!$.isFunction(instance[options]) || options.charAt(0) === &quot;_&quot;) {
	                    logError(&quot;no such method &#x27;&quot; + options + &quot;&#x27; for dlmenu instance&quot;);
	                    return;
	                }
	                instance[options].apply(instance, args);
	            });
	        }
	        else {
	            this.each(function () {
	                var instance = $.data(this, &#x27;dlmenu&#x27;);
	                if (instance) {
	                    instance._init();
	                }
	                else {
	                    instance = $.data(this, &#x27;dlmenu&#x27;, new $.DLMenu(options, this));
	                }
	            });
	        }
	        return this;
	    };

	})(jQuery, window);

/***/ }),
/* 222 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    /*=======================================
	     Hero Section
	     =======================================*/
	    if ($(&#x27;section.hero-header&#x27;).length &gt; 0) {
	        var $mainnav = $(&#x27;.mainnav&#x27;).height();
	        $(&#x27;section.hero-header&#x27;).height($(window).height());
	        // Window Resize
	        $(window).resize(function () {
	            $(&#x27;section.hero-header&#x27;).height($(window).height());
	        });
	    }
	    /*=======================================
	     Cut Section
	     =======================================*/
	    if ($(&#x27;.cut&#x27;).length &gt; 0) {
	        $(&#x27;.cut&#x27;).each(function () {
	            if ($(this).hasClass(&#x27;cut-top&#x27;))
	                $(this).css(&#x27;border-right-width&#x27;, $(this).parent().width() + &quot;px&quot;);
	            else if ($(this).hasClass(&#x27;cut-bottom&#x27;))
	                $(this).css(&#x27;border-left-width&#x27;, $(this).parent().width() + &quot;px&quot;);
	        });

	    }
	});

/***/ }),
/* 223 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    var type,
	        w3c,
	        start,
	        webkit,
	        opacity,
	        banner_overlay = &#x27;.overlay&#x27;,
	        color_start,
	        color_end,
	        orientation;


	    var overlay = $(banner_overlay);

	    overlay.each(function () {
	        var $this = $(this),
	            color_start = $this.data(&#x27;start&#x27;),
	            color_end = $this.data(&#x27;end&#x27;),
	            orientation = $this.data(&#x27;orientation&#x27;),
	            opacity = $this.data(&#x27;opacity&#x27;);

	        apply_gradient($this, color_start, color_end, orientation, opacity);

	    });


	    function apply_gradient(ele, color_start, color_end, orientation, opacity) {

	        switch (orientation) {
	            case &#x27;tobottomright&#x27;:
	                type = &quot;linear&quot;;
	                w3c = &quot;to bottom right&quot;;
	                start = &quot;top left&quot;;
	                webkit = &quot;left top, right bottom&quot;;
	                break;
	            case &#x27;tobottom&#x27;        :
	                type = &quot;linear&quot;;
	                w3c = &quot;to bottom&quot;;
	                start = &quot;top&quot;;
	                webkit = &quot;left top, left bottom&quot;;
	                break;
	            case &#x27;tobottomleft&#x27;    :
	                type = &quot;linear&quot;;
	                w3c = &quot;to bottom left&quot;;
	                start = &quot;top right&quot;;
	                webkit = &quot;right top, left bottom&quot;;
	                break;
	            case &#x27;toright&#x27;        :
	                type = &quot;linear&quot;;
	                w3c = &quot;to right&quot;;
	                start = &quot;left&quot;;
	                webkit = &quot;left top, right top&quot;;
	                break;
	            case &#x27;toleft&#x27;        :
	                type = &quot;linear&quot;;
	                w3c = &quot;to left&quot;;
	                start = &quot;right&quot;;
	                webkit = &quot;right top, left top&quot;;
	                break;
	            case &#x27;totopright&#x27;    :
	                type = &quot;linear&quot;;
	                w3c = &quot;to top right&quot;;
	                start = &quot;bottom left&quot;;
	                webkit = &quot;left bottom, right top&quot;;
	                break;
	            case &#x27;totop&#x27;        :
	                type = &quot;linear&quot;;
	                w3c = &quot;to top&quot;;
	                start = &quot;bottom&quot;;
	                webkit = &quot;left bottom, left top&quot;;
	                break;
	            case &#x27;totopleft&#x27;    :
	                type = &quot;linear&quot;;
	                w3c = &quot;to top left&quot;;
	                start = &quot;bottom right&quot;;
	                webkit = &quot;right bottom, left top&quot;;
	                break;
	            case &#x27;circulartopleft&#x27;        :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at left top&quot;;
	                start = &quot;left top, circle farthest-side&quot;;
	                webkit = &quot;left top, 0, left top, 973&quot;;
	                break;
	            case &#x27;circulartopcenter&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at center top&quot;;
	                start = &quot;center top, circle farthest-side&quot;;
	                webkit = &quot;center top, 0, center top, 487&quot;;
	                break;
	            case &#x27;circulartopright&#x27;        :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at right top&quot;;
	                start = &quot;right top, circle farthest-side&quot;;
	                webkit = &quot;right top, 0, right top, 973&quot;;
	                break;
	            case &#x27;circularmiddleleft&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at left center&quot;;
	                start = &quot;left center, circle farthest-side&quot;;
	                webkit = &quot;left center, 0, left center, 973&quot;;
	                break;
	            case &#x27;circularmiddlecenter&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at center&quot;;
	                start = &quot;center, circle farthest-side&quot;;
	                webkit = &quot;center center, 0, center center, 487&quot;;
	                break;
	            case &#x27;circularmiddleright&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at right center&quot;;
	                start = &quot;right center, circle farthest-side&quot;;
	                webkit = &quot;right center, 0, right center&quot;;
	                break;
	            case &#x27;circularbottomleft&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at left bottom&quot;;
	                start = &quot;left bottom, circle farthest-side&quot;;
	                webkit = &quot;left bottom, 0, left bottom, 973&quot;;
	                break;
	            case &#x27;circularbottomcenter&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at center bottom&quot;;
	                start = &quot;center bottom, circle farthest-side&quot;;
	                webkit = &quot;center bottom, 0, center bottom, 487&quot;;
	                break;
	            case &#x27;circularbottomright&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;circle farthest-side at right bottom&quot;;
	                start = &quot;right bottom, circle farthest-side&quot;;
	                webkit = &quot;right bottom, 0, right bottom, 973&quot;;
	                break;
	            case &#x27;ellipsetopleft&#x27;        :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at left top&quot;;
	                start = &quot;left top, ellipse farthest-side&quot;;
	                webkit = &quot;left top, 0, left top, 973&quot;;
	                break;
	            case &#x27;ellipsetopcenter&#x27;        :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at center top&quot;;
	                start = &quot;center top, ellipse farthest-side&quot;;
	                webkit = &quot;center top, 0, center top, 487&quot;;
	                break;
	            case &#x27;ellipsetopright&#x27;        :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at right top&quot;;
	                start = &quot;right top, ellipse farthest-side&quot;;
	                webkit = &quot;right top, 0, right top, 973&quot;;
	                break;
	            case &#x27;ellipsemiddleleft&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at left center&quot;;
	                start = &quot;left center, ellipse farthest-side&quot;;
	                webkit = &quot;left center, 0, left center, 973&quot;;
	                break;
	            case &#x27;ellipsemiddlecenter&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at center&quot;;
	                start = &quot;center, ellipse farthest-side&quot;;
	                webkit = &quot;center center, 0, center center, 487&quot;;
	                break;
	            case &#x27;ellipsemiddleright&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at right center&quot;;
	                start = &quot;right center, ellipse farthest-side&quot;;
	                webkit = &quot;right center, 0, right center&quot;;
	                break;
	            case &#x27;ellipsebottomleft&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at left bottom&quot;;
	                start = &quot;left bottom, ellipse farthest-side&quot;;
	                webkit = &quot;left bottom, 0, left bottom, 973&quot;;
	                break;
	            case &#x27;ellipsebottomcenter&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at center bottom&quot;;
	                start = &quot;center bottom, ellipse farthest-side&quot;;
	                webkit = &quot;center bottom, 0, center bottom, 487&quot;;
	                break;
	            case &#x27;ellipsebottomright&#x27;    :
	                type = &quot;radial&quot;;
	                w3c = &quot;ellipse farthest-side at right bottom&quot;;
	                start = &quot;right bottom, ellipse farthest-side&quot;;
	                webkit = &quot;right bottom, 0, right bottom, 973&quot;;
	                break;

	            default:
	                type = &quot;linear&quot;;
	                w3c = &quot;to right&quot;;
	                start = &quot;left&quot;;
	                webkit = &quot;left top, right top&quot;;
	                break;
	        }

	        if (color_end) {
	            jQuery(ele).css({&#x27;background&#x27;: color_start, &#x27;opacity&#x27;: opacity});
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-moz-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-webkit-gradient(&#x27; + type + &#x27;, &#x27; + webkit + &#x27;, color-stop(0, &#x27; + color_start + &#x27;), color-stop(1, &#x27; + color_end + &#x27;))&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-webkit-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-o-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-ms-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;&#x27; + type + &#x27;-gradient(&#x27; + w3c + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=\&#x27;&#x27; + color_start + &#x27;\&#x27;, endColorstr=\&#x27;&#x27; + color_end + &#x27;\&#x27;,GradientType=1 )&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	        }

	        else {
	            jQuery(ele).css({&#x27;background&#x27;: color_start, &#x27;opacity&#x27;: opacity});
	        }
	    }

	});


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(225);
	jQuery(function ($) {
	    &quot;use strict&quot;;
	    $(&#x27;.parallax&#x27;).stellar({
	        horizontalScrolling: false,
	        verticalOffset: 40,
	        responsive: true
	    });
	});

/***/ }),
/* 225 */
/***/ (function(module, exports) {

	/*! Stellar.js v0.6.2 | Copyright 2014, Mark Dalgleish | http://markdalgleish.com/projects/stellar.js | http://markdalgleish.mit-license.org */
	!function(a,b,c,d){function e(b,c){this.element=b,this.options=a.extend({},g,c),this._defaults=g,this._name=f,this.init()}var f=&quot;stellar&quot;,g={scrollProperty:&quot;scroll&quot;,positionProperty:&quot;position&quot;,horizontalScrolling:!0,verticalScrolling:!0,horizontalOffset:0,verticalOffset:0,responsive:!1,parallaxBackgrounds:!0,parallaxElements:!0,hideDistantElements:!0,hideElement:function(a){a.hide()},showElement:function(a){a.show()}},h={scroll:{getLeft:function(a){return a.scrollLeft()},setLeft:function(a,b){a.scrollLeft(b)},getTop:function(a){return a.scrollTop()},setTop:function(a,b){a.scrollTop(b)}},position:{getLeft:function(a){return-1*parseInt(a.css(&quot;left&quot;),10)},getTop:function(a){return-1*parseInt(a.css(&quot;top&quot;),10)}},margin:{getLeft:function(a){return-1*parseInt(a.css(&quot;margin-left&quot;),10)},getTop:function(a){return-1*parseInt(a.css(&quot;margin-top&quot;),10)}},transform:{getLeft:function(a){var b=getComputedStyle(a[0])[k];return&quot;none&quot;!==b?-1*parseInt(b.match(/(-?[0-9]+)/g)[4],10):0},getTop:function(a){var b=getComputedStyle(a[0])[k];return&quot;none&quot;!==b?-1*parseInt(b.match(/(-?[0-9]+)/g)[5],10):0}}},i={position:{setLeft:function(a,b){a.css(&quot;left&quot;,b)},setTop:function(a,b){a.css(&quot;top&quot;,b)}},transform:{setPosition:function(a,b,c,d,e){a[0].style[k]=&quot;translate3d(&quot;+(b-c)+&quot;px, &quot;+(d-e)+&quot;px, 0)&quot;}}},j=function(){var b,c=/^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/,d=a(&quot;script&quot;)[0].style,e=&quot;&quot;;for(b in d)if(c.test(b)){e=b.match(c)[0];break}return&quot;WebkitOpacity&quot;in d&amp;&amp;(e=&quot;Webkit&quot;),&quot;KhtmlOpacity&quot;in d&amp;&amp;(e=&quot;Khtml&quot;),function(a){return e+(e.length&gt;0?a.charAt(0).toUpperCase()+a.slice(1):a)}}(),k=j(&quot;transform&quot;),l=a(&quot;&lt;div /&gt;&quot;,{style:&quot;background:#fff&quot;}).css(&quot;background-position-x&quot;)!==d,m=l?function(a,b,c){a.css({&quot;background-position-x&quot;:b,&quot;background-position-y&quot;:c})}:function(a,b,c){a.css(&quot;background-position&quot;,b+&quot; &quot;+c)},n=l?function(a){return[a.css(&quot;background-position-x&quot;),a.css(&quot;background-position-y&quot;)]}:function(a){return a.css(&quot;background-position&quot;).split(&quot; &quot;)},o=b.requestAnimationFrame||b.webkitRequestAnimationFrame||b.mozRequestAnimationFrame||b.oRequestAnimationFrame||b.msRequestAnimationFrame||function(a){setTimeout(a,1e3/60)};e.prototype={init:function(){this.options.name=f+&quot;_&quot;+Math.floor(1e9*Math.random()),this._defineElements(),this._defineGetters(),this._defineSetters(),this._handleWindowLoadAndResize(),this._detectViewport(),this.refresh({firstLoad:!0}),&quot;scroll&quot;===this.options.scrollProperty?this._handleScrollEvent():this._startAnimationLoop()},_defineElements:function(){this.element===c.body&amp;&amp;(this.element=b),this.$scrollElement=a(this.element),this.$element=this.element===b?a(&quot;body&quot;):this.$scrollElement,this.$viewportElement=this.options.viewportElement!==d?a(this.options.viewportElement):this.$scrollElement[0]===b||&quot;scroll&quot;===this.options.scrollProperty?this.$scrollElement:this.$scrollElement.parent()},_defineGetters:function(){var a=this,b=h[a.options.scrollProperty];this._getScrollLeft=function(){return b.getLeft(a.$scrollElement)},this._getScrollTop=function(){return b.getTop(a.$scrollElement)}},_defineSetters:function(){var b=this,c=h[b.options.scrollProperty],d=i[b.options.positionProperty],e=c.setLeft,f=c.setTop;this._setScrollLeft=&quot;function&quot;==typeof e?function(a){e(b.$scrollElement,a)}:a.noop,this._setScrollTop=&quot;function&quot;==typeof f?function(a){f(b.$scrollElement,a)}:a.noop,this._setPosition=d.setPosition||function(a,c,e,f,g){b.options.horizontalScrolling&amp;&amp;d.setLeft(a,c,e),b.options.verticalScrolling&amp;&amp;d.setTop(a,f,g)}},_handleWindowLoadAndResize:function(){var c=this,d=a(b);c.options.responsive&amp;&amp;d.bind(&quot;load.&quot;+this.name,function(){c.refresh()}),d.bind(&quot;resize.&quot;+this.name,function(){c._detectViewport(),c.options.responsive&amp;&amp;c.refresh()})},refresh:function(c){var d=this,e=d._getScrollLeft(),f=d._getScrollTop();c&amp;&amp;c.firstLoad||this._reset(),this._setScrollLeft(0),this._setScrollTop(0),this._setOffsets(),this._findParticles(),this._findBackgrounds(),c&amp;&amp;c.firstLoad&amp;&amp;/WebKit/.test(navigator.userAgent)&amp;&amp;a(b).load(function(){var a=d._getScrollLeft(),b=d._getScrollTop();d._setScrollLeft(a+1),d._setScrollTop(b+1),d._setScrollLeft(a),d._setScrollTop(b)}),this._setScrollLeft(e),this._setScrollTop(f)},_detectViewport:function(){var a=this.$viewportElement.offset(),b=null!==a&amp;&amp;a!==d;this.viewportWidth=this.$viewportElement.width(),this.viewportHeight=this.$viewportElement.height(),this.viewportOffsetTop=b?a.top:0,this.viewportOffsetLeft=b?a.left:0},_findParticles:function(){{var b=this;this._getScrollLeft(),this._getScrollTop()}if(this.particles!==d)for(var c=this.particles.length-1;c&gt;=0;c--)this.particles[c].$element.data(&quot;stellar-elementIsActive&quot;,d);this.particles=[],this.options.parallaxElements&amp;&amp;this.$element.find(&quot;[data-stellar-ratio]&quot;).each(function(){var c,e,f,g,h,i,j,k,l,m=a(this),n=0,o=0,p=0,q=0;if(m.data(&quot;stellar-elementIsActive&quot;)){if(m.data(&quot;stellar-elementIsActive&quot;)!==this)return}else m.data(&quot;stellar-elementIsActive&quot;,this);b.options.showElement(m),m.data(&quot;stellar-startingLeft&quot;)?(m.css(&quot;left&quot;,m.data(&quot;stellar-startingLeft&quot;)),m.css(&quot;top&quot;,m.data(&quot;stellar-startingTop&quot;))):(m.data(&quot;stellar-startingLeft&quot;,m.css(&quot;left&quot;)),m.data(&quot;stellar-startingTop&quot;,m.css(&quot;top&quot;))),f=m.position().left,g=m.position().top,h=&quot;auto&quot;===m.css(&quot;margin-left&quot;)?0:parseInt(m.css(&quot;margin-left&quot;),10),i=&quot;auto&quot;===m.css(&quot;margin-top&quot;)?0:parseInt(m.css(&quot;margin-top&quot;),10),k=m.offset().left-h,l=m.offset().top-i,m.parents().each(function(){var b=a(this);return b.data(&quot;stellar-offset-parent&quot;)===!0?(n=p,o=q,j=b,!1):(p+=b.position().left,void(q+=b.position().top))}),c=m.data(&quot;stellar-horizontal-offset&quot;)!==d?m.data(&quot;stellar-horizontal-offset&quot;):j!==d&amp;&amp;j.data(&quot;stellar-horizontal-offset&quot;)!==d?j.data(&quot;stellar-horizontal-offset&quot;):b.horizontalOffset,e=m.data(&quot;stellar-vertical-offset&quot;)!==d?m.data(&quot;stellar-vertical-offset&quot;):j!==d&amp;&amp;j.data(&quot;stellar-vertical-offset&quot;)!==d?j.data(&quot;stellar-vertical-offset&quot;):b.verticalOffset,b.particles.push({$element:m,$offsetParent:j,isFixed:&quot;fixed&quot;===m.css(&quot;position&quot;),horizontalOffset:c,verticalOffset:e,startingPositionLeft:f,startingPositionTop:g,startingOffsetLeft:k,startingOffsetTop:l,parentOffsetLeft:n,parentOffsetTop:o,stellarRatio:m.data(&quot;stellar-ratio&quot;)!==d?m.data(&quot;stellar-ratio&quot;):1,width:m.outerWidth(!0),height:m.outerHeight(!0),isHidden:!1})})},_findBackgrounds:function(){var b,c=this,e=this._getScrollLeft(),f=this._getScrollTop();this.backgrounds=[],this.options.parallaxBackgrounds&amp;&amp;(b=this.$element.find(&quot;[data-stellar-background-ratio]&quot;),this.$element.data(&quot;stellar-background-ratio&quot;)&amp;&amp;(b=b.add(this.$element)),b.each(function(){var b,g,h,i,j,k,l,o=a(this),p=n(o),q=0,r=0,s=0,t=0;if(o.data(&quot;stellar-backgroundIsActive&quot;)){if(o.data(&quot;stellar-backgroundIsActive&quot;)!==this)return}else o.data(&quot;stellar-backgroundIsActive&quot;,this);o.data(&quot;stellar-backgroundStartingLeft&quot;)?m(o,o.data(&quot;stellar-backgroundStartingLeft&quot;),o.data(&quot;stellar-backgroundStartingTop&quot;)):(o.data(&quot;stellar-backgroundStartingLeft&quot;,p[0]),o.data(&quot;stellar-backgroundStartingTop&quot;,p[1])),h=&quot;auto&quot;===o.css(&quot;margin-left&quot;)?0:parseInt(o.css(&quot;margin-left&quot;),10),i=&quot;auto&quot;===o.css(&quot;margin-top&quot;)?0:parseInt(o.css(&quot;margin-top&quot;),10),j=o.offset().left-h-e,k=o.offset().top-i-f,o.parents().each(function(){var b=a(this);return b.data(&quot;stellar-offset-parent&quot;)===!0?(q=s,r=t,l=b,!1):(s+=b.position().left,void(t+=b.position().top))}),b=o.data(&quot;stellar-horizontal-offset&quot;)!==d?o.data(&quot;stellar-horizontal-offset&quot;):l!==d&amp;&amp;l.data(&quot;stellar-horizontal-offset&quot;)!==d?l.data(&quot;stellar-horizontal-offset&quot;):c.horizontalOffset,g=o.data(&quot;stellar-vertical-offset&quot;)!==d?o.data(&quot;stellar-vertical-offset&quot;):l!==d&amp;&amp;l.data(&quot;stellar-vertical-offset&quot;)!==d?l.data(&quot;stellar-vertical-offset&quot;):c.verticalOffset,c.backgrounds.push({$element:o,$offsetParent:l,isFixed:&quot;fixed&quot;===o.css(&quot;background-attachment&quot;),horizontalOffset:b,verticalOffset:g,startingValueLeft:p[0],startingValueTop:p[1],startingBackgroundPositionLeft:isNaN(parseInt(p[0],10))?0:parseInt(p[0],10),startingBackgroundPositionTop:isNaN(parseInt(p[1],10))?0:parseInt(p[1],10),startingPositionLeft:o.position().left,startingPositionTop:o.position().top,startingOffsetLeft:j,startingOffsetTop:k,parentOffsetLeft:q,parentOffsetTop:r,stellarRatio:o.data(&quot;stellar-background-ratio&quot;)===d?1:o.data(&quot;stellar-background-ratio&quot;)})}))},_reset:function(){var a,b,c,d,e;for(e=this.particles.length-1;e&gt;=0;e--)a=this.particles[e],b=a.$element.data(&quot;stellar-startingLeft&quot;),c=a.$element.data(&quot;stellar-startingTop&quot;),this._setPosition(a.$element,b,b,c,c),this.options.showElement(a.$element),a.$element.data(&quot;stellar-startingLeft&quot;,null).data(&quot;stellar-elementIsActive&quot;,null).data(&quot;stellar-backgroundIsActive&quot;,null);for(e=this.backgrounds.length-1;e&gt;=0;e--)d=this.backgrounds[e],d.$element.data(&quot;stellar-backgroundStartingLeft&quot;,null).data(&quot;stellar-backgroundStartingTop&quot;,null),m(d.$element,d.startingValueLeft,d.startingValueTop)},destroy:function(){this._reset(),this.$scrollElement.unbind(&quot;resize.&quot;+this.name).unbind(&quot;scroll.&quot;+this.name),this._animationLoop=a.noop,a(b).unbind(&quot;load.&quot;+this.name).unbind(&quot;resize.&quot;+this.name)},_setOffsets:function(){var c=this,d=a(b);d.unbind(&quot;resize.horizontal-&quot;+this.name).unbind(&quot;resize.vertical-&quot;+this.name),&quot;function&quot;==typeof this.options.horizontalOffset?(this.horizontalOffset=this.options.horizontalOffset(),d.bind(&quot;resize.horizontal-&quot;+this.name,function(){c.horizontalOffset=c.options.horizontalOffset()})):this.horizontalOffset=this.options.horizontalOffset,&quot;function&quot;==typeof this.options.verticalOffset?(this.verticalOffset=this.options.verticalOffset(),d.bind(&quot;resize.vertical-&quot;+this.name,function(){c.verticalOffset=c.options.verticalOffset()})):this.verticalOffset=this.options.verticalOffset},_repositionElements:function(){var a,b,c,d,e,f,g,h,i,j,k=this._getScrollLeft(),l=this._getScrollTop(),n=!0,o=!0;if(this.currentScrollLeft!==k||this.currentScrollTop!==l||this.currentWidth!==this.viewportWidth||this.currentHeight!==this.viewportHeight){for(this.currentScrollLeft=k,this.currentScrollTop=l,this.currentWidth=this.viewportWidth,this.currentHeight=this.viewportHeight,j=this.particles.length-1;j&gt;=0;j--)a=this.particles[j],b=a.isFixed?1:0,this.options.horizontalScrolling?(f=(k+a.horizontalOffset+this.viewportOffsetLeft+a.startingPositionLeft-a.startingOffsetLeft+a.parentOffsetLeft)*-(a.stellarRatio+b-1)+a.startingPositionLeft,h=f-a.startingPositionLeft+a.startingOffsetLeft):(f=a.startingPositionLeft,h=a.startingOffsetLeft),this.options.verticalScrolling?(g=(l+a.verticalOffset+this.viewportOffsetTop+a.startingPositionTop-a.startingOffsetTop+a.parentOffsetTop)*-(a.stellarRatio+b-1)+a.startingPositionTop,i=g-a.startingPositionTop+a.startingOffsetTop):(g=a.startingPositionTop,i=a.startingOffsetTop),this.options.hideDistantElements&amp;&amp;(o=!this.options.horizontalScrolling||h+a.width&gt;(a.isFixed?0:k)&amp;&amp;h&lt;(a.isFixed?0:k)+this.viewportWidth+this.viewportOffsetLeft,n=!this.options.verticalScrolling||i+a.height&gt;(a.isFixed?0:l)&amp;&amp;i&lt;(a.isFixed?0:l)+this.viewportHeight+this.viewportOffsetTop),o&amp;&amp;n?(a.isHidden&amp;&amp;(this.options.showElement(a.$element),a.isHidden=!1),this._setPosition(a.$element,f,a.startingPositionLeft,g,a.startingPositionTop)):a.isHidden||(this.options.hideElement(a.$element),a.isHidden=!0);for(j=this.backgrounds.length-1;j&gt;=0;j--)c=this.backgrounds[j],b=c.isFixed?0:1,d=this.options.horizontalScrolling?(k+c.horizontalOffset-this.viewportOffsetLeft-c.startingOffsetLeft+c.parentOffsetLeft-c.startingBackgroundPositionLeft)*(b-c.stellarRatio)+&quot;px&quot;:c.startingValueLeft,e=this.options.verticalScrolling?(l+c.verticalOffset-this.viewportOffsetTop-c.startingOffsetTop+c.parentOffsetTop-c.startingBackgroundPositionTop)*(b-c.stellarRatio)+&quot;px&quot;:c.startingValueTop,m(c.$element,d,e)}},_handleScrollEvent:function(){var a=this,b=!1,c=function(){a._repositionElements(),b=!1},d=function(){b||(o(c),b=!0)};this.$scrollElement.bind(&quot;scroll.&quot;+this.name,d),d()},_startAnimationLoop:function(){var a=this;this._animationLoop=function(){o(a._animationLoop),a._repositionElements()},this._animationLoop()}},a.fn[f]=function(b){var c=arguments;return b===d||&quot;object&quot;==typeof b?this.each(function(){a.data(this,&quot;plugin_&quot;+f)||a.data(this,&quot;plugin_&quot;+f,new e(this,b))}):&quot;string&quot;==typeof b&amp;&amp;&quot;_&quot;!==b[0]&amp;&amp;&quot;init&quot;!==b?this.each(function(){var d=a.data(this,&quot;plugin_&quot;+f);d instanceof e&amp;&amp;&quot;function&quot;==typeof d[b]&amp;&amp;d[b].apply(d,Array.prototype.slice.call(c,1)),&quot;destroy&quot;===b&amp;&amp;a.data(this,&quot;plugin_&quot;+f,null)}):void 0},a[f]=function(){var c=a(b);return c.stellar.apply(c,Array.prototype.slice.call(arguments,0))},a[f].scrollProperty=h,a[f].positionProperty=i,b.Stellar=e}(jQuery,this,document);

/***/ }),
/* 226 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    window.addEventListener(&quot;load&quot;, function () {
	        var form = document.getElementById(&quot;contactform&quot;);
	        form.addEventListener(&quot;submit&quot;, function (event) {

	            if (form.checkValidity() == false) {
	                event.preventDefault();
	                event.stopPropagation();
	            }else{
	                $.ajax({
	                    type: &quot;POST&quot;,
	                    url: &quot;assets/php/submit.php&quot;,
	                    data: form.serialize(),
	                    success: function () {
	                        $(&#x27;#valid-issue&#x27;).addClass(&#x27;alert-success&#x27;).html(&#x27;Your message has been sent,&lt;BR&gt; We will contact you back with in next 24 hours.&#x27;).show();
	                    }
	                });
	            }

	            form.classList.add(&quot;was-validated&quot;);
	        }, false);
	    }, false);
	});

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ( $(&quot;#contactform&quot;)) {
	        $(&quot;#contactform&quot;).submit(function (e) {
	            e.preventDefault();
	            var name = $(&quot;#name&quot;).val(),
	                email = $(&quot;#email&quot;).val(),
	                subject = $(&quot;#subject&quot;).val(),
	                message = $(&quot;#message&quot;).val(),
	                dataString = &#x27;name=&#x27; + name + &#x27;&amp;email=&#x27; + email + &#x27;&amp;subject=&#x27; + subject + &#x27;&amp;message=&#x27; + message;

	            if (name === &#x27;&#x27; || !IsEmail(email) || message === &#x27;&#x27;) {
	                $(&#x27;#valid-issue&#x27;).addClass(&#x27;alert-danger&#x27;).html(&#x27;Please Provide Valid Information&#x27;).slideDown();
	            } else {
	                $.ajax({
	                    type: &quot;POST&quot;,
	                    url: &quot;assets/php/submit.php&quot;,
	                    data: $(&quot;form&quot;).serialize(),
	                    success: function () {
	                        $(&#x27;#contactform&#x27;).slideUp();
	                        $(&#x27;#valid-issue&#x27;).addClass(&#x27;alert-success&#x27;).html(&#x27;Your message has been sent,&lt;BR&gt; We will contact you back with in next 24 hours.&#x27;).show();
	                    }
	                });
	            }
	        });
	    }
	});


	function IsEmail(email) {
	    var regex = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
	    return regex.test(email);
	}




/***/ }),
/* 227 */
/***/ (function(module, exports) {

	jQuery(function ($) {

	    var $logoSticky, $logo;
	    $logo = $(&#x27;.navbar-brand img&#x27;).attr(&#x27;src&#x27;);

	    window.onscroll = function () {
	        var $ele = $(&#x27;.nav-sticky&#x27;);
	        var $classes;
	        if ($ele.length &gt; 0) {
	            $classes = ($ele.data(&#x27;nav-sticky-classes&#x27;)) ? $ele.data(&#x27;nav-sticky-classes&#x27;) : &#x27;white&#x27;;
	            if ($(window).scrollTop() &gt; 50) {
	                if ($logoSticky = $ele.data(&#x27;nav-sticky-logo&#x27;)) {
	                    $(&#x27;.navbar-brand img&#x27;).attr(&#x27;src&#x27;, $logoSticky)
	                }
	                $ele.addClass(&#x27;sticky shadow &#x27; + $classes);
	            } else {
	                $ele.removeClass(&#x27;sticky shadow &#x27; + $classes);
	                $(&#x27;.navbar-brand img&#x27;).attr(&#x27;src&#x27;, $logo);
	            }
	        }
	    };
	});

/***/ })
/******/ ]);
		</script>
	</body>
</html>
