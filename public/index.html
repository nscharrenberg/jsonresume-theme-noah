<!doctype html>
<html>
	<head>
	
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimal-ui">
	
	<title>Noah Scharrenberg</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">

	<style>
	@charset "UTF-8";
/**
 *
 *  Command : gulp watch or gulp styles
 *
 */
/*!
 * Bootstrap v4.0.0-beta (https://getbootstrap.com)
 * Copyright 2011-2017 The Bootstrap Authors
 * Copyright 2011-2017 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
@import url("https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap");
@media print {
  *,
*::before,
*::after {
    text-shadow: none !important;
    box-shadow: none !important;
  }

  a,
a:visited {
    text-decoration: underline;
  }

  abbr[title]::after {
    content: " (" attr(title) ")";
  }

  pre {
    white-space: pre-wrap !important;
  }

  pre,
blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }

  thead {
    display: table-header-group;
  }

  tr,
img {
    page-break-inside: avoid;
  }

  p,
h2,
h3 {
    orphans: 3;
    widows: 3;
  }

  h2,
h3 {
    page-break-after: avoid;
  }

  .navbar {
    display: none;
  }

  .badge {
    border: 1px solid #000;
  }

  .table {
    border-collapse: collapse !important;
  }
  .table td,
.table th {
    background-color: #fff !important;
  }

  .table-bordered th,
.table-bordered td {
    border: 1px solid #ddd !important;
  }
}
*,
*::before,
*::after {
  box-sizing: border-box;
}

html {
  font-family: sans-serif;
  line-height: 1.15;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  -ms-overflow-style: scrollbar;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

@-ms-viewport {
  width: device-width;
}
article, aside, dialog, figcaption, figure, footer, header, hgroup, main, nav, section {
  display: block;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 1rem;
  font-weight: normal;
  line-height: 1.5;
  color: #212529;
  text-align: left;
  background-color: #fff;
}

[tabindex="-1"]:focus {
  outline: none !important;
}

hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 0.5rem;
}

p {
  margin-top: 0;
  margin-bottom: 1rem;
}

abbr[title],
abbr[data-original-title] {
  text-decoration: underline;
  text-decoration: underline dotted;
  cursor: help;
  border-bottom: 0;
}

address {
  margin-bottom: 1rem;
  font-style: normal;
  line-height: inherit;
}

ol,
ul,
dl {
  margin-top: 0;
  margin-bottom: 1rem;
}

ol ol,
ul ul,
ol ul,
ul ol {
  margin-bottom: 0;
}

dt {
  font-weight: bold;
}

dd {
  margin-bottom: 0.5rem;
  margin-left: 0;
}

blockquote {
  margin: 0 0 1rem;
}

dfn {
  font-style: italic;
}

b,
strong {
  font-weight: bolder;
}

small {
  font-size: 80%;
}

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

a {
  color: #03a9f4;
  text-decoration: none;
  background-color: transparent;
  -webkit-text-decoration-skip: objects;
}
a:hover {
  color: #0275a8;
  text-decoration: underline;
}

a:not([href]):not([tabindex]) {
  color: inherit;
  text-decoration: none;
}
a:not([href]):not([tabindex]):focus, a:not([href]):not([tabindex]):hover {
  color: inherit;
  text-decoration: none;
}
a:not([href]):not([tabindex]):focus {
  outline: 0;
}

pre,
code,
kbd,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

pre {
  margin-top: 0;
  margin-bottom: 1rem;
  overflow: auto;
}

figure {
  margin: 0 0 1rem;
}

img {
  vertical-align: middle;
  border-style: none;
}

svg:not(:root) {
  overflow: hidden;
}

a,
area,
button,
[role=button],
input:not([type=range]),
label,
select,
summary,
textarea {
  touch-action: manipulation;
}

table {
  border-collapse: collapse;
}

caption {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
  color: #868e96;
  text-align: left;
  caption-side: bottom;
}

th {
  text-align: inherit;
}

label {
  display: inline-block;
  margin-bottom: 0.5rem;
}

button:focus {
  outline: 1px dotted;
  outline: 5px auto -webkit-focus-ring-color;
}

input,
button,
select,
optgroup,
textarea {
  margin: 0;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

button,
input {
  overflow: visible;
}

button,
select {
  text-transform: none;
}

button,
html [type=button],
[type=reset],
[type=submit] {
  -webkit-appearance: button;
}

button::-moz-focus-inner,
[type=button]::-moz-focus-inner,
[type=reset]::-moz-focus-inner,
[type=submit]::-moz-focus-inner {
  padding: 0;
  border-style: none;
}

input[type=radio],
input[type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

input[type=date],
input[type=time],
input[type=datetime-local],
input[type=month] {
  -webkit-appearance: listbox;
}

textarea {
  overflow: auto;
  resize: vertical;
}

fieldset {
  min-width: 0;
  padding: 0;
  margin: 0;
  border: 0;
}

legend {
  display: block;
  width: 100%;
  max-width: 100%;
  padding: 0;
  margin-bottom: 0.5rem;
  font-size: 1.5rem;
  line-height: inherit;
  color: inherit;
  white-space: normal;
}

progress {
  vertical-align: baseline;
}

[type=number]::-webkit-inner-spin-button,
[type=number]::-webkit-outer-spin-button {
  height: auto;
}

[type=search] {
  outline-offset: -2px;
  -webkit-appearance: none;
}

[type=search]::-webkit-search-cancel-button,
[type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

::-webkit-file-upload-button {
  font: inherit;
  -webkit-appearance: button;
}

output {
  display: inline-block;
}

summary {
  display: list-item;
}

template {
  display: none;
}

[hidden] {
  display: none !important;
}

h1, h2, h3, h4, h5, h6,
.h1, .h2, .h3, .h4, .h5, .h6 {
  margin-bottom: 0.5rem;
  font-family: inherit;
  font-weight: 500;
  line-height: 1.1;
  color: inherit;
}

h1, .h1 {
  font-size: 2.5rem;
}

h2, .h2 {
  font-size: 2rem;
}

h3, .h3 {
  font-size: 1.75rem;
}

h4, .h4 {
  font-size: 1.5rem;
}

h5, .h5 {
  font-size: 1.25rem;
}

h6, .h6 {
  font-size: 1rem;
}

.lead {
  font-size: 1.25rem;
  font-weight: 300;
}

.display-1 {
  font-size: 6rem;
  font-weight: 300;
  line-height: 1.1;
}

.display-2 {
  font-size: 5.5rem;
  font-weight: 300;
  line-height: 1.1;
}

.display-3 {
  font-size: 4.5rem;
  font-weight: 300;
  line-height: 1.1;
}

.display-4 {
  font-size: 3.5rem;
  font-weight: 300;
  line-height: 1.1;
}

hr {
  margin-top: 1rem;
  margin-bottom: 1rem;
  border: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

small,
.small {
  font-size: 80%;
  font-weight: normal;
}

mark,
.mark {
  padding: 0.2em;
  background-color: #fcf8e3;
}

.list-unstyled {
  padding-left: 0;
  list-style: none;
}

.list-inline {
  padding-left: 0;
  list-style: none;
}

.list-inline-item {
  display: inline-block;
}
.list-inline-item:not(:last-child) {
  margin-right: 5px;
}

.initialism {
  font-size: 90%;
  text-transform: uppercase;
}

.blockquote {
  margin-bottom: 1rem;
  font-size: 1.25rem;
}

.blockquote-footer {
  display: block;
  font-size: 80%;
  color: #868e96;
}
.blockquote-footer::before {
  content: "— ";
}

.img-fluid {
  max-width: 100%;
  height: auto;
}

.img-thumbnail {
  padding: 0.25rem;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 0.25rem;
  transition: all 0.2s ease-in-out;
  max-width: 100%;
  height: auto;
}

.figure {
  display: inline-block;
}

.figure-img {
  margin-bottom: 0.5rem;
  line-height: 1;
}

.figure-caption {
  font-size: 90%;
  color: #868e96;
}

code,
kbd,
pre,
samp {
  font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

code {
  padding: 0.2rem 0.4rem;
  font-size: 90%;
  color: #bd4147;
  background-color: #f8f9fa;
  border-radius: 0.25rem;
}
a > code {
  padding: 0;
  color: inherit;
  background-color: inherit;
}

kbd {
  padding: 0.2rem 0.4rem;
  font-size: 90%;
  color: #fff;
  background-color: #212529;
  border-radius: 0.2rem;
}
kbd kbd {
  padding: 0;
  font-size: 100%;
  font-weight: bold;
}

pre {
  display: block;
  margin-top: 0;
  margin-bottom: 1rem;
  font-size: 90%;
  color: #212529;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit;
  background-color: transparent;
  border-radius: 0;
}

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll;
}

.container {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: 15px;
  padding-left: 15px;
}
@media (min-width: 576px) {
  .container {
    max-width: 540px;
  }
}
@media (min-width: 768px) {
  .container {
    max-width: 720px;
  }
}
@media (min-width: 992px) {
  .container {
    max-width: 960px;
  }
}
@media (min-width: 1200px) {
  .container {
    max-width: 1140px;
  }
}

.container-fluid {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: 15px;
  padding-left: 15px;
}

.row {
  display: flex;
  flex-wrap: wrap;
  margin-right: -15px;
  margin-left: -15px;
}

.no-gutters {
  margin-right: 0;
  margin-left: 0;
}
.no-gutters > .col,
.no-gutters > [class*=col-] {
  padding-right: 0;
  padding-left: 0;
}

.col-xl,
.col-xl-auto, .col-xl-12, .col-xl-11, .col-xl-10, .col-xl-9, .col-xl-8, .col-xl-7, .col-xl-6, .col-xl-5, .col-xl-4, .col-xl-3, .col-xl-2, .col-xl-1, .col-lg,
.col-lg-auto, .col-lg-12, .col-lg-11, .col-lg-10, .col-lg-9, .col-lg-8, .col-lg-7, .col-lg-6, .col-lg-5, .col-lg-4, .col-lg-3, .col-lg-2, .col-lg-1, .col-md,
.col-md-auto, .col-md-12, .col-md-11, .col-md-10, .col-md-9, .col-md-8, .col-md-7, .col-md-6, .col-md-5, .col-md-4, .col-md-3, .col-md-2, .col-md-1, .col-sm,
.col-sm-auto, .col-sm-12, .col-sm-11, .col-sm-10, .col-sm-9, .col-sm-8, .col-sm-7, .col-sm-6, .col-sm-5, .col-sm-4, .col-sm-3, .col-sm-2, .col-sm-1, .col,
.col-auto, .col-12, .col-11, .col-10, .col-9, .col-8, .col-7, .col-6, .col-5, .col-4, .col-3, .col-2, .col-1 {
  position: relative;
  width: 100%;
  min-height: 1px;
  padding-right: 15px;
  padding-left: 15px;
}

.col {
  flex-basis: 0;
  flex-grow: 1;
  max-width: 100%;
}

.col-auto {
  flex: 0 0 auto;
  width: auto;
  max-width: none;
}

.col-1 {
  flex: 0 0 8.3333333333%;
  max-width: 8.3333333333%;
}

.col-2 {
  flex: 0 0 16.6666666667%;
  max-width: 16.6666666667%;
}

.col-3 {
  flex: 0 0 25%;
  max-width: 25%;
}

.col-4 {
  flex: 0 0 33.3333333333%;
  max-width: 33.3333333333%;
}

.col-5 {
  flex: 0 0 41.6666666667%;
  max-width: 41.6666666667%;
}

.col-6 {
  flex: 0 0 50%;
  max-width: 50%;
}

.col-7 {
  flex: 0 0 58.3333333333%;
  max-width: 58.3333333333%;
}

.col-8 {
  flex: 0 0 66.6666666667%;
  max-width: 66.6666666667%;
}

.col-9 {
  flex: 0 0 75%;
  max-width: 75%;
}

.col-10 {
  flex: 0 0 83.3333333333%;
  max-width: 83.3333333333%;
}

.col-11 {
  flex: 0 0 91.6666666667%;
  max-width: 91.6666666667%;
}

.col-12 {
  flex: 0 0 100%;
  max-width: 100%;
}

.order-1 {
  order: 1;
}

.order-2 {
  order: 2;
}

.order-3 {
  order: 3;
}

.order-4 {
  order: 4;
}

.order-5 {
  order: 5;
}

.order-6 {
  order: 6;
}

.order-7 {
  order: 7;
}

.order-8 {
  order: 8;
}

.order-9 {
  order: 9;
}

.order-10 {
  order: 10;
}

.order-11 {
  order: 11;
}

.order-12 {
  order: 12;
}

.offset-1 {
  margin-left: 8.3333333333%;
}

.offset-2 {
  margin-left: 16.6666666667%;
}

.offset-3 {
  margin-left: 25%;
}

.offset-4 {
  margin-left: 33.3333333333%;
}

.offset-5 {
  margin-left: 41.6666666667%;
}

.offset-6 {
  margin-left: 50%;
}

.offset-7 {
  margin-left: 58.3333333333%;
}

.offset-8 {
  margin-left: 66.6666666667%;
}

.offset-9 {
  margin-left: 75%;
}

.offset-10 {
  margin-left: 83.3333333333%;
}

.offset-11 {
  margin-left: 91.6666666667%;
}

@media (min-width: 576px) {
  .col-sm {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-sm-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-sm-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-sm-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-sm-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-sm-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-sm-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-sm-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-sm-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-sm-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-sm-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-sm-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-sm-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-sm-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-sm-1 {
    order: 1;
  }

  .order-sm-2 {
    order: 2;
  }

  .order-sm-3 {
    order: 3;
  }

  .order-sm-4 {
    order: 4;
  }

  .order-sm-5 {
    order: 5;
  }

  .order-sm-6 {
    order: 6;
  }

  .order-sm-7 {
    order: 7;
  }

  .order-sm-8 {
    order: 8;
  }

  .order-sm-9 {
    order: 9;
  }

  .order-sm-10 {
    order: 10;
  }

  .order-sm-11 {
    order: 11;
  }

  .order-sm-12 {
    order: 12;
  }

  .offset-sm-0 {
    margin-left: 0%;
  }

  .offset-sm-1 {
    margin-left: 8.3333333333%;
  }

  .offset-sm-2 {
    margin-left: 16.6666666667%;
  }

  .offset-sm-3 {
    margin-left: 25%;
  }

  .offset-sm-4 {
    margin-left: 33.3333333333%;
  }

  .offset-sm-5 {
    margin-left: 41.6666666667%;
  }

  .offset-sm-6 {
    margin-left: 50%;
  }

  .offset-sm-7 {
    margin-left: 58.3333333333%;
  }

  .offset-sm-8 {
    margin-left: 66.6666666667%;
  }

  .offset-sm-9 {
    margin-left: 75%;
  }

  .offset-sm-10 {
    margin-left: 83.3333333333%;
  }

  .offset-sm-11 {
    margin-left: 91.6666666667%;
  }
}
@media (min-width: 768px) {
  .col-md {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-md-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-md-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-md-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-md-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-md-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-md-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-md-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-md-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-md-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-md-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-md-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-md-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-md-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-md-1 {
    order: 1;
  }

  .order-md-2 {
    order: 2;
  }

  .order-md-3 {
    order: 3;
  }

  .order-md-4 {
    order: 4;
  }

  .order-md-5 {
    order: 5;
  }

  .order-md-6 {
    order: 6;
  }

  .order-md-7 {
    order: 7;
  }

  .order-md-8 {
    order: 8;
  }

  .order-md-9 {
    order: 9;
  }

  .order-md-10 {
    order: 10;
  }

  .order-md-11 {
    order: 11;
  }

  .order-md-12 {
    order: 12;
  }

  .offset-md-0 {
    margin-left: 0%;
  }

  .offset-md-1 {
    margin-left: 8.3333333333%;
  }

  .offset-md-2 {
    margin-left: 16.6666666667%;
  }

  .offset-md-3 {
    margin-left: 25%;
  }

  .offset-md-4 {
    margin-left: 33.3333333333%;
  }

  .offset-md-5 {
    margin-left: 41.6666666667%;
  }

  .offset-md-6 {
    margin-left: 50%;
  }

  .offset-md-7 {
    margin-left: 58.3333333333%;
  }

  .offset-md-8 {
    margin-left: 66.6666666667%;
  }

  .offset-md-9 {
    margin-left: 75%;
  }

  .offset-md-10 {
    margin-left: 83.3333333333%;
  }

  .offset-md-11 {
    margin-left: 91.6666666667%;
  }
}
@media (min-width: 992px) {
  .col-lg {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-lg-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-lg-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-lg-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-lg-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-lg-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-lg-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-lg-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-lg-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-lg-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-lg-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-lg-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-lg-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-lg-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-lg-1 {
    order: 1;
  }

  .order-lg-2 {
    order: 2;
  }

  .order-lg-3 {
    order: 3;
  }

  .order-lg-4 {
    order: 4;
  }

  .order-lg-5 {
    order: 5;
  }

  .order-lg-6 {
    order: 6;
  }

  .order-lg-7 {
    order: 7;
  }

  .order-lg-8 {
    order: 8;
  }

  .order-lg-9 {
    order: 9;
  }

  .order-lg-10 {
    order: 10;
  }

  .order-lg-11 {
    order: 11;
  }

  .order-lg-12 {
    order: 12;
  }

  .offset-lg-0 {
    margin-left: 0%;
  }

  .offset-lg-1 {
    margin-left: 8.3333333333%;
  }

  .offset-lg-2 {
    margin-left: 16.6666666667%;
  }

  .offset-lg-3 {
    margin-left: 25%;
  }

  .offset-lg-4 {
    margin-left: 33.3333333333%;
  }

  .offset-lg-5 {
    margin-left: 41.6666666667%;
  }

  .offset-lg-6 {
    margin-left: 50%;
  }

  .offset-lg-7 {
    margin-left: 58.3333333333%;
  }

  .offset-lg-8 {
    margin-left: 66.6666666667%;
  }

  .offset-lg-9 {
    margin-left: 75%;
  }

  .offset-lg-10 {
    margin-left: 83.3333333333%;
  }

  .offset-lg-11 {
    margin-left: 91.6666666667%;
  }
}
@media (min-width: 1200px) {
  .col-xl {
    flex-basis: 0;
    flex-grow: 1;
    max-width: 100%;
  }

  .col-xl-auto {
    flex: 0 0 auto;
    width: auto;
    max-width: none;
  }

  .col-xl-1 {
    flex: 0 0 8.3333333333%;
    max-width: 8.3333333333%;
  }

  .col-xl-2 {
    flex: 0 0 16.6666666667%;
    max-width: 16.6666666667%;
  }

  .col-xl-3 {
    flex: 0 0 25%;
    max-width: 25%;
  }

  .col-xl-4 {
    flex: 0 0 33.3333333333%;
    max-width: 33.3333333333%;
  }

  .col-xl-5 {
    flex: 0 0 41.6666666667%;
    max-width: 41.6666666667%;
  }

  .col-xl-6 {
    flex: 0 0 50%;
    max-width: 50%;
  }

  .col-xl-7 {
    flex: 0 0 58.3333333333%;
    max-width: 58.3333333333%;
  }

  .col-xl-8 {
    flex: 0 0 66.6666666667%;
    max-width: 66.6666666667%;
  }

  .col-xl-9 {
    flex: 0 0 75%;
    max-width: 75%;
  }

  .col-xl-10 {
    flex: 0 0 83.3333333333%;
    max-width: 83.3333333333%;
  }

  .col-xl-11 {
    flex: 0 0 91.6666666667%;
    max-width: 91.6666666667%;
  }

  .col-xl-12 {
    flex: 0 0 100%;
    max-width: 100%;
  }

  .order-xl-1 {
    order: 1;
  }

  .order-xl-2 {
    order: 2;
  }

  .order-xl-3 {
    order: 3;
  }

  .order-xl-4 {
    order: 4;
  }

  .order-xl-5 {
    order: 5;
  }

  .order-xl-6 {
    order: 6;
  }

  .order-xl-7 {
    order: 7;
  }

  .order-xl-8 {
    order: 8;
  }

  .order-xl-9 {
    order: 9;
  }

  .order-xl-10 {
    order: 10;
  }

  .order-xl-11 {
    order: 11;
  }

  .order-xl-12 {
    order: 12;
  }

  .offset-xl-0 {
    margin-left: 0%;
  }

  .offset-xl-1 {
    margin-left: 8.3333333333%;
  }

  .offset-xl-2 {
    margin-left: 16.6666666667%;
  }

  .offset-xl-3 {
    margin-left: 25%;
  }

  .offset-xl-4 {
    margin-left: 33.3333333333%;
  }

  .offset-xl-5 {
    margin-left: 41.6666666667%;
  }

  .offset-xl-6 {
    margin-left: 50%;
  }

  .offset-xl-7 {
    margin-left: 58.3333333333%;
  }

  .offset-xl-8 {
    margin-left: 66.6666666667%;
  }

  .offset-xl-9 {
    margin-left: 75%;
  }

  .offset-xl-10 {
    margin-left: 83.3333333333%;
  }

  .offset-xl-11 {
    margin-left: 91.6666666667%;
  }
}
.table {
  width: 100%;
  max-width: 100%;
  margin-bottom: 1rem;
  background-color: transparent;
}
.table th,
.table td {
  padding: 0.75rem;
  vertical-align: top;
  border-top: 1px solid #e9ecef;
}
.table thead th {
  vertical-align: bottom;
  border-bottom: 2px solid #e9ecef;
}
.table tbody + tbody {
  border-top: 2px solid #e9ecef;
}
.table .table {
  background-color: #fff;
}

.table-sm th,
.table-sm td {
  padding: 0.3rem;
}

.table-bordered {
  border: 1px solid #e9ecef;
}
.table-bordered th,
.table-bordered td {
  border: 1px solid #e9ecef;
}
.table-bordered thead th,
.table-bordered thead td {
  border-bottom-width: 2px;
}

.table-striped tbody tr:nth-of-type(odd) {
  background-color: rgba(0, 0, 0, 0.05);
}

.table-hover tbody tr:hover {
  background-color: #F5F8FA;
}

.table-primary,
.table-primary > th,
.table-primary > td {
  background-color: #b8e7fc;
}

.table-hover .table-primary:hover {
  background-color: #a0dffb;
}
.table-hover .table-primary:hover > td,
.table-hover .table-primary:hover > th {
  background-color: #a0dffb;
}

.table-secondary,
.table-secondary > th,
.table-secondary > td {
  background-color: #dddfe2;
}

.table-hover .table-secondary:hover {
  background-color: #cfd2d6;
}
.table-hover .table-secondary:hover > td,
.table-hover .table-secondary:hover > th {
  background-color: #cfd2d6;
}

.table-success,
.table-success > th,
.table-success > td {
  background-color: #dbf0cf;
}

.table-hover .table-success:hover {
  background-color: #cceabc;
}
.table-hover .table-success:hover > td,
.table-hover .table-success:hover > th {
  background-color: #cceabc;
}

.table-info,
.table-info > th,
.table-info > td {
  background-color: #d9ecfa;
}

.table-hover .table-info:hover {
  background-color: #c2e1f7;
}
.table-hover .table-info:hover > td,
.table-hover .table-info:hover > th {
  background-color: #c2e1f7;
}

.table-warning,
.table-warning > th,
.table-warning > td {
  background-color: #fef1cf;
}

.table-hover .table-warning:hover {
  background-color: #fdeab6;
}
.table-hover .table-warning:hover > td,
.table-hover .table-warning:hover > th {
  background-color: #fdeab6;
}

.table-danger,
.table-danger > th,
.table-danger > td {
  background-color: #facfd4;
}

.table-hover .table-danger:hover {
  background-color: #f8b8bf;
}
.table-hover .table-danger:hover > td,
.table-hover .table-danger:hover > th {
  background-color: #f8b8bf;
}

.table-light,
.table-light > th,
.table-light > td {
  background-color: #fdfdfe;
}

.table-hover .table-light:hover {
  background-color: #ececf6;
}
.table-hover .table-light:hover > td,
.table-hover .table-light:hover > th {
  background-color: #ececf6;
}

.table-dark,
.table-dark > th,
.table-dark > td {
  background-color: #c6c8ca;
}

.table-hover .table-dark:hover {
  background-color: #b9bbbe;
}
.table-hover .table-dark:hover > td,
.table-hover .table-dark:hover > th {
  background-color: #b9bbbe;
}

.table-active,
.table-active > th,
.table-active > td {
  background-color: #F5F8FA;
}

.table-hover .table-active:hover {
  background-color: #e4ecf2;
}
.table-hover .table-active:hover > td,
.table-hover .table-active:hover > th {
  background-color: #e4ecf2;
}

.table .thead-dark th {
  color: #fff;
  background-color: #212529;
  border-color: #32383e;
}
.table .thead-light th {
  color: #495057;
  background-color: #e9ecef;
  border-color: #e9ecef;
}

.table-dark {
  color: #fff;
  background-color: #212529;
}
.table-dark th,
.table-dark td,
.table-dark thead th {
  border-color: #32383e;
}
.table-dark.table-bordered {
  border: 0;
}
.table-dark.table-striped tbody tr:nth-of-type(odd) {
  background-color: rgba(255, 255, 255, 0.05);
}
.table-dark.table-hover tbody tr:hover {
  background-color: rgba(255, 255, 255, 0.075);
}

@media (max-width: 575px) {
  .table-responsive-sm {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-sm.table-bordered {
    border: 0;
  }
}
@media (max-width: 767px) {
  .table-responsive-md {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-md.table-bordered {
    border: 0;
  }
}
@media (max-width: 991px) {
  .table-responsive-lg {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-lg.table-bordered {
    border: 0;
  }
}
@media (max-width: 1199px) {
  .table-responsive-xl {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: -ms-autohiding-scrollbar;
  }
  .table-responsive-xl.table-bordered {
    border: 0;
  }
}
.table-responsive {
  display: block;
  width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  -ms-overflow-style: -ms-autohiding-scrollbar;
}
.table-responsive.table-bordered {
  border: 0;
}

.form-control {
  display: block;
  width: 100%;
  padding: 0.5rem 0.75rem;
  font-size: 1rem;
  line-height: 1.25;
  color: #495057;
  background-color: #fff;
  background-image: none;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
  transition: border-color ease-in-out 0.15s, box-shadow ease-in-out 0.15s;
}
.form-control::-ms-expand {
  background-color: transparent;
  border: 0;
}
.form-control:focus {
  color: #495057;
  background-color: #fff;
  border-color: #79d4fd;
  outline: none;
}
.form-control::placeholder {
  color: #868e96;
  opacity: 1;
}
.form-control:disabled, .form-control[readonly] {
  background-color: #e9ecef;
  opacity: 1;
}

select.form-control:not([size]):not([multiple]) {
  height: calc(2.25rem + 2px);
}
select.form-control:focus::-ms-value {
  color: #495057;
  background-color: #fff;
}

.form-control-file,
.form-control-range {
  display: block;
}

.col-form-label {
  padding-top: calc(0.5rem - 1px * 2);
  padding-bottom: calc(0.5rem - 1px * 2);
  margin-bottom: 0;
}

.col-form-label-lg {
  padding-top: calc(0.5rem - 1px * 2);
  padding-bottom: calc(0.5rem - 1px * 2);
  font-size: 1.25rem;
}

.col-form-label-sm {
  padding-top: calc(0.25rem - 1px * 2);
  padding-bottom: calc(0.25rem - 1px * 2);
  font-size: 0.875rem;
}

.col-form-legend {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
  margin-bottom: 0;
  font-size: 1rem;
}

.form-control-plaintext {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
  margin-bottom: 0;
  line-height: 1.25;
  background-color: transparent;
  border: solid transparent;
  border-width: 1px 0;
}
.form-control-plaintext.form-control-sm, .input-group-sm > .form-control-plaintext.form-control,
.input-group-sm > .form-control-plaintext.input-group-addon,
.input-group-sm > .input-group-btn > .form-control-plaintext.btn, .form-control-plaintext.form-control-lg, .input-group-lg > .form-control-plaintext.form-control,
.input-group-lg > .form-control-plaintext.input-group-addon,
.input-group-lg > .input-group-btn > .form-control-plaintext.btn {
  padding-right: 0;
  padding-left: 0;
}

.form-control-sm, .input-group-sm > .form-control,
.input-group-sm > .input-group-addon,
.input-group-sm > .input-group-btn > .btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: 0.2rem;
}

select.form-control-sm:not([size]):not([multiple]), .input-group-sm > select.form-control:not([size]):not([multiple]),
.input-group-sm > select.input-group-addon:not([size]):not([multiple]),
.input-group-sm > .input-group-btn > select.btn:not([size]):not([multiple]) {
  height: calc(1.8125rem + 2px);
}

.form-control-lg, .input-group-lg > .form-control,
.input-group-lg > .input-group-addon,
.input-group-lg > .input-group-btn > .btn {
  padding: 0.5rem 1rem;
  font-size: 1.25rem;
  line-height: 1.5;
  border-radius: 0.3rem;
}

select.form-control-lg:not([size]):not([multiple]), .input-group-lg > select.form-control:not([size]):not([multiple]),
.input-group-lg > select.input-group-addon:not([size]):not([multiple]),
.input-group-lg > .input-group-btn > select.btn:not([size]):not([multiple]) {
  height: calc(2.875rem + 2px);
}

.form-group {
  margin-bottom: 1rem;
}

.form-text {
  display: block;
  margin-top: 0.25rem;
}

.form-row {
  display: flex;
  flex-wrap: wrap;
  margin-right: -5px;
  margin-left: -5px;
}
.form-row > .col,
.form-row > [class*=col-] {
  padding-right: 5px;
  padding-left: 5px;
}

.form-check {
  position: relative;
  display: block;
  margin-bottom: 0.5rem;
}
.form-check.disabled .form-check-label {
  color: #868e96;
}

.form-check-label {
  padding-left: 1.25rem;
  margin-bottom: 0;
}

.form-check-input {
  position: absolute;
  margin-top: 0.25rem;
  margin-left: -1.25rem;
}

.form-check-inline {
  display: inline-block;
  margin-right: 0.75rem;
}
.form-check-inline .form-check-label {
  vertical-align: middle;
}

.invalid-feedback {
  display: none;
  margin-top: 0.25rem;
  font-size: 0.875rem;
  color: #ED5564;
}

.invalid-tooltip {
  position: absolute;
  top: 100%;
  z-index: 5;
  display: none;
  width: 250px;
  padding: 0.5rem;
  margin-top: 0.1rem;
  font-size: 0.875rem;
  line-height: 1;
  color: #fff;
  background-color: rgba(237, 85, 100, 0.8);
  border-radius: 0.2rem;
}

.was-validated .form-control:valid, .form-control.is-valid,
.was-validated .custom-select:valid,
.custom-select.is-valid {
  border-color: #7dc855;
}
.was-validated .form-control:valid:focus, .form-control.is-valid:focus,
.was-validated .custom-select:valid:focus,
.custom-select.is-valid:focus {
  box-shadow: 0 0 0 0.2rem rgba(125, 200, 85, 0.25);
}
.was-validated .form-control:valid ~ .valid-feedback,
.was-validated .form-control:valid ~ .valid-tooltip, .form-control.is-valid ~ .valid-feedback,
.form-control.is-valid ~ .valid-tooltip,
.was-validated .custom-select:valid ~ .valid-feedback,
.was-validated .custom-select:valid ~ .valid-tooltip,
.custom-select.is-valid ~ .valid-feedback,
.custom-select.is-valid ~ .valid-tooltip {
  display: block;
}

.was-validated .form-check-input:valid + .form-check-label, .form-check-input.is-valid + .form-check-label {
  color: #7dc855;
}

.was-validated .custom-control-input:valid ~ .custom-control-indicator, .custom-control-input.is-valid ~ .custom-control-indicator {
  background-color: rgba(125, 200, 85, 0.25);
}
.was-validated .custom-control-input:valid ~ .custom-control-description, .custom-control-input.is-valid ~ .custom-control-description {
  color: #7dc855;
}

.was-validated .custom-file-input:valid ~ .custom-file-control, .custom-file-input.is-valid ~ .custom-file-control {
  border-color: #7dc855;
}
.was-validated .custom-file-input:valid ~ .custom-file-control::before, .custom-file-input.is-valid ~ .custom-file-control::before {
  border-color: inherit;
}
.was-validated .custom-file-input:valid:focus, .custom-file-input.is-valid:focus {
  box-shadow: 0 0 0 0.2rem rgba(125, 200, 85, 0.25);
}

.was-validated .form-control:invalid, .form-control.is-invalid,
.was-validated .custom-select:invalid,
.custom-select.is-invalid {
  border-color: #ED5564;
}
.was-validated .form-control:invalid:focus, .form-control.is-invalid:focus,
.was-validated .custom-select:invalid:focus,
.custom-select.is-invalid:focus {
  box-shadow: 0 0 0 0.2rem rgba(237, 85, 100, 0.25);
}
.was-validated .form-control:invalid ~ .invalid-feedback,
.was-validated .form-control:invalid ~ .invalid-tooltip, .form-control.is-invalid ~ .invalid-feedback,
.form-control.is-invalid ~ .invalid-tooltip,
.was-validated .custom-select:invalid ~ .invalid-feedback,
.was-validated .custom-select:invalid ~ .invalid-tooltip,
.custom-select.is-invalid ~ .invalid-feedback,
.custom-select.is-invalid ~ .invalid-tooltip {
  display: block;
}

.was-validated .form-check-input:invalid + .form-check-label, .form-check-input.is-invalid + .form-check-label {
  color: #ED5564;
}

.was-validated .custom-control-input:invalid ~ .custom-control-indicator, .custom-control-input.is-invalid ~ .custom-control-indicator {
  background-color: rgba(237, 85, 100, 0.25);
}
.was-validated .custom-control-input:invalid ~ .custom-control-description, .custom-control-input.is-invalid ~ .custom-control-description {
  color: #ED5564;
}

.was-validated .custom-file-input:invalid ~ .custom-file-control, .custom-file-input.is-invalid ~ .custom-file-control {
  border-color: #ED5564;
}
.was-validated .custom-file-input:invalid ~ .custom-file-control::before, .custom-file-input.is-invalid ~ .custom-file-control::before {
  border-color: inherit;
}
.was-validated .custom-file-input:invalid:focus, .custom-file-input.is-invalid:focus {
  box-shadow: 0 0 0 0.2rem rgba(237, 85, 100, 0.25);
}

.form-inline {
  display: flex;
  flex-flow: row wrap;
  align-items: center;
}
.form-inline .form-check {
  width: 100%;
}
@media (min-width: 576px) {
  .form-inline label {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 0;
  }
  .form-inline .form-group {
    display: flex;
    flex: 0 0 auto;
    flex-flow: row wrap;
    align-items: center;
    margin-bottom: 0;
  }
  .form-inline .form-control {
    display: inline-block;
    width: auto;
    vertical-align: middle;
  }
  .form-inline .form-control-plaintext {
    display: inline-block;
  }
  .form-inline .input-group {
    width: auto;
  }
  .form-inline .form-control-label {
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .form-check {
    display: flex;
    align-items: center;
    justify-content: center;
    width: auto;
    margin-top: 0;
    margin-bottom: 0;
  }
  .form-inline .form-check-label {
    padding-left: 0;
  }
  .form-inline .form-check-input {
    position: relative;
    margin-top: 0;
    margin-right: 0.25rem;
    margin-left: 0;
  }
  .form-inline .custom-control {
    display: flex;
    align-items: center;
    justify-content: center;
    padding-left: 0;
  }
  .form-inline .custom-control-indicator {
    position: static;
    display: inline-block;
    margin-right: 0.25rem;
    vertical-align: text-bottom;
  }
  .form-inline .has-feedback .form-control-feedback {
    top: 0;
  }
}

.btn {
  display: inline-block;
  font-weight: normal;
  text-align: center;
  white-space: nowrap;
  vertical-align: middle;
  user-select: none;
  border: 1px solid transparent;
  padding: 0.5rem 0.75rem;
  font-size: 1rem;
  line-height: 1.25;
  border-radius: 0.25rem;
  transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}
.btn:focus, .btn:hover {
  text-decoration: none;
}
.btn:focus, .btn.focus {
  outline: 0;
  box-shadow: 0 0 0 3px rgba(3, 169, 244, 0.25);
}
.btn.disabled, .btn:disabled {
  opacity: 0.65;
}
.btn:active, .btn.active {
  background-image: none;
}

a.btn.disabled,
fieldset[disabled] a.btn {
  pointer-events: none;
}

.btn-primary {
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.btn-primary:hover {
  color: #fff;
  background-color: #038fce;
  border-color: #0286c2;
}
.btn-primary:focus, .btn-primary.focus {
  box-shadow: 0 0 0 3px rgba(3, 169, 244, 0.5);
}
.btn-primary.disabled, .btn-primary:disabled {
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.btn-primary:active, .btn-primary.active, .show > .btn-primary.dropdown-toggle {
  background-color: #038fce;
  background-image: none;
  border-color: #0286c2;
}

.btn-secondary {
  color: #fff;
  background-color: #868e96;
  border-color: #868e96;
}
.btn-secondary:hover {
  color: #fff;
  background-color: #727b84;
  border-color: #6c757d;
}
.btn-secondary:focus, .btn-secondary.focus {
  box-shadow: 0 0 0 3px rgba(134, 142, 150, 0.5);
}
.btn-secondary.disabled, .btn-secondary:disabled {
  background-color: #868e96;
  border-color: #868e96;
}
.btn-secondary:active, .btn-secondary.active, .show > .btn-secondary.dropdown-toggle {
  background-color: #727b84;
  background-image: none;
  border-color: #6c757d;
}

.btn-success {
  color: #111;
  background-color: #7dc855;
  border-color: #7dc855;
}
.btn-success:hover {
  color: #fff;
  background-color: #68ba3c;
  border-color: #63b139;
}
.btn-success:focus, .btn-success.focus {
  box-shadow: 0 0 0 3px rgba(125, 200, 85, 0.5);
}
.btn-success.disabled, .btn-success:disabled {
  background-color: #7dc855;
  border-color: #7dc855;
}
.btn-success:active, .btn-success.active, .show > .btn-success.dropdown-toggle {
  background-color: #68ba3c;
  background-image: none;
  border-color: #63b139;
}

.btn-info {
  color: #111;
  background-color: #78BCEE;
  border-color: #78BCEE;
}
.btn-info:hover {
  color: #111;
  background-color: #56abea;
  border-color: #4ba6e8;
}
.btn-info:focus, .btn-info.focus {
  box-shadow: 0 0 0 3px rgba(120, 188, 238, 0.5);
}
.btn-info.disabled, .btn-info:disabled {
  background-color: #78BCEE;
  border-color: #78BCEE;
}
.btn-info:active, .btn-info.active, .show > .btn-info.dropdown-toggle {
  background-color: #56abea;
  background-image: none;
  border-color: #4ba6e8;
}

.btn-warning {
  color: #111;
  background-color: #FCCE54;
  border-color: #FCCE54;
}
.btn-warning:hover {
  color: #111;
  background-color: #fbc32e;
  border-color: #fbc022;
}
.btn-warning:focus, .btn-warning.focus {
  box-shadow: 0 0 0 3px rgba(252, 206, 84, 0.5);
}
.btn-warning.disabled, .btn-warning:disabled {
  background-color: #FCCE54;
  border-color: #FCCE54;
}
.btn-warning:active, .btn-warning.active, .show > .btn-warning.dropdown-toggle {
  background-color: #fbc32e;
  background-image: none;
  border-color: #fbc022;
}

.btn-danger {
  color: #fff;
  background-color: #ED5564;
  border-color: #ED5564;
}
.btn-danger:hover {
  color: #fff;
  background-color: #e93244;
  border-color: #e8273a;
}
.btn-danger:focus, .btn-danger.focus {
  box-shadow: 0 0 0 3px rgba(237, 85, 100, 0.5);
}
.btn-danger.disabled, .btn-danger:disabled {
  background-color: #ED5564;
  border-color: #ED5564;
}
.btn-danger:active, .btn-danger.active, .show > .btn-danger.dropdown-toggle {
  background-color: #e93244;
  background-image: none;
  border-color: #e8273a;
}

.btn-light {
  color: #111;
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}
.btn-light:hover {
  color: #111;
  background-color: #e2e6ea;
  border-color: #dae0e5;
}
.btn-light:focus, .btn-light.focus {
  box-shadow: 0 0 0 3px rgba(248, 249, 250, 0.5);
}
.btn-light.disabled, .btn-light:disabled {
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}
.btn-light:active, .btn-light.active, .show > .btn-light.dropdown-toggle {
  background-color: #e2e6ea;
  background-image: none;
  border-color: #dae0e5;
}

.btn-dark {
  color: #fff;
  background-color: #343a40;
  border-color: #343a40;
}
.btn-dark:hover {
  color: #fff;
  background-color: #23272b;
  border-color: #1d2124;
}
.btn-dark:focus, .btn-dark.focus {
  box-shadow: 0 0 0 3px rgba(52, 58, 64, 0.5);
}
.btn-dark.disabled, .btn-dark:disabled {
  background-color: #343a40;
  border-color: #343a40;
}
.btn-dark:active, .btn-dark.active, .show > .btn-dark.dropdown-toggle {
  background-color: #23272b;
  background-image: none;
  border-color: #1d2124;
}

.btn-outline-primary {
  color: #03a9f4;
  background-color: transparent;
  background-image: none;
  border-color: #03a9f4;
}
.btn-outline-primary:hover {
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.btn-outline-primary:focus, .btn-outline-primary.focus {
  box-shadow: 0 0 0 3px rgba(3, 169, 244, 0.5);
}
.btn-outline-primary.disabled, .btn-outline-primary:disabled {
  color: #03a9f4;
  background-color: transparent;
}
.btn-outline-primary:active, .btn-outline-primary.active, .show > .btn-outline-primary.dropdown-toggle {
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}

.btn-outline-secondary {
  color: #868e96;
  background-color: transparent;
  background-image: none;
  border-color: #868e96;
}
.btn-outline-secondary:hover {
  color: #fff;
  background-color: #868e96;
  border-color: #868e96;
}
.btn-outline-secondary:focus, .btn-outline-secondary.focus {
  box-shadow: 0 0 0 3px rgba(134, 142, 150, 0.5);
}
.btn-outline-secondary.disabled, .btn-outline-secondary:disabled {
  color: #868e96;
  background-color: transparent;
}
.btn-outline-secondary:active, .btn-outline-secondary.active, .show > .btn-outline-secondary.dropdown-toggle {
  color: #fff;
  background-color: #868e96;
  border-color: #868e96;
}

.btn-outline-success {
  color: #7dc855;
  background-color: transparent;
  background-image: none;
  border-color: #7dc855;
}
.btn-outline-success:hover {
  color: #fff;
  background-color: #7dc855;
  border-color: #7dc855;
}
.btn-outline-success:focus, .btn-outline-success.focus {
  box-shadow: 0 0 0 3px rgba(125, 200, 85, 0.5);
}
.btn-outline-success.disabled, .btn-outline-success:disabled {
  color: #7dc855;
  background-color: transparent;
}
.btn-outline-success:active, .btn-outline-success.active, .show > .btn-outline-success.dropdown-toggle {
  color: #fff;
  background-color: #7dc855;
  border-color: #7dc855;
}

.btn-outline-info {
  color: #78BCEE;
  background-color: transparent;
  background-image: none;
  border-color: #78BCEE;
}
.btn-outline-info:hover {
  color: #fff;
  background-color: #78BCEE;
  border-color: #78BCEE;
}
.btn-outline-info:focus, .btn-outline-info.focus {
  box-shadow: 0 0 0 3px rgba(120, 188, 238, 0.5);
}
.btn-outline-info.disabled, .btn-outline-info:disabled {
  color: #78BCEE;
  background-color: transparent;
}
.btn-outline-info:active, .btn-outline-info.active, .show > .btn-outline-info.dropdown-toggle {
  color: #fff;
  background-color: #78BCEE;
  border-color: #78BCEE;
}

.btn-outline-warning {
  color: #FCCE54;
  background-color: transparent;
  background-image: none;
  border-color: #FCCE54;
}
.btn-outline-warning:hover {
  color: #fff;
  background-color: #FCCE54;
  border-color: #FCCE54;
}
.btn-outline-warning:focus, .btn-outline-warning.focus {
  box-shadow: 0 0 0 3px rgba(252, 206, 84, 0.5);
}
.btn-outline-warning.disabled, .btn-outline-warning:disabled {
  color: #FCCE54;
  background-color: transparent;
}
.btn-outline-warning:active, .btn-outline-warning.active, .show > .btn-outline-warning.dropdown-toggle {
  color: #fff;
  background-color: #FCCE54;
  border-color: #FCCE54;
}

.btn-outline-danger {
  color: #ED5564;
  background-color: transparent;
  background-image: none;
  border-color: #ED5564;
}
.btn-outline-danger:hover {
  color: #fff;
  background-color: #ED5564;
  border-color: #ED5564;
}
.btn-outline-danger:focus, .btn-outline-danger.focus {
  box-shadow: 0 0 0 3px rgba(237, 85, 100, 0.5);
}
.btn-outline-danger.disabled, .btn-outline-danger:disabled {
  color: #ED5564;
  background-color: transparent;
}
.btn-outline-danger:active, .btn-outline-danger.active, .show > .btn-outline-danger.dropdown-toggle {
  color: #fff;
  background-color: #ED5564;
  border-color: #ED5564;
}

.btn-outline-light {
  color: #f8f9fa;
  background-color: transparent;
  background-image: none;
  border-color: #f8f9fa;
}
.btn-outline-light:hover {
  color: #212529;
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}
.btn-outline-light:focus, .btn-outline-light.focus {
  box-shadow: 0 0 0 3px rgba(248, 249, 250, 0.5);
}
.btn-outline-light.disabled, .btn-outline-light:disabled {
  color: #f8f9fa;
  background-color: transparent;
}
.btn-outline-light:active, .btn-outline-light.active, .show > .btn-outline-light.dropdown-toggle {
  color: #212529;
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}

.btn-outline-dark {
  color: #343a40;
  background-color: transparent;
  background-image: none;
  border-color: #343a40;
}
.btn-outline-dark:hover {
  color: #fff;
  background-color: #343a40;
  border-color: #343a40;
}
.btn-outline-dark:focus, .btn-outline-dark.focus {
  box-shadow: 0 0 0 3px rgba(52, 58, 64, 0.5);
}
.btn-outline-dark.disabled, .btn-outline-dark:disabled {
  color: #343a40;
  background-color: transparent;
}
.btn-outline-dark:active, .btn-outline-dark.active, .show > .btn-outline-dark.dropdown-toggle {
  color: #fff;
  background-color: #343a40;
  border-color: #343a40;
}

.btn-link {
  font-weight: normal;
  color: #03a9f4;
  background-color: transparent;
  border-radius: 0;
}
.btn-link:hover {
  color: #0275a8;
  text-decoration: underline;
  background-color: transparent;
  border-color: transparent;
}
.btn-link:focus, .btn-link.focus {
  border-color: transparent;
  box-shadow: none;
}
.btn-link:disabled, .btn-link.disabled {
  color: #868e96;
}

.btn-lg, .btn-group-lg > .btn {
  padding: 0.5rem 1rem;
  font-size: 1.25rem;
  line-height: 1.5;
  border-radius: 0.3rem;
}

.btn-sm, .btn-group-sm > .btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: 0.2rem;
}

.btn-block {
  display: block;
  width: 100%;
}

.btn-block + .btn-block {
  margin-top: 0.5rem;
}

input[type=submit].btn-block,
input[type=reset].btn-block,
input[type=button].btn-block {
  width: 100%;
}

.fade {
  opacity: 0;
  transition: opacity 0.15s linear;
}
.fade.show {
  opacity: 1;
}

.collapse {
  display: none;
}
.collapse.show {
  display: block;
}

tr.collapse.show {
  display: table-row;
}

tbody.collapse.show {
  display: table-row-group;
}

.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  transition: height 0.35s ease;
}

.dropup,
.dropdown {
  position: relative;
}

.dropdown-toggle::after {
  display: inline-block;
  width: 0;
  height: 0;
  margin-left: 0.255em;
  vertical-align: 0.255em;
  content: "";
  border-top: 0.3em solid;
  border-right: 0.3em solid transparent;
  border-left: 0.3em solid transparent;
}
.dropdown-toggle:empty::after {
  margin-left: 0;
}

.dropup .dropdown-menu {
  margin-top: 0;
  margin-bottom: 0.125rem;
}
.dropup .dropdown-toggle::after {
  border-top: 0;
  border-bottom: 0.3em solid;
}

.dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 1000;
  display: none;
  float: left;
  min-width: 10rem;
  padding: 0.5rem 0;
  margin: 0.125rem 0 0;
  font-size: 1rem;
  color: #212529;
  text-align: left;
  list-style: none;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
}

.dropdown-divider {
  height: 0;
  margin: 0.5rem 0;
  overflow: hidden;
  border-top: 1px solid #e9ecef;
}

.dropdown-item {
  display: block;
  width: 100%;
  padding: 0.25rem 1.5rem;
  clear: both;
  font-weight: normal;
  color: #212529;
  text-align: inherit;
  white-space: nowrap;
  background: none;
  border: 0;
}
.dropdown-item:focus, .dropdown-item:hover {
  color: #16181b;
  text-decoration: none;
  background-color: #f8f9fa;
}
.dropdown-item.active, .dropdown-item:active {
  color: #fff;
  text-decoration: none;
  background-color: #03a9f4;
}
.dropdown-item.disabled, .dropdown-item:disabled {
  color: #868e96;
  background-color: transparent;
}

.show > a {
  outline: 0;
}

.dropdown-menu.show {
  display: block;
}

.dropdown-header {
  display: block;
  padding: 0.5rem 1.5rem;
  margin-bottom: 0;
  font-size: 0.875rem;
  color: #868e96;
  white-space: nowrap;
}

.btn-group,
.btn-group-vertical {
  position: relative;
  display: inline-flex;
  vertical-align: middle;
}
.btn-group > .btn,
.btn-group-vertical > .btn {
  position: relative;
  flex: 0 1 auto;
}
.btn-group > .btn:hover,
.btn-group-vertical > .btn:hover {
  z-index: 2;
}
.btn-group > .btn:focus, .btn-group > .btn:active, .btn-group > .btn.active,
.btn-group-vertical > .btn:focus,
.btn-group-vertical > .btn:active,
.btn-group-vertical > .btn.active {
  z-index: 2;
}
.btn-group .btn + .btn,
.btn-group .btn + .btn-group,
.btn-group .btn-group + .btn,
.btn-group .btn-group + .btn-group,
.btn-group-vertical .btn + .btn,
.btn-group-vertical .btn + .btn-group,
.btn-group-vertical .btn-group + .btn,
.btn-group-vertical .btn-group + .btn-group {
  margin-left: -1px;
}

.btn-toolbar {
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
}
.btn-toolbar .input-group {
  width: auto;
}

.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
  border-radius: 0;
}

.btn-group > .btn:first-child {
  margin-left: 0;
}
.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.btn-group > .btn:last-child:not(:first-child),
.btn-group > .dropdown-toggle:not(:first-child) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.btn-group > .btn-group {
  float: left;
}

.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}

.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.btn + .dropdown-toggle-split {
  padding-right: 0.5625rem;
  padding-left: 0.5625rem;
}
.btn + .dropdown-toggle-split::after {
  margin-left: 0;
}

.btn-sm + .dropdown-toggle-split, .btn-group-sm > .btn + .dropdown-toggle-split {
  padding-right: 0.375rem;
  padding-left: 0.375rem;
}

.btn-lg + .dropdown-toggle-split, .btn-group-lg > .btn + .dropdown-toggle-split {
  padding-right: 0.75rem;
  padding-left: 0.75rem;
}

.btn-group-vertical {
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
}
.btn-group-vertical .btn,
.btn-group-vertical .btn-group {
  width: 100%;
}
.btn-group-vertical > .btn + .btn,
.btn-group-vertical > .btn + .btn-group,
.btn-group-vertical > .btn-group + .btn,
.btn-group-vertical > .btn-group + .btn-group {
  margin-top: -1px;
  margin-left: 0;
}
.btn-group-vertical > .btn:not(:first-child):not(:last-child) {
  border-radius: 0;
}
.btn-group-vertical:first-child:not(:last-child) {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical:last-child:not(:first-child) {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}
.btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

[data-toggle=buttons] > .btn input[type=radio],
[data-toggle=buttons] > .btn input[type=checkbox],
[data-toggle=buttons] > .btn-group > .btn input[type=radio],
[data-toggle=buttons] > .btn-group > .btn input[type=checkbox] {
  position: absolute;
  clip: rect(0, 0, 0, 0);
  pointer-events: none;
}

.input-group {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
}
.input-group .form-control {
  position: relative;
  z-index: 2;
  flex: 1 1 auto;
  width: 1%;
  margin-bottom: 0;
}
.input-group .form-control:focus, .input-group .form-control:active, .input-group .form-control:hover {
  z-index: 3;
}

.input-group-addon:not(:first-child):not(:last-child),
.input-group-btn:not(:first-child):not(:last-child),
.input-group .form-control:not(:first-child):not(:last-child) {
  border-radius: 0;
}

.input-group-addon,
.input-group-btn {
  white-space: nowrap;
}

.input-group-addon {
  padding: 0.5rem 0.75rem;
  margin-bottom: 0;
  font-size: 1rem;
  font-weight: normal;
  line-height: 1.25;
  color: #495057;
  text-align: center;
  background-color: #e9ecef;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
}
.input-group-addon.form-control-sm,
.input-group-sm > .input-group-addon,
.input-group-sm > .input-group-btn > .input-group-addon.btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  border-radius: 0.2rem;
}
.input-group-addon.form-control-lg,
.input-group-lg > .input-group-addon,
.input-group-lg > .input-group-btn > .input-group-addon.btn {
  padding: 0.5rem 1rem;
  font-size: 1.25rem;
  border-radius: 0.3rem;
}
.input-group-addon input[type=radio],
.input-group-addon input[type=checkbox] {
  margin-top: 0;
}

.input-group .form-control:not(:last-child),
.input-group-addon:not(:last-child),
.input-group-btn:not(:last-child) > .btn,
.input-group-btn:not(:last-child) > .btn-group > .btn,
.input-group-btn:not(:last-child) > .dropdown-toggle,
.input-group-btn:not(:first-child) > .btn:not(:last-child):not(.dropdown-toggle),
.input-group-btn:not(:first-child) > .btn-group:not(:last-child) > .btn {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.input-group-addon:not(:last-child) {
  border-right: 0;
}

.input-group .form-control:not(:first-child),
.input-group-addon:not(:first-child),
.input-group-btn:not(:first-child) > .btn,
.input-group-btn:not(:first-child) > .btn-group > .btn,
.input-group-btn:not(:first-child) > .dropdown-toggle,
.input-group-btn:not(:last-child) > .btn:not(:first-child),
.input-group-btn:not(:last-child) > .btn-group:not(:first-child) > .btn {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.form-control + .input-group-addon:not(:first-child) {
  border-left: 0;
}

.input-group-btn {
  position: relative;
  font-size: 0;
  white-space: nowrap;
}
.input-group-btn > .btn {
  position: relative;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
}
.input-group-btn > .btn + .btn {
  margin-left: -1px;
}
.input-group-btn > .btn:focus, .input-group-btn > .btn:active, .input-group-btn > .btn:hover {
  z-index: 3;
}
.input-group-btn:not(:last-child) > .btn,
.input-group-btn:not(:last-child) > .btn-group {
  margin-right: -1px;
}
.input-group-btn:not(:first-child) > .btn,
.input-group-btn:not(:first-child) > .btn-group {
  z-index: 2;
  margin-left: -1px;
}
.input-group-btn:not(:first-child) > .btn:focus, .input-group-btn:not(:first-child) > .btn:active, .input-group-btn:not(:first-child) > .btn:hover,
.input-group-btn:not(:first-child) > .btn-group:focus,
.input-group-btn:not(:first-child) > .btn-group:active,
.input-group-btn:not(:first-child) > .btn-group:hover {
  z-index: 3;
}

.custom-control {
  position: relative;
  display: inline-flex;
  min-height: 1.5rem;
  padding-left: 1.5rem;
  margin-right: 1rem;
}

.custom-control-input {
  position: absolute;
  z-index: -1;
  opacity: 0;
}
.custom-control-input:checked ~ .custom-control-indicator {
  color: #fff;
  background-color: #03a9f4;
}
.custom-control-input:focus ~ .custom-control-indicator {
  box-shadow: 0 0 0 1px #fff, 0 0 0 3px #03a9f4;
}
.custom-control-input:active ~ .custom-control-indicator {
  color: #fff;
  background-color: #ace4fe;
}
.custom-control-input:disabled ~ .custom-control-indicator {
  background-color: #e9ecef;
}
.custom-control-input:disabled ~ .custom-control-description {
  color: #868e96;
}

.custom-control-indicator {
  position: absolute;
  top: 0.25rem;
  left: 0;
  display: block;
  width: 1rem;
  height: 1rem;
  pointer-events: none;
  user-select: none;
  background-color: #ddd;
  background-repeat: no-repeat;
  background-position: center center;
  background-size: 50% 50%;
}

.custom-checkbox .custom-control-indicator {
  border-radius: 0.25rem;
}
.custom-checkbox .custom-control-input:checked ~ .custom-control-indicator {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3E%3C/svg%3E");
}
.custom-checkbox .custom-control-input:indeterminate ~ .custom-control-indicator {
  background-color: #03a9f4;
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 4'%3E%3Cpath stroke='%23fff' d='M0 2h4'/%3E%3C/svg%3E");
}

.custom-radio .custom-control-indicator {
  border-radius: 50%;
}
.custom-radio .custom-control-input:checked ~ .custom-control-indicator {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3E%3Ccircle r='3' fill='%23fff'/%3E%3C/svg%3E");
}

.custom-controls-stacked {
  display: flex;
  flex-direction: column;
}
.custom-controls-stacked .custom-control {
  margin-bottom: 0.25rem;
}
.custom-controls-stacked .custom-control + .custom-control {
  margin-left: 0;
}

.custom-select {
  display: inline-block;
  max-width: 100%;
  height: calc(2.25rem + 2px);
  padding: 0.375rem 1.75rem 0.375rem 0.75rem;
  line-height: 1.25;
  color: #495057;
  vertical-align: middle;
  background: #fff url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") no-repeat right 0.75rem center;
  background-clip: padding-box;
  background-size: 8px 10px;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
  appearance: none;
}
.custom-select:focus {
  border-color: #79d4fd;
  outline: none;
}
.custom-select:focus::-ms-value {
  color: #495057;
  background-color: #fff;
}
.custom-select:disabled {
  color: #868e96;
  background-color: #e9ecef;
}
.custom-select::-ms-expand {
  opacity: 0;
}

.custom-select-sm {
  height: calc(1.8125rem + 2px);
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
  font-size: 75%;
}

.custom-file {
  position: relative;
  display: inline-block;
  max-width: 100%;
  height: calc(2.25rem + 2px);
  margin-bottom: 0;
}

.custom-file-input {
  min-width: 14rem;
  max-width: 100%;
  height: calc(2.25rem + 2px);
  margin: 0;
  opacity: 0;
}
.custom-file-input:focus ~ .custom-file-control {
  box-shadow: 0 0 0 0.075rem #fff, 0 0 0 0.2rem #03a9f4;
}

.custom-file-control {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  z-index: 5;
  height: calc(2.25rem + 2px);
  padding: 0.5rem 0.75rem;
  overflow: hidden;
  line-height: 1.25;
  color: #495057;
  pointer-events: none;
  user-select: none;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 0.25rem;
}
.custom-file-control:lang(en):empty::after {
  content: "Choose file...";
}
.custom-file-control::before {
  position: absolute;
  top: 0;
  right: 0;
  z-index: 6;
  display: block;
  height: calc(2.25rem + 2px);
  padding: 0.5rem 0.75rem;
  line-height: 1.25;
  color: #495057;
  background-color: #e9ecef;
  border-left: 1px solid rgba(0, 0, 0, 0.15);
}
.custom-file-control:lang(en)::before {
  content: "Browse";
}

.nav {
  display: flex;
  flex-wrap: wrap;
  padding-left: 0;
  margin-bottom: 0;
  list-style: none;
}

.nav-link {
  display: block;
  padding: 0.5rem 1rem;
}
.nav-link:focus, .nav-link:hover {
  text-decoration: none;
}
.nav-link.disabled {
  color: #868e96;
}

.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs .nav-item {
  margin-bottom: -1px;
}
.nav-tabs .nav-link {
  border: 1px solid transparent;
  border-top-left-radius: 0.25rem;
  border-top-right-radius: 0.25rem;
}
.nav-tabs .nav-link:focus, .nav-tabs .nav-link:hover {
  border-color: #e9ecef #e9ecef #ddd;
}
.nav-tabs .nav-link.disabled {
  color: #868e96;
  background-color: transparent;
  border-color: transparent;
}
.nav-tabs .nav-link.active,
.nav-tabs .nav-item.show .nav-link {
  color: #495057;
  background-color: #fff;
  border-color: #ddd #ddd #fff;
}
.nav-tabs .dropdown-menu {
  margin-top: -1px;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

.nav-pills .nav-link {
  border-radius: 0.25rem;
}
.nav-pills .nav-link.active, .show > .nav-pills .nav-link {
  color: #fff;
  background-color: #03a9f4;
}

.nav-fill .nav-item {
  flex: 1 1 auto;
  text-align: center;
}

.nav-justified .nav-item {
  flex-basis: 0;
  flex-grow: 1;
  text-align: center;
}

.tab-content > .tab-pane {
  display: none;
}
.tab-content > .active {
  display: block;
}

.navbar {
  position: relative;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 1rem;
}
.navbar > .container,
.navbar > .container-fluid {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
}

.navbar-brand {
  display: inline-block;
  padding-top: 0.3125rem;
  padding-bottom: 0.3125rem;
  margin-right: 1rem;
  font-size: 1.25rem;
  line-height: inherit;
  white-space: nowrap;
}
.navbar-brand:focus, .navbar-brand:hover {
  text-decoration: none;
}

.navbar-nav {
  display: flex;
  flex-direction: column;
  padding-left: 0;
  margin-bottom: 0;
  list-style: none;
}
.navbar-nav .nav-link {
  padding-right: 0;
  padding-left: 0;
}
.navbar-nav .dropdown-menu {
  position: static;
  float: none;
}

.navbar-text {
  display: inline-block;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

.navbar-collapse {
  flex-basis: 100%;
  flex-grow: 1;
  align-items: center;
}

.navbar-toggler {
  padding: 0.25rem 0.75rem;
  font-size: 1.25rem;
  line-height: 1;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 0.25rem;
}
.navbar-toggler:focus, .navbar-toggler:hover {
  text-decoration: none;
}

.navbar-toggler-icon {
  display: inline-block;
  width: 1.5em;
  height: 1.5em;
  vertical-align: middle;
  content: "";
  background: no-repeat center center;
  background-size: 100% 100%;
}

@media (max-width: 575px) {
  .navbar-expand-sm > .container,
.navbar-expand-sm > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 576px) {
  .navbar-expand-sm {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-sm .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-sm .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-sm .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-sm .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-sm > .container,
.navbar-expand-sm > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-sm .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-sm .navbar-toggler {
    display: none;
  }
}
@media (max-width: 767px) {
  .navbar-expand-md > .container,
.navbar-expand-md > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 768px) {
  .navbar-expand-md {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-md .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-md .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-md .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-md .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-md > .container,
.navbar-expand-md > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-md .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-md .navbar-toggler {
    display: none;
  }
}
@media (max-width: 991px) {
  .navbar-expand-lg > .container,
.navbar-expand-lg > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 992px) {
  .navbar-expand-lg {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-lg .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-lg .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-lg .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-lg .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-lg > .container,
.navbar-expand-lg > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-lg .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-lg .navbar-toggler {
    display: none;
  }
}
@media (max-width: 1199px) {
  .navbar-expand-xl > .container,
.navbar-expand-xl > .container-fluid {
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 1200px) {
  .navbar-expand-xl {
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
  }
  .navbar-expand-xl .navbar-nav {
    flex-direction: row;
  }
  .navbar-expand-xl .navbar-nav .dropdown-menu {
    position: absolute;
  }
  .navbar-expand-xl .navbar-nav .dropdown-menu-right {
    right: 0;
    left: auto;
  }
  .navbar-expand-xl .navbar-nav .nav-link {
    padding-right: 0.5rem;
    padding-left: 0.5rem;
  }
  .navbar-expand-xl > .container,
.navbar-expand-xl > .container-fluid {
    flex-wrap: nowrap;
  }
  .navbar-expand-xl .navbar-collapse {
    display: flex !important;
    flex-basis: auto;
  }
  .navbar-expand-xl .navbar-toggler {
    display: none;
  }
}
.navbar-expand {
  flex-direction: row;
  flex-wrap: nowrap;
  justify-content: flex-start;
}
.navbar-expand > .container,
.navbar-expand > .container-fluid {
  padding-right: 0;
  padding-left: 0;
}
.navbar-expand .navbar-nav {
  flex-direction: row;
}
.navbar-expand .navbar-nav .dropdown-menu {
  position: absolute;
}
.navbar-expand .navbar-nav .dropdown-menu-right {
  right: 0;
  left: auto;
}
.navbar-expand .navbar-nav .nav-link {
  padding-right: 0.5rem;
  padding-left: 0.5rem;
}
.navbar-expand > .container,
.navbar-expand > .container-fluid {
  flex-wrap: nowrap;
}
.navbar-expand .navbar-collapse {
  display: flex !important;
  flex-basis: auto;
}
.navbar-expand .navbar-toggler {
  display: none;
}

.navbar-light .navbar-brand {
  color: rgba(0, 0, 0, 0.9);
}
.navbar-light .navbar-brand:focus, .navbar-light .navbar-brand:hover {
  color: rgba(0, 0, 0, 0.9);
}
.navbar-light .navbar-nav .nav-link {
  color: rgba(0, 0, 0, 0.5);
}
.navbar-light .navbar-nav .nav-link:focus, .navbar-light .navbar-nav .nav-link:hover {
  color: rgba(0, 0, 0, 0.7);
}
.navbar-light .navbar-nav .nav-link.disabled {
  color: rgba(0, 0, 0, 0.3);
}
.navbar-light .navbar-nav .show > .nav-link,
.navbar-light .navbar-nav .active > .nav-link,
.navbar-light .navbar-nav .nav-link.show,
.navbar-light .navbar-nav .nav-link.active {
  color: rgba(0, 0, 0, 0.9);
}
.navbar-light .navbar-toggler {
  color: rgba(0, 0, 0, 0.5);
  border-color: rgba(0, 0, 0, 0.1);
}
.navbar-light .navbar-toggler-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(0, 0, 0, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
}
.navbar-light .navbar-text {
  color: rgba(0, 0, 0, 0.5);
}

.navbar-dark .navbar-brand {
  color: white;
}
.navbar-dark .navbar-brand:focus, .navbar-dark .navbar-brand:hover {
  color: white;
}
.navbar-dark .navbar-nav .nav-link {
  color: rgba(255, 255, 255, 0.5);
}
.navbar-dark .navbar-nav .nav-link:focus, .navbar-dark .navbar-nav .nav-link:hover {
  color: rgba(255, 255, 255, 0.75);
}
.navbar-dark .navbar-nav .nav-link.disabled {
  color: rgba(255, 255, 255, 0.25);
}
.navbar-dark .navbar-nav .show > .nav-link,
.navbar-dark .navbar-nav .active > .nav-link,
.navbar-dark .navbar-nav .nav-link.show,
.navbar-dark .navbar-nav .nav-link.active {
  color: white;
}
.navbar-dark .navbar-toggler {
  color: rgba(255, 255, 255, 0.5);
  border-color: rgba(255, 255, 255, 0.1);
}
.navbar-dark .navbar-toggler-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(255, 255, 255, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
}
.navbar-dark .navbar-text {
  color: rgba(255, 255, 255, 0.5);
}

.card {
  position: relative;
  display: flex;
  flex-direction: column;
  min-width: 0;
  word-wrap: break-word;
  background-color: #fff;
  background-clip: border-box;
  border: 1px solid rgba(0, 0, 0, 0.125);
  border-radius: 0.25rem;
}

.card-body {
  flex: 1 1 auto;
  padding: 1.25rem;
}

.card-title {
  margin-bottom: 0.75rem;
}

.card-subtitle {
  margin-top: -0.375rem;
  margin-bottom: 0;
}

.card-text:last-child {
  margin-bottom: 0;
}

.card-link:hover {
  text-decoration: none;
}
.card-link + .card-link {
  margin-left: 1.25rem;
}

.card > .list-group:first-child .list-group-item:first-child {
  border-top-left-radius: 0.25rem;
  border-top-right-radius: 0.25rem;
}
.card > .list-group:last-child .list-group-item:last-child {
  border-bottom-right-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}
.card .card-header + .list-group > .list-group-item:first-child {
  border-top: 0;
}

.card-header {
  padding: 0.75rem 1.25rem;
  margin-bottom: 0;
  background-color: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid rgba(0, 0, 0, 0.125);
}
.card-header:first-child {
  border-radius: calc(0.25rem - 1px) calc(0.25rem - 1px) 0 0;
}

.card-footer {
  padding: 0.75rem 1.25rem;
  background-color: rgba(0, 0, 0, 0.03);
  border-top: 1px solid rgba(0, 0, 0, 0.125);
}
.card-footer:last-child {
  border-radius: 0 0 calc(0.25rem - 1px) calc(0.25rem - 1px);
}

.card-header-tabs {
  margin-right: -0.625rem;
  margin-bottom: -0.75rem;
  margin-left: -0.625rem;
  border-bottom: 0;
}

.card-header-pills {
  margin-right: -0.625rem;
  margin-left: -0.625rem;
}

.card-img-overlay {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  padding: 1.25rem;
}

.card-img {
  width: 100%;
  border-radius: calc(0.25rem - 1px);
}

.card-img-top {
  width: 100%;
  border-top-left-radius: calc(0.25rem - 1px);
  border-top-right-radius: calc(0.25rem - 1px);
}

.card-img-bottom {
  width: 100%;
  border-bottom-right-radius: calc(0.25rem - 1px);
  border-bottom-left-radius: calc(0.25rem - 1px);
}

.card-deck {
  display: flex;
  flex-direction: column;
}
.card-deck .card {
  margin-bottom: 15px;
}
@media (min-width: 576px) {
  .card-deck {
    flex-flow: row wrap;
    margin-right: -15px;
    margin-left: -15px;
  }
  .card-deck .card {
    display: flex;
    flex: 1 0 0%;
    flex-direction: column;
    margin-right: 15px;
    margin-bottom: 0;
    margin-left: 15px;
  }
}

.card-group {
  display: flex;
  flex-direction: column;
}
.card-group .card {
  margin-bottom: 15px;
}
@media (min-width: 576px) {
  .card-group {
    flex-flow: row wrap;
  }
  .card-group .card {
    flex: 1 0 0%;
    margin-bottom: 0;
  }
  .card-group .card + .card {
    margin-left: 0;
    border-left: 0;
  }
  .card-group .card:first-child {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }
  .card-group .card:first-child .card-img-top {
    border-top-right-radius: 0;
  }
  .card-group .card:first-child .card-img-bottom {
    border-bottom-right-radius: 0;
  }
  .card-group .card:last-child {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }
  .card-group .card:last-child .card-img-top {
    border-top-left-radius: 0;
  }
  .card-group .card:last-child .card-img-bottom {
    border-bottom-left-radius: 0;
  }
  .card-group .card:not(:first-child):not(:last-child) {
    border-radius: 0;
  }
  .card-group .card:not(:first-child):not(:last-child) .card-img-top,
.card-group .card:not(:first-child):not(:last-child) .card-img-bottom {
    border-radius: 0;
  }
}

.card-columns .card {
  margin-bottom: 0.75rem;
}
@media (min-width: 576px) {
  .card-columns {
    column-count: 3;
    column-gap: 1.25rem;
  }
  .card-columns .card {
    display: inline-block;
    width: 100%;
  }
}

.breadcrumb {
  display: flex;
  flex-wrap: wrap;
  padding: 0.75rem 1rem;
  margin-bottom: 1rem;
  list-style: none;
  background-color: #e9ecef;
  border-radius: 0.25rem;
}

.breadcrumb-item + .breadcrumb-item::before {
  display: inline-block;
  padding-right: 0.5rem;
  padding-left: 0.5rem;
  color: #868e96;
  content: "/";
}
.breadcrumb-item + .breadcrumb-item:hover::before {
  text-decoration: underline;
}
.breadcrumb-item + .breadcrumb-item:hover::before {
  text-decoration: none;
}
.breadcrumb-item.active {
  color: #868e96;
}

.pagination {
  display: flex;
  padding-left: 0;
  list-style: none;
  border-radius: 0.25rem;
}

.page-item:first-child .page-link {
  margin-left: 0;
  border-top-left-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}
.page-item:last-child .page-link {
  border-top-right-radius: 0.25rem;
  border-bottom-right-radius: 0.25rem;
}
.page-item.active .page-link {
  z-index: 2;
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}
.page-item.disabled .page-link {
  color: #868e96;
  pointer-events: none;
  background-color: #fff;
  border-color: #ddd;
}

.page-link {
  position: relative;
  display: block;
  padding: 0.5rem 0.75rem;
  margin-left: -1px;
  line-height: 1.25;
  color: #03a9f4;
  background-color: #fff;
  border: 1px solid #ddd;
}
.page-link:focus, .page-link:hover {
  color: #0275a8;
  text-decoration: none;
  background-color: #e9ecef;
  border-color: #ddd;
}

.pagination-lg .page-link {
  padding: 0.75rem 1.5rem;
  font-size: 1.25rem;
  line-height: 1.5;
}
.pagination-lg .page-item:first-child .page-link {
  border-top-left-radius: 0.3rem;
  border-bottom-left-radius: 0.3rem;
}
.pagination-lg .page-item:last-child .page-link {
  border-top-right-radius: 0.3rem;
  border-bottom-right-radius: 0.3rem;
}

.pagination-sm .page-link {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
}
.pagination-sm .page-item:first-child .page-link {
  border-top-left-radius: 0.2rem;
  border-bottom-left-radius: 0.2rem;
}
.pagination-sm .page-item:last-child .page-link {
  border-top-right-radius: 0.2rem;
  border-bottom-right-radius: 0.2rem;
}

.badge {
  display: inline-block;
  padding: 0.25em 0.4em;
  font-size: 75%;
  font-weight: bold;
  line-height: 1;
  text-align: center;
  white-space: nowrap;
  vertical-align: baseline;
  border-radius: 0.25rem;
}
.badge:empty {
  display: none;
}

.btn .badge {
  position: relative;
  top: -1px;
}

.badge-pill {
  padding-right: 0.6em;
  padding-left: 0.6em;
  border-radius: 10rem;
}

.badge-primary {
  color: #fff;
  background-color: #03a9f4;
}
.badge-primary[href]:focus, .badge-primary[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #0286c2;
}

.badge-secondary {
  color: #fff;
  background-color: #868e96;
}
.badge-secondary[href]:focus, .badge-secondary[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #6c757d;
}

.badge-success {
  color: #111;
  background-color: #7dc855;
}
.badge-success[href]:focus, .badge-success[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #63b139;
}

.badge-info {
  color: #111;
  background-color: #78BCEE;
}
.badge-info[href]:focus, .badge-info[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #4ba6e8;
}

.badge-warning {
  color: #111;
  background-color: #FCCE54;
}
.badge-warning[href]:focus, .badge-warning[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #fbc022;
}

.badge-danger {
  color: #fff;
  background-color: #ED5564;
}
.badge-danger[href]:focus, .badge-danger[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #e8273a;
}

.badge-light {
  color: #111;
  background-color: #f8f9fa;
}
.badge-light[href]:focus, .badge-light[href]:hover {
  color: #111;
  text-decoration: none;
  background-color: #dae0e5;
}

.badge-dark {
  color: #fff;
  background-color: #343a40;
}
.badge-dark[href]:focus, .badge-dark[href]:hover {
  color: #fff;
  text-decoration: none;
  background-color: #1d2124;
}

.jumbotron {
  padding: 2rem 1rem;
  margin-bottom: 2rem;
  background-color: #e9ecef;
  border-radius: 0.3rem;
}
@media (min-width: 576px) {
  .jumbotron {
    padding: 4rem 2rem;
  }
}

.jumbotron-fluid {
  padding-right: 0;
  padding-left: 0;
  border-radius: 0;
}

.alert {
  padding: 0.75rem 1.25rem;
  margin-bottom: 1rem;
  border: 1px solid transparent;
  border-radius: 0.25rem;
}

.alert-heading {
  color: inherit;
}

.alert-link {
  font-weight: bold;
}

.alert-dismissible .close {
  position: relative;
  top: -0.75rem;
  right: -1.25rem;
  padding: 0.75rem 1.25rem;
  color: inherit;
}

.alert-primary {
  color: #02587f;
  background-color: #cdeefd;
  border-color: #b8e7fc;
}
.alert-primary hr {
  border-top-color: #a0dffb;
}
.alert-primary .alert-link {
  color: #01354d;
}

.alert-secondary {
  color: #464a4e;
  background-color: #e7e8ea;
  border-color: #dddfe2;
}
.alert-secondary hr {
  border-top-color: #cfd2d6;
}
.alert-secondary .alert-link {
  color: #2e3133;
}

.alert-success {
  color: #41682c;
  background-color: #e5f4dd;
  border-color: #dbf0cf;
}
.alert-success hr {
  border-top-color: #cceabc;
}
.alert-success .alert-link {
  color: #2b441d;
}

.alert-info {
  color: #3e627c;
  background-color: #e4f2fc;
  border-color: #d9ecfa;
}
.alert-info hr {
  border-top-color: #c2e1f7;
}
.alert-info .alert-link {
  color: #2d475a;
}

.alert-warning {
  color: #836b2c;
  background-color: #fef5dd;
  border-color: #fef1cf;
}
.alert-warning hr {
  border-top-color: #fdeab6;
}
.alert-warning .alert-link {
  color: #5d4c1f;
}

.alert-danger {
  color: #7b2c34;
  background-color: #fbdde0;
  border-color: #facfd4;
}
.alert-danger hr {
  border-top-color: #f8b8bf;
}
.alert-danger .alert-link {
  color: #551f24;
}

.alert-light {
  color: #818182;
  background-color: #fefefe;
  border-color: #fdfdfe;
}
.alert-light hr {
  border-top-color: #ececf6;
}
.alert-light .alert-link {
  color: #686868;
}

.alert-dark {
  color: #1b1e21;
  background-color: #d6d8d9;
  border-color: #c6c8ca;
}
.alert-dark hr {
  border-top-color: #b9bbbe;
}
.alert-dark .alert-link {
  color: #040505;
}

@keyframes progress-bar-stripes {
  from {
    background-position: 1rem 0;
  }
  to {
    background-position: 0 0;
  }
}
.progress {
  display: flex;
  height: 1rem;
  overflow: hidden;
  font-size: 0.75rem;
  background-color: #e9ecef;
  border-radius: 0.25rem;
}

.progress-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  background-color: #03a9f4;
}

.progress-bar-striped {
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-size: 1rem 1rem;
}

.progress-bar-animated {
  animation: progress-bar-stripes 1s linear infinite;
}

.media {
  display: flex;
  align-items: flex-start;
}

.media-body {
  flex: 1;
}

.list-group {
  display: flex;
  flex-direction: column;
  padding-left: 0;
  margin-bottom: 0;
}

.list-group-item-action {
  width: 100%;
  color: #495057;
  text-align: inherit;
}
.list-group-item-action:focus, .list-group-item-action:hover {
  color: #495057;
  text-decoration: none;
  background-color: #f8f9fa;
}
.list-group-item-action:active {
  color: #212529;
  background-color: #e9ecef;
}

.list-group-item {
  position: relative;
  display: block;
  padding: 0.75rem 1.25rem;
  margin-bottom: -1px;
  background-color: #fff;
  border: 1px solid rgba(0, 0, 0, 0.125);
}
.list-group-item:first-child {
  border-top-left-radius: 0.25rem;
  border-top-right-radius: 0.25rem;
}
.list-group-item:last-child {
  margin-bottom: 0;
  border-bottom-right-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}
.list-group-item:focus, .list-group-item:hover {
  text-decoration: none;
}
.list-group-item.disabled, .list-group-item:disabled {
  color: #868e96;
  background-color: #fff;
}
.list-group-item.active {
  z-index: 2;
  color: #fff;
  background-color: #03a9f4;
  border-color: #03a9f4;
}

.list-group-flush .list-group-item {
  border-right: 0;
  border-left: 0;
  border-radius: 0;
}
.list-group-flush:first-child .list-group-item:first-child {
  border-top: 0;
}
.list-group-flush:last-child .list-group-item:last-child {
  border-bottom: 0;
}

.list-group-item-primary {
  color: #02587f;
  background-color: #b8e7fc;
}

a.list-group-item-primary,
button.list-group-item-primary {
  color: #02587f;
}
a.list-group-item-primary:focus, a.list-group-item-primary:hover,
button.list-group-item-primary:focus,
button.list-group-item-primary:hover {
  color: #02587f;
  background-color: #a0dffb;
}
a.list-group-item-primary.active,
button.list-group-item-primary.active {
  color: #fff;
  background-color: #02587f;
  border-color: #02587f;
}

.list-group-item-secondary {
  color: #464a4e;
  background-color: #dddfe2;
}

a.list-group-item-secondary,
button.list-group-item-secondary {
  color: #464a4e;
}
a.list-group-item-secondary:focus, a.list-group-item-secondary:hover,
button.list-group-item-secondary:focus,
button.list-group-item-secondary:hover {
  color: #464a4e;
  background-color: #cfd2d6;
}
a.list-group-item-secondary.active,
button.list-group-item-secondary.active {
  color: #fff;
  background-color: #464a4e;
  border-color: #464a4e;
}

.list-group-item-success {
  color: #41682c;
  background-color: #dbf0cf;
}

a.list-group-item-success,
button.list-group-item-success {
  color: #41682c;
}
a.list-group-item-success:focus, a.list-group-item-success:hover,
button.list-group-item-success:focus,
button.list-group-item-success:hover {
  color: #41682c;
  background-color: #cceabc;
}
a.list-group-item-success.active,
button.list-group-item-success.active {
  color: #fff;
  background-color: #41682c;
  border-color: #41682c;
}

.list-group-item-info {
  color: #3e627c;
  background-color: #d9ecfa;
}

a.list-group-item-info,
button.list-group-item-info {
  color: #3e627c;
}
a.list-group-item-info:focus, a.list-group-item-info:hover,
button.list-group-item-info:focus,
button.list-group-item-info:hover {
  color: #3e627c;
  background-color: #c2e1f7;
}
a.list-group-item-info.active,
button.list-group-item-info.active {
  color: #fff;
  background-color: #3e627c;
  border-color: #3e627c;
}

.list-group-item-warning {
  color: #836b2c;
  background-color: #fef1cf;
}

a.list-group-item-warning,
button.list-group-item-warning {
  color: #836b2c;
}
a.list-group-item-warning:focus, a.list-group-item-warning:hover,
button.list-group-item-warning:focus,
button.list-group-item-warning:hover {
  color: #836b2c;
  background-color: #fdeab6;
}
a.list-group-item-warning.active,
button.list-group-item-warning.active {
  color: #fff;
  background-color: #836b2c;
  border-color: #836b2c;
}

.list-group-item-danger {
  color: #7b2c34;
  background-color: #facfd4;
}

a.list-group-item-danger,
button.list-group-item-danger {
  color: #7b2c34;
}
a.list-group-item-danger:focus, a.list-group-item-danger:hover,
button.list-group-item-danger:focus,
button.list-group-item-danger:hover {
  color: #7b2c34;
  background-color: #f8b8bf;
}
a.list-group-item-danger.active,
button.list-group-item-danger.active {
  color: #fff;
  background-color: #7b2c34;
  border-color: #7b2c34;
}

.list-group-item-light {
  color: #818182;
  background-color: #fdfdfe;
}

a.list-group-item-light,
button.list-group-item-light {
  color: #818182;
}
a.list-group-item-light:focus, a.list-group-item-light:hover,
button.list-group-item-light:focus,
button.list-group-item-light:hover {
  color: #818182;
  background-color: #ececf6;
}
a.list-group-item-light.active,
button.list-group-item-light.active {
  color: #fff;
  background-color: #818182;
  border-color: #818182;
}

.list-group-item-dark {
  color: #1b1e21;
  background-color: #c6c8ca;
}

a.list-group-item-dark,
button.list-group-item-dark {
  color: #1b1e21;
}
a.list-group-item-dark:focus, a.list-group-item-dark:hover,
button.list-group-item-dark:focus,
button.list-group-item-dark:hover {
  color: #1b1e21;
  background-color: #b9bbbe;
}
a.list-group-item-dark.active,
button.list-group-item-dark.active {
  color: #fff;
  background-color: #1b1e21;
  border-color: #1b1e21;
}

.close {
  float: right;
  font-size: 1.5rem;
  font-weight: bold;
  line-height: 1;
  color: #000;
  text-shadow: 0 1px 0 #fff;
  opacity: 0.5;
}
.close:focus, .close:hover {
  color: #000;
  text-decoration: none;
  opacity: 0.75;
}

button.close {
  padding: 0;
  background: transparent;
  border: 0;
  -webkit-appearance: none;
}

.modal-open {
  overflow: hidden;
}

.modal {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1050;
  display: none;
  overflow: hidden;
  outline: 0;
}
.modal.fade .modal-dialog {
  transition: transform 0.3s ease-out;
  transform: translate(0, -25%);
}
.modal.show .modal-dialog {
  transform: translate(0, 0);
}

.modal-open .modal {
  overflow-x: hidden;
  overflow-y: auto;
}

.modal-dialog {
  position: relative;
  width: auto;
  margin: 10px;
  pointer-events: none;
}

.modal-content {
  position: relative;
  display: flex;
  flex-direction: column;
  pointer-events: auto;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 0.3rem;
  outline: 0;
}

.modal-backdrop {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1040;
  background-color: #000;
}
.modal-backdrop.fade {
  opacity: 0;
}
.modal-backdrop.show {
  opacity: 0.5;
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 15px;
  border-bottom: 1px solid #e9ecef;
}
.modal-header .close {
  margin-left: auto;
}

.modal-title {
  margin-bottom: 0;
  line-height: 1.5;
}

.modal-body {
  position: relative;
  flex: 1 1 auto;
  padding: 15px;
}

.modal-footer {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 15px;
  border-top: 1px solid #e9ecef;
}
.modal-footer > :not(:first-child) {
  margin-left: 0.25rem;
}
.modal-footer > :not(:last-child) {
  margin-right: 0.25rem;
}

.modal-scrollbar-measure {
  position: absolute;
  top: -9999px;
  width: 50px;
  height: 50px;
  overflow: scroll;
}

@media (min-width: 576px) {
  .modal-dialog {
    max-width: 500px;
    margin: 30px auto;
  }

  .modal-sm {
    max-width: 300px;
  }
}
@media (min-width: 992px) {
  .modal-lg {
    max-width: 800px;
  }
}
.tooltip {
  position: absolute;
  z-index: 1070;
  display: block;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-style: normal;
  font-weight: normal;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: 0.875rem;
  word-wrap: break-word;
  opacity: 0;
}
.tooltip.show {
  opacity: 0.9;
}
.tooltip .arrow {
  position: absolute;
  display: block;
  width: 5px;
  height: 5px;
}
.tooltip.bs-tooltip-top, .tooltip.bs-tooltip-auto[x-placement^=top] {
  padding: 5px 0;
}
.tooltip.bs-tooltip-top .arrow, .tooltip.bs-tooltip-auto[x-placement^=top] .arrow {
  bottom: 0;
}
.tooltip.bs-tooltip-top .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=top] .arrow::before {
  margin-left: -3px;
  content: "";
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.bs-tooltip-right, .tooltip.bs-tooltip-auto[x-placement^=right] {
  padding: 0 5px;
}
.tooltip.bs-tooltip-right .arrow, .tooltip.bs-tooltip-auto[x-placement^=right] .arrow {
  left: 0;
}
.tooltip.bs-tooltip-right .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=right] .arrow::before {
  margin-top: -3px;
  content: "";
  border-width: 5px 5px 5px 0;
  border-right-color: #000;
}
.tooltip.bs-tooltip-bottom, .tooltip.bs-tooltip-auto[x-placement^=bottom] {
  padding: 5px 0;
}
.tooltip.bs-tooltip-bottom .arrow, .tooltip.bs-tooltip-auto[x-placement^=bottom] .arrow {
  top: 0;
}
.tooltip.bs-tooltip-bottom .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=bottom] .arrow::before {
  margin-left: -3px;
  content: "";
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.tooltip.bs-tooltip-left, .tooltip.bs-tooltip-auto[x-placement^=left] {
  padding: 0 5px;
}
.tooltip.bs-tooltip-left .arrow, .tooltip.bs-tooltip-auto[x-placement^=left] .arrow {
  right: 0;
}
.tooltip.bs-tooltip-left .arrow::before, .tooltip.bs-tooltip-auto[x-placement^=left] .arrow::before {
  right: 0;
  margin-top: -3px;
  content: "";
  border-width: 5px 0 5px 5px;
  border-left-color: #000;
}
.tooltip .arrow::before {
  position: absolute;
  border-color: transparent;
  border-style: solid;
}

.tooltip-inner {
  max-width: 200px;
  padding: 3px 8px;
  color: #fff;
  text-align: center;
  background-color: #000;
  border-radius: 0.25rem;
}

.popover {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1060;
  display: block;
  max-width: 276px;
  padding: 1px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-style: normal;
  font-weight: normal;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: 0.875rem;
  word-wrap: break-word;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 0.3rem;
}
.popover .arrow {
  position: absolute;
  display: block;
  width: 10px;
  height: 5px;
}
.popover .arrow::before,
.popover .arrow::after {
  position: absolute;
  display: block;
  border-color: transparent;
  border-style: solid;
}
.popover .arrow::before {
  content: "";
  border-width: 11px;
}
.popover .arrow::after {
  content: "";
  border-width: 11px;
}
.popover.bs-popover-top, .popover.bs-popover-auto[x-placement^=top] {
  margin-bottom: 10px;
}
.popover.bs-popover-top .arrow, .popover.bs-popover-auto[x-placement^=top] .arrow {
  bottom: 0;
}
.popover.bs-popover-top .arrow::before, .popover.bs-popover-auto[x-placement^=top] .arrow::before,
.popover.bs-popover-top .arrow::after,
.popover.bs-popover-auto[x-placement^=top] .arrow::after {
  border-bottom-width: 0;
}
.popover.bs-popover-top .arrow::before, .popover.bs-popover-auto[x-placement^=top] .arrow::before {
  bottom: -11px;
  margin-left: -6px;
  border-top-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-top .arrow::after, .popover.bs-popover-auto[x-placement^=top] .arrow::after {
  bottom: -10px;
  margin-left: -6px;
  border-top-color: #fff;
}
.popover.bs-popover-right, .popover.bs-popover-auto[x-placement^=right] {
  margin-left: 10px;
}
.popover.bs-popover-right .arrow, .popover.bs-popover-auto[x-placement^=right] .arrow {
  left: 0;
}
.popover.bs-popover-right .arrow::before, .popover.bs-popover-auto[x-placement^=right] .arrow::before,
.popover.bs-popover-right .arrow::after,
.popover.bs-popover-auto[x-placement^=right] .arrow::after {
  margin-top: -8px;
  border-left-width: 0;
}
.popover.bs-popover-right .arrow::before, .popover.bs-popover-auto[x-placement^=right] .arrow::before {
  left: -11px;
  border-right-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-right .arrow::after, .popover.bs-popover-auto[x-placement^=right] .arrow::after {
  left: -10px;
  border-right-color: #fff;
}
.popover.bs-popover-bottom, .popover.bs-popover-auto[x-placement^=bottom] {
  margin-top: 10px;
}
.popover.bs-popover-bottom .arrow, .popover.bs-popover-auto[x-placement^=bottom] .arrow {
  top: 0;
}
.popover.bs-popover-bottom .arrow::before, .popover.bs-popover-auto[x-placement^=bottom] .arrow::before,
.popover.bs-popover-bottom .arrow::after,
.popover.bs-popover-auto[x-placement^=bottom] .arrow::after {
  margin-left: -7px;
  border-top-width: 0;
}
.popover.bs-popover-bottom .arrow::before, .popover.bs-popover-auto[x-placement^=bottom] .arrow::before {
  top: -11px;
  border-bottom-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-bottom .arrow::after, .popover.bs-popover-auto[x-placement^=bottom] .arrow::after {
  top: -10px;
  border-bottom-color: #fff;
}
.popover.bs-popover-bottom .popover-header::before, .popover.bs-popover-auto[x-placement^=bottom] .popover-header::before {
  position: absolute;
  top: 0;
  left: 50%;
  display: block;
  width: 20px;
  margin-left: -10px;
  content: "";
  border-bottom: 1px solid #f7f7f7;
}
.popover.bs-popover-left, .popover.bs-popover-auto[x-placement^=left] {
  margin-right: 10px;
}
.popover.bs-popover-left .arrow, .popover.bs-popover-auto[x-placement^=left] .arrow {
  right: 0;
}
.popover.bs-popover-left .arrow::before, .popover.bs-popover-auto[x-placement^=left] .arrow::before,
.popover.bs-popover-left .arrow::after,
.popover.bs-popover-auto[x-placement^=left] .arrow::after {
  margin-top: -8px;
  border-right-width: 0;
}
.popover.bs-popover-left .arrow::before, .popover.bs-popover-auto[x-placement^=left] .arrow::before {
  right: -11px;
  border-left-color: rgba(0, 0, 0, 0.25);
}
.popover.bs-popover-left .arrow::after, .popover.bs-popover-auto[x-placement^=left] .arrow::after {
  right: -10px;
  border-left-color: #fff;
}
.popover-header {
  padding: 8px 14px;
  margin-bottom: 0;
  font-size: 1rem;
  color: inherit;
  background-color: #f7f7f7;
  border-bottom: 1px solid #ebebeb;
  border-top-left-radius: calc(0.3rem - 1px);
  border-top-right-radius: calc(0.3rem - 1px);
}
.popover-header:empty {
  display: none;
}

.popover-body {
  padding: 9px 14px;
  color: #212529;
}

.carousel {
  position: relative;
}

.carousel-inner {
  position: relative;
  width: 100%;
  overflow: hidden;
}

.carousel-item {
  position: relative;
  display: none;
  align-items: center;
  width: 100%;
  transition: transform 0.6s ease;
  backface-visibility: hidden;
  perspective: 1000px;
}

.carousel-item.active,
.carousel-item-next,
.carousel-item-prev {
  display: block;
}

.carousel-item-next,
.carousel-item-prev {
  position: absolute;
  top: 0;
}

.carousel-item-next.carousel-item-left,
.carousel-item-prev.carousel-item-right {
  transform: translateX(0);
}
@supports (transform-style: preserve-3d) {
  .carousel-item-next.carousel-item-left,
.carousel-item-prev.carousel-item-right {
    transform: translate3d(0, 0, 0);
  }
}

.carousel-item-next,
.active.carousel-item-right {
  transform: translateX(100%);
}
@supports (transform-style: preserve-3d) {
  .carousel-item-next,
.active.carousel-item-right {
    transform: translate3d(100%, 0, 0);
  }
}

.carousel-item-prev,
.active.carousel-item-left {
  transform: translateX(-100%);
}
@supports (transform-style: preserve-3d) {
  .carousel-item-prev,
.active.carousel-item-left {
    transform: translate3d(-100%, 0, 0);
  }
}

.carousel-control-prev,
.carousel-control-next {
  position: absolute;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 15%;
  color: #fff;
  text-align: center;
  opacity: 0.5;
}
.carousel-control-prev:focus, .carousel-control-prev:hover,
.carousel-control-next:focus,
.carousel-control-next:hover {
  color: #fff;
  text-decoration: none;
  outline: 0;
  opacity: 0.9;
}

.carousel-control-prev {
  left: 0;
}

.carousel-control-next {
  right: 0;
}

.carousel-control-prev-icon,
.carousel-control-next-icon {
  display: inline-block;
  width: 20px;
  height: 20px;
  background: transparent no-repeat center center;
  background-size: 100% 100%;
}

.carousel-control-prev-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M4 0l-4 4 4 4 1.5-1.5-2.5-2.5 2.5-2.5-1.5-1.5z'/%3E%3C/svg%3E");
}

.carousel-control-next-icon {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M1.5 0l-1.5 1.5 2.5 2.5-2.5 2.5 1.5 1.5 4-4-4-4z'/%3E%3C/svg%3E");
}

.carousel-indicators {
  position: absolute;
  right: 0;
  bottom: 10px;
  left: 0;
  z-index: 15;
  display: flex;
  justify-content: center;
  padding-left: 0;
  margin-right: 15%;
  margin-left: 15%;
  list-style: none;
}
.carousel-indicators li {
  position: relative;
  flex: 0 1 auto;
  width: 30px;
  height: 3px;
  margin-right: 3px;
  margin-left: 3px;
  text-indent: -999px;
  background-color: rgba(255, 255, 255, 0.5);
}
.carousel-indicators li::before {
  position: absolute;
  top: -10px;
  left: 0;
  display: inline-block;
  width: 100%;
  height: 10px;
  content: "";
}
.carousel-indicators li::after {
  position: absolute;
  bottom: -10px;
  left: 0;
  display: inline-block;
  width: 100%;
  height: 10px;
  content: "";
}
.carousel-indicators .active {
  background-color: #fff;
}

.carousel-caption {
  position: absolute;
  right: 15%;
  bottom: 20px;
  left: 15%;
  z-index: 10;
  padding-top: 20px;
  padding-bottom: 20px;
  color: #fff;
  text-align: center;
}

.align-baseline {
  vertical-align: baseline !important;
}

.align-top {
  vertical-align: top !important;
}

.align-middle {
  vertical-align: middle !important;
}

.align-bottom {
  vertical-align: bottom !important;
}

.align-text-bottom {
  vertical-align: text-bottom !important;
}

.align-text-top {
  vertical-align: text-top !important;
}

.bg-primary {
  background-color: #03a9f4 !important;
}

a.bg-primary:focus, a.bg-primary:hover {
  background-color: #0286c2 !important;
}

.bg-secondary {
  background-color: #868e96 !important;
}

a.bg-secondary:focus, a.bg-secondary:hover {
  background-color: #6c757d !important;
}

.bg-success {
  background-color: #7dc855 !important;
}

a.bg-success:focus, a.bg-success:hover {
  background-color: #63b139 !important;
}

.bg-info {
  background-color: #78BCEE !important;
}

a.bg-info:focus, a.bg-info:hover {
  background-color: #4ba6e8 !important;
}

.bg-warning {
  background-color: #FCCE54 !important;
}

a.bg-warning:focus, a.bg-warning:hover {
  background-color: #fbc022 !important;
}

.bg-danger {
  background-color: #ED5564 !important;
}

a.bg-danger:focus, a.bg-danger:hover {
  background-color: #e8273a !important;
}

.bg-light {
  background-color: #f8f9fa !important;
}

a.bg-light:focus, a.bg-light:hover {
  background-color: #dae0e5 !important;
}

.bg-dark {
  background-color: #343a40 !important;
}

a.bg-dark:focus, a.bg-dark:hover {
  background-color: #1d2124 !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-transparent {
  background-color: transparent !important;
}

.border {
  border: 1px solid #e9ecef !important;
}

.border-0 {
  border: 0 !important;
}

.border-top-0 {
  border-top: 0 !important;
}

.border-right-0 {
  border-right: 0 !important;
}

.border-bottom-0 {
  border-bottom: 0 !important;
}

.border-left-0 {
  border-left: 0 !important;
}

.border-primary {
  border-color: #03a9f4 !important;
}

.border-secondary {
  border-color: #868e96 !important;
}

.border-success {
  border-color: #7dc855 !important;
}

.border-info {
  border-color: #78BCEE !important;
}

.border-warning {
  border-color: #FCCE54 !important;
}

.border-danger {
  border-color: #ED5564 !important;
}

.border-light {
  border-color: #f8f9fa !important;
}

.border-dark {
  border-color: #343a40 !important;
}

.border-white {
  border-color: #fff !important;
}

.rounded {
  border-radius: 0.25rem !important;
}

.rounded-top {
  border-top-left-radius: 0.25rem !important;
  border-top-right-radius: 0.25rem !important;
}

.rounded-right {
  border-top-right-radius: 0.25rem !important;
  border-bottom-right-radius: 0.25rem !important;
}

.rounded-bottom {
  border-bottom-right-radius: 0.25rem !important;
  border-bottom-left-radius: 0.25rem !important;
}

.rounded-left {
  border-top-left-radius: 0.25rem !important;
  border-bottom-left-radius: 0.25rem !important;
}

.rounded-circle {
  border-radius: 50% !important;
}

.rounded-0 {
  border-radius: 0 !important;
}

.clearfix::after {
  display: block;
  clear: both;
  content: "";
}

.d-none {
  display: none !important;
}

.d-inline {
  display: inline !important;
}

.d-inline-block {
  display: inline-block !important;
}

.d-block {
  display: block !important;
}

.d-table {
  display: table !important;
}

.d-table-cell {
  display: table-cell !important;
}

.d-flex {
  display: flex !important;
}

.d-inline-flex {
  display: inline-flex !important;
}

@media (min-width: 576px) {
  .d-sm-none {
    display: none !important;
  }

  .d-sm-inline {
    display: inline !important;
  }

  .d-sm-inline-block {
    display: inline-block !important;
  }

  .d-sm-block {
    display: block !important;
  }

  .d-sm-table {
    display: table !important;
  }

  .d-sm-table-cell {
    display: table-cell !important;
  }

  .d-sm-flex {
    display: flex !important;
  }

  .d-sm-inline-flex {
    display: inline-flex !important;
  }
}
@media (min-width: 768px) {
  .d-md-none {
    display: none !important;
  }

  .d-md-inline {
    display: inline !important;
  }

  .d-md-inline-block {
    display: inline-block !important;
  }

  .d-md-block {
    display: block !important;
  }

  .d-md-table {
    display: table !important;
  }

  .d-md-table-cell {
    display: table-cell !important;
  }

  .d-md-flex {
    display: flex !important;
  }

  .d-md-inline-flex {
    display: inline-flex !important;
  }
}
@media (min-width: 992px) {
  .d-lg-none {
    display: none !important;
  }

  .d-lg-inline {
    display: inline !important;
  }

  .d-lg-inline-block {
    display: inline-block !important;
  }

  .d-lg-block {
    display: block !important;
  }

  .d-lg-table {
    display: table !important;
  }

  .d-lg-table-cell {
    display: table-cell !important;
  }

  .d-lg-flex {
    display: flex !important;
  }

  .d-lg-inline-flex {
    display: inline-flex !important;
  }
}
@media (min-width: 1200px) {
  .d-xl-none {
    display: none !important;
  }

  .d-xl-inline {
    display: inline !important;
  }

  .d-xl-inline-block {
    display: inline-block !important;
  }

  .d-xl-block {
    display: block !important;
  }

  .d-xl-table {
    display: table !important;
  }

  .d-xl-table-cell {
    display: table-cell !important;
  }

  .d-xl-flex {
    display: flex !important;
  }

  .d-xl-inline-flex {
    display: inline-flex !important;
  }
}
.d-print-block {
  display: none !important;
}
@media print {
  .d-print-block {
    display: block !important;
  }
}

.d-print-inline {
  display: none !important;
}
@media print {
  .d-print-inline {
    display: inline !important;
  }
}

.d-print-inline-block {
  display: none !important;
}
@media print {
  .d-print-inline-block {
    display: inline-block !important;
  }
}

@media print {
  .d-print-none {
    display: none !important;
  }
}

.embed-responsive {
  position: relative;
  display: block;
  width: 100%;
  padding: 0;
  overflow: hidden;
}
.embed-responsive::before {
  display: block;
  content: "";
}
.embed-responsive .embed-responsive-item,
.embed-responsive iframe,
.embed-responsive embed,
.embed-responsive object,
.embed-responsive video {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 0;
}

.embed-responsive-21by9::before {
  padding-top: 42.8571428571%;
}

.embed-responsive-16by9::before {
  padding-top: 56.25%;
}

.embed-responsive-4by3::before {
  padding-top: 75%;
}

.embed-responsive-1by1::before {
  padding-top: 100%;
}

.flex-row {
  flex-direction: row !important;
}

.flex-column {
  flex-direction: column !important;
}

.flex-row-reverse {
  flex-direction: row-reverse !important;
}

.flex-column-reverse {
  flex-direction: column-reverse !important;
}

.flex-wrap {
  flex-wrap: wrap !important;
}

.flex-nowrap {
  flex-wrap: nowrap !important;
}

.flex-wrap-reverse {
  flex-wrap: wrap-reverse !important;
}

.justify-content-start {
  justify-content: flex-start !important;
}

.justify-content-end {
  justify-content: flex-end !important;
}

.justify-content-center {
  justify-content: center !important;
}

.justify-content-between {
  justify-content: space-between !important;
}

.justify-content-around {
  justify-content: space-around !important;
}

.align-items-start {
  align-items: flex-start !important;
}

.align-items-end {
  align-items: flex-end !important;
}

.align-items-center {
  align-items: center !important;
}

.align-items-baseline {
  align-items: baseline !important;
}

.align-items-stretch {
  align-items: stretch !important;
}

.align-content-start {
  align-content: flex-start !important;
}

.align-content-end {
  align-content: flex-end !important;
}

.align-content-center {
  align-content: center !important;
}

.align-content-between {
  align-content: space-between !important;
}

.align-content-around {
  align-content: space-around !important;
}

.align-content-stretch {
  align-content: stretch !important;
}

.align-self-auto {
  align-self: auto !important;
}

.align-self-start {
  align-self: flex-start !important;
}

.align-self-end {
  align-self: flex-end !important;
}

.align-self-center {
  align-self: center !important;
}

.align-self-baseline {
  align-self: baseline !important;
}

.align-self-stretch {
  align-self: stretch !important;
}

@media (min-width: 576px) {
  .flex-sm-row {
    flex-direction: row !important;
  }

  .flex-sm-column {
    flex-direction: column !important;
  }

  .flex-sm-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-sm-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-sm-wrap {
    flex-wrap: wrap !important;
  }

  .flex-sm-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-sm-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-sm-start {
    justify-content: flex-start !important;
  }

  .justify-content-sm-end {
    justify-content: flex-end !important;
  }

  .justify-content-sm-center {
    justify-content: center !important;
  }

  .justify-content-sm-between {
    justify-content: space-between !important;
  }

  .justify-content-sm-around {
    justify-content: space-around !important;
  }

  .align-items-sm-start {
    align-items: flex-start !important;
  }

  .align-items-sm-end {
    align-items: flex-end !important;
  }

  .align-items-sm-center {
    align-items: center !important;
  }

  .align-items-sm-baseline {
    align-items: baseline !important;
  }

  .align-items-sm-stretch {
    align-items: stretch !important;
  }

  .align-content-sm-start {
    align-content: flex-start !important;
  }

  .align-content-sm-end {
    align-content: flex-end !important;
  }

  .align-content-sm-center {
    align-content: center !important;
  }

  .align-content-sm-between {
    align-content: space-between !important;
  }

  .align-content-sm-around {
    align-content: space-around !important;
  }

  .align-content-sm-stretch {
    align-content: stretch !important;
  }

  .align-self-sm-auto {
    align-self: auto !important;
  }

  .align-self-sm-start {
    align-self: flex-start !important;
  }

  .align-self-sm-end {
    align-self: flex-end !important;
  }

  .align-self-sm-center {
    align-self: center !important;
  }

  .align-self-sm-baseline {
    align-self: baseline !important;
  }

  .align-self-sm-stretch {
    align-self: stretch !important;
  }
}
@media (min-width: 768px) {
  .flex-md-row {
    flex-direction: row !important;
  }

  .flex-md-column {
    flex-direction: column !important;
  }

  .flex-md-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-md-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-md-wrap {
    flex-wrap: wrap !important;
  }

  .flex-md-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-md-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-md-start {
    justify-content: flex-start !important;
  }

  .justify-content-md-end {
    justify-content: flex-end !important;
  }

  .justify-content-md-center {
    justify-content: center !important;
  }

  .justify-content-md-between {
    justify-content: space-between !important;
  }

  .justify-content-md-around {
    justify-content: space-around !important;
  }

  .align-items-md-start {
    align-items: flex-start !important;
  }

  .align-items-md-end {
    align-items: flex-end !important;
  }

  .align-items-md-center {
    align-items: center !important;
  }

  .align-items-md-baseline {
    align-items: baseline !important;
  }

  .align-items-md-stretch {
    align-items: stretch !important;
  }

  .align-content-md-start {
    align-content: flex-start !important;
  }

  .align-content-md-end {
    align-content: flex-end !important;
  }

  .align-content-md-center {
    align-content: center !important;
  }

  .align-content-md-between {
    align-content: space-between !important;
  }

  .align-content-md-around {
    align-content: space-around !important;
  }

  .align-content-md-stretch {
    align-content: stretch !important;
  }

  .align-self-md-auto {
    align-self: auto !important;
  }

  .align-self-md-start {
    align-self: flex-start !important;
  }

  .align-self-md-end {
    align-self: flex-end !important;
  }

  .align-self-md-center {
    align-self: center !important;
  }

  .align-self-md-baseline {
    align-self: baseline !important;
  }

  .align-self-md-stretch {
    align-self: stretch !important;
  }
}
@media (min-width: 992px) {
  .flex-lg-row {
    flex-direction: row !important;
  }

  .flex-lg-column {
    flex-direction: column !important;
  }

  .flex-lg-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-lg-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-lg-wrap {
    flex-wrap: wrap !important;
  }

  .flex-lg-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-lg-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-lg-start {
    justify-content: flex-start !important;
  }

  .justify-content-lg-end {
    justify-content: flex-end !important;
  }

  .justify-content-lg-center {
    justify-content: center !important;
  }

  .justify-content-lg-between {
    justify-content: space-between !important;
  }

  .justify-content-lg-around {
    justify-content: space-around !important;
  }

  .align-items-lg-start {
    align-items: flex-start !important;
  }

  .align-items-lg-end {
    align-items: flex-end !important;
  }

  .align-items-lg-center {
    align-items: center !important;
  }

  .align-items-lg-baseline {
    align-items: baseline !important;
  }

  .align-items-lg-stretch {
    align-items: stretch !important;
  }

  .align-content-lg-start {
    align-content: flex-start !important;
  }

  .align-content-lg-end {
    align-content: flex-end !important;
  }

  .align-content-lg-center {
    align-content: center !important;
  }

  .align-content-lg-between {
    align-content: space-between !important;
  }

  .align-content-lg-around {
    align-content: space-around !important;
  }

  .align-content-lg-stretch {
    align-content: stretch !important;
  }

  .align-self-lg-auto {
    align-self: auto !important;
  }

  .align-self-lg-start {
    align-self: flex-start !important;
  }

  .align-self-lg-end {
    align-self: flex-end !important;
  }

  .align-self-lg-center {
    align-self: center !important;
  }

  .align-self-lg-baseline {
    align-self: baseline !important;
  }

  .align-self-lg-stretch {
    align-self: stretch !important;
  }
}
@media (min-width: 1200px) {
  .flex-xl-row {
    flex-direction: row !important;
  }

  .flex-xl-column {
    flex-direction: column !important;
  }

  .flex-xl-row-reverse {
    flex-direction: row-reverse !important;
  }

  .flex-xl-column-reverse {
    flex-direction: column-reverse !important;
  }

  .flex-xl-wrap {
    flex-wrap: wrap !important;
  }

  .flex-xl-nowrap {
    flex-wrap: nowrap !important;
  }

  .flex-xl-wrap-reverse {
    flex-wrap: wrap-reverse !important;
  }

  .justify-content-xl-start {
    justify-content: flex-start !important;
  }

  .justify-content-xl-end {
    justify-content: flex-end !important;
  }

  .justify-content-xl-center {
    justify-content: center !important;
  }

  .justify-content-xl-between {
    justify-content: space-between !important;
  }

  .justify-content-xl-around {
    justify-content: space-around !important;
  }

  .align-items-xl-start {
    align-items: flex-start !important;
  }

  .align-items-xl-end {
    align-items: flex-end !important;
  }

  .align-items-xl-center {
    align-items: center !important;
  }

  .align-items-xl-baseline {
    align-items: baseline !important;
  }

  .align-items-xl-stretch {
    align-items: stretch !important;
  }

  .align-content-xl-start {
    align-content: flex-start !important;
  }

  .align-content-xl-end {
    align-content: flex-end !important;
  }

  .align-content-xl-center {
    align-content: center !important;
  }

  .align-content-xl-between {
    align-content: space-between !important;
  }

  .align-content-xl-around {
    align-content: space-around !important;
  }

  .align-content-xl-stretch {
    align-content: stretch !important;
  }

  .align-self-xl-auto {
    align-self: auto !important;
  }

  .align-self-xl-start {
    align-self: flex-start !important;
  }

  .align-self-xl-end {
    align-self: flex-end !important;
  }

  .align-self-xl-center {
    align-self: center !important;
  }

  .align-self-xl-baseline {
    align-self: baseline !important;
  }

  .align-self-xl-stretch {
    align-self: stretch !important;
  }
}
.float-left {
  float: left !important;
}

.float-right {
  float: right !important;
}

.float-none {
  float: none !important;
}

@media (min-width: 576px) {
  .float-sm-left {
    float: left !important;
  }

  .float-sm-right {
    float: right !important;
  }

  .float-sm-none {
    float: none !important;
  }
}
@media (min-width: 768px) {
  .float-md-left {
    float: left !important;
  }

  .float-md-right {
    float: right !important;
  }

  .float-md-none {
    float: none !important;
  }
}
@media (min-width: 992px) {
  .float-lg-left {
    float: left !important;
  }

  .float-lg-right {
    float: right !important;
  }

  .float-lg-none {
    float: none !important;
  }
}
@media (min-width: 1200px) {
  .float-xl-left {
    float: left !important;
  }

  .float-xl-right {
    float: right !important;
  }

  .float-xl-none {
    float: none !important;
  }
}
.position-static {
  position: static !important;
}

.position-relative {
  position: relative !important;
}

.position-absolute {
  position: absolute !important;
}

.position-fixed {
  position: fixed !important;
}

.position-sticky {
  position: sticky !important;
}

.fixed-top {
  position: fixed;
  top: 0;
  right: 0;
  left: 0;
  z-index: 1030;
}

.fixed-bottom {
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1030;
}

@supports (position: sticky) {
  .sticky-top {
    position: sticky;
    top: 0;
    z-index: 1020;
  }
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  clip-path: inset(50%);
  border: 0;
}

.sr-only-focusable:active, .sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  overflow: visible;
  clip: auto;
  white-space: normal;
  clip-path: none;
}

.w-25 {
  width: 25% !important;
}

.w-50 {
  width: 50% !important;
}

.w-75 {
  width: 75% !important;
}

.w-100 {
  width: 100% !important;
}

.h-25 {
  height: 25% !important;
}

.h-50 {
  height: 50% !important;
}

.h-75 {
  height: 75% !important;
}

.h-100 {
  height: 100% !important;
}

.mw-100 {
  max-width: 100% !important;
}

.mh-100 {
  max-height: 100% !important;
}

.m-0 {
  margin: 0 !important;
}

.mt-0,
.my-0 {
  margin-top: 0 !important;
}

.mr-0,
.mx-0 {
  margin-right: 0 !important;
}

.mb-0,
.my-0 {
  margin-bottom: 0 !important;
}

.ml-0,
.mx-0 {
  margin-left: 0 !important;
}

.m-1 {
  margin: 0.25rem !important;
}

.mt-1,
.my-1 {
  margin-top: 0.25rem !important;
}

.mr-1,
.mx-1 {
  margin-right: 0.25rem !important;
}

.mb-1,
.my-1 {
  margin-bottom: 0.25rem !important;
}

.ml-1,
.mx-1 {
  margin-left: 0.25rem !important;
}

.m-2 {
  margin: 0.5rem !important;
}

.mt-2,
.my-2 {
  margin-top: 0.5rem !important;
}

.mr-2,
.mx-2 {
  margin-right: 0.5rem !important;
}

.mb-2,
.my-2 {
  margin-bottom: 0.5rem !important;
}

.ml-2,
.mx-2 {
  margin-left: 0.5rem !important;
}

.m-3 {
  margin: 1rem !important;
}

.mt-3,
.my-3 {
  margin-top: 1rem !important;
}

.mr-3,
.mx-3 {
  margin-right: 1rem !important;
}

.mb-3,
.my-3 {
  margin-bottom: 1rem !important;
}

.ml-3,
.mx-3 {
  margin-left: 1rem !important;
}

.m-4 {
  margin: 1.5rem !important;
}

.mt-4,
.my-4 {
  margin-top: 1.5rem !important;
}

.mr-4,
.mx-4 {
  margin-right: 1.5rem !important;
}

.mb-4,
.my-4 {
  margin-bottom: 1.5rem !important;
}

.ml-4,
.mx-4 {
  margin-left: 1.5rem !important;
}

.m-5 {
  margin: 3rem !important;
}

.mt-5,
.my-5 {
  margin-top: 3rem !important;
}

.mr-5,
.mx-5 {
  margin-right: 3rem !important;
}

.mb-5,
.my-5 {
  margin-bottom: 3rem !important;
}

.ml-5,
.mx-5 {
  margin-left: 3rem !important;
}

.p-0 {
  padding: 0 !important;
}

.pt-0,
.py-0 {
  padding-top: 0 !important;
}

.pr-0,
.px-0 {
  padding-right: 0 !important;
}

.pb-0,
.py-0 {
  padding-bottom: 0 !important;
}

.pl-0,
.px-0 {
  padding-left: 0 !important;
}

.p-1 {
  padding: 0.25rem !important;
}

.pt-1,
.py-1 {
  padding-top: 0.25rem !important;
}

.pr-1,
.px-1 {
  padding-right: 0.25rem !important;
}

.pb-1,
.py-1 {
  padding-bottom: 0.25rem !important;
}

.pl-1,
.px-1 {
  padding-left: 0.25rem !important;
}

.p-2 {
  padding: 0.5rem !important;
}

.pt-2,
.py-2 {
  padding-top: 0.5rem !important;
}

.pr-2,
.px-2 {
  padding-right: 0.5rem !important;
}

.pb-2,
.py-2 {
  padding-bottom: 0.5rem !important;
}

.pl-2,
.px-2 {
  padding-left: 0.5rem !important;
}

.p-3 {
  padding: 1rem !important;
}

.pt-3,
.py-3 {
  padding-top: 1rem !important;
}

.pr-3,
.px-3 {
  padding-right: 1rem !important;
}

.pb-3,
.py-3 {
  padding-bottom: 1rem !important;
}

.pl-3,
.px-3 {
  padding-left: 1rem !important;
}

.p-4 {
  padding: 1.5rem !important;
}

.pt-4,
.py-4 {
  padding-top: 1.5rem !important;
}

.pr-4,
.px-4 {
  padding-right: 1.5rem !important;
}

.pb-4,
.py-4 {
  padding-bottom: 1.5rem !important;
}

.pl-4,
.px-4 {
  padding-left: 1.5rem !important;
}

.p-5 {
  padding: 3rem !important;
}

.pt-5,
.py-5 {
  padding-top: 3rem !important;
}

.pr-5,
.px-5 {
  padding-right: 3rem !important;
}

.pb-5,
.py-5 {
  padding-bottom: 3rem !important;
}

.pl-5,
.px-5 {
  padding-left: 3rem !important;
}

.m-auto {
  margin: auto !important;
}

.mt-auto,
.my-auto {
  margin-top: auto !important;
}

.mr-auto,
.mx-auto {
  margin-right: auto !important;
}

.mb-auto,
.my-auto {
  margin-bottom: auto !important;
}

.ml-auto,
.mx-auto {
  margin-left: auto !important;
}

@media (min-width: 576px) {
  .m-sm-0 {
    margin: 0 !important;
  }

  .mt-sm-0,
.my-sm-0 {
    margin-top: 0 !important;
  }

  .mr-sm-0,
.mx-sm-0 {
    margin-right: 0 !important;
  }

  .mb-sm-0,
.my-sm-0 {
    margin-bottom: 0 !important;
  }

  .ml-sm-0,
.mx-sm-0 {
    margin-left: 0 !important;
  }

  .m-sm-1 {
    margin: 0.25rem !important;
  }

  .mt-sm-1,
.my-sm-1 {
    margin-top: 0.25rem !important;
  }

  .mr-sm-1,
.mx-sm-1 {
    margin-right: 0.25rem !important;
  }

  .mb-sm-1,
.my-sm-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-sm-1,
.mx-sm-1 {
    margin-left: 0.25rem !important;
  }

  .m-sm-2 {
    margin: 0.5rem !important;
  }

  .mt-sm-2,
.my-sm-2 {
    margin-top: 0.5rem !important;
  }

  .mr-sm-2,
.mx-sm-2 {
    margin-right: 0.5rem !important;
  }

  .mb-sm-2,
.my-sm-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-sm-2,
.mx-sm-2 {
    margin-left: 0.5rem !important;
  }

  .m-sm-3 {
    margin: 1rem !important;
  }

  .mt-sm-3,
.my-sm-3 {
    margin-top: 1rem !important;
  }

  .mr-sm-3,
.mx-sm-3 {
    margin-right: 1rem !important;
  }

  .mb-sm-3,
.my-sm-3 {
    margin-bottom: 1rem !important;
  }

  .ml-sm-3,
.mx-sm-3 {
    margin-left: 1rem !important;
  }

  .m-sm-4 {
    margin: 1.5rem !important;
  }

  .mt-sm-4,
.my-sm-4 {
    margin-top: 1.5rem !important;
  }

  .mr-sm-4,
.mx-sm-4 {
    margin-right: 1.5rem !important;
  }

  .mb-sm-4,
.my-sm-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-sm-4,
.mx-sm-4 {
    margin-left: 1.5rem !important;
  }

  .m-sm-5 {
    margin: 3rem !important;
  }

  .mt-sm-5,
.my-sm-5 {
    margin-top: 3rem !important;
  }

  .mr-sm-5,
.mx-sm-5 {
    margin-right: 3rem !important;
  }

  .mb-sm-5,
.my-sm-5 {
    margin-bottom: 3rem !important;
  }

  .ml-sm-5,
.mx-sm-5 {
    margin-left: 3rem !important;
  }

  .p-sm-0 {
    padding: 0 !important;
  }

  .pt-sm-0,
.py-sm-0 {
    padding-top: 0 !important;
  }

  .pr-sm-0,
.px-sm-0 {
    padding-right: 0 !important;
  }

  .pb-sm-0,
.py-sm-0 {
    padding-bottom: 0 !important;
  }

  .pl-sm-0,
.px-sm-0 {
    padding-left: 0 !important;
  }

  .p-sm-1 {
    padding: 0.25rem !important;
  }

  .pt-sm-1,
.py-sm-1 {
    padding-top: 0.25rem !important;
  }

  .pr-sm-1,
.px-sm-1 {
    padding-right: 0.25rem !important;
  }

  .pb-sm-1,
.py-sm-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-sm-1,
.px-sm-1 {
    padding-left: 0.25rem !important;
  }

  .p-sm-2 {
    padding: 0.5rem !important;
  }

  .pt-sm-2,
.py-sm-2 {
    padding-top: 0.5rem !important;
  }

  .pr-sm-2,
.px-sm-2 {
    padding-right: 0.5rem !important;
  }

  .pb-sm-2,
.py-sm-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-sm-2,
.px-sm-2 {
    padding-left: 0.5rem !important;
  }

  .p-sm-3 {
    padding: 1rem !important;
  }

  .pt-sm-3,
.py-sm-3 {
    padding-top: 1rem !important;
  }

  .pr-sm-3,
.px-sm-3 {
    padding-right: 1rem !important;
  }

  .pb-sm-3,
.py-sm-3 {
    padding-bottom: 1rem !important;
  }

  .pl-sm-3,
.px-sm-3 {
    padding-left: 1rem !important;
  }

  .p-sm-4 {
    padding: 1.5rem !important;
  }

  .pt-sm-4,
.py-sm-4 {
    padding-top: 1.5rem !important;
  }

  .pr-sm-4,
.px-sm-4 {
    padding-right: 1.5rem !important;
  }

  .pb-sm-4,
.py-sm-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-sm-4,
.px-sm-4 {
    padding-left: 1.5rem !important;
  }

  .p-sm-5 {
    padding: 3rem !important;
  }

  .pt-sm-5,
.py-sm-5 {
    padding-top: 3rem !important;
  }

  .pr-sm-5,
.px-sm-5 {
    padding-right: 3rem !important;
  }

  .pb-sm-5,
.py-sm-5 {
    padding-bottom: 3rem !important;
  }

  .pl-sm-5,
.px-sm-5 {
    padding-left: 3rem !important;
  }

  .m-sm-auto {
    margin: auto !important;
  }

  .mt-sm-auto,
.my-sm-auto {
    margin-top: auto !important;
  }

  .mr-sm-auto,
.mx-sm-auto {
    margin-right: auto !important;
  }

  .mb-sm-auto,
.my-sm-auto {
    margin-bottom: auto !important;
  }

  .ml-sm-auto,
.mx-sm-auto {
    margin-left: auto !important;
  }
}
@media (min-width: 768px) {
  .m-md-0 {
    margin: 0 !important;
  }

  .mt-md-0,
.my-md-0 {
    margin-top: 0 !important;
  }

  .mr-md-0,
.mx-md-0 {
    margin-right: 0 !important;
  }

  .mb-md-0,
.my-md-0 {
    margin-bottom: 0 !important;
  }

  .ml-md-0,
.mx-md-0 {
    margin-left: 0 !important;
  }

  .m-md-1 {
    margin: 0.25rem !important;
  }

  .mt-md-1,
.my-md-1 {
    margin-top: 0.25rem !important;
  }

  .mr-md-1,
.mx-md-1 {
    margin-right: 0.25rem !important;
  }

  .mb-md-1,
.my-md-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-md-1,
.mx-md-1 {
    margin-left: 0.25rem !important;
  }

  .m-md-2 {
    margin: 0.5rem !important;
  }

  .mt-md-2,
.my-md-2 {
    margin-top: 0.5rem !important;
  }

  .mr-md-2,
.mx-md-2 {
    margin-right: 0.5rem !important;
  }

  .mb-md-2,
.my-md-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-md-2,
.mx-md-2 {
    margin-left: 0.5rem !important;
  }

  .m-md-3 {
    margin: 1rem !important;
  }

  .mt-md-3,
.my-md-3 {
    margin-top: 1rem !important;
  }

  .mr-md-3,
.mx-md-3 {
    margin-right: 1rem !important;
  }

  .mb-md-3,
.my-md-3 {
    margin-bottom: 1rem !important;
  }

  .ml-md-3,
.mx-md-3 {
    margin-left: 1rem !important;
  }

  .m-md-4 {
    margin: 1.5rem !important;
  }

  .mt-md-4,
.my-md-4 {
    margin-top: 1.5rem !important;
  }

  .mr-md-4,
.mx-md-4 {
    margin-right: 1.5rem !important;
  }

  .mb-md-4,
.my-md-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-md-4,
.mx-md-4 {
    margin-left: 1.5rem !important;
  }

  .m-md-5 {
    margin: 3rem !important;
  }

  .mt-md-5,
.my-md-5 {
    margin-top: 3rem !important;
  }

  .mr-md-5,
.mx-md-5 {
    margin-right: 3rem !important;
  }

  .mb-md-5,
.my-md-5 {
    margin-bottom: 3rem !important;
  }

  .ml-md-5,
.mx-md-5 {
    margin-left: 3rem !important;
  }

  .p-md-0 {
    padding: 0 !important;
  }

  .pt-md-0,
.py-md-0 {
    padding-top: 0 !important;
  }

  .pr-md-0,
.px-md-0 {
    padding-right: 0 !important;
  }

  .pb-md-0,
.py-md-0 {
    padding-bottom: 0 !important;
  }

  .pl-md-0,
.px-md-0 {
    padding-left: 0 !important;
  }

  .p-md-1 {
    padding: 0.25rem !important;
  }

  .pt-md-1,
.py-md-1 {
    padding-top: 0.25rem !important;
  }

  .pr-md-1,
.px-md-1 {
    padding-right: 0.25rem !important;
  }

  .pb-md-1,
.py-md-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-md-1,
.px-md-1 {
    padding-left: 0.25rem !important;
  }

  .p-md-2 {
    padding: 0.5rem !important;
  }

  .pt-md-2,
.py-md-2 {
    padding-top: 0.5rem !important;
  }

  .pr-md-2,
.px-md-2 {
    padding-right: 0.5rem !important;
  }

  .pb-md-2,
.py-md-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-md-2,
.px-md-2 {
    padding-left: 0.5rem !important;
  }

  .p-md-3 {
    padding: 1rem !important;
  }

  .pt-md-3,
.py-md-3 {
    padding-top: 1rem !important;
  }

  .pr-md-3,
.px-md-3 {
    padding-right: 1rem !important;
  }

  .pb-md-3,
.py-md-3 {
    padding-bottom: 1rem !important;
  }

  .pl-md-3,
.px-md-3 {
    padding-left: 1rem !important;
  }

  .p-md-4 {
    padding: 1.5rem !important;
  }

  .pt-md-4,
.py-md-4 {
    padding-top: 1.5rem !important;
  }

  .pr-md-4,
.px-md-4 {
    padding-right: 1.5rem !important;
  }

  .pb-md-4,
.py-md-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-md-4,
.px-md-4 {
    padding-left: 1.5rem !important;
  }

  .p-md-5 {
    padding: 3rem !important;
  }

  .pt-md-5,
.py-md-5 {
    padding-top: 3rem !important;
  }

  .pr-md-5,
.px-md-5 {
    padding-right: 3rem !important;
  }

  .pb-md-5,
.py-md-5 {
    padding-bottom: 3rem !important;
  }

  .pl-md-5,
.px-md-5 {
    padding-left: 3rem !important;
  }

  .m-md-auto {
    margin: auto !important;
  }

  .mt-md-auto,
.my-md-auto {
    margin-top: auto !important;
  }

  .mr-md-auto,
.mx-md-auto {
    margin-right: auto !important;
  }

  .mb-md-auto,
.my-md-auto {
    margin-bottom: auto !important;
  }

  .ml-md-auto,
.mx-md-auto {
    margin-left: auto !important;
  }
}
@media (min-width: 992px) {
  .m-lg-0 {
    margin: 0 !important;
  }

  .mt-lg-0,
.my-lg-0 {
    margin-top: 0 !important;
  }

  .mr-lg-0,
.mx-lg-0 {
    margin-right: 0 !important;
  }

  .mb-lg-0,
.my-lg-0 {
    margin-bottom: 0 !important;
  }

  .ml-lg-0,
.mx-lg-0 {
    margin-left: 0 !important;
  }

  .m-lg-1 {
    margin: 0.25rem !important;
  }

  .mt-lg-1,
.my-lg-1 {
    margin-top: 0.25rem !important;
  }

  .mr-lg-1,
.mx-lg-1 {
    margin-right: 0.25rem !important;
  }

  .mb-lg-1,
.my-lg-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-lg-1,
.mx-lg-1 {
    margin-left: 0.25rem !important;
  }

  .m-lg-2 {
    margin: 0.5rem !important;
  }

  .mt-lg-2,
.my-lg-2 {
    margin-top: 0.5rem !important;
  }

  .mr-lg-2,
.mx-lg-2 {
    margin-right: 0.5rem !important;
  }

  .mb-lg-2,
.my-lg-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-lg-2,
.mx-lg-2 {
    margin-left: 0.5rem !important;
  }

  .m-lg-3 {
    margin: 1rem !important;
  }

  .mt-lg-3,
.my-lg-3 {
    margin-top: 1rem !important;
  }

  .mr-lg-3,
.mx-lg-3 {
    margin-right: 1rem !important;
  }

  .mb-lg-3,
.my-lg-3 {
    margin-bottom: 1rem !important;
  }

  .ml-lg-3,
.mx-lg-3 {
    margin-left: 1rem !important;
  }

  .m-lg-4 {
    margin: 1.5rem !important;
  }

  .mt-lg-4,
.my-lg-4 {
    margin-top: 1.5rem !important;
  }

  .mr-lg-4,
.mx-lg-4 {
    margin-right: 1.5rem !important;
  }

  .mb-lg-4,
.my-lg-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-lg-4,
.mx-lg-4 {
    margin-left: 1.5rem !important;
  }

  .m-lg-5 {
    margin: 3rem !important;
  }

  .mt-lg-5,
.my-lg-5 {
    margin-top: 3rem !important;
  }

  .mr-lg-5,
.mx-lg-5 {
    margin-right: 3rem !important;
  }

  .mb-lg-5,
.my-lg-5 {
    margin-bottom: 3rem !important;
  }

  .ml-lg-5,
.mx-lg-5 {
    margin-left: 3rem !important;
  }

  .p-lg-0 {
    padding: 0 !important;
  }

  .pt-lg-0,
.py-lg-0 {
    padding-top: 0 !important;
  }

  .pr-lg-0,
.px-lg-0 {
    padding-right: 0 !important;
  }

  .pb-lg-0,
.py-lg-0 {
    padding-bottom: 0 !important;
  }

  .pl-lg-0,
.px-lg-0 {
    padding-left: 0 !important;
  }

  .p-lg-1 {
    padding: 0.25rem !important;
  }

  .pt-lg-1,
.py-lg-1 {
    padding-top: 0.25rem !important;
  }

  .pr-lg-1,
.px-lg-1 {
    padding-right: 0.25rem !important;
  }

  .pb-lg-1,
.py-lg-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-lg-1,
.px-lg-1 {
    padding-left: 0.25rem !important;
  }

  .p-lg-2 {
    padding: 0.5rem !important;
  }

  .pt-lg-2,
.py-lg-2 {
    padding-top: 0.5rem !important;
  }

  .pr-lg-2,
.px-lg-2 {
    padding-right: 0.5rem !important;
  }

  .pb-lg-2,
.py-lg-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-lg-2,
.px-lg-2 {
    padding-left: 0.5rem !important;
  }

  .p-lg-3 {
    padding: 1rem !important;
  }

  .pt-lg-3,
.py-lg-3 {
    padding-top: 1rem !important;
  }

  .pr-lg-3,
.px-lg-3 {
    padding-right: 1rem !important;
  }

  .pb-lg-3,
.py-lg-3 {
    padding-bottom: 1rem !important;
  }

  .pl-lg-3,
.px-lg-3 {
    padding-left: 1rem !important;
  }

  .p-lg-4 {
    padding: 1.5rem !important;
  }

  .pt-lg-4,
.py-lg-4 {
    padding-top: 1.5rem !important;
  }

  .pr-lg-4,
.px-lg-4 {
    padding-right: 1.5rem !important;
  }

  .pb-lg-4,
.py-lg-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-lg-4,
.px-lg-4 {
    padding-left: 1.5rem !important;
  }

  .p-lg-5 {
    padding: 3rem !important;
  }

  .pt-lg-5,
.py-lg-5 {
    padding-top: 3rem !important;
  }

  .pr-lg-5,
.px-lg-5 {
    padding-right: 3rem !important;
  }

  .pb-lg-5,
.py-lg-5 {
    padding-bottom: 3rem !important;
  }

  .pl-lg-5,
.px-lg-5 {
    padding-left: 3rem !important;
  }

  .m-lg-auto {
    margin: auto !important;
  }

  .mt-lg-auto,
.my-lg-auto {
    margin-top: auto !important;
  }

  .mr-lg-auto,
.mx-lg-auto {
    margin-right: auto !important;
  }

  .mb-lg-auto,
.my-lg-auto {
    margin-bottom: auto !important;
  }

  .ml-lg-auto,
.mx-lg-auto {
    margin-left: auto !important;
  }
}
@media (min-width: 1200px) {
  .m-xl-0 {
    margin: 0 !important;
  }

  .mt-xl-0,
.my-xl-0 {
    margin-top: 0 !important;
  }

  .mr-xl-0,
.mx-xl-0 {
    margin-right: 0 !important;
  }

  .mb-xl-0,
.my-xl-0 {
    margin-bottom: 0 !important;
  }

  .ml-xl-0,
.mx-xl-0 {
    margin-left: 0 !important;
  }

  .m-xl-1 {
    margin: 0.25rem !important;
  }

  .mt-xl-1,
.my-xl-1 {
    margin-top: 0.25rem !important;
  }

  .mr-xl-1,
.mx-xl-1 {
    margin-right: 0.25rem !important;
  }

  .mb-xl-1,
.my-xl-1 {
    margin-bottom: 0.25rem !important;
  }

  .ml-xl-1,
.mx-xl-1 {
    margin-left: 0.25rem !important;
  }

  .m-xl-2 {
    margin: 0.5rem !important;
  }

  .mt-xl-2,
.my-xl-2 {
    margin-top: 0.5rem !important;
  }

  .mr-xl-2,
.mx-xl-2 {
    margin-right: 0.5rem !important;
  }

  .mb-xl-2,
.my-xl-2 {
    margin-bottom: 0.5rem !important;
  }

  .ml-xl-2,
.mx-xl-2 {
    margin-left: 0.5rem !important;
  }

  .m-xl-3 {
    margin: 1rem !important;
  }

  .mt-xl-3,
.my-xl-3 {
    margin-top: 1rem !important;
  }

  .mr-xl-3,
.mx-xl-3 {
    margin-right: 1rem !important;
  }

  .mb-xl-3,
.my-xl-3 {
    margin-bottom: 1rem !important;
  }

  .ml-xl-3,
.mx-xl-3 {
    margin-left: 1rem !important;
  }

  .m-xl-4 {
    margin: 1.5rem !important;
  }

  .mt-xl-4,
.my-xl-4 {
    margin-top: 1.5rem !important;
  }

  .mr-xl-4,
.mx-xl-4 {
    margin-right: 1.5rem !important;
  }

  .mb-xl-4,
.my-xl-4 {
    margin-bottom: 1.5rem !important;
  }

  .ml-xl-4,
.mx-xl-4 {
    margin-left: 1.5rem !important;
  }

  .m-xl-5 {
    margin: 3rem !important;
  }

  .mt-xl-5,
.my-xl-5 {
    margin-top: 3rem !important;
  }

  .mr-xl-5,
.mx-xl-5 {
    margin-right: 3rem !important;
  }

  .mb-xl-5,
.my-xl-5 {
    margin-bottom: 3rem !important;
  }

  .ml-xl-5,
.mx-xl-5 {
    margin-left: 3rem !important;
  }

  .p-xl-0 {
    padding: 0 !important;
  }

  .pt-xl-0,
.py-xl-0 {
    padding-top: 0 !important;
  }

  .pr-xl-0,
.px-xl-0 {
    padding-right: 0 !important;
  }

  .pb-xl-0,
.py-xl-0 {
    padding-bottom: 0 !important;
  }

  .pl-xl-0,
.px-xl-0 {
    padding-left: 0 !important;
  }

  .p-xl-1 {
    padding: 0.25rem !important;
  }

  .pt-xl-1,
.py-xl-1 {
    padding-top: 0.25rem !important;
  }

  .pr-xl-1,
.px-xl-1 {
    padding-right: 0.25rem !important;
  }

  .pb-xl-1,
.py-xl-1 {
    padding-bottom: 0.25rem !important;
  }

  .pl-xl-1,
.px-xl-1 {
    padding-left: 0.25rem !important;
  }

  .p-xl-2 {
    padding: 0.5rem !important;
  }

  .pt-xl-2,
.py-xl-2 {
    padding-top: 0.5rem !important;
  }

  .pr-xl-2,
.px-xl-2 {
    padding-right: 0.5rem !important;
  }

  .pb-xl-2,
.py-xl-2 {
    padding-bottom: 0.5rem !important;
  }

  .pl-xl-2,
.px-xl-2 {
    padding-left: 0.5rem !important;
  }

  .p-xl-3 {
    padding: 1rem !important;
  }

  .pt-xl-3,
.py-xl-3 {
    padding-top: 1rem !important;
  }

  .pr-xl-3,
.px-xl-3 {
    padding-right: 1rem !important;
  }

  .pb-xl-3,
.py-xl-3 {
    padding-bottom: 1rem !important;
  }

  .pl-xl-3,
.px-xl-3 {
    padding-left: 1rem !important;
  }

  .p-xl-4 {
    padding: 1.5rem !important;
  }

  .pt-xl-4,
.py-xl-4 {
    padding-top: 1.5rem !important;
  }

  .pr-xl-4,
.px-xl-4 {
    padding-right: 1.5rem !important;
  }

  .pb-xl-4,
.py-xl-4 {
    padding-bottom: 1.5rem !important;
  }

  .pl-xl-4,
.px-xl-4 {
    padding-left: 1.5rem !important;
  }

  .p-xl-5 {
    padding: 3rem !important;
  }

  .pt-xl-5,
.py-xl-5 {
    padding-top: 3rem !important;
  }

  .pr-xl-5,
.px-xl-5 {
    padding-right: 3rem !important;
  }

  .pb-xl-5,
.py-xl-5 {
    padding-bottom: 3rem !important;
  }

  .pl-xl-5,
.px-xl-5 {
    padding-left: 3rem !important;
  }

  .m-xl-auto {
    margin: auto !important;
  }

  .mt-xl-auto,
.my-xl-auto {
    margin-top: auto !important;
  }

  .mr-xl-auto,
.mx-xl-auto {
    margin-right: auto !important;
  }

  .mb-xl-auto,
.my-xl-auto {
    margin-bottom: auto !important;
  }

  .ml-xl-auto,
.mx-xl-auto {
    margin-left: auto !important;
  }
}
.text-justify {
  text-align: justify !important;
}

.text-nowrap {
  white-space: nowrap !important;
}

.text-truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.text-left {
  text-align: left !important;
}

.text-right {
  text-align: right !important;
}

.text-center {
  text-align: center !important;
}

@media (min-width: 576px) {
  .text-sm-left {
    text-align: left !important;
  }

  .text-sm-right {
    text-align: right !important;
  }

  .text-sm-center {
    text-align: center !important;
  }
}
@media (min-width: 768px) {
  .text-md-left {
    text-align: left !important;
  }

  .text-md-right {
    text-align: right !important;
  }

  .text-md-center {
    text-align: center !important;
  }
}
@media (min-width: 992px) {
  .text-lg-left {
    text-align: left !important;
  }

  .text-lg-right {
    text-align: right !important;
  }

  .text-lg-center {
    text-align: center !important;
  }
}
@media (min-width: 1200px) {
  .text-xl-left {
    text-align: left !important;
  }

  .text-xl-right {
    text-align: right !important;
  }

  .text-xl-center {
    text-align: center !important;
  }
}
.text-lowercase {
  text-transform: lowercase !important;
}

.text-uppercase {
  text-transform: uppercase !important;
}

.text-capitalize {
  text-transform: capitalize !important;
}

.font-weight-light {
  font-weight: 300 !important;
}

.font-weight-normal {
  font-weight: normal !important;
}

.font-weight-bold {
  font-weight: bold !important;
}

.font-italic {
  font-style: italic !important;
}

.text-white {
  color: #fff !important;
}

.text-primary {
  color: #03a9f4 !important;
}

a.text-primary:focus, a.text-primary:hover {
  color: #0286c2 !important;
}

.text-secondary {
  color: #868e96 !important;
}

a.text-secondary:focus, a.text-secondary:hover {
  color: #6c757d !important;
}

.text-success {
  color: #7dc855 !important;
}

a.text-success:focus, a.text-success:hover {
  color: #63b139 !important;
}

.text-info {
  color: #78BCEE !important;
}

a.text-info:focus, a.text-info:hover {
  color: #4ba6e8 !important;
}

.text-warning {
  color: #FCCE54 !important;
}

a.text-warning:focus, a.text-warning:hover {
  color: #fbc022 !important;
}

.text-danger {
  color: #ED5564 !important;
}

a.text-danger:focus, a.text-danger:hover {
  color: #e8273a !important;
}

.text-light {
  color: #f8f9fa !important;
}

a.text-light:focus, a.text-light:hover {
  color: #dae0e5 !important;
}

.text-dark {
  color: #343a40 !important;
}

a.text-dark:focus, a.text-dark:hover {
  color: #1d2124 !important;
}

.text-muted {
  color: #868e96 !important;
}

.text-hide {
  font: 0/0 a;
  color: transparent;
  text-shadow: none;
  background-color: transparent;
  border: 0;
}

.visible {
  visibility: visible !important;
}

.invisible {
  visibility: hidden !important;
}

/*
 * Should be at top of all other
 */
/*

@include tablet-and-phone {
    display: none;
}

*/
@media (max-width: 1031px) {
  .responsive {
    text-align: center !important;
  }
  .responsive h1, .responsive h2, .responsive h3, .responsive p, .responsive a, .responsive .text-left, .responsive .text-right, .responsive img {
    text-align: center !important;
  }
}
@media (max-width: 420px) {
  .responsive-phone {
    text-align: center;
  }
}
/* =Transition
-------------------------------------------------------------- */
body {
  color: #86939e;
  font-family: "Roboto", sans-serif, serif;
  font-size: 14px;
  height: 100%;
  line-height: 1.5;
  font-weight: 300;
  letter-spacing: 0.2px;
  padding-right: 0 !important;
}

a {
  color: #03a9f4;
}
a:hover, a:active, a:focus {
  outline: none;
  text-decoration: none;
  color: #03a9f4;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  color: #606676;
  font-weight: 300;
  font-family: "Roboto", sans-serif;
}

.h5 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 4px;
  text-transform: uppercase;
}

p {
  font-size: 14px;
  font-weight: 300;
  letter-spacing: 0.2px;
}

img {
  max-width: 100%;
}

ul li {
  list-style: none;
  font-weight: 300;
}
ul li i {
  padding-right: 15px;
}

header h2 {
  line-height: 60px;
}

.overflow-hide {
  overflow: hidden;
}

.section {
  padding: 50px 0;
}
.section header {
  text-align: center;
  padding-bottom: 50px;
}

.section-heading {
  text-align: center;
  padding-bottom: 40px;
}

.section-title {
  font-weight: 300;
  color: #43484d;
}
@media (min-width: 1031px) {
  .section-title {
    font-size: 52px;
  }
}

.section-subtitle {
  font-size: 22px;
  font-weight: 100;
  line-height: 32px;
  color: #5e6977;
  width: 55%;
  margin: 20px auto 40px;
}

.page .search-section, .page .page-header {
  padding: 30px;
}
.page .search-section h1, .page .page-header h1 {
  font-size: 28px;
}
.page .search-section h1 small, .page .page-header h1 small {
  background: #03a9f4;
  color: #fff;
  font-size: 14px;
  font-weight: 300;
  padding: 3px 10px;
  vertical-align: middle;
}

#page_wrap {
  height: 100%;
  overflow-x: hidden;
  position: relative;
  transition: all 0.5s ease 0s;
  width: 100%;
}

.offcanvas #page_wrap {
  overflow: hidden;
  position: absolute;
}

.offcanvas #page_wrap::after {
  background: rgba(245, 248, 250, 0.7) none repeat scroll 0 0;
  bottom: 0;
  content: "";
  left: 0;
  position: absolute;
  right: 0;
  top: 0;
  transition: all 2s ease 0s;
  z-index: 101;
}

@media (min-width: 1031px) {
  .enable-offcanvas .paper-nav-toggle,
.enable-offcanvas #paper-offcanvas {
    display: block;
  }
}
.block {
  font-size: 14px;
}
.block img {
  border-radius: 3px;
  margin: 15px 0 20px;
  max-width: 100%;
}

.service-sidebar.sidebar-wrapper {
  background-color: #f9f9fb;
  border-radius: 5px;
  margin-bottom: 35px;
  padding: 20px;
}
.service-sidebar.sidebar-wrapper h2 {
  font-size: 24px;
  font-weight: normal;
  line-height: 36px;
  padding-bottom: 0;
  text-transform: capitalize;
}

.paper-block {
  padding: 15px;
  border: 3px solid #f5f8fa;
  border-radius: 3px;
  margin-bottom: 30px;
}

@media (min-width: 1400px) {
  .inside {
    margin: 0 auto;
    background: #fff;
    width: 80%;
  }
}
.card-header {
  position: relative;
}
.card-header .card-handle {
  position: absolute;
  right: 20px;
}

.content-wrapper {
  padding: 40px 0;
}

.section {
  padding: 50px 0;
}
.section header {
  text-align: center;
  padding-bottom: 50px;
}
.section header h1 {
  text-transform: uppercase;
}

/***************************** Header ****************************/
.section {
  margin-top: 80px;
  margin-bottom: 80px;
}
.section header {
  text-align: center;
  padding: 40px;
}

.social {
  list-style: none;
  padding-bottom: 35px;
  padding-top: 15px;
}
.social li {
  display: inline-block;
  border-radius: 50%;
  color: #fff;
  height: 40px;
  line-height: 40px;
  width: 40px;
  font-size: 18px;
  margin-right: 15px;
  text-align: center;
}
.social li a {
  color: #fff;
}
.social li i {
  padding: 0;
}
.social.square li {
  border-radius: 0;
}
.social.rounded li {
  border-radius: 10px;
}

.facebook {
  background: #507cbe;
}

.twitter {
  background: #63cdf1;
}

.gplus {
  background: #f16261;
}

.instagram {
  background: #444444;
}

.youtube {
  background: #CA3737;
}

.linkedin {
  background: #90cadd;
}

.github {
  background: #24292e;
}

.skype {
  background: #00aff0;
}

.lh-0 {
  line-height: 0;
}

.lh-05 {
  line-height: 0.5;
}

.lh-10 {
  line-height: 1;
}

.lh-15 {
  line-height: 1.5;
}

.lh-20 {
  line-height: 2;
}

.lh-25 {
  line-height: 2.5;
}

.p-t-0 {
  padding-top: 0 !important;
}

.p-t-10 {
  padding-top: 10px !important;
}

.p-b-10 {
  padding-bottom: 10px !important;
}

.p-t-20 {
  padding-top: 20px !important;
}

.p-b-20 {
  padding-bottom: 20px !important;
}

.p-t-40 {
  padding-top: 40px !important;
}

.p-b-40 {
  padding-bottom: 40px !important;
}

.p-t-80 {
  padding-top: 80px !important;
}

.p-b-80 {
  padding-bottom: 80px !important;
}

.p-b-100 {
  padding-bottom: 100px !important;
}

.p-t-100 {
  padding-top: 100px !important;
}

.p-t-b-10 {
  padding-top: 10px !important;
  padding-bottom: 10px !important;
}

.p-t-b-20 {
  padding-top: 20px !important;
  padding-bottom: 20px !important;
}

.p-t-b-40 {
  padding-top: 40px !important;
  padding-bottom: 40px !important;
}

.p-t-b-50 {
  padding-top: 50px !important;
  padding-bottom: 50px !important;
}

.p-t-b-80 {
  padding: 80px 0 !important;
}

.p-t-b-100 {
  padding: 100px 0 !important;
}

.p-10 {
  padding: 10px !important;
}

.p-40 {
  padding: 40px !important;
}

.p-t-50 {
  padding-top: 50px !important;
}

.m-t-50 {
  margin-top: 50px !important;
}

.m-t-150 {
  margin-top: 150px;
}
@media (max-width: 1031px) {
  .m-t-150 {
    margin-top: 50px;
  }
}

.m-b-50 {
  margin-bottom: 50px !important;
}

.m-t-b-50 {
  margin: 50px 0 !important;
}

.p-b-0 {
  padding-bottom: 0 !important;
}

.b-b {
  border-bottom: 1px solid #e1e8ee !important;
}

@media (min-width: 1031px) {
  .b-r {
    border-right: 1px solid #e1e8ee;
  }

  .b-l {
    border-left: 1px solid #e1e8ee;
  }

  .b-r-o {
    border-right: 1px solid rgba(0, 0, 0, 0.09);
  }

  .b-l-o {
    border-left: 1px solid rgba(0, 0, 0, 0.09);
  }
}
.b-t {
  border-top: 1px solid #e1e8ee;
}

.b-t-b {
  border-top: 1px solid #e1e8ee;
  border-bottom: 1px solid #e1e8ee;
}

.border {
  border: 1px solid #e1e8ee;
}

.section-text-white h1, .section-text-white h2, .section-text-white h3, .section-text-white h4, .section-text-white h5, .section-text-white h6, .section-text-white p, .section-text-white span {
  color: #fff !important;
}

.no-p {
  padding: 0 !important;
}

.no-m {
  margin: 0 !important;
}

.no-b, .b-0, .no-b .mainnav, .no-b li {
  border: medium none !important;
}

.no-r, .r-0 {
  border-radius: 0 !important;
}

.separator {
  border-bottom: 1px solid #edf0f2;
}

.grid img {
  border-radius: 0;
}

.r-3 {
  border-radius: 3px !important;
}

.r-5 {
  border-radius: 5px !important;
}

.r-10 {
  border-radius: 10px !important;
}

.r-15 {
  border-radius: 15px !important;
}

.r-20 {
  border-radius: 20px !important;
}

.r-30 {
  border-radius: 30px !important;
}

.paper-card {
  background: #fff;
  padding: 40px;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.1);
}

.shadow {
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.1);
}

.shadow1 {
  box-shadow: 0 3px 9px 0 rgba(0, 0, 0, 0.26);
}

.shadow2 {
  box-shadow: 0 0 25px 0 #e5f0fa;
}

.no-shadow {
  box-shadow: none !important;
}

.text-big-bold {
  font-size: 62px;
  font-weight: 800;
  line-height: 62px;
}

.font-weight-lighter, .thin {
  font-weight: 100 !important;
}

.font-weight-bolder, .bolder {
  font-weight: 900 !important;
}

.l-s-1 {
  letter-spacing: 0.2rem;
}

.l-s-2 {
  letter-spacing: 0.4rem;
}

.l-s-3 {
  letter-spacing: 0.6rem;
}

.l-s-4 {
  letter-spacing: 0.8rem;
}

.l-s-5 {
  letter-spacing: 1rem;
}

.s-12 {
  font-size: 12px !important;
}

.s-14 {
  font-size: 14px !important;
}

.s-18 {
  font-size: 18px !important;
}

.s-24 {
  font-size: 24px !important;
}

.s-36 {
  font-size: 36px !important;
}

@media (min-width: 1031px) {
  .s-48 {
    font-size: 48px !important;
  }
}

@media (min-width: 1031px) {
  .s-64 {
    font-size: 64px !important;
  }
}

@media (min-width: 1031px) {
  .s-128 {
    font-size: 128px !important;
  }
}

.s-256 {
  font-size: 256px !important;
}
@media (max-width: 420px) {
  .s-256 {
    font-size: 128px !important;
  }
}

.img-40 {
  width: 40px;
  height: 40px;
}

.w-10 {
  width: 10%;
}

.w-15 {
  width: 15%;
}

.img-80 {
  width: 80px;
}

.img-100 {
  width: 100px;
}

.img-150 {
  width: 150px;
}

.height-50 {
  height: 50px;
}

.height-90 {
  height: 90px;
}

.height-100 {
  height: 100px;
}

.height-full {
  background: #F3F5F8;
  min-height: 100vh;
}

.width-400 {
  max-width: 400px;
}

.width-250 {
  width: 250px !important;
}

.width-900 {
  max-width: 900px;
}

.img-border {
  padding: 5px;
  border: 1px solid #e1e8ee;
}

.text-white {
  color: #fff !important;
}
.text-white p,
.text-white h1,
.text-white h2,
.text-white h3,
.text-white h4,
.text-white h5,
.text-white h6,
.text-white p,
.text-white span,
.text-white strong,
.text-white a,
.text-white b,
.text-white li,
.text-white i {
  color: #fff !important;
}

.text-blue {
  color: #4ea9e0 !important;
}

.text-red {
  color: #e84c3d !important;
}

.text-green {
  color: #40d17d !important;
}

.text-purple {
  color: #9b58b5 !important;
}

.text-black {
  color: #000 !important;
}

.text-yellow {
  color: #f1c40f !important;
}

.white {
  background: #fff !important;
}

.light {
  background-color: #F5F8FA;
}

.light-2 {
  background: #F6FAFD;
}

.text-light-blue {
  color: #03a9f4 !important;
}

.light-blue {
  background-color: #03a9f4 !important;
}

.dark-blue {
  background-color: #26374A !important;
}

.blue4 {
  background-color: #274da8 !important;
}

.blue3 {
  background-color: #375EBC !important;
}

.blue2 {
  background-color: #4CA5E8 !important;
}

.blue1 {
  background-color: #78BCEE !important;
}

.success {
  background-color: #68ba3c !important;
}

.strawberry, .danger {
  background-color: #ED5564 !important;
}

.sunfollower, warning {
  background-color: #FCCE54 !important;
}

.grey-black {
  background-color: #454545 !important;
}

.dark-grey {
  background-color: #2B2D34 !important;
}

.paper-white {
  background: #f5f8fa;
}

.mint {
  background-color: #45CFC0 !important;
}

.gradient {
  border: none;
  background: #4c88ef;
  background: -webkit-gradient(linear, left top, right bottom, color-stop(0%, #4c88ef), color-stop(100%, #17e4d9));
  background: -webkit-linear-gradient(-45deg, #4c88ef 0%, #17e4d9 100%);
  background: -webkit-linear-gradient(315deg, #4c88ef 0%, #17e4d9 100%);
  background: linear-gradient(135deg, #4c88ef 0%, #17e4d9 100%);
}

.gradient-green {
  background-image: linear-gradient(45deg, #00E3AE 0%, #9BE15D 100%);
}

.center {
  margin: 0 auto;
}

.border-list li {
  border-bottom: 1px solid #eee;
}
.border-list li:last-child {
  border: none;
}

@media (min-width: 1031px) {
  .big-heading {
    font-size: 72px;
  }
}
.parallel {
  overflow-x: hidden;
  width: 100%;
}
@media (min-width: 1031px) {
  .parallel {
    overflow: hidden;
    position: fixed;
  }
}

.overlay-light::before {
  content: "";
  background: rgba(255, 255, 255, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.overlay-light::before {
  content: "";
  background: rgba(255, 255, 255, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.overlay-light::before {
  content: "";
  background: rgba(255, 255, 255, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.overlay-dark::before {
  content: "";
  background: rgba(0, 0, 0, 0.78);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.section {
  position: relative;
}

.relative {
  position: relative !important;
}

.fixed {
  position: fixed !important;
}

[data-bg-repeat=false] {
  background-repeat: no-repeat !important;
}

[data-bg-possition=bottom] {
  background-position: bottom !important;
}

[data-bg-possition=top] {
  background-position: top !important;
}

[data-bg-possition=center] {
  background-position: center !important;
}

[data-bg-possition=centerleft] {
  background-position: center left !important;
}

.grid [class*=col-], .grid figure {
  padding: 0;
  margin: 0;
}
@media (min-width: 1031px) {
  .grid.grid-border [class*=col-] {
    border-right: 1px solid #eee;
  }
  .grid.grid-border [class*=col-]:last-child {
    border-right: 0;
  }
  .grid.grid-border.row {
    border-top: 1px solid #eee;
  }
  .grid.grid-border.row:nth-of-type(1) {
    border-top: none !important;
  }
}

ul.list-group.list-group-striped li:nth-of-type(even) {
  background: #F5F8FA;
}
ul.list-group.list-group-hover li:hover {
  background: red;
}

.mdb-color.lighten-5 {
  background-color: #D0D6E2 !important;
}

.mdb-color.lighten-4 {
  background-color: #B1BACE !important;
}

.mdb-color.lighten-3 {
  background-color: #929FBA !important;
}

.mdb-color.lighten-2 {
  background-color: #7283A7 !important;
}

.mdb-color.lighten-1 {
  background-color: #59698D !important;
}

.mdb-color {
  background-color: #45526E !important;
}

.mdb-color-text {
  color: #45526E !important;
}

.mdb-color.darken-1 {
  background-color: #3B465E !important;
}

.mdb-color.darken-2 {
  background-color: #2E3951 !important;
}

.mdb-color.darken-3 {
  background-color: #1C2A48 !important;
}

.mdb-color.darken-4 {
  background-color: #1C2331 !important;
}

.red.lighten-5 {
  background-color: #FFEBEE !important;
}

.red.lighten-4 {
  background-color: #FFCDD2 !important;
}

.red.lighten-3 {
  background-color: #EF9A9A !important;
}

.red.lighten-2 {
  background-color: #E57373 !important;
}

.red.lighten-1 {
  background-color: #EF5350 !important;
}

.red {
  background-color: #F44336 !important;
}

.red-text {
  color: #F44336 !important;
}

.red.darken-1 {
  background-color: #E53935 !important;
}

.red.darken-2 {
  background-color: #D32F2F !important;
}

.red.darken-3 {
  background-color: #C62828 !important;
}

.red.darken-4 {
  background-color: #B71C1C !important;
}

.red.accent-1 {
  background-color: #FF8A80 !important;
}

.red.accent-2 {
  background-color: #FF5252 !important;
}

.red.accent-3 {
  background-color: #FF1744 !important;
}

.red.accent-4 {
  background-color: #D50000 !important;
}

.pink.lighten-5 {
  background-color: #fce4ec !important;
}

.pink.lighten-4 {
  background-color: #f8bbd0 !important;
}

.pink.lighten-3 {
  background-color: #f48fb1 !important;
}

.pink.lighten-2 {
  background-color: #f06292 !important;
}

.pink.lighten-1 {
  background-color: #ec407a !important;
}

.pink {
  background-color: #e91e63 !important;
}

.pink-text {
  color: #e91e63 !important;
}

.pink.darken-1 {
  background-color: #d81b60 !important;
}

.pink.darken-2 {
  background-color: #c2185b !important;
}

.pink.darken-3 {
  background-color: #ad1457 !important;
}

.pink.darken-4 {
  background-color: #880e4f !important;
}

.pink.accent-1 {
  background-color: #ff80ab !important;
}

.pink.accent-2 {
  background-color: #ff4081 !important;
}

.pink.accent-3 {
  background-color: #f50057 !important;
}

.pink.accent-4 {
  background-color: #c51162 !important;
}

.purple.lighten-5 {
  background-color: #f3e5f5 !important;
}

.purple.lighten-4 {
  background-color: #e1bee7 !important;
}

.purple.lighten-3 {
  background-color: #ce93d8 !important;
}

.purple.lighten-2 {
  background-color: #ba68c8 !important;
}

.purple.lighten-1 {
  background-color: #ab47bc !important;
}

.purple {
  background-color: #9c27b0 !important;
}

.purple-text {
  color: #9c27b0 !important;
}

.purple.darken-1 {
  background-color: #8e24aa !important;
}

.purple.darken-2 {
  background-color: #7b1fa2 !important;
}

.purple.darken-3 {
  background-color: #6a1b9a !important;
}

.purple.darken-4 {
  background-color: #4a148c !important;
}

.purple.accent-1 {
  background-color: #ea80fc !important;
}

.purple.accent-2 {
  background-color: #e040fb !important;
}

.purple.accent-3 {
  background-color: #d500f9 !important;
}

.purple.accent-4 {
  background-color: #aa00ff !important;
}

.deep-purple.lighten-5 {
  background-color: #ede7f6 !important;
}

.deep-purple.lighten-4 {
  background-color: #d1c4e9 !important;
}

.deep-purple.lighten-3 {
  background-color: #b39ddb !important;
}

.deep-purple.lighten-2 {
  background-color: #9575cd !important;
}

.deep-purple.lighten-1 {
  background-color: #7e57c2 !important;
}

.deep-purple {
  background-color: #673ab7 !important;
}

.deep-purple-text {
  color: #673ab7 !important;
}

.deep-purple.darken-1 {
  background-color: #5e35b1 !important;
}

.deep-purple.darken-2 {
  background-color: #512da8 !important;
}

.deep-purple.darken-3 {
  background-color: #4527a0 !important;
}

.deep-purple.darken-4 {
  background-color: #311b92 !important;
}

.deep-purple.accent-1 {
  background-color: #b388ff !important;
}

.deep-purple.accent-2 {
  background-color: #7c4dff !important;
}

.deep-purple.accent-3 {
  background-color: #651fff !important;
}

.deep-purple.accent-4 {
  background-color: #6200ea !important;
}

.indigo.lighten-5 {
  background-color: #e8eaf6 !important;
}

.indigo.lighten-4 {
  background-color: #c5cae9 !important;
}

.indigo.lighten-3 {
  background-color: #9fa8da !important;
}

.indigo.lighten-2 {
  background-color: #7986cb !important;
}

.indigo.lighten-1 {
  background-color: #5c6bc0 !important;
}

.indigo {
  background-color: #3f51b5 !important;
}

.indigo-text {
  color: #3f51b5 !important;
}

.indigo.darken-1 {
  background-color: #3949ab !important;
}

.indigo.darken-2 {
  background-color: #303f9f !important;
}

.indigo.darken-3 {
  background-color: #283593 !important;
}

.indigo.darken-4 {
  background-color: #1a237e !important;
}

.indigo.accent-1 {
  background-color: #8c9eff !important;
}

.indigo.accent-2 {
  background-color: #536dfe !important;
}

.indigo.accent-3 {
  background-color: #3d5afe !important;
}

.indigo.accent-4 {
  background-color: #304ffe !important;
}

.blue.lighten-5 {
  background-color: #E3F2FD !important;
}

.blue.lighten-4 {
  background-color: #BBDEFB !important;
}

.blue.lighten-3 {
  background-color: #90CAF9 !important;
}

.blue.lighten-2 {
  background-color: #64B5F6 !important;
}

.blue.lighten-1 {
  background-color: #42A5F5 !important;
}

.blue {
  background-color: #2196F3 !important;
}

.blue-text {
  color: #2196F3 !important;
}

.blue.darken-1 {
  background-color: #1E88E5 !important;
}

.blue.darken-2 {
  background-color: #1976D2 !important;
}

.blue.darken-3 {
  background-color: #1565C0 !important;
}

.blue.darken-4 {
  background-color: #0D47A1 !important;
}

.blue.accent-1 {
  background-color: #82B1FF !important;
}

.blue.accent-2 {
  background-color: #448AFF !important;
}

.blue.accent-3 {
  background-color: #2979FF !important;
}

.blue.accent-4 {
  background-color: #2962FF !important;
}

.light-blue.lighten-5 {
  background-color: #e1f5fe !important;
}

.light-blue.lighten-4 {
  background-color: #b3e5fc !important;
}

.light-blue.lighten-3 {
  background-color: #81d4fa !important;
}

.light-blue.lighten-2 {
  background-color: #4fc3f7 !important;
}

.light-blue.lighten-1 {
  background-color: #29b6f6 !important;
}

.light-blue {
  background-color: #03a9f4 !important;
}

.light-blue-text {
  color: #03a9f4 !important;
}

.light-blue.darken-1 {
  background-color: #039be5 !important;
}

.light-blue.darken-2 {
  background-color: #0288d1 !important;
}

.light-blue.darken-3 {
  background-color: #0277bd !important;
}

.light-blue.darken-4 {
  background-color: #01579b !important;
}

.light-blue.accent-1 {
  background-color: #80d8ff !important;
}

.light-blue.accent-2 {
  background-color: #40c4ff !important;
}

.light-blue.accent-3 {
  background-color: #00b0ff !important;
}

.light-blue.accent-4 {
  background-color: #0091ea !important;
}

.cyan.lighten-5 {
  background-color: #e0f7fa !important;
}

.cyan.lighten-4 {
  background-color: #b2ebf2 !important;
}

.cyan.lighten-3 {
  background-color: #80deea !important;
}

.cyan.lighten-2 {
  background-color: #4dd0e1 !important;
}

.cyan.lighten-1 {
  background-color: #26c6da !important;
}

.cyan {
  background-color: #00bcd4 !important;
}

.cyan-text {
  color: #00bcd4 !important;
}

.cyan.darken-1 {
  background-color: #00acc1 !important;
}

.cyan.darken-2 {
  background-color: #0097a7 !important;
}

.cyan.darken-3 {
  background-color: #00838f !important;
}

.cyan.darken-4 {
  background-color: #006064 !important;
}

.cyan.accent-1 {
  background-color: #84ffff !important;
}

.cyan.accent-2 {
  background-color: #18ffff !important;
}

.cyan.accent-3 {
  background-color: #00e5ff !important;
}

.cyan.accent-4 {
  background-color: #00b8d4 !important;
}

.teal.lighten-5 {
  background-color: #e0f2f1 !important;
}

.teal.lighten-4 {
  background-color: #b2dfdb !important;
}

.teal.lighten-3 {
  background-color: #80cbc4 !important;
}

.teal.lighten-2 {
  background-color: #4db6ac !important;
}

.teal.lighten-1 {
  background-color: #26a69a !important;
}

.teal {
  background-color: #009688 !important;
}

.teal-text {
  color: #009688 !important;
}

.teal.darken-1 {
  background-color: #00897b !important;
}

.teal.darken-2 {
  background-color: #00796b !important;
}

.teal.darken-3 {
  background-color: #00695c !important;
}

.teal.darken-4 {
  background-color: #004d40 !important;
}

.teal.accent-1 {
  background-color: #a7ffeb !important;
}

.teal.accent-2 {
  background-color: #64ffda !important;
}

.teal.accent-3 {
  background-color: #1de9b6 !important;
}

.teal.accent-4 {
  background-color: #00bfa5 !important;
}

.green.lighten-5 {
  background-color: #E8F5E9 !important;
}

.green.lighten-4 {
  background-color: #C8E6C9 !important;
}

.green.lighten-3 {
  background-color: #A5D6A7 !important;
}

.green.lighten-2 {
  background-color: #81C784 !important;
}

.green.lighten-1 {
  background-color: #66BB6A !important;
}

.green {
  background-color: #4CAF50 !important;
}

.green-text {
  color: #4CAF50 !important;
}

.green.darken-1 {
  background-color: #43A047 !important;
}

.green.darken-2 {
  background-color: #388E3C !important;
}

.green.darken-3 {
  background-color: #2E7D32 !important;
}

.green.darken-4 {
  background-color: #1B5E20 !important;
}

.green.accent-1 {
  background-color: #B9F6CA !important;
}

.green.accent-2 {
  background-color: #69F0AE !important;
}

.green.accent-3 {
  background-color: #00E676 !important;
}

.green.accent-4 {
  background-color: #00C853 !important;
}

.light-green.lighten-5 {
  background-color: #f1f8e9 !important;
}

.light-green.lighten-4 {
  background-color: #dcedc8 !important;
}

.light-green.lighten-3 {
  background-color: #c5e1a5 !important;
}

.light-green.lighten-2 {
  background-color: #aed581 !important;
}

.light-green.lighten-1 {
  background-color: #9ccc65 !important;
}

.light-green {
  background-color: #8bc34a !important;
}

.light-green-text {
  color: #8bc34a !important;
}

.light-green.darken-1 {
  background-color: #7cb342 !important;
}

.light-green.darken-2 {
  background-color: #689f38 !important;
}

.light-green.darken-3 {
  background-color: #558b2f !important;
}

.light-green.darken-4 {
  background-color: #33691e !important;
}

.light-green.accent-1 {
  background-color: #ccff90 !important;
}

.light-green.accent-2 {
  background-color: #b2ff59 !important;
}

.light-green.accent-3 {
  background-color: #76ff03 !important;
}

.light-green.accent-4 {
  background-color: #64dd17 !important;
}

.lime.lighten-5 {
  background-color: #f9fbe7 !important;
}

.lime.lighten-4 {
  background-color: #f0f4c3 !important;
}

.lime.lighten-3 {
  background-color: #e6ee9c !important;
}

.lime.lighten-2 {
  background-color: #dce775 !important;
}

.lime.lighten-1 {
  background-color: #d4e157 !important;
}

.lime {
  background-color: #cddc39 !important;
}

.lime-text {
  color: #cddc39 !important;
}

.lime.darken-1 {
  background-color: #c0ca33 !important;
}

.lime.darken-2 {
  background-color: #afb42b !important;
}

.lime.darken-3 {
  background-color: #9e9d24 !important;
}

.lime.darken-4 {
  background-color: #827717 !important;
}

.lime.accent-1 {
  background-color: #f4ff81 !important;
}

.lime.accent-2 {
  background-color: #eeff41 !important;
}

.lime.accent-3 {
  background-color: #c6ff00 !important;
}

.lime.accent-4 {
  background-color: #aeea00 !important;
}

.yellow.lighten-5 {
  background-color: #fffde7 !important;
}

.yellow.lighten-4 {
  background-color: #fff9c4 !important;
}

.yellow.lighten-3 {
  background-color: #fff59d !important;
}

.yellow.lighten-2 {
  background-color: #fff176 !important;
}

.yellow.lighten-1 {
  background-color: #ffee58 !important;
}

.yellow {
  background-color: #ffeb3b !important;
}

.yellow-text {
  color: #ffeb3b !important;
}

.yellow.darken-1 {
  background-color: #fdd835 !important;
}

.yellow.darken-2 {
  background-color: #fbc02d !important;
}

.yellow.darken-3 {
  background-color: #f9a825 !important;
}

.yellow.darken-4 {
  background-color: #f57f17 !important;
}

.yellow.accent-1 {
  background-color: #ffff8d !important;
}

.yellow.accent-2 {
  background-color: #ffff00 !important;
}

.yellow.accent-3 {
  background-color: #ffea00 !important;
}

.yellow.accent-4 {
  background-color: #ffd600 !important;
}

.amber.lighten-5 {
  background-color: #fff8e1 !important;
}

.amber.lighten-4 {
  background-color: #ffecb3 !important;
}

.amber.lighten-3 {
  background-color: #ffe082 !important;
}

.amber.lighten-2 {
  background-color: #ffd54f !important;
}

.amber.lighten-1 {
  background-color: #ffca28 !important;
}

.amber {
  background-color: #ffc107 !important;
}

.amber-text {
  color: #ffc107 !important;
}

.amber.darken-1 {
  background-color: #ffb300 !important;
}

.amber.darken-2 {
  background-color: #ffa000 !important;
}

.amber.darken-3 {
  background-color: #ff8f00 !important;
}

.amber.darken-4 {
  background-color: #ff6f00 !important;
}

.amber.accent-1 {
  background-color: #ffe57f !important;
}

.amber.accent-2 {
  background-color: #ffd740 !important;
}

.amber.accent-3 {
  background-color: #ffc400 !important;
}

.amber.accent-4 {
  background-color: #ffab00 !important;
}

.orange.lighten-5 {
  background-color: #fff3e0 !important;
}

.orange.lighten-4 {
  background-color: #ffe0b2 !important;
}

.orange.lighten-3 {
  background-color: #ffcc80 !important;
}

.orange.lighten-2 {
  background-color: #ffb74d !important;
}

.orange.lighten-1 {
  background-color: #ffa726 !important;
}

.orange {
  background-color: #ff9800 !important;
}

.orange-text {
  color: #ff9800 !important;
}

.orange.darken-1 {
  background-color: #fb8c00 !important;
}

.orange.darken-2 {
  background-color: #f57c00 !important;
}

.orange.darken-3 {
  background-color: #ef6c00 !important;
}

.orange.darken-4 {
  background-color: #e65100 !important;
}

.orange.accent-1 {
  background-color: #ffd180 !important;
}

.orange.accent-2 {
  background-color: #ffab40 !important;
}

.orange.accent-3 {
  background-color: #ff9100 !important;
}

.orange.accent-4 {
  background-color: #ff6d00 !important;
}

.deep-orange.lighten-5 {
  background-color: #fbe9e7 !important;
}

.deep-orange.lighten-4 {
  background-color: #ffccbc !important;
}

.deep-orange.lighten-3 {
  background-color: #ffab91 !important;
}

.deep-orange.lighten-2 {
  background-color: #ff8a65 !important;
}

.deep-orange.lighten-1 {
  background-color: #ff7043 !important;
}

.deep-orange {
  background-color: #ff5722 !important;
}

.deep-orange-text {
  color: #ff5722 !important;
}

.deep-orange.darken-1 {
  background-color: #f4511e !important;
}

.deep-orange.darken-2 {
  background-color: #e64a19 !important;
}

.deep-orange.darken-3 {
  background-color: #d84315 !important;
}

.deep-orange.darken-4 {
  background-color: #bf360c !important;
}

.deep-orange.accent-1 {
  background-color: #ff9e80 !important;
}

.deep-orange.accent-2 {
  background-color: #ff6e40 !important;
}

.deep-orange.accent-3 {
  background-color: #ff3d00 !important;
}

.deep-orange.accent-4 {
  background-color: #dd2c00 !important;
}

.brown.lighten-5 {
  background-color: #efebe9 !important;
}

.brown.lighten-4 {
  background-color: #d7ccc8 !important;
}

.brown.lighten-3 {
  background-color: #bcaaa4 !important;
}

.brown.lighten-2 {
  background-color: #a1887f !important;
}

.brown.lighten-1 {
  background-color: #8d6e63 !important;
}

.brown {
  background-color: #795548 !important;
}

.brown-text {
  color: #795548 !important;
}

.brown.darken-1 {
  background-color: #6d4c41 !important;
}

.brown.darken-2 {
  background-color: #5d4037 !important;
}

.brown.darken-3 {
  background-color: #4e342e !important;
}

.brown.darken-4 {
  background-color: #3e2723 !important;
}

.blue-grey.lighten-5 {
  background-color: #eceff1 !important;
}

.blue-grey.lighten-4 {
  background-color: #cfd8dc !important;
}

.blue-grey.lighten-3 {
  background-color: #b0bec5 !important;
}

.blue-grey.lighten-2 {
  background-color: #90a4ae !important;
}

.blue-grey.lighten-1 {
  background-color: #78909c !important;
}

.blue-grey {
  background-color: #607d8b !important;
}

.blue-grey-text {
  color: #607d8b !important;
}

.blue-grey.darken-1 {
  background-color: #546e7a !important;
}

.blue-grey.darken-2 {
  background-color: #455a64 !important;
}

.blue-grey.darken-3 {
  background-color: #37474f !important;
}

.blue-grey.darken-4 {
  background-color: #263238 !important;
}

.grey.lighten-5 {
  background-color: #fafafa !important;
}

.grey.lighten-4 {
  background-color: #f5f5f5 !important;
}

.grey.lighten-3 {
  background-color: #eeeeee !important;
}

.grey.lighten-2 {
  background-color: #e0e0e0 !important;
}

.grey.lighten-1 {
  background-color: #bdbdbd !important;
}

.grey {
  background-color: #9e9e9e !important;
}

.grey-text {
  color: #9e9e9e !important;
}

.grey.darken-1 {
  background-color: #757575 !important;
}

.grey.darken-2 {
  background-color: #616161 !important;
}

.grey.darken-3 {
  background-color: #424242 !important;
}

.grey.darken-4 {
  background-color: #212121 !important;
}

.shades.black {
  background-color: #000000 !important;
}

.shades.white {
  background-color: #FFFFFF !important;
}

.shades.transparent {
  background-color: transparent !important;
}

.black {
  background-color: #000000 !important;
}

.black-text {
  color: #000000 !important;
}

.white {
  background-color: #FFFFFF !important;
}

.white-text {
  color: #FFFFFF !important;
}

.transparent {
  background-color: transparent !important;
}

.transparent-text {
  color: transparent !important;
}

.light-blue-text {
  color: #82B1FF !important;
}

.dark-grey-text {
  color: #4f4f4f !important;
}

.danger-color {
  background-color: #ED5564 !important;
}

.danger-color-dark {
  background-color: #CC0000 !important;
}

.warning-color {
  background-color: #FCCE54 !important;
}

.warning-color-dark {
  background-color: #FF8800 !important;
}

.success-color {
  background-color: #7dc855 !important;
}

.success-color-dark {
  background-color: #007E33 !important;
}

.info-color {
  background-color: #78BCEE !important;
}

.info-color-dark {
  background-color: #0099CC !important;
}

.default-color {
  background-color: #2BBBAD !important;
}

.default-color-dark {
  background-color: #00695c !important;
}

.primary-color {
  background-color: #4285F4 !important;
}

.primary-color-dark {
  background-color: #0d47a1 !important;
}

.secondary-color {
  background-color: #aa66cc !important;
}

.secondary-color-dark {
  background-color: #9933CC !important;
}

.elegant-color {
  background-color: #2E2E2E !important;
}

.elegant-color-dark {
  background-color: #212121 !important;
}

.stylish-color {
  background-color: #4B515D !important;
}

.stylish-color-dark {
  background-color: #3E4551 !important;
}

.special-color {
  background-color: #37474F !important;
}

.special-color-dark {
  background-color: #263238 !important;
}

.unique-color {
  background-color: #3F729B !important;
}

.unique-color-dark {
  background-color: #1C2331 !important;
}

.mdb-color {
  background-color: #45526E !important;
}

.rgba-blue-light {
  background-color: rgba(3, 169, 244, 0.3) !important;
}

.rgba-red-light {
  background-color: rgba(244, 67, 54, 0.3) !important;
}

.rgba-pink-light {
  background-color: rgba(233, 30, 99, 0.3) !important;
}

.rgba-purple-light {
  background-color: rgba(156, 39, 176, 0.3) !important;
}

.rgba-indigo-light {
  background-color: rgba(63, 81, 181, 0.3) !important;
}

.rgba-cyan-light {
  background-color: rgba(0, 188, 212, 0.3) !important;
}

.rgba-teal-light {
  background-color: rgba(0, 150, 136, 0.3) !important;
}

.rgba-green-light {
  background-color: rgba(76, 175, 80, 0.3) !important;
}

.rgba-lime-light {
  background-color: rgba(205, 220, 57, 0.3) !important;
}

.rgba-yellow-light {
  background-color: rgba(255, 235, 59, 0.3) !important;
}

.rgba-orange-light {
  background-color: rgba(255, 152, 0, 0.3) !important;
}

.rgba-brown-light {
  background-color: rgba(121, 85, 72, 0.3) !important;
}

.rgba-grey-light {
  background-color: rgba(158, 158, 158, 0.3) !important;
}

.rgba-bluegrey-light {
  background-color: rgba(96, 125, 139, 0.3) !important;
}

.rgba-black-light {
  background-color: rgba(0, 0, 0, 0.3) !important;
}

.rgba-stylish-light {
  background-color: rgba(62, 69, 81, 0.3) !important;
}

.rgba-white-light {
  background-color: rgba(255, 255, 255, 0.3) !important;
}

.rgba-blue-strong {
  background-color: rgba(3, 169, 244, 0.7) !important;
}

.rgba-red-strong {
  background-color: rgba(244, 67, 54, 0.7) !important;
}

.rgba-pink-strong {
  background-color: rgba(233, 30, 99, 0.7) !important;
}

.rgba-purple-strong {
  background-color: rgba(156, 39, 176, 0.7) !important;
}

.rgba-indigo-strong {
  background-color: rgba(63, 81, 181, 0.7) !important;
}

.rgba-cyan-strong {
  background-color: rgba(0, 188, 212, 0.7) !important;
}

.rgba-teal-strong {
  background-color: rgba(0, 150, 136, 0.7) !important;
}

.rgba-green-strong {
  background-color: rgba(76, 175, 80, 0.7) !important;
}

.rgba-lime-strong {
  background-color: rgba(205, 220, 57, 0.7) !important;
}

.rgba-yellow-strong {
  background-color: rgba(255, 235, 59, 0.7) !important;
}

.rgba-orange-strong {
  background-color: rgba(255, 152, 0, 0.7) !important;
}

.rgba-brown-strong {
  background-color: rgba(121, 85, 72, 0.7) !important;
}

.rgba-grey-strong {
  background-color: rgba(158, 158, 158, 0.7) !important;
}

.rgba-bluegrey-strong {
  background-color: rgba(96, 125, 139, 0.7) !important;
}

.rgba-black-strong {
  background-color: rgba(0, 0, 0, 0.7) !important;
}

.rgba-stylish-strong {
  background-color: rgba(62, 69, 81, 0.7) !important;
}

.rgba-white-strong {
  background-color: rgba(255, 255, 255, 0.7) !important;
}

.rgba-blue-slight {
  background-color: rgba(3, 169, 244, 0.1) !important;
}

.rgba-red-slight {
  background-color: rgba(244, 67, 54, 0.1) !important;
}

.rgba-pink-slight {
  background-color: rgba(233, 30, 99, 0.1) !important;
}

.rgba-purple-slight {
  background-color: rgba(156, 39, 176, 0.1) !important;
}

.rgba-indigo-slight {
  background-color: rgba(63, 81, 181, 0.1) !important;
}

.rgba-cyan-slight {
  background-color: rgba(0, 188, 212, 0.1) !important;
}

.rgba-teal-slight {
  background-color: rgba(0, 150, 136, 0.1) !important;
}

.rgba-green-slight {
  background-color: rgba(76, 175, 80, 0.1) !important;
}

.rgba-lime-slight {
  background-color: rgba(205, 220, 57, 0.1) !important;
}

.rgba-yellow-slight {
  background-color: rgba(255, 235, 59, 0.1) !important;
}

.rgba-orange-slight {
  background-color: rgba(255, 152, 0, 0.1) !important;
}

.rgba-brown-slight {
  background-color: rgba(121, 85, 72, 0.1) !important;
}

.rgba-grey-slight {
  background-color: rgba(158, 158, 158, 0.1) !important;
}

.rgba-bluegrey-slight {
  background-color: rgba(96, 125, 139, 0.1) !important;
}

.rgba-black-slight {
  background-color: rgba(0, 0, 0, 0.1) !important;
}

.rgba-stylish-slight {
  background-color: rgba(62, 69, 81, 0.1) !important;
}

.rgba-white-slight {
  background-color: rgba(255, 255, 255, 0.1) !important;
}

.bg-primary {
  background-color: #4285F4 !important;
}

.bg-danger {
  background-color: #ED5564 !important;
}

.bg-warning {
  background-color: #FF8800 !important;
}

.bg-success {
  background-color: #7dc855 !important;
}

.bg-info {
  background-color: #78BCEE !important;
}

.bg-default {
  background-color: #2BBBAD !important;
}

.bg-secondary {
  background-color: #aa66cc !important;
}

.bg-elegant {
  background-color: #2E2E2E !important;
}

.bg-unique {
  background-color: #880e4f !important;
}

.bg-dark-green {
  background-color: #388E3C !important;
}

.bg-mdb-color {
  background-color: #59698D !important;
}

.bg-red {
  background-color: #D32F2F !important;
}

.bg-pink {
  background-color: #ec407a !important;
}

.bg-purple {
  background-color: #8e24aa !important;
}

.bg-deep-purple {
  background-color: #512da8 !important;
}

.bg-indigo {
  background-color: #3f51b5 !important;
}

.bg-blue {
  background-color: #1976D2 !important;
}

.bg-light-blue {
  background-color: #82B1FF !important;
}

.bg-cyan {
  background-color: #00bcd4 !important;
}

.bg-teal {
  background-color: #00796b !important;
}

.bg-green {
  background-color: #388E3C !important;
}

.bg-light-green {
  background-color: #8bc34a !important;
}

.bg-lime {
  background-color: #afb42b !important;
}

.bg-yellow {
  background-color: #fbc02d !important;
}

.bg-amber {
  background-color: #ffa000 !important;
}

.bg-orange {
  background-color: #f57c00 !important;
}

.bg-deep-orange {
  background-color: #ff7043 !important;
}

.bg-brown {
  background-color: #795548 !important;
}

.bg-grey {
  background-color: #616161 !important;
}

.bg-blue-grey {
  background-color: #78909c !important;
}

.bg-white {
  background-color: #fff !important;
}

.bg-black {
  background-color: #000 !important;
}

.zolkusowy-gradient {
  background: #00ff90;
  background: -moz-linear-gradient(top, #00ff90 0%, #59ffdd 47%, #ffff00 100%);
  background: -webkit-linear-gradient(top, #00ff90 0%, #59ffdd 47%, #ffff00 100%);
  background: linear-gradient(to bottom, #00ff90 0%, #59ffdd 47%, #ffff00 100%);
}

/*
 * Basic or Must have Elements
 * You might not want to comment or delete them
 */
footer {
  background-color: #fff;
  border-top: 1px solid #eee;
  padding: 35px 0 0;
}
@media (max-width: 420px) {
  footer .brand {
    text-align: center;
  }
}
footer h6 {
  font-weight: 400;
}
footer .brand img {
  padding-top: 50px;
  padding-bottom: 50px;
}
footer ul {
  padding: 0;
}
footer .footer-links {
  padding-top: 5px;
}
footer .footer-links li {
  display: block;
  list-style: none;
}
footer .footer-links li a {
  color: #86939e;
  line-height: 26px;
}
footer .footer-links li a:hover {
  color: #03a9f4;
}
footer .social {
  padding: 20px 0;
}
footer .copyright {
  color: #5e6977;
}
footer li {
  position: relative;
}
footer .customeIconList {
  margin-top: 30px;
}
footer .customeIconList li {
  position: relative;
  padding-left: 15px;
  display: block;
  margin-bottom: 25px;
}
footer ul.customeIconList > li {
  padding-left: 30px;
}
footer .customeIconList li .icon {
  position: absolute;
  top: 0;
  left: 0;
  font-size: 16px;
  color: #5fb7ea;
}
footer hr {
  border-top: 1px solid rgba(255, 255, 255, 0.05);
}
footer .copyrights {
  padding: 10px 0;
  font-weight: 300;
}

.user_profile {
  width: 200px;
  border: 1px solid #eee;
  background: #fff;
  padding: 5px;
  border-radius: 50%;
}

/***************************** 3- Topics ****************************/
.topics {
  padding: 50px 0;
}
.topics header {
  border-bottom: 1px solid #eee;
  position: relative;
}
.topics header h2 {
  font-size: 38px;
  font-weight: 300;
  font-family: "Roboto", sans-serif;
  color: #43484d;
}
.topics header p {
  font-size: 16px;
  font-weight: 300;
  font-family: "Roboto", sans-serif;
  color: #5e6977;
}
.topics .topics-btn {
  margin-top: 30px;
}
.topics .topics-btn .btn {
  margin-top: 60px;
  color: #358ed7;
}
.topics .topics-btn span {
  display: inline;
  padding-left: 30px;
}
.topics .topic-header {
  font-size: 18px;
  font-weight: 400;
  font-family: "Roboto", sans-serif;
  color: #43484d;
  text-decoration: none;
}

.media-border {
  border-bottom: 1px solid #eeeeee;
}

.topics-wrapper {
  border-radius: 5px;
  margin-bottom: 40px;
}
.topics-wrapper h3 {
  padding: 0;
}
.topics-wrapper .topics-list {
  padding: 20px 0;
}
.topics-wrapper .topics-list li {
  list-style: none;
  line-height: 35px;
}
.topics-wrapper .topics-list li a {
  padding-left: 25px;
  color: #86939e;
  font-size: 12px;
  font-weight: 400;
  text-decoration: none;
  outline: 0 none;
}
.topics-wrapper .topics-list li a:hover {
  color: #03a9f4;
}
.topics-wrapper .topics-list li:before {
  color: #b5bfc7;
  font-size: 18px;
}
.topics-wrapper .topics-meta {
  padding: 7px 0;
  margin: 0;
  border-top: 1px solid #e1e8ee;
}
.topics-wrapper .topics-meta li {
  list-style: none;
  display: inline-block;
  color: #5e6977;
  font-size: 14px;
  font-weight: 300;
  padding-right: 10px;
}
.topics-wrapper .icon {
  color: #4ea9e0;
  font-size: 24px;
  font-weight: bold;
  margin-right: 15px;
}

.topics-wrapper.border-style {
  border: 3px solid #e1e8ee;
}
.topics-wrapper.border-style h3 {
  padding: 20px 40px 0;
}
.topics-wrapper.border-style .topics-list {
  padding: 20px 40px;
}
.topics-wrapper.border-style .topics-list li {
  position: relative;
  padding-left: 5px;
}
.topics-wrapper.border-style .topics-meta {
  background: #f5f8fa;
  padding: 7px 10px;
  text-align: center;
  border-top: 1px solid #e1e8ee;
}

/*
 * Templates Specific Styles
 */
.bg-icon-plane {
  background-image: url("../img/icon/icon-plane.png");
  background-repeat: no-repeat;
}

.template-resume .contactBar .icon {
  padding: 15px;
}
.template-resume .resume-header {
  background-color: #f5f8fa;
  background-position: bottom center;
  color: #86939e;
  padding-top: 150px;
  padding-bottom: 150px;
  border-bottom: 1px solid #e1e8ee;
  z-index: -1;
  text-align: center;
}
.template-resume .resume-header h1 {
  font-size: 48px;
  color: #86939e;
  text-transform: capitalize;
  font-weight: 100;
}
.template-resume .resume-header .subtitle {
  font-size: 24px;
  padding: 35px 0;
}
.template-resume .profiles {
  text-align: center;
}

.resume2 .resume-header {
  padding: 78px 0;
}

/*
 * Components
 */
.paper-timeline {
  list-style: none;
  position: relative;
}

.paper-timeline:before {
  top: 30px;
  bottom: 0;
  position: absolute;
  content: " ";
  width: 3px;
  background-color: #f5f8fa;
  left: 50%;
  margin-left: -1.5px;
  z-index: -1;
}

.paper-timeline .clearFix {
  clear: both;
  height: 0;
}

.start-icon svg {
  display: block;
  margin: 0 auto;
  margin-bottom: 0px;
  color: #dfe7ed;
  font-size: 64px;
  background-color: #fff;
}

.end-icon svg {
  display: block;
  margin: 0 auto;
  margin-bottom: 0px;
  color: #f5f8fa;
  font-size: 15px;
  background-color: #fff;
}

.paper-timeline {
  color: #86939e;
  padding-bottom: 80px;
}
.paper-timeline .timeline-item h3 {
  font-size: 18px;
  font-weight: 400;
  color: #86939e;
}
.paper-timeline .left::after {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  right: 0;
  top: 50%;
  width: 66px;
}
.paper-timeline .right::before {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  left: 0;
  top: 50%;
  width: 66px;
}
.paper-timeline .mini .left::after {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  right: 0;
  top: 50%;
  width: 56px;
}
.paper-timeline .mini .right::before {
  border: 2px solid #f5f8fa;
  content: "";
  height: 3px;
  position: absolute;
  left: 0;
  top: 50%;
  width: 56px;
}
.paper-timeline .timeline-panel {
  border: 3px solid #f5f8fa;
  border-radius: 5px;
  padding: 20px 30px 10px;
  position: relative;
  background: #fff;
}
@media (max-width: 980px) {
  .paper-timeline .timeline-panel {
    margin-top: 30px;
  }
  .paper-timeline .left::after {
    border: none !important;
  }
  .paper-timeline .right::before {
    border: none !important;
  }
}

.contactBar {
  margin-top: -80px;
  z-index: 96;
}
.contactBar .contacts {
  border: 1px solid #e1e8ee;
  border-radius: 5px;
  background: #fff;
  text-align: center;
}
.contactBar .contacts a {
  color: #86939e;
}
.contactBar .icon {
  padding: 30px;
  font-size: 48px;
  display: block;
}
.contactBar img {
  padding: 25px;
}
.contactBar .grey {
  background: #fbfcfd;
}
.contactBar .btn {
  margin-top: 45px;
  padding: 18px 70px;
}
.contactBar p {
  margin-bottom: 20px;
}
@media (max-width: 980px) {
  .contactBar .btn {
    margin-bottom: 22px;
    margin-top: 22px;
  }
}

.contactIcon {
  color: #dfe7ed;
  font-size: 64px;
  margin-top: 25px;
  margin-bottom: 25px;
}

.service-blocks .service-block {
  margin-bottom: 35px;
}
.service-blocks .service-block .service-icon {
  float: left;
}
.service-blocks .service-block .service-icon svg {
  border-radius: 100%;
  color: #86939e;
  height: 70px;
  width: 70px;
  display: flex;
  flex-direction: column;
}
.service-blocks .service-block:hover .service-icon svg {
  opacity: 0.5;
}
.service-blocks .service-block .service-icon svg {
  font-size: 60px;
  color: #dfe7ed;
}
.service-blocks .service-block .service-icon svg::before {
  font-size: 60px;
  color: #dfe7ed;
}
.service-blocks .service-block .service-content {
  overflow: hidden;
}
.service-blocks .service-block .service-content h3 {
  font-size: 18px;
  margin-bottom: 10px;
  font-weight: 400;
}
.service-blocks .service-block .service-content h3 a {
  color: #606676;
}
.service-blocks .service-block .service-content h3 a:hover {
  color: #03a9f4;
}
.service-blocks .service-block .btn {
  margin: 20px 0 10px 0;
}
.service-blocks .service-block.s1 .service-icon {
  float: none;
}
.service-blocks .service-block.s2 {
  padding: 20px;
}
.service-blocks .service-block.s2 .service-icon svg::before {
  font-size: 40px;
}
.service-blocks .center {
  text-align: center;
}
.service-blocks .center .service-icon {
  float: none !important;
}
.service-blocks .center .service-icon svg {
  margin: 0 auto;
}

.single-service-contents {
  padding: 100px 0 65px;
}

/*# sourceMappingURL=app.css.map */

	</style>
	
	</head>
	<body>
		<div id="app">
			<main class="template-resume resume2">
				<section class="resume-header bg-icon-plane">
					<div class="container">
						<div class="row">
							<div class="col-8 mx-md-auto">
								<h1>Noah Scharrenberg</h1>
			
								<p class="subtitle">Software Engineer</p>
			
									<img src="https://www.arion.run/wp-content/uploads/2020/02/noah-ddw.png" alt="Noah Scharrenberg" class="user_profile">
			
									<ul class="social">
											<li class="linkedin">
												<a href="https://www.linkedin.com/in/nscharrenberg/" target="_blank" title="nscharrenberg on linkedin">
													<i class="fab fa-linkedin"></i>
												</a>
											</li>
											<li class="github">
												<a href="https://github.com/nscharrenberg" target="_blank" title="nscharrenberg on github">
													<i class="fab fa-github"></i>
												</a>
											</li>
									</ul>
							</div>
						</div>
					</div>
				</section>
			
				<section class="contactBar">
					<div class="container">
						<div class="row contacts">
								<div class="col-md">
									<span>
										<i class="fas fa-link contactIcon"></i>
									</span>
			
									<p>
										<a href="https://nscharrenberg.nl"> https://nscharrenberg.nl</a>
									</p>
								</div>
			
								<div class="col-md">
									<span>
										<i class="fas fa-envelope-open contactIcon"></i>
									</span>
			
									<p>
										<a href="nscharrenberg@hotmail.com"> nscharrenberg@hotmail.com</a>
									</p>
								</div>
			
								<div class="col-md">
									<span>
										<i class="fas fa-map-marker-alt contactIcon"></i>
									</span>
			
									<p>
										<a href="Kruidenlaan 148, Venray, Limburg, NL, 5803BH"> Kruidenlaan 148, Venray, Limburg, NL, 5803BH</a>
									</p>
								</div>
						</div>
					</div>
				</section>
			
				<section id="about-me">
					<div class="container">
						<header class="section-heading p-t-40">
							<h2>About</h2>
							
						</header>
					</div>
				</section>
			<section id="work">
				<h2>Work</h2>
				<div class="item">
					<h3 class="name">
						Student aan huis
					</h3>
					<div class="date">
						<span class="startDate">
							Aug, 2016
						</span>
						<span class="endDate">
							- Aug, 2018
						</span>
					</div>
					<div class="position">
						IT Support
					</div>
					<div class="website">
						<a href="https://www.studentaanhuis.nl/">https://www.studentaanhuis.nl/</a>
					</div>
					<div class="summary">
						<p>&lt;p&gt;Solving and teaching IT related problems at location for customers from diffirent target groups.&lt;/p&gt;
			</p>
					</div>
				</div>
				<div class="item">
					<h3 class="name">
						Bearingpoint Caribbean
					</h3>
					<div class="date">
						<span class="startDate">
							Aug, 2018
						</span>
						<span class="endDate">
							- Jan, 2019
						</span>
					</div>
					<div class="position">
						Blockchain Intern
					</div>
					<div class="website">
						<a href="https://www.bearingpointcaribbean.com/en/">https://www.bearingpointcaribbean.com/en/</a>
					</div>
					<div class="summary">
						<p>&lt;p&gt;Performing research on the possibilities of Blockchain within the companies portfolio, providing an advisory report regarding and a basic prototype with Blockchain integration on an existing system.&lt;/p&gt;
			</p>
					</div>
				</div>
				<div class="item">
					<h3 class="name">
						ATO-Gear
					</h3>
					<div class="date">
						<span class="startDate">
							Jan, 2020
						</span>
						<span class="endDate">
							- Present
						</span>
					</div>
					<div class="position">
						Intern
					</div>
					<div class="website">
						<a href="https://www.arion.run/">https://www.arion.run/</a>
					</div>
					<div class="summary">
						<p>&lt;p&gt;Researching the implementation of a conversational AI within the Arion app, to avoid users from touching their phone during running.&lt;/p&gt;
			</p>
					</div>
				</div>
			</section>
			<section id="volunteer">
				<h2>Volunteer</h2>
				<div class="item">
					<h3 class="company">
						Stichting DOG
					</h3>
					<div class="date">
						<span class="startDate">
							Sep, 2018
						</span>
						<span class="endDate">
							- Jan, 2019
						</span>
					</div>
					<div class="position">
						Volunteer
					</div>
					<div class="website">
						<a href="https://stichtingdog.org/">https://stichtingdog.org/</a>
					</div>
					<div class="summary">
						<p>&lt;p&gt;Helping with the maintenance of the terrain and caretaking of the dogs.&lt;/p&gt;
			</p>
					</div>
				</div>
			</section>
			<section id="education">
				<h2>Education</h2>
				<div class="item">
					<div class="date">
						<span class="startDate">
							Aug, 2016
						</span>
						<span class="endDate">
							- Present
						</span>
					</div>
					<div class="institution">
						Fontys University of Applied Sciences
					</div>
					<div class="area">
						Software Engineering
					</div>
					<div class="studyType">
						Bachelor of Science
					</div>
				</div>
			</section>
			<section id="skills">
				<h2>Skills</h2>
				<div class="item">
					<div class="name">
						Web Development
					</div>
					<div class="level">
						<em>Advanced</em>
					</div>
					<ul class="keywords">
						<li>&lt;p&gt;HTML&lt;/p&gt;
			</li>
						<li>&lt;p&gt;CSS&lt;/p&gt;
			</li>
						<li>&lt;p&gt;Javascript&lt;/p&gt;
			</li>
						<li>&lt;p&gt;Vue&lt;/p&gt;
			</li>
						<li>&lt;p&gt;Angular&lt;/p&gt;
			</li>
						<li>&lt;p&gt;React&lt;/p&gt;
			</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Mobile Development
					</div>
					<div class="level">
						<em>Beginner</em>
					</div>
					<ul class="keywords">
						<li>&lt;p&gt;React-Native&lt;/p&gt;
			</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Java
					</div>
					<div class="level">
						<em>Advanced</em>
					</div>
					<ul class="keywords">
						<li>&lt;p&gt;Java EE&lt;/p&gt;
			</li>
						<li>&lt;p&gt;Sprint&lt;/p&gt;
			</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Blockchain
					</div>
					<div class="level">
						<em>Advanced</em>
					</div>
				</div>
				<div class="item">
					<div class="name">
						C#
					</div>
					<div class="level">
						<em>Average</em>
					</div>
					<ul class="keywords">
						<li>&lt;p&gt;ASP.NET&lt;/p&gt;
			</li>
						<li>&lt;p&gt;.NET Core&lt;/p&gt;
			</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Artificial Intelligence
					</div>
					<div class="level">
						<em>Beginner</em>
					</div>
				</div>
			</section>
			<section id="languages">
				<h2>Languages</h2>
				<div class="item">
					<div class="language">
						Dutch
					</div>
					<div class="fluency">
						<em>Native speaker</em>
					</div>
				</div>
				<div class="item">
					<div class="language">
						English
					</div>
					<div class="fluency">
						<em>Good</em>
					</div>
				</div>
				<div class="item">
					<div class="language">
						Deutsch
					</div>
					<div class="fluency">
						<em>Basic</em>
					</div>
				</div>
			</section>
			<section id="interests">
				<h2>Interests</h2>
				<div class="item">
					<div class="name">
						New or Interesting Technologies
					</div>
					<ul class="keywords">
						<li>Artificial Intelligence</li>
						<li>Blockchain</li>
					</ul>
				</div>
				<div class="item">
					<div class="name">
						Movies &amp; Series
					</div>
				</div>
				<div class="item">
					<div class="name">
						Music
					</div>
				</div>
				<div class="item">
					<div class="name">
						Traveling
					</div>
				</div>
			</section>
			</main>
		</div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script>
		<script>
			/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules &#x3D; {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module &#x3D; installedModules[moduleId] &#x3D; {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded &#x3D; true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m &#x3D; modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c &#x3D; installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p &#x3D; &quot;&quot;;

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports &#x3D; __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Boot everything we need for paper front end
	 * We are using Gulp webpack to include scripts because
	 * its supper simple
	 */

	__webpack_require__(2);

	__webpack_require__(219);

	__webpack_require__(220);

	__webpack_require__(222);

	__webpack_require__(223);

	__webpack_require__(224);

	__webpack_require__(226);

	__webpack_require__(227);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 * Scripts common for both Admin &amp; Front End.
	 */
	__webpack_require__(3);

	window.$ &#x3D; window.jQuery &#x3D; __webpack_require__(5);

	__webpack_require__(6);

	__webpack_require__(7);

	window.Popper &#x3D; __webpack_require__(8);

	__webpack_require__(9);

	__webpack_require__(10);

	__webpack_require__(11);

	__webpack_require__(12);

	__webpack_require__(14);

	__webpack_require__(15);

	__webpack_require__(16);

	__webpack_require__(18); // Masonary + isotope + portfolio filter

	__webpack_require__(27);

	__webpack_require__(29);

	__webpack_require__(31);

	__webpack_require__(32);

	__webpack_require__(215);

	__webpack_require__(217);

	__webpack_require__(218);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var NProgress &#x3D; __webpack_require__(4);
	document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
	    NProgress.start();
	});
	window.addEventListener(&#x27;load&#x27;, function() {
	    var body &#x3D; document.body;
	    var loader &#x3D; document.getElementById(&#x27;loader&#x27;);
	    body.classList.add(&#x27;loaded&#x27;);
	    loader.classList.add(&#x27;loader-fade&#x27;);
	    NProgress.done();
	}, true);

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
	 * @license MIT */

	;(function(root, factory) {

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (factory), __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports &#x3D;&#x3D;&#x3D; &#x27;object&#x27;) {
	    module.exports &#x3D; factory();
	  } else {
	    root.NProgress &#x3D; factory();
	  }

	})(this, function() {
	  var NProgress &#x3D; {};

	  NProgress.version &#x3D; &#x27;0.2.0&#x27;;

	  var Settings &#x3D; NProgress.settings &#x3D; {
	    minimum: 0.08,
	    easing: &#x27;ease&#x27;,
	    positionUsing: &#x27;&#x27;,
	    speed: 200,
	    trickle: true,
	    trickleRate: 0.02,
	    trickleSpeed: 800,
	    showSpinner: true,
	    barSelector: &#x27;[role&#x3D;&quot;bar&quot;]&#x27;,
	    spinnerSelector: &#x27;[role&#x3D;&quot;spinner&quot;]&#x27;,
	    parent: &#x27;body&#x27;,
	    template: &#x27;&lt;div class&#x3D;&quot;bar&quot; role&#x3D;&quot;bar&quot;&gt;&lt;div class&#x3D;&quot;peg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class&#x3D;&quot;spinner&quot; role&#x3D;&quot;spinner&quot;&gt;&lt;div class&#x3D;&quot;spinner-icon&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;
	  };

	  /**
	   * Updates configuration.
	   *
	   *     NProgress.configure({
	   *       minimum: 0.1
	   *     });
	   */
	  NProgress.configure &#x3D; function(options) {
	    var key, value;
	    for (key in options) {
	      value &#x3D; options[key];
	      if (value !&#x3D;&#x3D; undefined &amp;&amp; options.hasOwnProperty(key)) Settings[key] &#x3D; value;
	    }

	    return this;
	  };

	  /**
	   * Last number.
	   */

	  NProgress.status &#x3D; null;

	  /**
	   * Sets the progress bar status, where &#x60;n&#x60; is a number from &#x60;0.0&#x60; to &#x60;1.0&#x60;.
	   *
	   *     NProgress.set(0.4);
	   *     NProgress.set(1.0);
	   */

	  NProgress.set &#x3D; function(n) {
	    var started &#x3D; NProgress.isStarted();

	    n &#x3D; clamp(n, Settings.minimum, 1);
	    NProgress.status &#x3D; (n &#x3D;&#x3D;&#x3D; 1 ? null : n);

	    var progress &#x3D; NProgress.render(!started),
	        bar      &#x3D; progress.querySelector(Settings.barSelector),
	        speed    &#x3D; Settings.speed,
	        ease     &#x3D; Settings.easing;

	    progress.offsetWidth; /* Repaint */

	    queue(function(next) {
	      // Set positionUsing if it hasn&#x27;t already been set
	      if (Settings.positionUsing &#x3D;&#x3D;&#x3D; &#x27;&#x27;) Settings.positionUsing &#x3D; NProgress.getPositioningCSS();

	      // Add transition
	      css(bar, barPositionCSS(n, speed, ease));

	      if (n &#x3D;&#x3D;&#x3D; 1) {
	        // Fade out
	        css(progress, { 
	          transition: &#x27;none&#x27;, 
	          opacity: 1 
	        });
	        progress.offsetWidth; /* Repaint */

	        setTimeout(function() {
	          css(progress, { 
	            transition: &#x27;all &#x27; + speed + &#x27;ms linear&#x27;, 
	            opacity: 0 
	          });
	          setTimeout(function() {
	            NProgress.remove();
	            next();
	          }, speed);
	        }, speed);
	      } else {
	        setTimeout(next, speed);
	      }
	    });

	    return this;
	  };

	  NProgress.isStarted &#x3D; function() {
	    return typeof NProgress.status &#x3D;&#x3D;&#x3D; &#x27;number&#x27;;
	  };

	  /**
	   * Shows the progress bar.
	   * This is the same as setting the status to 0%, except that it doesn&#x27;t go backwards.
	   *
	   *     NProgress.start();
	   *
	   */
	  NProgress.start &#x3D; function() {
	    if (!NProgress.status) NProgress.set(0);

	    var work &#x3D; function() {
	      setTimeout(function() {
	        if (!NProgress.status) return;
	        NProgress.trickle();
	        work();
	      }, Settings.trickleSpeed);
	    };

	    if (Settings.trickle) work();

	    return this;
	  };

	  /**
	   * Hides the progress bar.
	   * This is the *sort of* the same as setting the status to 100%, with the
	   * difference being &#x60;done()&#x60; makes some placebo effect of some realistic motion.
	   *
	   *     NProgress.done();
	   *
	   * If &#x60;true&#x60; is passed, it will show the progress bar even if its hidden.
	   *
	   *     NProgress.done(true);
	   */

	  NProgress.done &#x3D; function(force) {
	    if (!force &amp;&amp; !NProgress.status) return this;

	    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
	  };

	  /**
	   * Increments by a random amount.
	   */

	  NProgress.inc &#x3D; function(amount) {
	    var n &#x3D; NProgress.status;

	    if (!n) {
	      return NProgress.start();
	    } else {
	      if (typeof amount !&#x3D;&#x3D; &#x27;number&#x27;) {
	        amount &#x3D; (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
	      }

	      n &#x3D; clamp(n + amount, 0, 0.994);
	      return NProgress.set(n);
	    }
	  };

	  NProgress.trickle &#x3D; function() {
	    return NProgress.inc(Math.random() * Settings.trickleRate);
	  };

	  /**
	   * Waits for all supplied jQuery promises and
	   * increases the progress as the promises resolve.
	   *
	   * @param $promise jQUery Promise
	   */
	  (function() {
	    var initial &#x3D; 0, current &#x3D; 0;

	    NProgress.promise &#x3D; function($promise) {
	      if (!$promise || $promise.state() &#x3D;&#x3D;&#x3D; &quot;resolved&quot;) {
	        return this;
	      }

	      if (current &#x3D;&#x3D;&#x3D; 0) {
	        NProgress.start();
	      }

	      initial++;
	      current++;

	      $promise.always(function() {
	        current--;
	        if (current &#x3D;&#x3D;&#x3D; 0) {
	            initial &#x3D; 0;
	            NProgress.done();
	        } else {
	            NProgress.set((initial - current) / initial);
	        }
	      });

	      return this;
	    };

	  })();

	  /**
	   * (Internal) renders the progress bar markup based on the &#x60;template&#x60;
	   * setting.
	   */

	  NProgress.render &#x3D; function(fromStart) {
	    if (NProgress.isRendered()) return document.getElementById(&#x27;nprogress&#x27;);

	    addClass(document.documentElement, &#x27;nprogress-busy&#x27;);
	    
	    var progress &#x3D; document.createElement(&#x27;div&#x27;);
	    progress.id &#x3D; &#x27;nprogress&#x27;;
	    progress.innerHTML &#x3D; Settings.template;

	    var bar      &#x3D; progress.querySelector(Settings.barSelector),
	        perc     &#x3D; fromStart ? &#x27;-100&#x27; : toBarPerc(NProgress.status || 0),
	        parent   &#x3D; document.querySelector(Settings.parent),
	        spinner;
	    
	    css(bar, {
	      transition: &#x27;all 0 linear&#x27;,
	      transform: &#x27;translate3d(&#x27; + perc + &#x27;%,0,0)&#x27;
	    });

	    if (!Settings.showSpinner) {
	      spinner &#x3D; progress.querySelector(Settings.spinnerSelector);
	      spinner &amp;&amp; removeElement(spinner);
	    }

	    if (parent !&#x3D; document.body) {
	      addClass(parent, &#x27;nprogress-custom-parent&#x27;);
	    }

	    parent.appendChild(progress);
	    return progress;
	  };

	  /**
	   * Removes the element. Opposite of render().
	   */

	  NProgress.remove &#x3D; function() {
	    removeClass(document.documentElement, &#x27;nprogress-busy&#x27;);
	    removeClass(document.querySelector(Settings.parent), &#x27;nprogress-custom-parent&#x27;);
	    var progress &#x3D; document.getElementById(&#x27;nprogress&#x27;);
	    progress &amp;&amp; removeElement(progress);
	  };

	  /**
	   * Checks if the progress bar is rendered.
	   */

	  NProgress.isRendered &#x3D; function() {
	    return !!document.getElementById(&#x27;nprogress&#x27;);
	  };

	  /**
	   * Determine which positioning CSS rule to use.
	   */

	  NProgress.getPositioningCSS &#x3D; function() {
	    // Sniff on document.body.style
	    var bodyStyle &#x3D; document.body.style;

	    // Sniff prefixes
	    var vendorPrefix &#x3D; (&#x27;WebkitTransform&#x27; in bodyStyle) ? &#x27;Webkit&#x27; :
	                       (&#x27;MozTransform&#x27; in bodyStyle) ? &#x27;Moz&#x27; :
	                       (&#x27;msTransform&#x27; in bodyStyle) ? &#x27;ms&#x27; :
	                       (&#x27;OTransform&#x27; in bodyStyle) ? &#x27;O&#x27; : &#x27;&#x27;;

	    if (vendorPrefix + &#x27;Perspective&#x27; in bodyStyle) {
	      // Modern browsers with 3D support, e.g. Webkit, IE10
	      return &#x27;translate3d&#x27;;
	    } else if (vendorPrefix + &#x27;Transform&#x27; in bodyStyle) {
	      // Browsers without 3D support, e.g. IE9
	      return &#x27;translate&#x27;;
	    } else {
	      // Browsers without translate() support, e.g. IE7-8
	      return &#x27;margin&#x27;;
	    }
	  };

	  /**
	   * Helpers
	   */

	  function clamp(n, min, max) {
	    if (n &lt; min) return min;
	    if (n &gt; max) return max;
	    return n;
	  }

	  /**
	   * (Internal) converts a percentage (&#x60;0..1&#x60;) to a bar translateX
	   * percentage (&#x60;-100%..0%&#x60;).
	   */

	  function toBarPerc(n) {
	    return (-1 + n) * 100;
	  }


	  /**
	   * (Internal) returns the correct CSS for changing the bar&#x27;s
	   * position given an n percentage, and speed and ease from Settings
	   */

	  function barPositionCSS(n, speed, ease) {
	    var barCSS;

	    if (Settings.positionUsing &#x3D;&#x3D;&#x3D; &#x27;translate3d&#x27;) {
	      barCSS &#x3D; { transform: &#x27;translate3d(&#x27;+toBarPerc(n)+&#x27;%,0,0)&#x27; };
	    } else if (Settings.positionUsing &#x3D;&#x3D;&#x3D; &#x27;translate&#x27;) {
	      barCSS &#x3D; { transform: &#x27;translate(&#x27;+toBarPerc(n)+&#x27;%,0)&#x27; };
	    } else {
	      barCSS &#x3D; { &#x27;margin-left&#x27;: toBarPerc(n)+&#x27;%&#x27; };
	    }

	    barCSS.transition &#x3D; &#x27;all &#x27;+speed+&#x27;ms &#x27;+ease;

	    return barCSS;
	  }

	  /**
	   * (Internal) Queues a function to be executed.
	   */

	  var queue &#x3D; (function() {
	    var pending &#x3D; [];
	    
	    function next() {
	      var fn &#x3D; pending.shift();
	      if (fn) {
	        fn(next);
	      }
	    }

	    return function(fn) {
	      pending.push(fn);
	      if (pending.length &#x3D;&#x3D; 1) next();
	    };
	  })();

	  /**
	   * (Internal) Applies css properties to an element, similar to the jQuery 
	   * css method.
	   *
	   * While this helper does assist with vendor prefixed property names, it 
	   * does not perform any manipulation of values prior to setting styles.
	   */

	  var css &#x3D; (function() {
	    var cssPrefixes &#x3D; [ &#x27;Webkit&#x27;, &#x27;O&#x27;, &#x27;Moz&#x27;, &#x27;ms&#x27; ],
	        cssProps    &#x3D; {};

	    function camelCase(string) {
	      return string.replace(/^-ms-/, &#x27;ms-&#x27;).replace(/-([\da-z])/gi, function(match, letter) {
	        return letter.toUpperCase();
	      });
	    }

	    function getVendorProp(name) {
	      var style &#x3D; document.body.style;
	      if (name in style) return name;

	      var i &#x3D; cssPrefixes.length,
	          capName &#x3D; name.charAt(0).toUpperCase() + name.slice(1),
	          vendorName;
	      while (i--) {
	        vendorName &#x3D; cssPrefixes[i] + capName;
	        if (vendorName in style) return vendorName;
	      }

	      return name;
	    }

	    function getStyleProp(name) {
	      name &#x3D; camelCase(name);
	      return cssProps[name] || (cssProps[name] &#x3D; getVendorProp(name));
	    }

	    function applyCss(element, prop, value) {
	      prop &#x3D; getStyleProp(prop);
	      element.style[prop] &#x3D; value;
	    }

	    return function(element, properties) {
	      var args &#x3D; arguments,
	          prop, 
	          value;

	      if (args.length &#x3D;&#x3D; 2) {
	        for (prop in properties) {
	          value &#x3D; properties[prop];
	          if (value !&#x3D;&#x3D; undefined &amp;&amp; properties.hasOwnProperty(prop)) applyCss(element, prop, value);
	        }
	      } else {
	        applyCss(element, args[1], args[2]);
	      }
	    }
	  })();

	  /**
	   * (Internal) Determines if an element or space separated list of class names contains a class name.
	   */

	  function hasClass(element, name) {
	    var list &#x3D; typeof element &#x3D;&#x3D; &#x27;string&#x27; ? element : classList(element);
	    return list.indexOf(&#x27; &#x27; + name + &#x27; &#x27;) &gt;&#x3D; 0;
	  }

	  /**
	   * (Internal) Adds a class to an element.
	   */

	  function addClass(element, name) {
	    var oldList &#x3D; classList(element),
	        newList &#x3D; oldList + name;

	    if (hasClass(oldList, name)) return; 

	    // Trim the opening space.
	    element.className &#x3D; newList.substring(1);
	  }

	  /**
	   * (Internal) Removes a class from an element.
	   */

	  function removeClass(element, name) {
	    var oldList &#x3D; classList(element),
	        newList;

	    if (!hasClass(element, name)) return;

	    // Replace the class name.
	    newList &#x3D; oldList.replace(&#x27; &#x27; + name + &#x27; &#x27;, &#x27; &#x27;);

	    // Trim the opening and closing spaces.
	    element.className &#x3D; newList.substring(1, newList.length - 1);
	  }

	  /**
	   * (Internal) Gets a space separated list of the class names on the element. 
	   * The list is wrapped with a single space on each end to facilitate finding 
	   * matches within the list.
	   */

	  function classList(element) {
	    return (&#x27; &#x27; + (element.className || &#x27;&#x27;) + &#x27; &#x27;).replace(/\s+/gi, &#x27; &#x27;);
	  }

	  /**
	   * (Internal) Removes an element from the DOM.
	   */

	  function removeElement(element) {
	    element &amp;&amp; element.parentNode &amp;&amp; element.parentNode.removeChild(element);
	  }

	  return NProgress;
	});



/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		&quot;use strict&quot;;

		if ( typeof module &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof module.exports &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {

			// For CommonJS and CommonJS-like environments where a proper &#x60;window&#x60;
			// is present, execute the factory and get jQuery.
			// For environments that do not have a &#x60;window&#x60; with a &#x60;document&#x60;
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real &#x60;window&#x60;.
			// e.g. var jQuery &#x3D; require(&quot;jquery&quot;)(window);
			// See ticket #14549 for more info.
			module.exports &#x3D; global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( &quot;jQuery requires a window with a document&quot; );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !&#x3D;&#x3D; &quot;undefined&quot; ? window : this, function( window, noGlobal ) {

	// Edge &lt;&#x3D; 12 - 13+, Firefox &lt;&#x3D;18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	&quot;use strict&quot;;

	var arr &#x3D; [];

	var document &#x3D; window.document;

	var getProto &#x3D; Object.getPrototypeOf;

	var slice &#x3D; arr.slice;

	var concat &#x3D; arr.concat;

	var push &#x3D; arr.push;

	var indexOf &#x3D; arr.indexOf;

	var class2type &#x3D; {};

	var toString &#x3D; class2type.toString;

	var hasOwn &#x3D; class2type.hasOwnProperty;

	var fnToString &#x3D; hasOwn.toString;

	var ObjectFunctionString &#x3D; fnToString.call( Object );

	var support &#x3D; {};

	var isFunction &#x3D; function isFunction( obj ) {

	      // Support: Chrome &lt;&#x3D;57, Firefox &lt;&#x3D;52
	      // In some browsers, typeof returns &quot;function&quot; for HTML &lt;object&gt; elements
	      // (i.e., &#x60;typeof document.createElement( &quot;object&quot; ) &#x3D;&#x3D;&#x3D; &quot;function&quot;&#x60;).
	      // We don&#x27;t want to classify *any* DOM node as a function.
	      return typeof obj &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; typeof obj.nodeType !&#x3D;&#x3D; &quot;number&quot;;
	  };


	var isWindow &#x3D; function isWindow( obj ) {
			return obj !&#x3D; null &amp;&amp; obj &#x3D;&#x3D;&#x3D; obj.window;
		};




		var preservedScriptAttributes &#x3D; {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc &#x3D; doc || document;

			var i,
				script &#x3D; doc.createElement( &quot;script&quot; );

			script.text &#x3D; code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] &#x3D; node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj &#x3D;&#x3D; null ) {
			return obj + &quot;&quot;;
		}

		// Support: Android &lt;&#x3D;2.3 only (functionish RegExp)
		return typeof obj &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof obj &#x3D;&#x3D;&#x3D; &quot;function&quot; ?
			class2type[ toString.call( obj ) ] || &quot;object&quot; :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version &#x3D; &quot;3.3.1&quot;,

		// Define a local copy of jQuery
		jQuery &#x3D; function( selector, context ) {

			// The jQuery object is actually just the init constructor &#x27;enhanced&#x27;
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android &lt;&#x3D;4.0 only
		// Make sure we trim BOM and NBSP
		rtrim &#x3D; /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn &#x3D; jQuery.prototype &#x3D; {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num &#x3D;&#x3D; null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num &lt; 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret &#x3D; jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject &#x3D; this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len &#x3D; this.length,
				j &#x3D; +i + ( i &lt; 0 ? len : 0 );
			return this.pushStack( j &gt;&#x3D; 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array&#x27;s method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend &#x3D; jQuery.fn.extend &#x3D; function() {
		var options, name, src, copy, copyIsArray, clone,
			target &#x3D; arguments[ 0 ] || {},
			i &#x3D; 1,
			length &#x3D; arguments.length,
			deep &#x3D; false;

		// Handle a deep copy situation
		if ( typeof target &#x3D;&#x3D;&#x3D; &quot;boolean&quot; ) {
			deep &#x3D; target;

			// Skip the boolean and the target
			target &#x3D; arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !&#x3D;&#x3D; &quot;object&quot; &amp;&amp; !isFunction( target ) ) {
			target &#x3D; {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i &#x3D;&#x3D;&#x3D; length ) {
			target &#x3D; this;
			i--;
		}

		for ( ; i &lt; length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options &#x3D; arguments[ i ] ) !&#x3D; null ) {

				// Extend the base object
				for ( name in options ) {
					src &#x3D; target[ name ];
					copy &#x3D; options[ name ];

					// Prevent never-ending loop
					if ( target &#x3D;&#x3D;&#x3D; copy ) {
						continue;
					}

					// Recurse if we&#x27;re merging plain objects or arrays
					if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||
						( copyIsArray &#x3D; Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray &#x3D; false;
							clone &#x3D; src &amp;&amp; Array.isArray( src ) ? src : [];

						} else {
							clone &#x3D; src &amp;&amp; jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] &#x3D; jQuery.extend( deep, clone, copy );

					// Don&#x27;t bring in undefined values
					} else if ( copy !&#x3D;&#x3D; undefined ) {
						target[ name ] &#x3D; copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !&#x3D;&#x3D; &quot;[object Object]&quot; ) {
				return false;
			}

			proto &#x3D; getProto( obj );

			// Objects with no prototype (e.g., &#x60;Object.create( null )&#x60;) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor &#x3D; hasOwn.call( proto, &quot;constructor&quot; ) &amp;&amp; proto.constructor;
			return typeof Ctor &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; fnToString.call( Ctor ) &#x3D;&#x3D;&#x3D; ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i &#x3D; 0;

			if ( isArrayLike( obj ) ) {
				length &#x3D; obj.length;
				for ( ; i &lt; length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) &#x3D;&#x3D;&#x3D; false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) &#x3D;&#x3D;&#x3D; false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android &lt;&#x3D;4.0 only
		trim: function( text ) {
			return text &#x3D;&#x3D; null ?
				&quot;&quot; :
				( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret &#x3D; results || [];

			if ( arr !&#x3D; null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr &#x3D;&#x3D;&#x3D; &quot;string&quot; ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr &#x3D;&#x3D; null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android &lt;&#x3D;4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len &#x3D; +second.length,
				j &#x3D; 0,
				i &#x3D; first.length;

			for ( ; j &lt; len; j++ ) {
				first[ i++ ] &#x3D; second[ j ];
			}

			first.length &#x3D; i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches &#x3D; [],
				i &#x3D; 0,
				length &#x3D; elems.length,
				callbackExpect &#x3D; !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i &lt; length; i++ ) {
				callbackInverse &#x3D; !callback( elems[ i ], i );
				if ( callbackInverse !&#x3D;&#x3D; callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i &#x3D; 0,
				ret &#x3D; [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length &#x3D; elems.length;
				for ( ; i &lt; length; i++ ) {
					value &#x3D; callback( elems[ i ], i, arg );

					if ( value !&#x3D; null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value &#x3D; callback( elems[ i ], i, arg );

					if ( value !&#x3D; null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol &#x3D;&#x3D;&#x3D; &quot;function&quot; ) {
		jQuery.fn[ Symbol.iterator ] &#x3D; arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( &quot;Boolean Number String Function Array Date RegExp Object Error Symbol&quot;.split( &quot; &quot; ),
	function( i, name ) {
		class2type[ &quot;[object &quot; + name + &quot;]&quot; ] &#x3D; name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// &#x60;in&#x60; check used to prevent JIT error (gh-2145)
		// hasOwn isn&#x27;t used here due to false negatives
		// regarding Nodelist length in IE
		var length &#x3D; !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,
			type &#x3D; toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type &#x3D;&#x3D;&#x3D; &quot;array&quot; || length &#x3D;&#x3D;&#x3D; 0 ||
			typeof length &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;
	}
	var Sizzle &#x3D;
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando &#x3D; &quot;sizzle&quot; + 1 * new Date(),
		preferredDoc &#x3D; window.document,
		dirruns &#x3D; 0,
		done &#x3D; 0,
		classCache &#x3D; createCache(),
		tokenCache &#x3D; createCache(),
		compilerCache &#x3D; createCache(),
		sortOrder &#x3D; function( a, b ) {
			if ( a &#x3D;&#x3D;&#x3D; b ) {
				hasDuplicate &#x3D; true;
			}
			return 0;
		},

		// Instance methods
		hasOwn &#x3D; ({}).hasOwnProperty,
		arr &#x3D; [],
		pop &#x3D; arr.pop,
		push_native &#x3D; arr.push,
		push &#x3D; arr.push,
		slice &#x3D; arr.slice,
		// Use a stripped-down indexOf as it&#x27;s faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf &#x3D; function( list, elem ) {
			var i &#x3D; 0,
				len &#x3D; list.length;
			for ( ; i &lt; len; i++ ) {
				if ( list[i] &#x3D;&#x3D;&#x3D; elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans &#x3D; &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace &#x3D; &quot;[\\x20\\t\\r\\n\\f]&quot;,

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier &#x3D; &quot;(?:\\\\.|[\\w-]|[^\0-\\xa0])+&quot;,

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes &#x3D; &quot;\\[&quot; + whitespace + &quot;*(&quot; + identifier + &quot;)(?:&quot; + whitespace +
			// Operator (capture 2)
			&quot;*([*^$|!~]?&#x3D;)&quot; + whitespace +
			// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;
			&quot;*(?:&#x27;((?:\\\\.|[^\\\\&#x27;])*)&#x27;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot; + identifier + &quot;))|)&quot; + whitespace +
			&quot;*\\]&quot;,

		pseudos &#x3D; &quot;:(&quot; + identifier + &quot;)(?:\\((&quot; +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			&quot;(&#x27;((?:\\\\.|[^\\\\&#x27;])*)&#x27;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot; +
			// 2. simple (capture 6)
			&quot;((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes + &quot;)*)|&quot; +
			// 3. anything else (capture 2)
			&quot;.*&quot; +
			&quot;)\\)|)&quot;,

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace &#x3D; new RegExp( whitespace + &quot;+&quot;, &quot;g&quot; ),
		rtrim &#x3D; new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),

		rcomma &#x3D; new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
		rcombinators &#x3D; new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),

		rattributeQuotes &#x3D; new RegExp( &quot;&#x3D;&quot; + whitespace + &quot;*([^\\]&#x27;\&quot;]*?)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ),

		rpseudo &#x3D; new RegExp( pseudos ),
		ridentifier &#x3D; new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),

		matchExpr &#x3D; {
			&quot;ID&quot;: new RegExp( &quot;^#(&quot; + identifier + &quot;)&quot; ),
			&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + identifier + &quot;)&quot; ),
			&quot;TAG&quot;: new RegExp( &quot;^(&quot; + identifier + &quot;|[*])&quot; ),
			&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
			&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
			&quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
				&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
				&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
			&quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
			// For use in libraries implementing .is()
			// We use this for POS matching in &#x60;select&#x60;
			&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
				whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?&#x3D;[^-]|$)&quot;, &quot;i&quot; )
		},

		rinputs &#x3D; /^(?:input|select|textarea|button)$/i,
		rheader &#x3D; /^h\d$/i,

		rnative &#x3D; /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr &#x3D; /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling &#x3D; /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape &#x3D; new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
		funescape &#x3D; function( _, escaped, escapedWhitespace ) {
			var high &#x3D; &quot;0x&quot; + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox&lt;24
			// Workaround erroneous numeric interpretation of +&quot;0x&quot;
			return high !&#x3D;&#x3D; high || escapedWhitespace ?
				escaped :
				high &lt; 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape &#x3D; /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape &#x3D; function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch &#x3D;&#x3D;&#x3D; &quot;\0&quot; ) {
					return &quot;\uFFFD&quot;;
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + &quot;\\&quot; + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + &quot; &quot;;
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return &quot;\\&quot; + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a &quot;Permission Denied&quot;
		// error in IE
		unloadHandler &#x3D; function() {
			setDocument();
		},

		disabledAncestor &#x3D; addCombinator(
			function( elem ) {
				return elem.disabled &#x3D;&#x3D;&#x3D; true &amp;&amp; (&quot;form&quot; in elem || &quot;label&quot; in elem);
			},
			{ dir: &quot;parentNode&quot;, next: &quot;legend&quot; }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr &#x3D; slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android&lt;4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push &#x3D; { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE&lt;9
			// Otherwise append directly
			function( target, els ) {
				var j &#x3D; target.length,
					i &#x3D; 0;
				// Can&#x27;t trust NodeList.length
				while ( (target[j++] &#x3D; els[i++]) ) {}
				target.length &#x3D; j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext &#x3D; context &amp;&amp; context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType &#x3D; context ? context.nodeType : 9;

		results &#x3D; results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !&#x3D;&#x3D; &quot;string&quot; || !selector ||
			nodeType !&#x3D;&#x3D; 1 &amp;&amp; nodeType !&#x3D;&#x3D; 9 &amp;&amp; nodeType !&#x3D;&#x3D; 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !&#x3D;&#x3D; document ) {
				setDocument( context );
			}
			context &#x3D; context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a &quot;get*By*&quot; DOM method
				// (excepting DocumentFragment context, where the methods don&#x27;t exist)
				if ( nodeType !&#x3D;&#x3D; 11 &amp;&amp; (match &#x3D; rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m &#x3D; match[1]) ) {

						// Document context
						if ( nodeType &#x3D;&#x3D;&#x3D; 9 ) {
							if ( (elem &#x3D; context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id &#x3D;&#x3D;&#x3D; m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext &amp;&amp; (elem &#x3D; newContext.getElementById( m )) &amp;&amp;
								contains( context, elem ) &amp;&amp;
								elem.id &#x3D;&#x3D;&#x3D; m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m &#x3D; match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp;
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &amp;&amp;
					!compilerCache[ selector + &quot; &quot; ] &amp;&amp;
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !&#x3D;&#x3D; 1 ) {
						newContext &#x3D; context;
						newSelector &#x3D; selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE &lt;&#x3D;8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !&#x3D;&#x3D; &quot;object&quot; ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid &#x3D; context.getAttribute( &quot;id&quot; )) ) {
							nid &#x3D; nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( &quot;id&quot;, (nid &#x3D; expando) );
						}

						// Prefix every selector in the list
						groups &#x3D; tokenize( selector );
						i &#x3D; groups.length;
						while ( i-- ) {
							groups[i] &#x3D; &quot;#&quot; + nid + &quot; &quot; + toSelector( groups[i] );
						}
						newSelector &#x3D; groups.join( &quot;,&quot; );

						// Expand context for sibling selectors
						newContext &#x3D; rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid &#x3D;&#x3D;&#x3D; expando ) {
								context.removeAttribute( &quot;id&quot; );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys &#x3D; [];

		function cache( key, value ) {
			// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + &quot; &quot; ] &#x3D; value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] &#x3D; true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el &#x3D; document.createElement(&quot;fieldset&quot;);

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el &#x3D; null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr &#x3D; attrs.split(&quot;|&quot;),
			i &#x3D; arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] &#x3D; handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur &#x3D; b &amp;&amp; a,
			diff &#x3D; cur &amp;&amp; a.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp;
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur &#x3D; cur.nextSibling) ) {
				if ( cur &#x3D;&#x3D;&#x3D; b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name &#x3D; elem.nodeName.toLowerCase();
			return name &#x3D;&#x3D;&#x3D; &quot;input&quot; &amp;&amp; elem.type &#x3D;&#x3D;&#x3D; type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name &#x3D; elem.nodeName.toLowerCase();
			return (name &#x3D;&#x3D;&#x3D; &quot;input&quot; || name &#x3D;&#x3D;&#x3D; &quot;button&quot;) &amp;&amp; elem.type &#x3D;&#x3D;&#x3D; type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] &gt; legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( &quot;form&quot; in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a &quot;form&quot; property.
				if ( elem.parentNode &amp;&amp; elem.disabled &#x3D;&#x3D;&#x3D; false ) {

					// Option elements defer to a parent optgroup if present
					if ( &quot;label&quot; in elem ) {
						if ( &quot;label&quot; in elem.parentNode ) {
							return elem.parentNode.disabled &#x3D;&#x3D;&#x3D; disabled;
						} else {
							return elem.disabled &#x3D;&#x3D;&#x3D; disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled &#x3D;&#x3D;&#x3D; disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !&#x3D;&#x3D; !disabled &amp;&amp;
							disabledAncestor( elem ) &#x3D;&#x3D;&#x3D; disabled;
				}

				return elem.disabled &#x3D;&#x3D;&#x3D; disabled;

			// Try to winnow out elements that can&#x27;t be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn&#x27;t
			// even exist on them, let alone have a boolean value.
			} else if ( &quot;label&quot; in elem ) {
				return elem.disabled &#x3D;&#x3D;&#x3D; disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument &#x3D; +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes &#x3D; fn( [], seed.length, argument ),
					i &#x3D; matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j &#x3D; matchIndexes[i]) ] ) {
						seed[j] &#x3D; !(matches[j] &#x3D; seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object&#x3D;} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context &amp;&amp; typeof context.getElementsByTagName !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; context;
	}

	// Expose support vars for convenience
	support &#x3D; Sizzle.support &#x3D; {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML &#x3D; Sizzle.isXML &#x3D; function( elem ) {
		// documentElement is verified for cases where it doesn&#x27;t yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement &#x3D; elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !&#x3D;&#x3D; &quot;HTML&quot; : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument &#x3D; Sizzle.setDocument &#x3D; function( node ) {
		var hasCompare, subWindow,
			doc &#x3D; node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc &#x3D;&#x3D;&#x3D; document || doc.nodeType !&#x3D;&#x3D; 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document &#x3D; doc;
		docElem &#x3D; document.documentElement;
		documentIsHTML &#x3D; !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws &quot;permission denied&quot; errors (jQuery #13936)
		if ( preferredDoc !&#x3D;&#x3D; document &amp;&amp;
			(subWindow &#x3D; document.defaultView) &amp;&amp; subWindow.top !&#x3D;&#x3D; subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( &quot;unload&quot;, unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( &quot;onunload&quot;, unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE&lt;8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes &#x3D; assert(function( el ) {
			el.className &#x3D; &quot;i&quot;;
			return !el.getAttribute(&quot;className&quot;);
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName(&quot;*&quot;) returns only elements
		support.getElementsByTagName &#x3D; assert(function( el ) {
			el.appendChild( document.createComment(&quot;&quot;) );
			return !el.getElementsByTagName(&quot;*&quot;).length;
		});

		// Support: IE&lt;9
		support.getElementsByClassName &#x3D; rnative.test( document.getElementsByClassName );

		// Support: IE&lt;10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don&#x27;t pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById &#x3D; assert(function( el ) {
			docElem.appendChild( el ).id &#x3D; expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter[&quot;ID&quot;] &#x3D; function( id ) {
				var attrId &#x3D; id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute(&quot;id&quot;) &#x3D;&#x3D;&#x3D; attrId;
				};
			};
			Expr.find[&quot;ID&quot;] &#x3D; function( id, context ) {
				if ( typeof context.getElementById !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
					var elem &#x3D; context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter[&quot;ID&quot;] &#x3D;  function( id ) {
				var attrId &#x3D; id.replace( runescape, funescape );
				return function( elem ) {
					var node &#x3D; typeof elem.getAttributeNode !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;
						elem.getAttributeNode(&quot;id&quot;);
					return node &amp;&amp; node.value &#x3D;&#x3D;&#x3D; attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find[&quot;ID&quot;] &#x3D; function( id, context ) {
				if ( typeof context.getElementById !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
					var node, i, elems,
						elem &#x3D; context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node &#x3D; elem.getAttributeNode(&quot;id&quot;);
						if ( node &amp;&amp; node.value &#x3D;&#x3D;&#x3D; id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems &#x3D; context.getElementsByName( id );
						i &#x3D; 0;
						while ( (elem &#x3D; elems[i++]) ) {
							node &#x3D; elem.getAttributeNode(&quot;id&quot;);
							if ( node &amp;&amp; node.value &#x3D;&#x3D;&#x3D; id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find[&quot;TAG&quot;] &#x3D; support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !&#x3D;&#x3D; &quot;undefined&quot; ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don&#x27;t have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp &#x3D; [],
					i &#x3D; 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results &#x3D; context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag &#x3D;&#x3D;&#x3D; &quot;*&quot; ) {
					while ( (elem &#x3D; results[i++]) ) {
						if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find[&quot;CLASS&quot;] &#x3D; support.getElementsByClassName &amp;&amp; function( className, context ) {
			if ( typeof context.getElementsByClassName !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches &#x3D; [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever &#x60;document.activeElement&#x60; is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA &#x3D; [];

		if ( (support.qsa &#x3D; rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE&#x27;s treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML &#x3D; &quot;&lt;a id&#x3D;&#x27;&quot; + expando + &quot;&#x27;&gt;&lt;/a&gt;&quot; +
					&quot;&lt;select id&#x3D;&#x27;&quot; + expando + &quot;-\r\\&#x27; msallowcapture&#x3D;&#x27;&#x27;&gt;&quot; +
					&quot;&lt;option selected&#x3D;&#x27;&#x27;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^&#x3D; or $&#x3D; or *&#x3D;
				// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll(&quot;[msallowcapture^&#x3D;&#x27;&#x27;]&quot;).length ) {
					rbuggyQSA.push( &quot;[*^$]&#x3D;&quot; + whitespace + &quot;*(?:&#x27;&#x27;|\&quot;\&quot;)&quot; );
				}

				// Support: IE8
				// Boolean attributes and &quot;value&quot; are not treated correctly
				if ( !el.querySelectorAll(&quot;[selected]&quot;).length ) {
					rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
				}

				// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+
				if ( !el.querySelectorAll( &quot;[id~&#x3D;&quot; + expando + &quot;-]&quot; ).length ) {
					rbuggyQSA.push(&quot;~&#x3D;&quot;);
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(&quot;:checked&quot;).length ) {
					rbuggyQSA.push(&quot;:checked&quot;);
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id&#x3D;136851
				// In-page &#x60;selector#id sibling-combinator selector&#x60; fails
				if ( !el.querySelectorAll( &quot;a#&quot; + expando + &quot;+*&quot; ).length ) {
					rbuggyQSA.push(&quot;.#.+[+~]&quot;);
				}
			});

			assert(function( el ) {
				el.innerHTML &#x3D; &quot;&lt;a href&#x3D;&#x27;&#x27; disabled&#x3D;&#x27;disabled&#x27;&gt;&lt;/a&gt;&quot; +
					&quot;&lt;select disabled&#x3D;&#x27;disabled&#x27;&gt;&lt;option/&gt;&lt;/select&gt;&quot;;

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input &#x3D; document.createElement(&quot;input&quot;);
				input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
				el.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll(&quot;[name&#x3D;d]&quot;).length ) {
					rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?&#x3D;&quot; );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(&quot;:enabled&quot;).length !&#x3D;&#x3D; 2 ) {
					rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
				}

				// Support: IE9-11+
				// IE&#x27;s :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled &#x3D; true;
				if ( el.querySelectorAll(&quot;:disabled&quot;).length !&#x3D;&#x3D; 2 ) {
					rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll(&quot;*,:x&quot;);
				rbuggyQSA.push(&quot;,.*:&quot;);
			});
		}

		if ( (support.matchesSelector &#x3D; rnative.test( (matches &#x3D; docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it&#x27;s possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch &#x3D; matches.call( el, &quot;*&quot; );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, &quot;[s!&#x3D;&#x27;&#x27;]:x&quot; );
				rbuggyMatches.push( &quot;!&#x3D;&quot;, pseudos );
			});
		}

		rbuggyQSA &#x3D; rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
		rbuggyMatches &#x3D; rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare &#x3D; rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains &#x3D; hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown &#x3D; a.nodeType &#x3D;&#x3D;&#x3D; 9 ? a.documentElement : a,
					bup &#x3D; b &amp;&amp; b.parentNode;
				return a &#x3D;&#x3D;&#x3D; bup || !!( bup &amp;&amp; bup.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b &#x3D; b.parentNode) ) {
						if ( b &#x3D;&#x3D;&#x3D; a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder &#x3D; hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a &#x3D;&#x3D;&#x3D; b ) {
				hasDuplicate &#x3D; true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare &#x3D; !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare &#x3D; ( a.ownerDocument || a ) &#x3D;&#x3D;&#x3D; ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare &amp; 1 ||
				(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) &#x3D;&#x3D;&#x3D; compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a &#x3D;&#x3D;&#x3D; document || a.ownerDocument &#x3D;&#x3D;&#x3D; preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b &#x3D;&#x3D;&#x3D; document || b.ownerDocument &#x3D;&#x3D;&#x3D; preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare &amp; 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a &#x3D;&#x3D;&#x3D; b ) {
				hasDuplicate &#x3D; true;
				return 0;
			}

			var cur,
				i &#x3D; 0,
				aup &#x3D; a.parentNode,
				bup &#x3D; b.parentNode,
				ap &#x3D; [ a ],
				bp &#x3D; [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a &#x3D;&#x3D;&#x3D; document ? -1 :
					b &#x3D;&#x3D;&#x3D; document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup &#x3D;&#x3D;&#x3D; bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur &#x3D; a;
			while ( (cur &#x3D; cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur &#x3D; b;
			while ( (cur &#x3D; cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] &#x3D;&#x3D;&#x3D; bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] &#x3D;&#x3D;&#x3D; preferredDoc ? -1 :
				bp[i] &#x3D;&#x3D;&#x3D; preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches &#x3D; function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector &#x3D; function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !&#x3D;&#x3D; document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr &#x3D; expr.replace( rattributeQuotes, &quot;&#x3D;&#x27;$1&#x27;]&quot; );

		if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
			!compilerCache[ expr + &quot; &quot; ] &amp;&amp;
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret &#x3D; matches.call( elem, expr );

				// IE 9&#x27;s matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document &amp;&amp; elem.document.nodeType !&#x3D;&#x3D; 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length &gt; 0;
	};

	Sizzle.contains &#x3D; function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !&#x3D;&#x3D; document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr &#x3D; function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !&#x3D;&#x3D; document ) {
			setDocument( elem );
		}

		var fn &#x3D; Expr.attrHandle[ name.toLowerCase() ],
			// Don&#x27;t get fooled by Object.prototype properties (jQuery #13807)
			val &#x3D; fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !&#x3D;&#x3D; undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val &#x3D; elem.getAttributeNode(name)) &amp;&amp; val.specified ?
					val.value :
					null;
	};

	Sizzle.escape &#x3D; function( sel ) {
		return (sel + &quot;&quot;).replace( rcssescape, fcssescape );
	};

	Sizzle.error &#x3D; function( msg ) {
		throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort &#x3D; function( results ) {
		var elem,
			duplicates &#x3D; [],
			j &#x3D; 0,
			i &#x3D; 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate &#x3D; !support.detectDuplicates;
		sortInput &#x3D; !support.sortStable &amp;&amp; results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem &#x3D; results[i++]) ) {
				if ( elem &#x3D;&#x3D;&#x3D; results[ i ] ) {
					j &#x3D; duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput &#x3D; null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText &#x3D; Sizzle.getText &#x3D; function( elem ) {
		var node,
			ret &#x3D; &quot;&quot;,
			i &#x3D; 0,
			nodeType &#x3D; elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node &#x3D; elem[i++]) ) {
				// Do not traverse comment nodes
				ret +&#x3D; getText( node );
			}
		} else if ( nodeType &#x3D;&#x3D;&#x3D; 1 || nodeType &#x3D;&#x3D;&#x3D; 9 || nodeType &#x3D;&#x3D;&#x3D; 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem &#x3D; elem.firstChild; elem; elem &#x3D; elem.nextSibling ) {
					ret +&#x3D; getText( elem );
				}
			}
		} else if ( nodeType &#x3D;&#x3D;&#x3D; 3 || nodeType &#x3D;&#x3D;&#x3D; 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr &#x3D; Sizzle.selectors &#x3D; {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
			&quot; &quot;: { dir: &quot;parentNode&quot; },
			&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
			&quot;~&quot;: { dir: &quot;previousSibling&quot; }
		},

		preFilter: {
			&quot;ATTR&quot;: function( match ) {
				match[1] &#x3D; match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] &#x3D; ( match[3] || match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );

				if ( match[2] &#x3D;&#x3D;&#x3D; &quot;~&#x3D;&quot; ) {
					match[3] &#x3D; &quot; &quot; + match[3] + &quot; &quot;;
				}

				return match.slice( 0, 4 );
			},

			&quot;CHILD&quot;: function( match ) {
				/* matches from matchExpr[&quot;CHILD&quot;]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] &#x3D; match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) &#x3D;&#x3D;&#x3D; &quot;nth&quot; ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] &#x3D; +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] &#x3D;&#x3D;&#x3D; &quot;even&quot; || match[3] &#x3D;&#x3D;&#x3D; &quot;odd&quot; ) );
					match[5] &#x3D; +( ( match[7] + match[8] ) || match[3] &#x3D;&#x3D;&#x3D; &quot;odd&quot; );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			&quot;PSEUDO&quot;: function( match ) {
				var excess,
					unquoted &#x3D; !match[6] &amp;&amp; match[2];

				if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] &#x3D; match[4] || match[5] || &quot;&quot;;

				// Strip excess characters from unquoted arguments
				} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
					// Get excess from tokenize (recursively)
					(excess &#x3D; tokenize( unquoted, true )) &amp;&amp;
					// advance to the next closing parenthesis
					(excess &#x3D; unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] &#x3D; match[0].slice( 0, excess );
					match[2] &#x3D; unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			&quot;TAG&quot;: function( nodeNameSelector ) {
				var nodeName &#x3D; nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector &#x3D;&#x3D;&#x3D; &quot;*&quot; ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; nodeName;
					};
			},

			&quot;CLASS&quot;: function( className ) {
				var pattern &#x3D; classCache[ className + &quot; &quot; ];

				return pattern ||
					(pattern &#x3D; new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className &#x3D;&#x3D;&#x3D; &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
					});
			},

			&quot;ATTR&quot;: function( name, operator, check ) {
				return function( elem ) {
					var result &#x3D; Sizzle.attr( elem, name );

					if ( result &#x3D;&#x3D; null ) {
						return operator &#x3D;&#x3D;&#x3D; &quot;!&#x3D;&quot;;
					}
					if ( !operator ) {
						return true;
					}

					result +&#x3D; &quot;&quot;;

					return operator &#x3D;&#x3D;&#x3D; &quot;&#x3D;&quot; ? result &#x3D;&#x3D;&#x3D; check :
						operator &#x3D;&#x3D;&#x3D; &quot;!&#x3D;&quot; ? result !&#x3D;&#x3D; check :
						operator &#x3D;&#x3D;&#x3D; &quot;^&#x3D;&quot; ? check &amp;&amp; result.indexOf( check ) &#x3D;&#x3D;&#x3D; 0 :
						operator &#x3D;&#x3D;&#x3D; &quot;*&#x3D;&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
						operator &#x3D;&#x3D;&#x3D; &quot;$&#x3D;&quot; ? check &amp;&amp; result.slice( -check.length ) &#x3D;&#x3D;&#x3D; check :
						operator &#x3D;&#x3D;&#x3D; &quot;~&#x3D;&quot; ? ( &quot; &quot; + result.replace( rwhitespace, &quot; &quot; ) + &quot; &quot; ).indexOf( check ) &gt; -1 :
						operator &#x3D;&#x3D;&#x3D; &quot;|&#x3D;&quot; ? result &#x3D;&#x3D;&#x3D; check || result.slice( 0, check.length + 1 ) &#x3D;&#x3D;&#x3D; check + &quot;-&quot; :
						false;
				};
			},

			&quot;CHILD&quot;: function( type, what, argument, first, last ) {
				var simple &#x3D; type.slice( 0, 3 ) !&#x3D;&#x3D; &quot;nth&quot;,
					forward &#x3D; type.slice( -4 ) !&#x3D;&#x3D; &quot;last&quot;,
					ofType &#x3D; what &#x3D;&#x3D;&#x3D; &quot;of-type&quot;;

				return first &#x3D;&#x3D;&#x3D; 1 &amp;&amp; last &#x3D;&#x3D;&#x3D; 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir &#x3D; simple !&#x3D;&#x3D; forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
							parent &#x3D; elem.parentNode,
							name &#x3D; ofType &amp;&amp; elem.nodeName.toLowerCase(),
							useCache &#x3D; !xml &amp;&amp; !ofType,
							diff &#x3D; false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node &#x3D; elem;
									while ( (node &#x3D; node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; name :
											node.nodeType &#x3D;&#x3D;&#x3D; 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven&#x27;t yet done so)
									start &#x3D; dir &#x3D; type &#x3D;&#x3D;&#x3D; &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
								}
								return true;
							}

							start &#x3D; [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on &#x60;parent&#x60;
							if ( forward &amp;&amp; useCache ) {

								// Seek &#x60;elem&#x60; from a previously-cached index

								// ...in a gzip-friendly way
								node &#x3D; parent;
								outerCache &#x3D; node[ expando ] || (node[ expando ] &#x3D; {});

								// Support: IE &lt;9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache &#x3D; outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] &#x3D; {});

								cache &#x3D; uniqueCache[ type ] || [];
								nodeIndex &#x3D; cache[ 0 ] &#x3D;&#x3D;&#x3D; dirruns &amp;&amp; cache[ 1 ];
								diff &#x3D; nodeIndex &amp;&amp; cache[ 2 ];
								node &#x3D; nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];

								while ( (node &#x3D; ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||

									// Fallback to seeking &#x60;elem&#x60; from the start
									(diff &#x3D; nodeIndex &#x3D; 0) || start.pop()) ) {

									// When found, cache indexes on &#x60;parent&#x60; and break
									if ( node.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; ++diff &amp;&amp; node &#x3D;&#x3D;&#x3D; elem ) {
										uniqueCache[ type ] &#x3D; [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node &#x3D; elem;
									outerCache &#x3D; node[ expando ] || (node[ expando ] &#x3D; {});

									// Support: IE &lt;9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache &#x3D; outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] &#x3D; {});

									cache &#x3D; uniqueCache[ type ] || [];
									nodeIndex &#x3D; cache[ 0 ] &#x3D;&#x3D;&#x3D; dirruns &amp;&amp; cache[ 1 ];
									diff &#x3D; nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff &#x3D;&#x3D;&#x3D; false ) {
									// Use the same loop as above to seek &#x60;elem&#x60; from the start
									while ( (node &#x3D; ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
										(diff &#x3D; nodeIndex &#x3D; 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; name :
											node.nodeType &#x3D;&#x3D;&#x3D; 1 ) &amp;&amp;
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache &#x3D; node[ expando ] || (node[ expando ] &#x3D; {});

												// Support: IE &lt;9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache &#x3D; outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] &#x3D; {});

												uniqueCache[ type ] &#x3D; [ dirruns, diff ];
											}

											if ( node &#x3D;&#x3D;&#x3D; elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -&#x3D; last;
							return diff &#x3D;&#x3D;&#x3D; first || ( diff % first &#x3D;&#x3D;&#x3D; 0 &amp;&amp; diff / first &gt;&#x3D; 0 );
						}
					};
			},

			&quot;PSEUDO&quot;: function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn &#x3D; Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length &gt; 1 ) {
					args &#x3D; [ pseudo, pseudo, &quot;&quot;, argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched &#x3D; fn( seed, argument ),
								i &#x3D; matched.length;
							while ( i-- ) {
								idx &#x3D; indexOf( seed, matched[i] );
								seed[ idx ] &#x3D; !( matches[ idx ] &#x3D; matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			&quot;not&quot;: markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input &#x3D; [],
					results &#x3D; [],
					matcher &#x3D; compile( selector.replace( rtrim, &quot;$1&quot; ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched &#x3D; matcher( seed, null, xml, [] ),
							i &#x3D; seed.length;

						// Match elements unmatched by &#x60;matcher&#x60;
						while ( i-- ) {
							if ( (elem &#x3D; unmatched[i]) ) {
								seed[i] &#x3D; !(matches[i] &#x3D; elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] &#x3D; elem;
						matcher( input, null, xml, results );
						// Don&#x27;t keep the element (issue #299)
						input[0] &#x3D; null;
						return !results.pop();
					};
			}),

			&quot;has&quot;: markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length &gt; 0;
				};
			}),

			&quot;contains&quot;: markFunction(function( text ) {
				text &#x3D; text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
				};
			}),

			// &quot;Whether an element is represented by a :lang() selector
			// is based solely on the element&#x27;s language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by &quot;-&quot;.
			// The matching of C against the element&#x27;s language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name.&quot;
			// http://www.w3.org/TR/selectors/#lang-pseudo
			&quot;lang&quot;: markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || &quot;&quot;) ) {
					Sizzle.error( &quot;unsupported lang: &quot; + lang );
				}
				lang &#x3D; lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang &#x3D; documentIsHTML ?
							elem.lang :
							elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {

							elemLang &#x3D; elemLang.toLowerCase();
							return elemLang &#x3D;&#x3D;&#x3D; lang || elemLang.indexOf( lang + &quot;-&quot; ) &#x3D;&#x3D;&#x3D; 0;
						}
					} while ( (elem &#x3D; elem.parentNode) &amp;&amp; elem.nodeType &#x3D;&#x3D;&#x3D; 1 );
					return false;
				};
			}),

			// Miscellaneous
			&quot;target&quot;: function( elem ) {
				var hash &#x3D; window.location &amp;&amp; window.location.hash;
				return hash &amp;&amp; hash.slice( 1 ) &#x3D;&#x3D;&#x3D; elem.id;
			},

			&quot;root&quot;: function( elem ) {
				return elem &#x3D;&#x3D;&#x3D; docElem;
			},

			&quot;focus&quot;: function( elem ) {
				return elem &#x3D;&#x3D;&#x3D; document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			&quot;enabled&quot;: createDisabledPseudo( false ),
			&quot;disabled&quot;: createDisabledPseudo( true ),

			&quot;checked&quot;: function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName &#x3D; elem.nodeName.toLowerCase();
				return (nodeName &#x3D;&#x3D;&#x3D; &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName &#x3D;&#x3D;&#x3D; &quot;option&quot; &amp;&amp; !!elem.selected);
			},

			&quot;selected&quot;: function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected &#x3D;&#x3D;&#x3D; true;
			},

			// Contents
			&quot;empty&quot;: function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType &lt; 6 works because attributes (2) do not appear as children
				for ( elem &#x3D; elem.firstChild; elem; elem &#x3D; elem.nextSibling ) {
					if ( elem.nodeType &lt; 6 ) {
						return false;
					}
				}
				return true;
			},

			&quot;parent&quot;: function( elem ) {
				return !Expr.pseudos[&quot;empty&quot;]( elem );
			},

			// Element/input types
			&quot;header&quot;: function( elem ) {
				return rheader.test( elem.nodeName );
			},

			&quot;input&quot;: function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			&quot;button&quot;: function( elem ) {
				var name &#x3D; elem.nodeName.toLowerCase();
				return name &#x3D;&#x3D;&#x3D; &quot;input&quot; &amp;&amp; elem.type &#x3D;&#x3D;&#x3D; &quot;button&quot; || name &#x3D;&#x3D;&#x3D; &quot;button&quot;;
			},

			&quot;text&quot;: function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; &quot;input&quot; &amp;&amp;
					elem.type &#x3D;&#x3D;&#x3D; &quot;text&quot; &amp;&amp;

					// Support: IE&lt;8
					// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type &#x3D;&#x3D;&#x3D; &quot;text&quot;
					( (attr &#x3D; elem.getAttribute(&quot;type&quot;)) &#x3D;&#x3D; null || attr.toLowerCase() &#x3D;&#x3D;&#x3D; &quot;text&quot; );
			},

			// Position-in-collection
			&quot;first&quot;: createPositionalPseudo(function() {
				return [ 0 ];
			}),

			&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument &lt; 0 ? argument + length : argument ];
			}),

			&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
				var i &#x3D; 0;
				for ( ; i &lt; length; i +&#x3D; 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
				var i &#x3D; 1;
				for ( ; i &lt; length; i +&#x3D; 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i &#x3D; argument &lt; 0 ? argument + length : argument;
				for ( ; --i &gt;&#x3D; 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i &#x3D; argument &lt; 0 ? argument + length : argument;
				for ( ; ++i &lt; length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos[&quot;nth&quot;] &#x3D; Expr.pseudos[&quot;eq&quot;];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] &#x3D; createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] &#x3D; createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype &#x3D; Expr.filters &#x3D; Expr.pseudos;
	Expr.setFilters &#x3D; new setFilters();

	tokenize &#x3D; Sizzle.tokenize &#x3D; function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached &#x3D; tokenCache[ selector + &quot; &quot; ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar &#x3D; selector;
		groups &#x3D; [];
		preFilters &#x3D; Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match &#x3D; rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don&#x27;t consume trailing commas as valid
					soFar &#x3D; soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens &#x3D; []) );
			}

			matched &#x3D; false;

			// Combinators
			if ( (match &#x3D; rcombinators.exec( soFar )) ) {
				matched &#x3D; match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, &quot; &quot; )
				});
				soFar &#x3D; soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match &#x3D; matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
					(match &#x3D; preFilters[ type ]( match ))) ) {
					matched &#x3D; match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar &#x3D; soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we&#x27;re just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i &#x3D; 0,
			len &#x3D; tokens.length,
			selector &#x3D; &quot;&quot;;
		for ( ; i &lt; len; i++ ) {
			selector +&#x3D; tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir &#x3D; combinator.dir,
			skip &#x3D; combinator.next,
			key &#x3D; skip || dir,
			checkNonElements &#x3D; base &amp;&amp; key &#x3D;&#x3D;&#x3D; &quot;parentNode&quot;,
			doneName &#x3D; done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem &#x3D; elem[ dir ]) ) {
					if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache &#x3D; [ dirruns, doneName ];

				// We can&#x27;t set arbitrary data on XML nodes, so they don&#x27;t benefit from combinator caching
				if ( xml ) {
					while ( (elem &#x3D; elem[ dir ]) ) {
						if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem &#x3D; elem[ dir ]) ) {
						if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 || checkNonElements ) {
							outerCache &#x3D; elem[ expando ] || (elem[ expando ] &#x3D; {});

							// Support: IE &lt;9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache &#x3D; outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] &#x3D; {});

							if ( skip &amp;&amp; skip &#x3D;&#x3D;&#x3D; elem.nodeName.toLowerCase() ) {
								elem &#x3D; elem[ dir ] || elem;
							} else if ( (oldCache &#x3D; uniqueCache[ key ]) &amp;&amp;
								oldCache[ 0 ] &#x3D;&#x3D;&#x3D; dirruns &amp;&amp; oldCache[ 1 ] &#x3D;&#x3D;&#x3D; doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] &#x3D; oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] &#x3D; newCache;

								// A match means we&#x27;re done; a fail means we have to keep checking
								if ( (newCache[ 2 ] &#x3D; matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length &gt; 1 ?
			function( elem, context, xml ) {
				var i &#x3D; matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i &#x3D; 0,
			len &#x3D; contexts.length;
		for ( ; i &lt; len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched &#x3D; [],
			i &#x3D; 0,
			len &#x3D; unmatched.length,
			mapped &#x3D; map !&#x3D; null;

		for ( ; i &lt; len; i++ ) {
			if ( (elem &#x3D; unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
			postFilter &#x3D; setMatcher( postFilter );
		}
		if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
			postFinder &#x3D; setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap &#x3D; [],
				postMap &#x3D; [],
				preexisting &#x3D; results.length,

				// Get initial elements from seed or context
				elems &#x3D; seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn &#x3D; preFilter &amp;&amp; ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut &#x3D; matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp &#x3D; condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i &#x3D; temp.length;
				while ( i-- ) {
					if ( (elem &#x3D; temp[i]) ) {
						matcherOut[ postMap[i] ] &#x3D; !(matcherIn[ postMap[i] ] &#x3D; elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp &#x3D; [];
						i &#x3D; matcherOut.length;
						while ( i-- ) {
							if ( (elem &#x3D; matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] &#x3D; elem) );
							}
						}
						postFinder( null, (matcherOut &#x3D; []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i &#x3D; matcherOut.length;
					while ( i-- ) {
						if ( (elem &#x3D; matcherOut[i]) &amp;&amp;
							(temp &#x3D; postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -1 ) {

							seed[temp] &#x3D; !(results[temp] &#x3D; elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut &#x3D; condense(
					matcherOut &#x3D;&#x3D;&#x3D; results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len &#x3D; tokens.length,
			leadingRelative &#x3D; Expr.relative[ tokens[0].type ],
			implicitRelative &#x3D; leadingRelative || Expr.relative[&quot; &quot;],
			i &#x3D; leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext &#x3D; addCombinator( function( elem ) {
				return elem &#x3D;&#x3D;&#x3D; checkContext;
			}, implicitRelative, true ),
			matchAnyContext &#x3D; addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) &gt; -1;
			}, implicitRelative, true ),
			matchers &#x3D; [ function( elem, context, xml ) {
				var ret &#x3D; ( !leadingRelative &amp;&amp; ( xml || context !&#x3D;&#x3D; outermostContext ) ) || (
					(checkContext &#x3D; context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext &#x3D; null;
				return ret;
			} ];

		for ( ; i &lt; len; i++ ) {
			if ( (matcher &#x3D; Expr.relative[ tokens[i].type ]) ) {
				matchers &#x3D; [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher &#x3D; Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j &#x3D; ++i;
					for ( ; j &lt; len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i &gt; 1 &amp;&amp; elementMatcher( matchers ),
						i &gt; 1 &amp;&amp; toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element &#x60;*&#x60;
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type &#x3D;&#x3D;&#x3D; &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
						).replace( rtrim, &quot;$1&quot; ),
						matcher,
						i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
						j &lt; len &amp;&amp; matcherFromTokens( (tokens &#x3D; tokens.slice( j )) ),
						j &lt; len &amp;&amp; toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet &#x3D; setMatchers.length &gt; 0,
			byElement &#x3D; elementMatchers.length &gt; 0,
			superMatcher &#x3D; function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount &#x3D; 0,
					i &#x3D; &quot;0&quot;,
					unmatched &#x3D; seed &amp;&amp; [],
					setMatched &#x3D; [],
					contextBackup &#x3D; outermostContext,
					// We must always have either seed elements or outermost context
					elems &#x3D; seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique &#x3D; (dirruns +&#x3D; contextBackup &#x3D;&#x3D; null ? 1 : Math.random() || 0.1),
					len &#x3D; elems.length;

				if ( outermost ) {
					outermostContext &#x3D; context &#x3D;&#x3D;&#x3D; document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE&lt;9, Safari
				// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
				for ( ; i !&#x3D;&#x3D; len &amp;&amp; (elem &#x3D; elems[i]) !&#x3D; null; i++ ) {
					if ( byElement &amp;&amp; elem ) {
						j &#x3D; 0;
						if ( !context &amp;&amp; elem.ownerDocument !&#x3D;&#x3D; document ) {
							setDocument( elem );
							xml &#x3D; !documentIsHTML;
						}
						while ( (matcher &#x3D; elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns &#x3D; dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem &#x3D; !matcher &amp;&amp; elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// &#x60;i&#x60; is now the count of elements visited above, and adding it to &#x60;matchedCount&#x60;
				// makes the latter nonnegative.
				matchedCount +&#x3D; i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., &#x60;matchedCount&#x60;
				// equals &#x60;i&#x60;), unless we didn&#x27;t visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string &quot;0&quot; &#x60;i&#x60; allows &#x60;i&#x60; to remain a string only in that
				// case, which will result in a &quot;00&quot; &#x60;matchedCount&#x60; that differs from &#x60;i&#x60; but is also
				// numerically zero.
				if ( bySet &amp;&amp; i !&#x3D;&#x3D; matchedCount ) {
					j &#x3D; 0;
					while ( (matcher &#x3D; setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount &gt; 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] &#x3D; pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched &#x3D; condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
						( matchedCount + setMatchers.length ) &gt; 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns &#x3D; dirrunsUnique;
					outermostContext &#x3D; contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile &#x3D; Sizzle.compile &#x3D; function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers &#x3D; [],
			elementMatchers &#x3D; [],
			cached &#x3D; compilerCache[ selector + &quot; &quot; ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match &#x3D; tokenize( selector );
			}
			i &#x3D; match.length;
			while ( i-- ) {
				cached &#x3D; matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached &#x3D; compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector &#x3D; selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle&#x27;s compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select &#x3D; Sizzle.select &#x3D; function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled &#x3D; typeof selector &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; selector,
			match &#x3D; !seed &amp;&amp; tokenize( (selector &#x3D; compiled.selector || selector) );

		results &#x3D; results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length &#x3D;&#x3D;&#x3D; 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens &#x3D; match[0] &#x3D; match[0].slice( 0 );
			if ( tokens.length &gt; 2 &amp;&amp; (token &#x3D; tokens[0]).type &#x3D;&#x3D;&#x3D; &quot;ID&quot; &amp;&amp;
					context.nodeType &#x3D;&#x3D;&#x3D; 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[1].type ] ) {

				context &#x3D; ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context &#x3D; context.parentNode;
				}

				selector &#x3D; selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i &#x3D; matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token &#x3D; tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type &#x3D; token.type) ] ) {
					break;
				}
				if ( (find &#x3D; Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed &#x3D; find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector &#x3D; seed.length &amp;&amp; toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide &#x60;match&#x60; to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable &#x3D; expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) &#x3D;&#x3D;&#x3D; expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren&#x27;t passed to the comparison function
	support.detectDuplicates &#x3D; !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached &#x3D; assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement(&quot;fieldset&quot;) ) &amp; 1;
	});

	// Support: IE&lt;8
	// Prevent attribute/property &quot;interpolation&quot;
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML &#x3D; &quot;&lt;a href&#x3D;&#x27;#&#x27;&gt;&lt;/a&gt;&quot;;
		return el.firstChild.getAttribute(&quot;href&quot;) &#x3D;&#x3D;&#x3D; &quot;#&quot; ;
	}) ) {
		addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() &#x3D;&#x3D;&#x3D; &quot;type&quot; ? 1 : 2 );
			}
		});
	}

	// Support: IE&lt;9
	// Use defaultValue in place of getAttribute(&quot;value&quot;)
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML &#x3D; &quot;&lt;input/&gt;&quot;;
		el.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
		return el.firstChild.getAttribute( &quot;value&quot; ) &#x3D;&#x3D;&#x3D; &quot;&quot;;
	}) ) {
		addHandle( &quot;value&quot;, function( elem, name, isXML ) {
			if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; &quot;input&quot; ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE&lt;9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute(&quot;disabled&quot;) &#x3D;&#x3D; null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] &#x3D;&#x3D;&#x3D; true ? name.toLowerCase() :
						(val &#x3D; elem.getAttributeNode( name )) &amp;&amp; val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find &#x3D; Sizzle;
	jQuery.expr &#x3D; Sizzle.selectors;

	// Deprecated
	jQuery.expr[ &quot;:&quot; ] &#x3D; jQuery.expr.pseudos;
	jQuery.uniqueSort &#x3D; jQuery.unique &#x3D; Sizzle.uniqueSort;
	jQuery.text &#x3D; Sizzle.getText;
	jQuery.isXMLDoc &#x3D; Sizzle.isXML;
	jQuery.contains &#x3D; Sizzle.contains;
	jQuery.escapeSelector &#x3D; Sizzle.escape;




	var dir &#x3D; function( elem, dir, until ) {
		var matched &#x3D; [],
			truncate &#x3D; until !&#x3D;&#x3D; undefined;

		while ( ( elem &#x3D; elem[ dir ] ) &amp;&amp; elem.nodeType !&#x3D;&#x3D; 9 ) {
			if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
				if ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings &#x3D; function( n, elem ) {
		var matched &#x3D; [];

		for ( ; n; n &#x3D; n.nextSibling ) {
			if ( n.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; n !&#x3D;&#x3D; elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext &#x3D; jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; name.toLowerCase();

	};
	var rsingleTag &#x3D; ( /^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !&#x3D;&#x3D; not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem &#x3D;&#x3D;&#x3D; qualifier ) !&#x3D;&#x3D; not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !&#x3D;&#x3D; &quot;string&quot; ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) &gt; -1 ) !&#x3D;&#x3D; not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter &#x3D; function( expr, elems, not ) {
		var elem &#x3D; elems[ 0 ];

		if ( not ) {
			expr &#x3D; &quot;:not(&quot; + expr + &quot;)&quot;;
		}

		if ( elems.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType &#x3D;&#x3D;&#x3D; 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len &#x3D; this.length,
				self &#x3D; this;

			if ( typeof selector !&#x3D;&#x3D; &quot;string&quot; ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i &#x3D; 0; i &lt; len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret &#x3D; this.pushStack( [] );

			for ( i &#x3D; 0; i &lt; len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len &gt; 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&#x27;t return true for a doc with two &quot;p&quot;.
				typeof selector &#x3D;&#x3D;&#x3D; &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with &lt;)
		// Shortcut simple #id case for speed
		rquickExpr &#x3D; /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/,

		init &#x3D; jQuery.fn.init &#x3D; function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root &#x3D; root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
				if ( selector[ 0 ] &#x3D;&#x3D;&#x3D; &quot;&lt;&quot; &amp;&amp;
					selector[ selector.length - 1 ] &#x3D;&#x3D;&#x3D; &quot;&gt;&quot; &amp;&amp;
					selector.length &gt;&#x3D; 3 ) {

					// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
					match &#x3D; [ null, selector, null ];

				} else {
					match &#x3D; rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match &amp;&amp; ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -&gt; $(array)
					if ( match[ 1 ] ) {
						context &#x3D; context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem &#x3D; document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] &#x3D; elem;
							this.length &#x3D; 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] &#x3D; selector;
				this.length &#x3D; 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !&#x3D;&#x3D; undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype &#x3D; jQuery.fn;

	// Initialize central reference
	rootjQuery &#x3D; jQuery( document );


	var rparentsprev &#x3D; /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique &#x3D; {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets &#x3D; jQuery( target, this ),
				l &#x3D; targets.length;

			return this.filter( function() {
				var i &#x3D; 0;
				for ( ; i &lt; l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i &#x3D; 0,
				l &#x3D; this.length,
				matched &#x3D; [],
				targets &#x3D; typeof selectors !&#x3D;&#x3D; &quot;string&quot; &amp;&amp; jQuery( selectors );

			// Positional selectors never match, since there&#x27;s no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i &lt; l; i++ ) {
					for ( cur &#x3D; this[ i ]; cur &amp;&amp; cur !&#x3D;&#x3D; context; cur &#x3D; cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType &lt; 11 &amp;&amp; ( targets ?
							targets.index( cur ) &gt; -1 :

							// Don&#x27;t pass non-elements to Sizzle
							cur.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp;
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length &gt; 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] &amp;&amp; this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector &#x3D;&#x3D; null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur &#x3D; cur[ dir ] ) &amp;&amp; cur.nodeType !&#x3D;&#x3D; 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent &#x3D; elem.parentNode;
			return parent &amp;&amp; parent.nodeType !&#x3D;&#x3D; 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, &quot;parentNode&quot; );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, &quot;parentNode&quot;, until );
		},
		next: function( elem ) {
			return sibling( elem, &quot;nextSibling&quot; );
		},
		prev: function( elem ) {
			return sibling( elem, &quot;previousSibling&quot; );
		},
		nextAll: function( elem ) {
			return dir( elem, &quot;nextSibling&quot; );
		},
		prevAll: function( elem ) {
			return dir( elem, &quot;previousSibling&quot; );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, &quot;nextSibling&quot;, until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, &quot;previousSibling&quot;, until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, &quot;iframe&quot; ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser &lt;&#x3D;4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don&#x27;t support it.
	        if ( nodeName( elem, &quot;template&quot; ) ) {
	            elem &#x3D; elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] &#x3D; function( until, selector ) {
			var matched &#x3D; jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !&#x3D;&#x3D; &quot;Until&quot; ) {
				selector &#x3D; until;
			}

			if ( selector &amp;&amp; typeof selector &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
				matched &#x3D; jQuery.filter( selector, matched );
			}

			if ( this.length &gt; 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite &#x3D; ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object &#x3D; {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] &#x3D; true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * &quot;fired&quot; multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest &quot;memorized&quot;
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks &#x3D; function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options &#x3D; typeof options &#x3D;&#x3D;&#x3D; &quot;string&quot; ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list &#x3D; [],

			// Queue of execution data for repeatable lists
			queue &#x3D; [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex &#x3D; -1,

			// Fire callbacks
			fire &#x3D; function() {

				// Enforce single-firing
				locked &#x3D; locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired &#x3D; firing &#x3D; true;
				for ( ; queue.length; firingIndex &#x3D; -1 ) {
					memory &#x3D; queue.shift();
					while ( ++firingIndex &lt; list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) &#x3D;&#x3D;&#x3D; false &amp;&amp;
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn&#x27;t re-fire
							firingIndex &#x3D; list.length;
							memory &#x3D; false;
						}
					}
				}

				// Forget the data if we&#x27;re done with it
				if ( !options.memory ) {
					memory &#x3D; false;
				}

				firing &#x3D; false;

				// Clean up if we&#x27;re done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list &#x3D; [];

					// Otherwise, this object is spent
					} else {
						list &#x3D; &quot;&quot;;
					}
				}
			},

			// Actual Callbacks object
			self &#x3D; {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory &amp;&amp; !firing ) {
							firingIndex &#x3D; list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg &amp;&amp; arg.length &amp;&amp; toType( arg ) !&#x3D;&#x3D; &quot;string&quot; ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory &amp;&amp; !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index &#x3D; jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index &lt;&#x3D; firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) &gt; -1 :
						list.length &gt; 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list &#x3D; [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked &#x3D; queue &#x3D; [];
					list &#x3D; memory &#x3D; &quot;&quot;;
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked &#x3D; queue &#x3D; [];
					if ( !memory &amp;&amp; !firing ) {
						list &#x3D; memory &#x3D; &quot;&quot;;
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args &#x3D; args || [];
						args &#x3D; [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value &amp;&amp; isFunction( ( method &#x3D; value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value &amp;&amp; isFunction( ( method &#x3D; value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control &#x60;resolve&#x60; arguments by letting Array#slice cast boolean &#x60;noValue&#x60; to integer:
				// * false: [ value ].slice( 0 ) &#x3D;&gt; resolve( value )
				// * true: [ value ].slice( 1 ) &#x3D;&gt; resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn&#x27;t unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples &#x3D; [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks( &quot;memory&quot; ),
						jQuery.Callbacks( &quot;memory&quot; ), 2 ],
					[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
						jQuery.Callbacks( &quot;once memory&quot; ), 0, &quot;resolved&quot; ],
					[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
						jQuery.Callbacks( &quot;once memory&quot; ), 1, &quot;rejected&quot; ]
				],
				state &#x3D; &quot;pending&quot;,
				promise &#x3D; {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					&quot;catch&quot;: function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns &#x3D; arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn &#x3D; isFunction( fns[ tuple[ 4 ] ] ) &amp;&amp; fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned &#x3D; fn &amp;&amp; fn.apply( this, arguments );
									if ( returned &amp;&amp; isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + &quot;With&quot; ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns &#x3D; null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth &#x3D; 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that &#x3D; this,
									args &#x3D; arguments,
									mightThrow &#x3D; function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth &lt; maxDepth ) {
											return;
										}

										returned &#x3D; handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned &#x3D;&#x3D;&#x3D; deferred.promise() ) {
											throw new TypeError( &quot;Thenable self-resolution&quot; );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve &#x60;then&#x60; only once
										then &#x3D; returned &amp;&amp;

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned &#x3D;&#x3D;&#x3D; &quot;object&quot; ||
												typeof returned &#x3D;&#x3D;&#x3D; &quot;function&quot; ) &amp;&amp;
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !&#x3D;&#x3D; Identity ) {
												that &#x3D; undefined;
												args &#x3D; [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process &#x3D; special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 &gt;&#x3D; maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !&#x3D;&#x3D; Thrower ) {
														that &#x3D; undefined;
														args &#x3D; [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it&#x27;s otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace &#x3D; jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj !&#x3D; null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred &#x3D; {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list &#x3D; tuple[ 2 ],
					stateString &#x3D; tuple[ 5 ];

				// promise.progress &#x3D; list.add
				// promise.done &#x3D; list.add
				// promise.fail &#x3D; list.add
				promise[ tuple[ 1 ] ] &#x3D; list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state &#x3D; &quot;resolved&quot; (i.e., fulfilled)
							// state &#x3D; &quot;rejected&quot;
							state &#x3D; stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify &#x3D; function() { deferred.notifyWith(...) }
				// deferred.resolve &#x3D; function() { deferred.resolveWith(...) }
				// deferred.reject &#x3D; function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] &#x3D; function() {
					deferred[ tuple[ 0 ] + &quot;With&quot; ]( this &#x3D;&#x3D;&#x3D; deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith &#x3D; list.fireWith
				// deferred.resolveWith &#x3D; list.fireWith
				// deferred.rejectWith &#x3D; list.fireWith
				deferred[ tuple[ 0 ] + &quot;With&quot; ] &#x3D; list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining &#x3D; arguments.length,

				// count of unprocessed arguments
				i &#x3D; remaining,

				// subordinate fulfillment data
				resolveContexts &#x3D; Array( i ),
				resolveValues &#x3D; slice.call( arguments ),

				// the master Deferred
				master &#x3D; jQuery.Deferred(),

				// subordinate callback factory
				updateFunc &#x3D; function( i ) {
					return function( value ) {
						resolveContexts[ i ] &#x3D; this;
						resolveValues[ i ] &#x3D; arguments.length &gt; 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining &lt;&#x3D; 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() &#x3D;&#x3D;&#x3D; &quot;pending&quot; ||
					isFunction( resolveValues[ i ] &amp;&amp; resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames &#x3D; /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook &#x3D; function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console &amp;&amp; window.console.warn &amp;&amp; error &amp;&amp; rerrorNames.test( error.name ) ) {
			window.console.warn( &quot;jQuery.Deferred exception: &quot; + error.message, error.stack, stack );
		}
	};




	jQuery.readyException &#x3D; function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList &#x3D; jQuery.Deferred();

	jQuery.fn.ready &#x3D; function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we&#x27;re already ready
			if ( wait &#x3D;&#x3D;&#x3D; true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady &#x3D; true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !&#x3D;&#x3D; true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then &#x3D; readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( &quot;DOMContentLoaded&quot;, completed );
		window.removeEventListener( &quot;load&quot;, completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE &lt;&#x3D;9 - 10 only
	// Older IE sometimes signals &quot;interactive&quot; too soon
	if ( document.readyState &#x3D;&#x3D;&#x3D; &quot;complete&quot; ||
		( document.readyState !&#x3D;&#x3D; &quot;loading&quot; &amp;&amp; !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( &quot;DOMContentLoaded&quot;, completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( &quot;load&quot;, completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it&#x27;s a function
	var access &#x3D; function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i &#x3D; 0,
			len &#x3D; elems.length,
			bulk &#x3D; key &#x3D;&#x3D; null;

		// Sets many values
		if ( toType( key ) &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {
			chainable &#x3D; true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !&#x3D;&#x3D; undefined ) {
			chainable &#x3D; true;

			if ( !isFunction( value ) ) {
				raw &#x3D; true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn &#x3D; null;

				// ...except when executing function values
				} else {
					bulk &#x3D; fn;
					fn &#x3D; function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i &lt; len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix &#x3D; /^-ms-/,
		rdashAlpha &#x3D; /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE &lt;&#x3D;9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData &#x3D; function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType &#x3D;&#x3D;&#x3D; 1 || owner.nodeType &#x3D;&#x3D;&#x3D; 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando &#x3D; jQuery.expando + Data.uid++;
	}

	Data.uid &#x3D; 1;

	Data.prototype &#x3D; {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value &#x3D; owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value &#x3D; {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] &#x3D; value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache &#x3D; this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
				cache[ camelCase( data ) ] &#x3D; value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] &#x3D; data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key &#x3D;&#x3D;&#x3D; undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] &amp;&amp; owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the &quot;read&quot; path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key &#x3D;&#x3D;&#x3D; undefined ||
					( ( key &amp;&amp; typeof key &#x3D;&#x3D;&#x3D; &quot;string&quot; ) &amp;&amp; value &#x3D;&#x3D;&#x3D; undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the &quot;set&quot; path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !&#x3D;&#x3D; undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache &#x3D; owner[ this.expando ];

			if ( cache &#x3D;&#x3D;&#x3D; undefined ) {
				return;
			}

			if ( key !&#x3D;&#x3D; undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key &#x3D; key.map( camelCase );
				} else {
					key &#x3D; camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key &#x3D; key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i &#x3D; key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there&#x27;s no more data
			if ( key &#x3D;&#x3D;&#x3D; undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome &lt;&#x3D;35 - 45
				// Webkit &amp; Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id&#x3D;378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] &#x3D; undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache &#x3D; owner[ this.expando ];
			return cache !&#x3D;&#x3D; undefined &amp;&amp; !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv &#x3D; new Data();

	var dataUser &#x3D; new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module&#x27;s maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.
	//	4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace &#x3D; /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash &#x3D; /[A-Z]/g;

	function getData( data ) {
		if ( data &#x3D;&#x3D;&#x3D; &quot;true&quot; ) {
			return true;
		}

		if ( data &#x3D;&#x3D;&#x3D; &quot;false&quot; ) {
			return false;
		}

		if ( data &#x3D;&#x3D;&#x3D; &quot;null&quot; ) {
			return null;
		}

		// Only convert to a number if it doesn&#x27;t change the string
		if ( data &#x3D;&#x3D;&#x3D; +data + &quot;&quot; ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data &#x3D;&#x3D;&#x3D; undefined &amp;&amp; elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
			name &#x3D; &quot;data-&quot; + key.replace( rmultiDash, &quot;-$&amp;&quot; ).toLowerCase();
			data &#x3D; elem.getAttribute( name );

			if ( typeof data &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
				try {
					data &#x3D; getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn&#x27;t changed later
				dataUser.set( elem, key, data );
			} else {
				data &#x3D; undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem &#x3D; this[ 0 ],
				attrs &#x3D; elem &amp;&amp; elem.attributes;

			// Gets all values
			if ( key &#x3D;&#x3D;&#x3D; undefined ) {
				if ( this.length ) {
					data &#x3D; dataUser.get( elem );

					if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; !dataPriv.get( elem, &quot;hasDataAttrs&quot; ) ) {
						i &#x3D; attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name &#x3D; attrs[ i ].name;
								if ( name.indexOf( &quot;data-&quot; ) &#x3D;&#x3D;&#x3D; 0 ) {
									name &#x3D; camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, &quot;hasDataAttrs&quot;, true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// &#x60;value&#x60; parameter was not undefined. An empty jQuery object
				// will result in &#x60;undefined&#x60; for elem &#x3D; this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem &amp;&amp; value &#x3D;&#x3D;&#x3D; undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data &#x3D; dataUser.get( elem, key );
					if ( data !&#x3D;&#x3D; undefined ) {
						return data;
					}

					// Attempt to &quot;discover&quot; the data in
					// HTML5 custom data-* attrs
					data &#x3D; dataAttr( elem, key );
					if ( data !&#x3D;&#x3D; undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn&#x27;t exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length &gt; 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type &#x3D; ( type || &quot;fx&quot; ) + &quot;queue&quot;;
				queue &#x3D; dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue &#x3D; dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type &#x3D; type || &quot;fx&quot;;

			var queue &#x3D; jQuery.queue( elem, type ),
				startLength &#x3D; queue.length,
				fn &#x3D; queue.shift(),
				hooks &#x3D; jQuery._queueHooks( elem, type ),
				next &#x3D; function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn &#x3D;&#x3D;&#x3D; &quot;inprogress&quot; ) {
				fn &#x3D; queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type &#x3D;&#x3D;&#x3D; &quot;fx&quot; ) {
					queue.unshift( &quot;inprogress&quot; );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength &amp;&amp; hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key &#x3D; type + &quot;queueHooks&quot;;
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( &quot;once memory&quot; ).add( function() {
					dataPriv.remove( elem, [ type + &quot;queue&quot;, key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter &#x3D; 2;

			if ( typeof type !&#x3D;&#x3D; &quot;string&quot; ) {
				data &#x3D; type;
				type &#x3D; &quot;fx&quot;;
				setter--;
			}

			if ( arguments.length &lt; setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data &#x3D;&#x3D;&#x3D; undefined ?
				this :
				this.each( function() {
					var queue &#x3D; jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type &#x3D;&#x3D;&#x3D; &quot;fx&quot; &amp;&amp; queue[ 0 ] !&#x3D;&#x3D; &quot;inprogress&quot; ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || &quot;fx&quot;, [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count &#x3D; 1,
				defer &#x3D; jQuery.Deferred(),
				elements &#x3D; this,
				i &#x3D; this.length,
				resolve &#x3D; function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !&#x3D;&#x3D; &quot;string&quot; ) {
				obj &#x3D; type;
				type &#x3D; undefined;
			}
			type &#x3D; type || &quot;fx&quot;;

			while ( i-- ) {
				tmp &#x3D; dataPriv.get( elements[ i ], type + &quot;queueHooks&quot; );
				if ( tmp &amp;&amp; tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum &#x3D; ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum &#x3D; new RegExp( &quot;^(?:([+-])&#x3D;|)(&quot; + pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; );


	var cssExpand &#x3D; [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ];

	var isHiddenWithinTree &#x3D; function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem &#x3D; el || elem;

			// Inline style trumps all
			return elem.style.display &#x3D;&#x3D;&#x3D; &quot;none&quot; ||
				elem.style.display &#x3D;&#x3D;&#x3D; &quot;&quot; &amp;&amp;

				// Otherwise, check computed style
				// Support: Firefox &lt;&#x3D;43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &amp;&amp;

				jQuery.css( elem, &quot;display&quot; ) &#x3D;&#x3D;&#x3D; &quot;none&quot;;
		};

	var swap &#x3D; function( elem, options, callback, args ) {
		var ret, name,
			old &#x3D; {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] &#x3D; elem.style[ name ];
			elem.style[ name ] &#x3D; options[ name ];
		}

		ret &#x3D; callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] &#x3D; old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations &#x3D; 20,
			currentValue &#x3D; tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, &quot;&quot; );
				},
			initial &#x3D; currentValue(),
			unit &#x3D; valueParts &amp;&amp; valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit &#x3D; ( jQuery.cssNumber[ prop ] || unit !&#x3D;&#x3D; &quot;px&quot; &amp;&amp; +initial ) &amp;&amp;
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit &amp;&amp; initialInUnit[ 3 ] !&#x3D;&#x3D; unit ) {

			// Support: Firefox &lt;&#x3D;54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial &#x3D; initial / 2;

			// Trust units reported by jQuery.css
			unit &#x3D; unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit &#x3D; +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale &#x3D; currentValue() / initial || 0.5 ) ) &lt;&#x3D; 0 ) {
					maxIterations &#x3D; 0;
				}
				initialInUnit &#x3D; initialInUnit / scale;

			}

			initialInUnit &#x3D; initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts &#x3D; valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit &#x3D; +initialInUnit || +initial || 0;

			// Apply relative offset (+&#x3D;/-&#x3D;) if specified
			adjusted &#x3D; valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit &#x3D; unit;
				tween.start &#x3D; initialInUnit;
				tween.end &#x3D; adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap &#x3D; {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc &#x3D; elem.ownerDocument,
			nodeName &#x3D; elem.nodeName,
			display &#x3D; defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp &#x3D; doc.body.appendChild( doc.createElement( nodeName ) );
		display &#x3D; jQuery.css( temp, &quot;display&quot; );

		temp.parentNode.removeChild( temp );

		if ( display &#x3D;&#x3D;&#x3D; &quot;none&quot; ) {
			display &#x3D; &quot;block&quot;;
		}
		defaultDisplayMap[ nodeName ] &#x3D; display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values &#x3D; [],
			index &#x3D; 0,
			length &#x3D; elements.length;

		// Determine new display value for elements that need to change
		for ( ; index &lt; length; index++ ) {
			elem &#x3D; elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display &#x3D; elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display &#x3D;&#x3D;&#x3D; &quot;none&quot; ) {
					values[ index ] &#x3D; dataPriv.get( elem, &quot;display&quot; ) || null;
					if ( !values[ index ] ) {
						elem.style.display &#x3D; &quot;&quot;;
					}
				}
				if ( elem.style.display &#x3D;&#x3D;&#x3D; &quot;&quot; &amp;&amp; isHiddenWithinTree( elem ) ) {
					values[ index ] &#x3D; getDefaultDisplay( elem );
				}
			} else {
				if ( display !&#x3D;&#x3D; &quot;none&quot; ) {
					values[ index ] &#x3D; &quot;none&quot;;

					// Remember what we&#x27;re overwriting
					dataPriv.set( elem, &quot;display&quot;, display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index &#x3D; 0; index &lt; length; index++ ) {
			if ( values[ index ] !&#x3D; null ) {
				elements[ index ].style.display &#x3D; values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state &#x3D;&#x3D;&#x3D; &quot;boolean&quot; ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType &#x3D; ( /^(?:checkbox|radio)$/i );

	var rtagName &#x3D; ( /&lt;([a-z][^\/\0&gt;\x20\t\r\n\f]+)/i );

	var rscriptType &#x3D; ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap &#x3D; {

		// Support: IE &lt;&#x3D;9 only
		option: [ 1, &quot;&lt;select multiple&#x3D;&#x27;multiple&#x27;&gt;&quot;, &quot;&lt;/select&gt;&quot; ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting &lt;tbody&gt; or other required elements.
		thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
		col: [ 2, &quot;&lt;table&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
		tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
		td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],

		_default: [ 0, &quot;&quot;, &quot;&quot; ]
	};

	// Support: IE &lt;&#x3D;9 only
	wrapMap.optgroup &#x3D; wrapMap.option;

	wrapMap.tbody &#x3D; wrapMap.tfoot &#x3D; wrapMap.colgroup &#x3D; wrapMap.caption &#x3D; wrapMap.thead;
	wrapMap.th &#x3D; wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE &lt;&#x3D;9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !&#x3D;&#x3D; &quot;undefined&quot; ) {
			ret &#x3D; context.getElementsByTagName( tag || &quot;*&quot; );

		} else if ( typeof context.querySelectorAll !&#x3D;&#x3D; &quot;undefined&quot; ) {
			ret &#x3D; context.querySelectorAll( tag || &quot;*&quot; );

		} else {
			ret &#x3D; [];
		}

		if ( tag &#x3D;&#x3D;&#x3D; undefined || tag &amp;&amp; nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i &#x3D; 0,
			l &#x3D; elems.length;

		for ( ; i &lt; l; i++ ) {
			dataPriv.set(
				elems[ i ],
				&quot;globalEval&quot;,
				!refElements || dataPriv.get( refElements[ i ], &quot;globalEval&quot; )
			);
		}
	}


	var rhtml &#x3D; /&lt;|&amp;#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment &#x3D; context.createDocumentFragment(),
			nodes &#x3D; [],
			i &#x3D; 0,
			l &#x3D; elems.length;

		for ( ; i &lt; l; i++ ) {
			elem &#x3D; elems[ i ];

			if ( elem || elem &#x3D;&#x3D;&#x3D; 0 ) {

				// Add nodes directly
				if ( toType( elem ) &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {

					// Support: Android &lt;&#x3D;4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp &#x3D; tmp || fragment.appendChild( context.createElement( &quot;div&quot; ) );

					// Deserialize a standard representation
					tag &#x3D; ( rtagName.exec( elem ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase();
					wrap &#x3D; wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML &#x3D; wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j &#x3D; wrap[ 0 ];
					while ( j-- ) {
						tmp &#x3D; tmp.lastChild;
					}

					// Support: Android &lt;&#x3D;4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp &#x3D; fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent &#x3D; &quot;&quot;;
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent &#x3D; &quot;&quot;;

		i &#x3D; 0;
		while ( ( elem &#x3D; nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection &amp;&amp; jQuery.inArray( elem, selection ) &gt; -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains &#x3D; jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp &#x3D; getAll( fragment.appendChild( elem ), &quot;script&quot; );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j &#x3D; 0;
				while ( ( elem &#x3D; tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || &quot;&quot; ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment &#x3D; document.createDocumentFragment(),
			div &#x3D; fragment.appendChild( document.createElement( &quot;div&quot; ) ),
			input &#x3D; document.createElement( &quot;input&quot; );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// &#x60;name&#x60; and &#x60;type&#x60; must use .setAttribute for WWA (#14901)
		input.setAttribute( &quot;type&quot;, &quot;radio&quot; );
		input.setAttribute( &quot;checked&quot;, &quot;checked&quot; );
		input.setAttribute( &quot;name&quot;, &quot;t&quot; );

		div.appendChild( input );

		// Support: Android &lt;&#x3D;4.1 only
		// Older WebKit doesn&#x27;t clone checked state correctly in fragments
		support.checkClone &#x3D; div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE &lt;&#x3D;11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML &#x3D; &quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;;
		support.noCloneChecked &#x3D; !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement &#x3D; document.documentElement;



	var
		rkeyEvent &#x3D; /^key/,
		rmouseEvent &#x3D; /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace &#x3D; /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE &lt;&#x3D;9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {

			// ( types-Object, selector, data )
			if ( typeof selector !&#x3D;&#x3D; &quot;string&quot; ) {

				// ( types-Object, data )
				data &#x3D; data || selector;
				selector &#x3D; undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data &#x3D;&#x3D; null &amp;&amp; fn &#x3D;&#x3D; null ) {

			// ( types, fn )
			fn &#x3D; selector;
			data &#x3D; selector &#x3D; undefined;
		} else if ( fn &#x3D;&#x3D; null ) {
			if ( typeof selector &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {

				// ( types, selector, fn )
				fn &#x3D; data;
				data &#x3D; undefined;
			} else {

				// ( types, data, fn )
				fn &#x3D; data;
				data &#x3D; selector;
				selector &#x3D; undefined;
			}
		}
		if ( fn &#x3D;&#x3D;&#x3D; false ) {
			fn &#x3D; returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one &#x3D;&#x3D;&#x3D; 1 ) {
			origFn &#x3D; fn;
			fn &#x3D; function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid &#x3D; origFn.guid || ( origFn.guid &#x3D; jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards&#x27; addEvent library for many of the ideas.
	 */
	jQuery.event &#x3D; {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData &#x3D; dataPriv.get( elem );

			// Don&#x27;t attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn &#x3D; handler;
				handler &#x3D; handleObjIn.handler;
				selector &#x3D; handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid &#x3D; jQuery.guid++;
			}

			// Init the element&#x27;s event structure and main handler, if this is the first
			if ( !( events &#x3D; elemData.events ) ) {
				events &#x3D; elemData.events &#x3D; {};
			}
			if ( !( eventHandle &#x3D; elemData.handle ) ) {
				eventHandle &#x3D; elemData.handle &#x3D; function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; jQuery.event.triggered !&#x3D;&#x3D; e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types &#x3D; ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
			t &#x3D; types.length;
			while ( t-- ) {
				tmp &#x3D; rtypenamespace.exec( types[ t ] ) || [];
				type &#x3D; origType &#x3D; tmp[ 1 ];
				namespaces &#x3D; ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special &#x3D; jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type &#x3D; ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special &#x3D; jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj &#x3D; jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( &quot;.&quot; )
				}, handleObjIn );

				// Init the event handler queue if we&#x27;re the first
				if ( !( handlers &#x3D; events[ type ] ) ) {
					handlers &#x3D; events[ type ] &#x3D; [];
					handlers.delegateCount &#x3D; 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) &#x3D;&#x3D;&#x3D; false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid &#x3D; handler.guid;
					}
				}

				// Add to the element&#x27;s handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] &#x3D; true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData &#x3D; dataPriv.hasData( elem ) &amp;&amp; dataPriv.get( elem );

			if ( !elemData || !( events &#x3D; elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types &#x3D; ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
			t &#x3D; types.length;
			while ( t-- ) {
				tmp &#x3D; rtypenamespace.exec( types[ t ] ) || [];
				type &#x3D; origType &#x3D; tmp[ 1 ];
				namespaces &#x3D; ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special &#x3D; jQuery.event.special[ type ] || {};
				type &#x3D; ( selector ? special.delegateType : special.bindType ) || type;
				handlers &#x3D; events[ type ] || [];
				tmp &#x3D; tmp[ 2 ] &amp;&amp;
					new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; );

				// Remove matching events
				origCount &#x3D; j &#x3D; handlers.length;
				while ( j-- ) {
					handleObj &#x3D; handlers[ j ];

					if ( ( mappedTypes || origType &#x3D;&#x3D;&#x3D; handleObj.origType ) &amp;&amp;
						( !handler || handler.guid &#x3D;&#x3D;&#x3D; handleObj.guid ) &amp;&amp;
						( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
						( !selector || selector &#x3D;&#x3D;&#x3D; handleObj.selector ||
							selector &#x3D;&#x3D;&#x3D; &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount &amp;&amp; !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) &#x3D;&#x3D;&#x3D; false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it&#x27;s no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, &quot;handle events&quot; );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event &#x3D; jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args &#x3D; new Array( arguments.length ),
				handlers &#x3D; ( dataPriv.get( this, &quot;events&quot; ) || {} )[ event.type ] || [],
				special &#x3D; jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] &#x3D; event;

			for ( i &#x3D; 1; i &lt; arguments.length; i++ ) {
				args[ i ] &#x3D; arguments[ i ];
			}

			event.delegateTarget &#x3D; this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) &#x3D;&#x3D;&#x3D; false ) {
				return;
			}

			// Determine handlers
			handlerQueue &#x3D; jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i &#x3D; 0;
			while ( ( matched &#x3D; handlerQueue[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
				event.currentTarget &#x3D; matched.elem;

				j &#x3D; 0;
				while ( ( handleObj &#x3D; matched.handlers[ j++ ] ) &amp;&amp;
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj &#x3D; handleObj;
						event.data &#x3D; handleObj.data;

						ret &#x3D; ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !&#x3D;&#x3D; undefined ) {
							if ( ( event.result &#x3D; ret ) &#x3D;&#x3D;&#x3D; false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue &#x3D; [],
				delegateCount &#x3D; handlers.delegateCount,
				cur &#x3D; event.target;

			// Find delegate handlers
			if ( delegateCount &amp;&amp;

				// Support: IE &lt;&#x3D;9
				// Black-hole SVG &lt;use&gt; instance trees (trac-13180)
				cur.nodeType &amp;&amp;

				// Support: Firefox &lt;&#x3D;42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key &quot;clicks&quot; of radio inputs, which can have &#x60;button&#x60; -1 (gh-2343)
				!( event.type &#x3D;&#x3D;&#x3D; &quot;click&quot; &amp;&amp; event.button &gt;&#x3D; 1 ) ) {

				for ( ; cur !&#x3D;&#x3D; this; cur &#x3D; cur.parentNode || this ) {

					// Don&#x27;t check non-elements (#13208)
					// Don&#x27;t process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; !( event.type &#x3D;&#x3D;&#x3D; &quot;click&quot; &amp;&amp; cur.disabled &#x3D;&#x3D;&#x3D; true ) ) {
						matchedHandlers &#x3D; [];
						matchedSelectors &#x3D; {};
						for ( i &#x3D; 0; i &lt; delegateCount; i++ ) {
							handleObj &#x3D; handlers[ i ];

							// Don&#x27;t conflict with Object.prototype properties (#13203)
							sel &#x3D; handleObj.selector + &quot; &quot;;

							if ( matchedSelectors[ sel ] &#x3D;&#x3D;&#x3D; undefined ) {
								matchedSelectors[ sel ] &#x3D; handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) &gt; -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur &#x3D; this;
			if ( delegateCount &lt; handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !&#x3D;&#x3D; safeActiveElement() &amp;&amp; this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: &quot;focusin&quot;
			},
			blur: {
				trigger: function() {
					if ( this &#x3D;&#x3D;&#x3D; safeActiveElement() &amp;&amp; this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: &quot;focusout&quot;
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type &#x3D;&#x3D;&#x3D; &quot;checkbox&quot; &amp;&amp; this.click &amp;&amp; nodeName( this, &quot;input&quot; ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don&#x27;t fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, &quot;a&quot; );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn&#x27;t alert if the returnValue field is not set.
					if ( event.result !&#x3D;&#x3D; undefined &amp;&amp; event.originalEvent ) {
						event.originalEvent.returnValue &#x3D; event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent &#x3D; function( elem, type, handle ) {

		// This &quot;if&quot; is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event &#x3D; function( src, props ) {

		// Allow instantiation without the &#x27;new&#x27; keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src &amp;&amp; src.type ) {
			this.originalEvent &#x3D; src;
			this.type &#x3D; src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented &#x3D; src.defaultPrevented ||
					src.defaultPrevented &#x3D;&#x3D;&#x3D; undefined &amp;&amp;

					// Support: Android &lt;&#x3D;2.3 only
					src.returnValue &#x3D;&#x3D;&#x3D; false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari &lt;&#x3D;6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target &#x3D; ( src.target &amp;&amp; src.target.nodeType &#x3D;&#x3D;&#x3D; 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget &#x3D; src.currentTarget;
			this.relatedTarget &#x3D; src.relatedTarget;

		// Event type
		} else {
			this.type &#x3D; src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn&#x27;t have one
		this.timeStamp &#x3D; src &amp;&amp; src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] &#x3D; true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype &#x3D; {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e &#x3D; this.originalEvent;

			this.isDefaultPrevented &#x3D; returnTrue;

			if ( e &amp;&amp; !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e &#x3D; this.originalEvent;

			this.isPropagationStopped &#x3D; returnTrue;

			if ( e &amp;&amp; !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e &#x3D; this.originalEvent;

			this.isImmediatePropagationStopped &#x3D; returnTrue;

			if ( e &amp;&amp; !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		&quot;char&quot;: true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button &#x3D; event.button;

			// Add which for key events
			if ( event.which &#x3D;&#x3D; null &amp;&amp; rkeyEvent.test( event.type ) ) {
				return event.charCode !&#x3D; null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 &#x3D;&#x3D;&#x3D; left; 2 &#x3D;&#x3D;&#x3D; middle; 3 &#x3D;&#x3D;&#x3D; right
			if ( !event.which &amp;&amp; button !&#x3D;&#x3D; undefined &amp;&amp; rmouseEvent.test( event.type ) ) {
				if ( button &amp; 1 ) {
					return 1;
				}

				if ( button &amp; 2 ) {
					return 3;
				}

				if ( button &amp; 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id&#x3D;470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: &quot;mouseover&quot;,
		mouseleave: &quot;mouseout&quot;,
		pointerenter: &quot;pointerover&quot;,
		pointerleave: &quot;pointerout&quot;
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] &#x3D; {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target &#x3D; this,
					related &#x3D; event.relatedTarget,
					handleObj &#x3D; event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !&#x3D;&#x3D; target &amp;&amp; !jQuery.contains( target, related ) ) ) {
					event.type &#x3D; handleObj.origType;
					ret &#x3D; handleObj.handler.apply( this, arguments );
					event.type &#x3D; fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj &#x3D; types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + &quot;.&quot; + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector &#x3D;&#x3D;&#x3D; false || typeof selector &#x3D;&#x3D;&#x3D; &quot;function&quot; ) {

				// ( types [, fn] )
				fn &#x3D; selector;
				selector &#x3D; undefined;
			}
			if ( fn &#x3D;&#x3D;&#x3D; false ) {
				fn &#x3D; returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag &#x3D; /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi,

		/* eslint-enable */

		// Support: IE &lt;&#x3D;10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml &#x3D; /&lt;script|&lt;style|&lt;link/i,

		// checked&#x3D;&quot;checked&quot; or checked
		rchecked &#x3D; /checked\s*(?:[^&#x3D;]|&#x3D;\s*.checked.)/i,
		rcleanScript &#x3D; /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, &quot;table&quot; ) &amp;&amp;
			nodeName( content.nodeType !&#x3D;&#x3D; 11 ? content : content.firstChild, &quot;tr&quot; ) ) {

			return jQuery( elem ).children( &quot;tbody&quot; )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type &#x3D; ( elem.getAttribute( &quot;type&quot; ) !&#x3D;&#x3D; null ) + &quot;/&quot; + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || &quot;&quot; ).slice( 0, 5 ) &#x3D;&#x3D;&#x3D; &quot;true/&quot; ) {
			elem.type &#x3D; elem.type.slice( 5 );
		} else {
			elem.removeAttribute( &quot;type&quot; );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !&#x3D;&#x3D; 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld &#x3D; dataPriv.access( src );
			pdataCur &#x3D; dataPriv.set( dest, pdataOld );
			events &#x3D; pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events &#x3D; {};

				for ( type in events ) {
					for ( i &#x3D; 0, l &#x3D; events[ type ].length; i &lt; l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld &#x3D; dataUser.access( src );
			udataCur &#x3D; jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName &#x3D; dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName &#x3D;&#x3D;&#x3D; &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) {
			dest.checked &#x3D; src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName &#x3D;&#x3D;&#x3D; &quot;input&quot; || nodeName &#x3D;&#x3D;&#x3D; &quot;textarea&quot; ) {
			dest.defaultValue &#x3D; src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args &#x3D; concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i &#x3D; 0,
			l &#x3D; collection.length,
			iNoClone &#x3D; l - 1,
			value &#x3D; args[ 0 ],
			valueIsFunction &#x3D; isFunction( value );

		// We can&#x27;t cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l &gt; 1 &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &quot;string&quot; &amp;&amp;
					!support.checkClone &amp;&amp; rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self &#x3D; collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] &#x3D; value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment &#x3D; buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first &#x3D; fragment.firstChild;

			if ( fragment.childNodes.length &#x3D;&#x3D;&#x3D; 1 ) {
				fragment &#x3D; first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts &#x3D; jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript );
				hasScripts &#x3D; scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i &lt; l; i++ ) {
					node &#x3D; fragment;

					if ( i !&#x3D;&#x3D; iNoClone ) {
						node &#x3D; jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android &lt;&#x3D;4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, &quot;script&quot; ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc &#x3D; scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i &#x3D; 0; i &lt; hasScripts; i++ ) {
						node &#x3D; scripts[ i ];
						if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp;
							!dataPriv.access( node, &quot;globalEval&quot; ) &amp;&amp;
							jQuery.contains( doc, node ) ) {

							if ( node.src &amp;&amp; ( node.type || &quot;&quot; ).toLowerCase()  !&#x3D;&#x3D; &quot;module&quot; ) {

								// Optional AJAX dependency, but won&#x27;t run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, &quot;&quot; ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes &#x3D; selector ? jQuery.filter( selector, elem ) : elem,
			i &#x3D; 0;

		for ( ; ( node &#x3D; nodes[ i ] ) !&#x3D; null; i++ ) {
			if ( !keepData &amp;&amp; node.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, &quot;script&quot; ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone &#x3D; elem.cloneNode( true ),
				inPage &#x3D; jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked &amp;&amp; ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 || elem.nodeType &#x3D;&#x3D;&#x3D; 11 ) &amp;&amp;
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements &#x3D; getAll( clone );
				srcElements &#x3D; getAll( elem );

				for ( i &#x3D; 0, l &#x3D; srcElements.length; i &lt; l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements &#x3D; srcElements || getAll( elem );
					destElements &#x3D; destElements || getAll( clone );

					for ( i &#x3D; 0, l &#x3D; srcElements.length; i &lt; l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements &#x3D; getAll( clone, &quot;script&quot; );
			if ( destElements.length &gt; 0 ) {
				setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special &#x3D; jQuery.event.special,
				i &#x3D; 0;

			for ( ; ( elem &#x3D; elems[ i ] ) !&#x3D;&#x3D; undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data &#x3D; elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove&#x27;s overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome &lt;&#x3D;35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] &#x3D; undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome &lt;&#x3D;35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] &#x3D; undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value &#x3D;&#x3D;&#x3D; undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType &#x3D;&#x3D;&#x3D; 1 || this.nodeType &#x3D;&#x3D;&#x3D; 11 || this.nodeType &#x3D;&#x3D;&#x3D; 9 ) {
							this.textContent &#x3D; value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType &#x3D;&#x3D;&#x3D; 1 || this.nodeType &#x3D;&#x3D;&#x3D; 11 || this.nodeType &#x3D;&#x3D;&#x3D; 9 ) {
					var target &#x3D; manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType &#x3D;&#x3D;&#x3D; 1 || this.nodeType &#x3D;&#x3D;&#x3D; 11 || this.nodeType &#x3D;&#x3D;&#x3D; 9 ) {
					var target &#x3D; manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i &#x3D; 0;

			for ( ; ( elem &#x3D; this[ i ] ) !&#x3D; null; i++ ) {
				if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent &#x3D; &quot;&quot;;
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents &#x3D; dataAndEvents &#x3D;&#x3D; null ? false : dataAndEvents;
			deepDataAndEvents &#x3D; deepDataAndEvents &#x3D;&#x3D; null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem &#x3D; this[ 0 ] || {},
					i &#x3D; 0,
					l &#x3D; this.length;

				if ( value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value &#x3D;&#x3D;&#x3D; &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
					!wrapMap[ ( rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase() ] ) {

					value &#x3D; jQuery.htmlPrefilter( value );

					try {
						for ( ; i &lt; l; i++ ) {
							elem &#x3D; this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML &#x3D; value;
							}
						}

						elem &#x3D; 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored &#x3D; [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent &#x3D; this.parentNode;

				if ( jQuery.inArray( this, ignored ) &lt; 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: &quot;append&quot;,
		prependTo: &quot;prepend&quot;,
		insertBefore: &quot;before&quot;,
		insertAfter: &quot;after&quot;,
		replaceAll: &quot;replaceWith&quot;
	}, function( name, original ) {
		jQuery.fn[ name ] &#x3D; function( selector ) {
			var elems,
				ret &#x3D; [],
				insert &#x3D; jQuery( selector ),
				last &#x3D; insert.length - 1,
				i &#x3D; 0;

			for ( ; i &lt;&#x3D; last; i++ ) {
				elems &#x3D; i &#x3D;&#x3D;&#x3D; last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android &lt;&#x3D;4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx &#x3D; new RegExp( &quot;^(&quot; + pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; );

	var getStyles &#x3D; function( elem ) {

			// Support: IE &lt;&#x3D;11 only, Firefox &lt;&#x3D;30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;
			var view &#x3D; elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view &#x3D; window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle &#x3D; new RegExp( cssExpand.join( &quot;|&quot; ), &quot;i&quot; );



	( function() {

		// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout
		// so they&#x27;re executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText &#x3D; &quot;position:absolute;left:-11111px;width:60px;&quot; +
				&quot;margin-top:1px;padding:0;border:0&quot;;
			div.style.cssText &#x3D;
				&quot;position:relative;display:block;box-sizing:border-box;overflow:scroll;&quot; +
				&quot;margin:auto;border:1px;padding:1px;&quot; +
				&quot;width:60%;top:1%&quot;;
			documentElement.appendChild( container ).appendChild( div );

			var divStyle &#x3D; window.getComputedStyle( div );
			pixelPositionVal &#x3D; divStyle.top !&#x3D;&#x3D; &quot;1%&quot;;

			// Support: Android 4.0 - 4.3 only, Firefox &lt;&#x3D;3 - 44
			reliableMarginLeftVal &#x3D; roundPixelMeasures( divStyle.marginLeft ) &#x3D;&#x3D;&#x3D; 12;

			// Support: Android 4.0 - 4.3 only, Safari &lt;&#x3D;9.1 - 10.1, iOS &lt;&#x3D;7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn&#x27;t
			div.style.right &#x3D; &quot;60%&quot;;
			pixelBoxStylesVal &#x3D; roundPixelMeasures( divStyle.right ) &#x3D;&#x3D;&#x3D; 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal &#x3D; roundPixelMeasures( divStyle.width ) &#x3D;&#x3D;&#x3D; 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position &#x3D; &quot;absolute&quot;;
			scrollboxSizeVal &#x3D; div.offsetWidth &#x3D;&#x3D;&#x3D; 36 || &quot;absolute&quot;;

			documentElement.removeChild( container );

			// Nullify the div so it wouldn&#x27;t be stored in the memory and
			// it will also be a sign that checks already performed
			div &#x3D; null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container &#x3D; document.createElement( &quot;div&quot; ),
			div &#x3D; document.createElement( &quot;div&quot; );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE &lt;&#x3D;9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip &#x3D; &quot;content-box&quot;;
		div.cloneNode( true ).style.backgroundClip &#x3D; &quot;&quot;;
		support.clearCloneStyle &#x3D; div.style.backgroundClip &#x3D;&#x3D;&#x3D; &quot;content-box&quot;;

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style &#x3D; elem.style;

		computed &#x3D; computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css(&#x27;filter&#x27;) (IE 9 only, #12537)
		//   .css(&#x27;--customProperty) (#3144)
		if ( computed ) {
			ret &#x3D; computed.getPropertyValue( name ) || computed[ name ];

			if ( ret &#x3D;&#x3D;&#x3D; &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret &#x3D; jQuery.style( elem, name );
			}

			// A tribute to the &quot;awesome hack by Dean Edwards&quot;
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() &amp;&amp; rnumnonpx.test( ret ) &amp;&amp; rboxStyle.test( name ) ) {

				// Remember the original values
				width &#x3D; style.width;
				minWidth &#x3D; style.minWidth;
				maxWidth &#x3D; style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth &#x3D; style.maxWidth &#x3D; style.width &#x3D; ret;
				ret &#x3D; computed.width;

				// Revert the changed values
				style.width &#x3D; width;
				style.minWidth &#x3D; minWidth;
				style.maxWidth &#x3D; maxWidth;
			}
		}

		return ret !&#x3D;&#x3D; undefined ?

			// Support: IE &lt;&#x3D;9 - 11 only
			// IE returns zIndex value as an integer.
			ret + &quot;&quot; :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we&#x27;ll check on the first run if it&#x27;s really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it&#x27;s not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get &#x3D; hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap &#x3D; /^(none|table(?!-c[ea]).+)/,
		rcustomProp &#x3D; /^--/,
		cssShow &#x3D; { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
		cssNormalTransform &#x3D; {
			letterSpacing: &quot;0&quot;,
			fontWeight: &quot;400&quot;
		},

		cssPrefixes &#x3D; [ &quot;Webkit&quot;, &quot;Moz&quot;, &quot;ms&quot; ],
		emptyStyle &#x3D; document.createElement( &quot;div&quot; ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName &#x3D; name[ 0 ].toUpperCase() + name.slice( 1 ),
			i &#x3D; cssPrefixes.length;

		while ( i-- ) {
			name &#x3D; cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret &#x3D; jQuery.cssProps[ name ];
		if ( !ret ) {
			ret &#x3D; jQuery.cssProps[ name ] &#x3D; vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches &#x3D; rcssNum.exec( value );
		return matches ?

			// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || &quot;px&quot; ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i &#x3D; dimension &#x3D;&#x3D;&#x3D; &quot;width&quot; ? 1 : 0,
			extra &#x3D; 0,
			delta &#x3D; 0;

		// Adjustment may not be necessary
		if ( box &#x3D;&#x3D;&#x3D; ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ) {
			return 0;
		}

		for ( ; i &lt; 4; i +&#x3D; 2 ) {

			// Both box models exclude margin
			if ( box &#x3D;&#x3D;&#x3D; &quot;margin&quot; ) {
				delta +&#x3D; jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we&#x27;re seeking &quot;padding&quot; or &quot;border&quot; or &quot;margin&quot;
			if ( !isBorderBox ) {

				// Add padding
				delta +&#x3D; jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );

				// For &quot;border&quot; or &quot;margin&quot;, add border
				if ( box !&#x3D;&#x3D; &quot;padding&quot; ) {
					delta +&#x3D; jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );

				// But still keep track of it otherwise
				} else {
					extra +&#x3D; jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
				}

			// If we get here with a border-box (content + padding + border), we&#x27;re seeking &quot;content&quot; or
			// &quot;padding&quot; or &quot;margin&quot;
			} else {

				// For &quot;content&quot;, subtract padding
				if ( box &#x3D;&#x3D;&#x3D; &quot;content&quot; ) {
					delta -&#x3D; jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
				}

				// For &quot;content&quot; or &quot;padding&quot;, subtract border
				if ( box !&#x3D;&#x3D; &quot;margin&quot; ) {
					delta -&#x3D; jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox &amp;&amp; computedVal &gt;&#x3D; 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta +&#x3D; Math.max( 0, Math.ceil(
				elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles &#x3D; getStyles( elem ),
			val &#x3D; curCSS( elem, dimension, styles ),
			isBorderBox &#x3D; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) &#x3D;&#x3D;&#x3D; &quot;border-box&quot;,
			valueIsBorderBox &#x3D; isBorderBox;

		// Support: Firefox &lt;&#x3D;54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val &#x3D; &quot;auto&quot;;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox &#x3D; valueIsBorderBox &amp;&amp;
			( support.boxSizingReliable() || val &#x3D;&#x3D;&#x3D; elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is &quot;auto&quot;
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android &lt;&#x3D;4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val &#x3D;&#x3D;&#x3D; &quot;auto&quot; ||
			!parseFloat( val ) &amp;&amp; jQuery.css( elem, &quot;display&quot;, false, styles ) &#x3D;&#x3D;&#x3D; &quot;inline&quot; ) {

			val &#x3D; elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox &#x3D; true;
		}

		// Normalize &quot;&quot; and auto
		val &#x3D; parseFloat( val ) || 0;

		// Adjust for the element&#x27;s box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + &quot;px&quot;;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret &#x3D; curCSS( elem, &quot;opacity&quot; );
						return ret &#x3D;&#x3D;&#x3D; &quot;&quot; ? &quot;1&quot; : ret;
					}
				}
			}
		},

		// Don&#x27;t automatically add &quot;px&quot; to these possibly-unitless properties
		cssNumber: {
			&quot;animationIterationCount&quot;: true,
			&quot;columnCount&quot;: true,
			&quot;fillOpacity&quot;: true,
			&quot;flexGrow&quot;: true,
			&quot;flexShrink&quot;: true,
			&quot;fontWeight&quot;: true,
			&quot;lineHeight&quot;: true,
			&quot;opacity&quot;: true,
			&quot;order&quot;: true,
			&quot;orphans&quot;: true,
			&quot;widows&quot;: true,
			&quot;zIndex&quot;: true,
			&quot;zoom&quot;: true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don&#x27;t set styles on text and comment nodes
			if ( !elem || elem.nodeType &#x3D;&#x3D;&#x3D; 3 || elem.nodeType &#x3D;&#x3D;&#x3D; 8 || !elem.style ) {
				return;
			}

			// Make sure that we&#x27;re working with the right name
			var ret, type, hooks,
				origName &#x3D; camelCase( name ),
				isCustomProp &#x3D; rcustomProp.test( name ),
				style &#x3D; elem.style;

			// Make sure that we&#x27;re working with the right name. We don&#x27;t
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name &#x3D; finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks &#x3D; jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we&#x27;re setting a value
			if ( value !&#x3D;&#x3D; undefined ) {
				type &#x3D; typeof value;

				// Convert &quot;+&#x3D;&quot; or &quot;-&#x3D;&quot; to relative numbers (#7345)
				if ( type &#x3D;&#x3D;&#x3D; &quot;string&quot; &amp;&amp; ( ret &#x3D; rcssNum.exec( value ) ) &amp;&amp; ret[ 1 ] ) {
					value &#x3D; adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type &#x3D; &quot;number&quot;;
				}

				// Make sure that null and NaN values aren&#x27;t set (#7116)
				if ( value &#x3D;&#x3D; null || value !&#x3D;&#x3D; value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type &#x3D;&#x3D;&#x3D; &quot;number&quot; ) {
					value +&#x3D; ret &amp;&amp; ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? &quot;&quot; : &quot;px&quot; );
				}

				// background-* props affect original clone&#x27;s values
				if ( !support.clearCloneStyle &amp;&amp; value &#x3D;&#x3D;&#x3D; &quot;&quot; &amp;&amp; name.indexOf( &quot;background&quot; ) &#x3D;&#x3D;&#x3D; 0 ) {
					style[ name ] &#x3D; &quot;inherit&quot;;
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( &quot;set&quot; in hooks ) ||
					( value &#x3D; hooks.set( elem, value, extra ) ) !&#x3D;&#x3D; undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] &#x3D; value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp;
					( ret &#x3D; hooks.get( elem, false, extra ) ) !&#x3D;&#x3D; undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName &#x3D; camelCase( name ),
				isCustomProp &#x3D; rcustomProp.test( name );

			// Make sure that we&#x27;re working with the right name. We don&#x27;t
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name &#x3D; finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks &#x3D; jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
				val &#x3D; hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val &#x3D;&#x3D;&#x3D; undefined ) {
				val &#x3D; curCSS( elem, name, styles );
			}

			// Convert &quot;normal&quot; to computed value
			if ( val &#x3D;&#x3D;&#x3D; &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
				val &#x3D; cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra &#x3D;&#x3D;&#x3D; &quot;&quot; || extra ) {
				num &#x3D; parseFloat( val );
				return extra &#x3D;&#x3D;&#x3D; true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ &quot;height&quot;, &quot;width&quot; ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] &#x3D; {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) &amp;&amp;

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth &amp; zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE &lt;&#x3D;11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles &#x3D; getStyles( elem ),
					isBorderBox &#x3D; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) &#x3D;&#x3D;&#x3D; &quot;border-box&quot;,
					subtract &#x3D; extra &amp;&amp; boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox &amp;&amp; support.scrollboxSize() &#x3D;&#x3D;&#x3D; styles.position ) {
					subtract -&#x3D; Math.ceil(
						elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, &quot;border&quot;, false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract &amp;&amp; ( matches &#x3D; rcssNum.exec( value ) ) &amp;&amp;
					( matches[ 3 ] || &quot;px&quot; ) !&#x3D;&#x3D; &quot;px&quot; ) {

					elem.style[ dimension ] &#x3D; value;
					value &#x3D; jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft &#x3D; addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, &quot;marginLeft&quot; ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + &quot;px&quot;;
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: &quot;&quot;,
		padding: &quot;&quot;,
		border: &quot;Width&quot;
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] &#x3D; {
			expand: function( value ) {
				var i &#x3D; 0,
					expanded &#x3D; {},

					// Assumes a single number if not a string
					parts &#x3D; typeof value &#x3D;&#x3D;&#x3D; &quot;string&quot; ? value.split( &quot; &quot; ) : [ value ];

				for ( ; i &lt; 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] &#x3D;
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !&#x3D;&#x3D; &quot;margin&quot; ) {
			jQuery.cssHooks[ prefix + suffix ].set &#x3D; setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map &#x3D; {},
					i &#x3D; 0;

				if ( Array.isArray( name ) ) {
					styles &#x3D; getStyles( elem );
					len &#x3D; name.length;

					for ( ; i &lt; len; i++ ) {
						map[ name[ i ] ] &#x3D; jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !&#x3D;&#x3D; undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length &gt; 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween &#x3D; Tween;

	Tween.prototype &#x3D; {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem &#x3D; elem;
			this.prop &#x3D; prop;
			this.easing &#x3D; easing || jQuery.easing._default;
			this.options &#x3D; options;
			this.start &#x3D; this.now &#x3D; this.cur();
			this.end &#x3D; end;
			this.unit &#x3D; unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
		},
		cur: function() {
			var hooks &#x3D; Tween.propHooks[ this.prop ];

			return hooks &amp;&amp; hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks &#x3D; Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos &#x3D; eased &#x3D; jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos &#x3D; eased &#x3D; percent;
			}
			this.now &#x3D; ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks &amp;&amp; hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype &#x3D; Tween.prototype;

	Tween.propHooks &#x3D; {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !&#x3D;&#x3D; 1 ||
					tween.elem[ tween.prop ] !&#x3D; null &amp;&amp; tween.elem.style[ tween.prop ] &#x3D;&#x3D; null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as &quot;10px&quot; are parsed to Float;
				// complex values such as &quot;rotate(1rad)&quot; are returned as-is.
				result &#x3D; jQuery.css( tween.elem, tween.prop, &quot;&quot; );

				// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
				return !result || result &#x3D;&#x3D;&#x3D; &quot;auto&quot; ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp;
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] !&#x3D; null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] &#x3D; tween.now;
				}
			}
		}
	};

	// Support: IE &lt;&#x3D;9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop &#x3D; Tween.propHooks.scrollLeft &#x3D; {
		set: function( tween ) {
			if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
				tween.elem[ tween.prop ] &#x3D; tween.now;
			}
		}
	};

	jQuery.easing &#x3D; {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: &quot;swing&quot;
	};

	jQuery.fx &#x3D; Tween.prototype.init;

	// Back compat &lt;1.8 extension point
	jQuery.fx.step &#x3D; {};




	var
		fxNow, inProgress,
		rfxtypes &#x3D; /^(?:toggle|show|hide)$/,
		rrun &#x3D; /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden &#x3D;&#x3D;&#x3D; false &amp;&amp; window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow &#x3D; undefined;
		} );
		return ( fxNow &#x3D; Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i &#x3D; 0,
			attrs &#x3D; { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth &#x3D; includeWidth ? 1 : 0;
		for ( ; i &lt; 4; i +&#x3D; 2 - includeWidth ) {
			which &#x3D; cssExpand[ i ];
			attrs[ &quot;margin&quot; + which ] &#x3D; attrs[ &quot;padding&quot; + which ] &#x3D; type;
		}

		if ( includeWidth ) {
			attrs.opacity &#x3D; attrs.width &#x3D; type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection &#x3D; ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ &quot;*&quot; ] ),
			index &#x3D; 0,
			length &#x3D; collection.length;
		for ( ; index &lt; length; index++ ) {
			if ( ( tween &#x3D; collection[ index ].call( animation, prop, value ) ) ) {

				// We&#x27;re done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox &#x3D; &quot;width&quot; in props || &quot;height&quot; in props,
			anim &#x3D; this,
			orig &#x3D; {},
			style &#x3D; elem.style,
			hidden &#x3D; elem.nodeType &amp;&amp; isHiddenWithinTree( elem ),
			dataShow &#x3D; dataPriv.get( elem, &quot;fxshow&quot; );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks &#x3D; jQuery._queueHooks( elem, &quot;fx&quot; );
			if ( hooks.unqueued &#x3D;&#x3D; null ) {
				hooks.unqueued &#x3D; 0;
				oldfire &#x3D; hooks.empty.fire;
				hooks.empty.fire &#x3D; function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value &#x3D; props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle &#x3D; toggle || value &#x3D;&#x3D;&#x3D; &quot;toggle&quot;;
				if ( value &#x3D;&#x3D;&#x3D; ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {

					// Pretend to be hidden if this is a &quot;show&quot; and
					// there is still data from a stopped show/hide
					if ( value &#x3D;&#x3D;&#x3D; &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !&#x3D;&#x3D; undefined ) {
						hidden &#x3D; true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] &#x3D; dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween &#x3D; !jQuery.isEmptyObject( props );
		if ( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict &quot;overflow&quot; and &quot;display&quot; styles during box animations
		if ( isBox &amp;&amp; elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {

			// Support: IE &lt;&#x3D;9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow &#x3D; [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay &#x3D; dataShow &amp;&amp; dataShow.display;
			if ( restoreDisplay &#x3D;&#x3D; null ) {
				restoreDisplay &#x3D; dataPriv.get( elem, &quot;display&quot; );
			}
			display &#x3D; jQuery.css( elem, &quot;display&quot; );
			if ( display &#x3D;&#x3D;&#x3D; &quot;none&quot; ) {
				if ( restoreDisplay ) {
					display &#x3D; restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay &#x3D; elem.style.display || restoreDisplay;
					display &#x3D; jQuery.css( elem, &quot;display&quot; );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display &#x3D;&#x3D;&#x3D; &quot;inline&quot; || display &#x3D;&#x3D;&#x3D; &quot;inline-block&quot; &amp;&amp; restoreDisplay !&#x3D; null ) {
				if ( jQuery.css( elem, &quot;float&quot; ) &#x3D;&#x3D;&#x3D; &quot;none&quot; ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display &#x3D; restoreDisplay;
						} );
						if ( restoreDisplay &#x3D;&#x3D; null ) {
							display &#x3D; style.display;
							restoreDisplay &#x3D; display &#x3D;&#x3D;&#x3D; &quot;none&quot; ? &quot;&quot; : display;
						}
					}
					style.display &#x3D; &quot;inline-block&quot;;
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow &#x3D; &quot;hidden&quot;;
			anim.always( function() {
				style.overflow &#x3D; opts.overflow[ 0 ];
				style.overflowX &#x3D; opts.overflow[ 1 ];
				style.overflowY &#x3D; opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween &#x3D; false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( &quot;hidden&quot; in dataShow ) {
						hidden &#x3D; dataShow.hidden;
					}
				} else {
					dataShow &#x3D; dataPriv.access( elem, &quot;fxshow&quot;, { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so &#x60;.stop().toggle()&#x60; &quot;reverses&quot;
				if ( toggle ) {
					dataShow.hidden &#x3D; !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a &quot;hide&quot; animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, &quot;fxshow&quot; );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween &#x3D; createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] &#x3D; propTween.start;
				if ( hidden ) {
					propTween.end &#x3D; propTween.start;
					propTween.start &#x3D; 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name &#x3D; camelCase( index );
			easing &#x3D; specialEasing[ name ];
			value &#x3D; props[ index ];
			if ( Array.isArray( value ) ) {
				easing &#x3D; value[ 1 ];
				value &#x3D; props[ index ] &#x3D; value[ 0 ];
			}

			if ( index !&#x3D;&#x3D; name ) {
				props[ name ] &#x3D; value;
				delete props[ index ];
			}

			hooks &#x3D; jQuery.cssHooks[ name ];
			if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
				value &#x3D; hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won&#x27;t overwrite existing keys.
				// Reusing &#x27;index&#x27; because we have the correct &quot;name&quot;
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] &#x3D; value[ index ];
						specialEasing[ index ] &#x3D; easing;
					}
				}
			} else {
				specialEasing[ name ] &#x3D; easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index &#x3D; 0,
			length &#x3D; Animation.prefilters.length,
			deferred &#x3D; jQuery.Deferred().always( function() {

				// Don&#x27;t match elem in the :animated selector
				delete tick.elem;
			} ),
			tick &#x3D; function() {
				if ( stopped ) {
					return false;
				}
				var currentTime &#x3D; fxNow || createFxNow(),
					remaining &#x3D; Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won&#x27;t allow us to use &#x60;1 - ( 0.5 || 0 )&#x60; (#12497)
					temp &#x3D; remaining / animation.duration || 0,
					percent &#x3D; 1 - temp,
					index &#x3D; 0,
					length &#x3D; animation.tweens.length;

				for ( ; index &lt; length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there&#x27;s more to do, yield
				if ( percent &lt; 1 &amp;&amp; length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation &#x3D; deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween &#x3D; jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index &#x3D; 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length &#x3D; gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped &#x3D; true;
					for ( ; index &lt; length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props &#x3D; animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index &lt; length; index++ ) {
			result &#x3D; Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop &#x3D;
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation &#x3D; jQuery.extend( Animation, {

		tweeners: {
			&quot;*&quot;: [ function( prop, value ) {
				var tween &#x3D; this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback &#x3D; props;
				props &#x3D; [ &quot;*&quot; ];
			} else {
				props &#x3D; props.match( rnothtmlwhite );
			}

			var prop,
				index &#x3D; 0,
				length &#x3D; props.length;

			for ( ; index &lt; length; index++ ) {
				prop &#x3D; props[ index ];
				Animation.tweeners[ prop ] &#x3D; Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed &#x3D; function( speed, easing, fn ) {
		var opt &#x3D; speed &amp;&amp; typeof speed &#x3D;&#x3D;&#x3D; &quot;object&quot; ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn &amp;&amp; easing ||
				isFunction( speed ) &amp;&amp; speed,
			duration: speed,
			easing: fn &amp;&amp; easing || easing &amp;&amp; !isFunction( easing ) &amp;&amp; easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration &#x3D; 0;

		} else {
			if ( typeof opt.duration !&#x3D;&#x3D; &quot;number&quot; ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration &#x3D; jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration &#x3D; jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
		if ( opt.queue &#x3D;&#x3D; null || opt.queue &#x3D;&#x3D;&#x3D; true ) {
			opt.queue &#x3D; &quot;fx&quot;;
		}

		// Queueing
		opt.old &#x3D; opt.complete;

		opt.complete &#x3D; function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( &quot;opacity&quot;, 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty &#x3D; jQuery.isEmptyObject( prop ),
				optall &#x3D; jQuery.speed( speed, easing, callback ),
				doAnimation &#x3D; function() {

					// Operate on a copy of prop so per-property easing won&#x27;t be lost
					var anim &#x3D; Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, &quot;finish&quot; ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish &#x3D; doAnimation;

			return empty || optall.queue &#x3D;&#x3D;&#x3D; false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue &#x3D; function( hooks ) {
				var stop &#x3D; hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !&#x3D;&#x3D; &quot;string&quot; ) {
				gotoEnd &#x3D; clearQueue;
				clearQueue &#x3D; type;
				type &#x3D; undefined;
			}
			if ( clearQueue &amp;&amp; type !&#x3D;&#x3D; false ) {
				this.queue( type || &quot;fx&quot;, [] );
			}

			return this.each( function() {
				var dequeue &#x3D; true,
					index &#x3D; type !&#x3D; null &amp;&amp; type + &quot;queueHooks&quot;,
					timers &#x3D; jQuery.timers,
					data &#x3D; dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] &amp;&amp; data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index &#x3D; timers.length; index--; ) {
					if ( timers[ index ].elem &#x3D;&#x3D;&#x3D; this &amp;&amp;
						( type &#x3D;&#x3D; null || timers[ index ].queue &#x3D;&#x3D;&#x3D; type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue &#x3D; false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn&#x27;t forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !&#x3D;&#x3D; false ) {
				type &#x3D; type || &quot;fx&quot;;
			}
			return this.each( function() {
				var index,
					data &#x3D; dataPriv.get( this ),
					queue &#x3D; data[ type + &quot;queue&quot; ],
					hooks &#x3D; data[ type + &quot;queueHooks&quot; ],
					timers &#x3D; jQuery.timers,
					length &#x3D; queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish &#x3D; true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks &amp;&amp; hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index &#x3D; timers.length; index--; ) {
					if ( timers[ index ].elem &#x3D;&#x3D;&#x3D; this &amp;&amp; timers[ index ].queue &#x3D;&#x3D;&#x3D; type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index &#x3D; 0; index &lt; length; index++ ) {
					if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) {
		var cssFn &#x3D; jQuery.fn[ name ];
		jQuery.fn[ name ] &#x3D; function( speed, easing, callback ) {
			return speed &#x3D;&#x3D; null || typeof speed &#x3D;&#x3D;&#x3D; &quot;boolean&quot; ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( &quot;show&quot; ),
		slideUp: genFx( &quot;hide&quot; ),
		slideToggle: genFx( &quot;toggle&quot; ),
		fadeIn: { opacity: &quot;show&quot; },
		fadeOut: { opacity: &quot;hide&quot; },
		fadeToggle: { opacity: &quot;toggle&quot; }
	}, function( name, props ) {
		jQuery.fn[ name ] &#x3D; function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers &#x3D; [];
	jQuery.fx.tick &#x3D; function() {
		var timer,
			i &#x3D; 0,
			timers &#x3D; jQuery.timers;

		fxNow &#x3D; Date.now();

		for ( ; i &lt; timers.length; i++ ) {
			timer &#x3D; timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() &amp;&amp; timers[ i ] &#x3D;&#x3D;&#x3D; timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow &#x3D; undefined;
	};

	jQuery.fx.timer &#x3D; function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval &#x3D; 13;
	jQuery.fx.start &#x3D; function() {
		if ( inProgress ) {
			return;
		}

		inProgress &#x3D; true;
		schedule();
	};

	jQuery.fx.stop &#x3D; function() {
		inProgress &#x3D; null;
	};

	jQuery.fx.speeds &#x3D; {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay &#x3D; function( time, type ) {
		time &#x3D; jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type &#x3D; type || &quot;fx&quot;;

		return this.queue( type, function( next, hooks ) {
			var timeout &#x3D; window.setTimeout( next, time );
			hooks.stop &#x3D; function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input &#x3D; document.createElement( &quot;input&quot; ),
			select &#x3D; document.createElement( &quot;select&quot; ),
			opt &#x3D; select.appendChild( document.createElement( &quot;option&quot; ) );

		input.type &#x3D; &quot;checkbox&quot;;

		// Support: Android &lt;&#x3D;4.3 only
		// Default value for a checkbox should be &quot;on&quot;
		support.checkOn &#x3D; input.value !&#x3D;&#x3D; &quot;&quot;;

		// Support: IE &lt;&#x3D;11 only
		// Must access selectedIndex to make default options select
		support.optSelected &#x3D; opt.selected;

		// Support: IE &lt;&#x3D;11 only
		// An input loses its value after becoming a radio
		input &#x3D; document.createElement( &quot;input&quot; );
		input.value &#x3D; &quot;t&quot;;
		input.type &#x3D; &quot;radio&quot;;
		support.radioValue &#x3D; input.value &#x3D;&#x3D;&#x3D; &quot;t&quot;;
	} )();


	var boolHook,
		attrHandle &#x3D; jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType &#x3D; elem.nodeType;

			// Don&#x27;t get/set attributes on text, comment and attribute nodes
			if ( nType &#x3D;&#x3D;&#x3D; 3 || nType &#x3D;&#x3D;&#x3D; 8 || nType &#x3D;&#x3D;&#x3D; 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute &#x3D;&#x3D;&#x3D; &quot;undefined&quot; ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !&#x3D;&#x3D; 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks &#x3D; jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !&#x3D;&#x3D; undefined ) {
				if ( value &#x3D;&#x3D;&#x3D; null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
					( ret &#x3D; hooks.set( elem, value, name ) ) !&#x3D;&#x3D; undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + &quot;&quot; );
				return value;
			}

			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret &#x3D; hooks.get( elem, name ) ) !&#x3D;&#x3D; null ) {
				return ret;
			}

			ret &#x3D; jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret &#x3D;&#x3D; null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue &amp;&amp; value &#x3D;&#x3D;&#x3D; &quot;radio&quot; &amp;&amp;
						nodeName( elem, &quot;input&quot; ) ) {
						var val &#x3D; elem.value;
						elem.setAttribute( &quot;type&quot;, value );
						if ( val ) {
							elem.value &#x3D; val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i &#x3D; 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames &#x3D; value &amp;&amp; value.match( rnothtmlwhite );

			if ( attrNames &amp;&amp; elem.nodeType &#x3D;&#x3D;&#x3D; 1 ) {
				while ( ( name &#x3D; attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook &#x3D; {
		set: function( elem, value, name ) {
			if ( value &#x3D;&#x3D;&#x3D; false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter &#x3D; attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] &#x3D; function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName &#x3D; name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle &#x3D; attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] &#x3D; ret;
				ret &#x3D; getter( elem, name, isXML ) !&#x3D; null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] &#x3D; handle;
			}
			return ret;
		};
	} );




	var rfocusable &#x3D; /^(?:input|select|textarea|button)$/i,
		rclickable &#x3D; /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType &#x3D; elem.nodeType;

			// Don&#x27;t get/set properties on text, comment and attribute nodes
			if ( nType &#x3D;&#x3D;&#x3D; 3 || nType &#x3D;&#x3D;&#x3D; 8 || nType &#x3D;&#x3D;&#x3D; 2 ) {
				return;
			}

			if ( nType !&#x3D;&#x3D; 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name &#x3D; jQuery.propFix[ name ] || name;
				hooks &#x3D; jQuery.propHooks[ name ];
			}

			if ( value !&#x3D;&#x3D; undefined ) {
				if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
					( ret &#x3D; hooks.set( elem, value, name ) ) !&#x3D;&#x3D; undefined ) {
					return ret;
				}

				return ( elem[ name ] &#x3D; value );
			}

			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret &#x3D; hooks.get( elem, name ) ) !&#x3D;&#x3D; null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE &lt;&#x3D;9 - 11 only
					// elem.tabIndex doesn&#x27;t always return the
					// correct value when it hasn&#x27;t been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex &#x3D; jQuery.find.attr( elem, &quot;tabindex&quot; );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &amp;&amp;
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			&quot;for&quot;: &quot;htmlFor&quot;,
			&quot;class&quot;: &quot;className&quot;
		}
	} );

	// Support: IE &lt;&#x3D;11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule &quot;no-unused-expressions&quot; is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected &#x3D; {
			get: function( elem ) {

				/* eslint no-unused-expressions: &quot;off&quot; */

				var parent &#x3D; elem.parentNode;
				if ( parent &amp;&amp; parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: &quot;off&quot; */

				var parent &#x3D; elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		&quot;tabIndex&quot;,
		&quot;readOnly&quot;,
		&quot;maxLength&quot;,
		&quot;cellSpacing&quot;,
		&quot;cellPadding&quot;,
		&quot;rowSpan&quot;,
		&quot;colSpan&quot;,
		&quot;useMap&quot;,
		&quot;frameBorder&quot;,
		&quot;contentEditable&quot;
	], function() {
		jQuery.propFix[ this.toLowerCase() ] &#x3D; this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens &#x3D; value.match( rnothtmlwhite ) || [];
			return tokens.join( &quot; &quot; );
		}


	function getClass( elem ) {
		return elem.getAttribute &amp;&amp; elem.getAttribute( &quot;class&quot; ) || &quot;&quot;;
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i &#x3D; 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes &#x3D; classesToArray( value );

			if ( classes.length ) {
				while ( ( elem &#x3D; this[ i++ ] ) ) {
					curValue &#x3D; getClass( elem );
					cur &#x3D; elem.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );

					if ( cur ) {
						j &#x3D; 0;
						while ( ( clazz &#x3D; classes[ j++ ] ) ) {
							if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) {
								cur +&#x3D; clazz + &quot; &quot;;
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue &#x3D; stripAndCollapse( cur );
						if ( curValue !&#x3D;&#x3D; finalValue ) {
							elem.setAttribute( &quot;class&quot;, finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i &#x3D; 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( &quot;class&quot;, &quot;&quot; );
			}

			classes &#x3D; classesToArray( value );

			if ( classes.length ) {
				while ( ( elem &#x3D; this[ i++ ] ) ) {
					curValue &#x3D; getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur &#x3D; elem.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );

					if ( cur ) {
						j &#x3D; 0;
						while ( ( clazz &#x3D; classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt; -1 ) {
								cur &#x3D; cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue &#x3D; stripAndCollapse( cur );
						if ( curValue !&#x3D;&#x3D; finalValue ) {
							elem.setAttribute( &quot;class&quot;, finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type &#x3D; typeof value,
				isValidValue &#x3D; type &#x3D;&#x3D;&#x3D; &quot;string&quot; || Array.isArray( value );

			if ( typeof stateVal &#x3D;&#x3D;&#x3D; &quot;boolean&quot; &amp;&amp; isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i &#x3D; 0;
					self &#x3D; jQuery( this );
					classNames &#x3D; classesToArray( value );

					while ( ( className &#x3D; classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value &#x3D;&#x3D;&#x3D; undefined || type &#x3D;&#x3D;&#x3D; &quot;boolean&quot; ) {
					className &#x3D; getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, &quot;__className__&quot;, className );
					}

					// If the element has a class name or if we&#x27;re passed &#x60;false&#x60;,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( &quot;class&quot;,
							className || value &#x3D;&#x3D;&#x3D; false ?
							&quot;&quot; :
							dataPriv.get( this, &quot;__className__&quot; ) || &quot;&quot;
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i &#x3D; 0;

			className &#x3D; &quot; &quot; + selector + &quot; &quot;;
			while ( ( elem &#x3D; this[ i++ ] ) ) {
				if ( elem.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp;
					( &quot; &quot; + stripAndCollapse( getClass( elem ) ) + &quot; &quot; ).indexOf( className ) &gt; -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn &#x3D; /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem &#x3D; this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks &#x3D; jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &amp;&amp;
						&quot;get&quot; in hooks &amp;&amp;
						( ret &#x3D; hooks.get( elem, &quot;value&quot; ) ) !&#x3D;&#x3D; undefined
					) {
						return ret;
					}

					ret &#x3D; elem.value;

					// Handle most common string cases
					if ( typeof ret &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
						return ret.replace( rreturn, &quot;&quot; );
					}

					// Handle cases where value is null/undef or number
					return ret &#x3D;&#x3D; null ? &quot;&quot; : ret;
				}

				return;
			}

			valueIsFunction &#x3D; isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !&#x3D;&#x3D; 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val &#x3D; value.call( this, i, jQuery( this ).val() );
				} else {
					val &#x3D; value;
				}

				// Treat null/undefined as &quot;&quot;; convert numbers to string
				if ( val &#x3D;&#x3D; null ) {
					val &#x3D; &quot;&quot;;

				} else if ( typeof val &#x3D;&#x3D;&#x3D; &quot;number&quot; ) {
					val +&#x3D; &quot;&quot;;

				} else if ( Array.isArray( val ) ) {
					val &#x3D; jQuery.map( val, function( value ) {
						return value &#x3D;&#x3D; null ? &quot;&quot; : value + &quot;&quot;;
					} );
				}

				hooks &#x3D; jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( &quot;set&quot; in hooks ) || hooks.set( this, val, &quot;value&quot; ) &#x3D;&#x3D;&#x3D; undefined ) {
					this.value &#x3D; val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val &#x3D; jQuery.find.attr( elem, &quot;value&quot; );
					return val !&#x3D; null ?
						val :

						// Support: IE &lt;&#x3D;10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options &#x3D; elem.options,
						index &#x3D; elem.selectedIndex,
						one &#x3D; elem.type &#x3D;&#x3D;&#x3D; &quot;select-one&quot;,
						values &#x3D; one ? null : [],
						max &#x3D; one ? index + 1 : options.length;

					if ( index &lt; 0 ) {
						i &#x3D; max;

					} else {
						i &#x3D; one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i &lt; max; i++ ) {
						option &#x3D; options[ i ];

						// Support: IE &lt;&#x3D;9 only
						// IE8-9 doesn&#x27;t update selected after form reset (#2551)
						if ( ( option.selected || i &#x3D;&#x3D;&#x3D; index ) &amp;&amp;

								// Don&#x27;t return options that are disabled or in a disabled optgroup
								!option.disabled &amp;&amp;
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {

							// Get the specific value for the option
							value &#x3D; jQuery( option ).val();

							// We don&#x27;t need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options &#x3D; elem.options,
						values &#x3D; jQuery.makeArray( value ),
						i &#x3D; options.length;

					while ( i-- ) {
						option &#x3D; options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected &#x3D;
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt; -1
						) {
							optionSet &#x3D; true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex &#x3D; -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
		jQuery.valHooks[ this ] &#x3D; {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked &#x3D; jQuery.inArray( jQuery( elem ).val(), value ) &gt; -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get &#x3D; function( elem ) {
				return elem.getAttribute( &quot;value&quot; ) &#x3D;&#x3D;&#x3D; null ? &quot;on&quot; : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin &#x3D; &quot;onfocusin&quot; in window;


	var rfocusMorph &#x3D; /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback &#x3D; function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath &#x3D; [ elem || document ],
				type &#x3D; hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
				namespaces &#x3D; hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split( &quot;.&quot; ) : [];

			cur &#x3D; lastElement &#x3D; tmp &#x3D; elem &#x3D; elem || document;

			// Don&#x27;t do events on text and comment nodes
			if ( elem.nodeType &#x3D;&#x3D;&#x3D; 3 || elem.nodeType &#x3D;&#x3D;&#x3D; 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we&#x27;re not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( &quot;.&quot; ) &gt; -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces &#x3D; type.split( &quot;.&quot; );
				type &#x3D; namespaces.shift();
				namespaces.sort();
			}
			ontype &#x3D; type.indexOf( &quot;:&quot; ) &lt; 0 &amp;&amp; &quot;on&quot; + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event &#x3D; event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; event );

			// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
			event.isTrigger &#x3D; onlyHandlers ? 2 : 3;
			event.namespace &#x3D; namespaces.join( &quot;.&quot; );
			event.rnamespace &#x3D; event.namespace ?
				new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; ) :
				null;

			// Clean up the event in case it is being reused
			event.result &#x3D; undefined;
			if ( !event.target ) {
				event.target &#x3D; elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data &#x3D; data &#x3D;&#x3D; null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special &#x3D; jQuery.event.special[ type ] || {};
			if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) &#x3D;&#x3D;&#x3D; false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !isWindow( elem ) ) {

				bubbleType &#x3D; special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur &#x3D; cur.parentNode;
				}
				for ( ; cur; cur &#x3D; cur.parentNode ) {
					eventPath.push( cur );
					tmp &#x3D; cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp &#x3D;&#x3D;&#x3D; ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i &#x3D; 0;
			while ( ( cur &#x3D; eventPath[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
				lastElement &#x3D; cur;
				event.type &#x3D; i &gt; 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle &#x3D; ( dataPriv.get( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp;
					dataPriv.get( cur, &quot;handle&quot; );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle &#x3D; ontype &amp;&amp; cur[ ontype ];
				if ( handle &amp;&amp; handle.apply &amp;&amp; acceptData( cur ) ) {
					event.result &#x3D; handle.apply( cur, data );
					if ( event.result &#x3D;&#x3D;&#x3D; false ) {
						event.preventDefault();
					}
				}
			}
			event.type &#x3D; type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) &#x3D;&#x3D;&#x3D; false ) &amp;&amp;
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don&#x27;t do default actions on window, that&#x27;s where global variables be (#6170)
					if ( ontype &amp;&amp; isFunction( elem[ type ] ) &amp;&amp; !isWindow( elem ) ) {

						// Don&#x27;t re-trigger an onFOO event when we call its FOO() method
						tmp &#x3D; elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] &#x3D; null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered &#x3D; type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered &#x3D; undefined;

						if ( tmp ) {
							elem[ ontype ] &#x3D; tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for &#x60;focus(in | out)&#x60; events
		simulate: function( type, elem, event ) {
			var e &#x3D; jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem &#x3D; this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox &lt;&#x3D;44
	// Firefox doesn&#x27;t have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id&#x3D;687787
	//
	// Support: Chrome &lt;&#x3D;48 - 49, Safari &lt;&#x3D;9.0 - 9.1
	// focus(in | out) events fire after focus &amp; blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id&#x3D;449857
	if ( !support.focusin ) {
		jQuery.each( { focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler &#x3D; function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] &#x3D; {
				setup: function() {
					var doc &#x3D; this.ownerDocument || this,
						attaches &#x3D; dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc &#x3D; this.ownerDocument || this,
						attaches &#x3D; dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location &#x3D; window.location;

	var nonce &#x3D; Date.now();

	var rquery &#x3D; ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML &#x3D; function( data ) {
		var xml;
		if ( !data || typeof data !&#x3D;&#x3D; &quot;string&quot; ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml &#x3D; ( new window.DOMParser() ).parseFromString( data, &quot;text/xml&quot; );
		} catch ( e ) {
			xml &#x3D; undefined;
		}

		if ( !xml || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
			jQuery.error( &quot;Invalid XML: &quot; + data );
		}
		return xml;
	};


	var
		rbracket &#x3D; /\[\]$/,
		rCRLF &#x3D; /\r?\n/g,
		rsubmitterTypes &#x3D; /^(?:submit|button|image|reset|file)$/i,
		rsubmittable &#x3D; /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + &quot;[&quot; + ( typeof v &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; v !&#x3D; null ? i : &quot;&quot; ) + &quot;]&quot;,
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional &amp;&amp; toType( obj ) &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param &#x3D; function( a, traditional ) {
		var prefix,
			s &#x3D; [],
			add &#x3D; function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value &#x3D; isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] &#x3D; encodeURIComponent( key ) + &quot;&#x3D;&quot; +
					encodeURIComponent( value &#x3D;&#x3D; null ? &quot;&quot; : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( &quot;&amp;&quot; );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for &quot;elements&quot; to filter or add form elements
				var elements &#x3D; jQuery.prop( this, &quot;elements&quot; );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type &#x3D; this.type;

				// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works
				return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
					rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val &#x3D; jQuery( this ).val();

				if ( val &#x3D;&#x3D; null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
			} ).get();
		}
	} );


	var
		r20 &#x3D; /%20/g,
		rhash &#x3D; /#.*$/,
		rantiCache &#x3D; /([?&amp;])_&#x3D;[^&amp;]*/,
		rheaders &#x3D; /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol &#x3D; /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent &#x3D; /^(?:GET|HEAD)$/,
		rprotocol &#x3D; /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol &quot;*&quot; can be used
		 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
		 */
		prefilters &#x3D; {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol &quot;*&quot; can be used
		 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
		 */
		transports &#x3D; {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes &#x3D; &quot;*/&quot;.concat( &quot;*&quot; ),

		// Anchor tag for parsing the document origin
		originAnchor &#x3D; document.createElement( &quot;a&quot; );
		originAnchor.href &#x3D; location.href;

	// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to &quot;*&quot;
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !&#x3D;&#x3D; &quot;string&quot; ) {
				func &#x3D; dataTypeExpression;
				dataTypeExpression &#x3D; &quot;*&quot;;
			}

			var dataType,
				i &#x3D; 0,
				dataTypes &#x3D; dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType &#x3D; dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] &#x3D;&#x3D;&#x3D; &quot;+&quot; ) {
						dataType &#x3D; dataType.slice( 1 ) || &quot;*&quot;;
						( structure[ dataType ] &#x3D; structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] &#x3D; structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected &#x3D; {},
			seekingTransport &#x3D; ( structure &#x3D;&#x3D;&#x3D; transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] &#x3D; true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport &#x3D; prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport &#x3D;&#x3D;&#x3D; &quot;string&quot; &amp;&amp;
					!seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected &#x3D; dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );
	}

	// A special extend for ajax options
	// that takes &quot;flat&quot; options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions &#x3D; jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !&#x3D;&#x3D; undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep &#x3D; {} ) ) )[ key ] &#x3D; src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents &#x3D; s.contents,
			dataTypes &#x3D; s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] &#x3D;&#x3D;&#x3D; &quot;*&quot; ) {
			dataTypes.shift();
			if ( ct &#x3D;&#x3D;&#x3D; undefined ) {
				ct &#x3D; s.mimeType || jqXHR.getResponseHeader( &quot;Content-Type&quot; );
			}
		}

		// Check if we&#x27;re dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType &#x3D; dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[ 0 ] ] ) {
					finalDataType &#x3D; type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType &#x3D; type;
				}
			}

			// Or just use first one
			finalDataType &#x3D; finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !&#x3D;&#x3D; dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters &#x3D; {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes &#x3D; s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] &#x3D; s.converters[ conv ];
			}
		}

		current &#x3D; dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] &#x3D; response;
			}

			// Apply the dataFilter if provided
			if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
				response &#x3D; s.dataFilter( response, s.dataType );
			}

			prev &#x3D; current;
			current &#x3D; dataTypes.shift();

			if ( current ) {

				// There&#x27;s only work to do if current dataType is non-auto
				if ( current &#x3D;&#x3D;&#x3D; &quot;*&quot; ) {

					current &#x3D; prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !&#x3D;&#x3D; &quot;*&quot; &amp;&amp; prev !&#x3D;&#x3D; current ) {

					// Seek a direct converter
					conv &#x3D; converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp &#x3D; conv2.split( &quot; &quot; );
							if ( tmp[ 1 ] &#x3D;&#x3D;&#x3D; current ) {

								// If prev can be converted to accepted input
								conv &#x3D; converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
									converters[ &quot;* &quot; + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv &#x3D;&#x3D;&#x3D; true ) {
										conv &#x3D; converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !&#x3D;&#x3D; true ) {
										current &#x3D; tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !&#x3D;&#x3D; true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv &amp;&amp; s.throws ) {
							response &#x3D; conv( response );
						} else {
							try {
								response &#x3D; conv( response );
							} catch ( e ) {
								return {
									state: &quot;parsererror&quot;,
									error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current
								};
							}
						}
					}
				}
			}
		}

		return { state: &quot;success&quot;, data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: &quot;GET&quot;,
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: &quot;application/x-www-form-urlencoded; charset&#x3D;UTF-8&quot;,

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				&quot;*&quot;: allTypes,
				text: &quot;text/plain&quot;,
				html: &quot;text/html&quot;,
				xml: &quot;application/xml, text/xml&quot;,
				json: &quot;application/json, text/javascript&quot;
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: &quot;responseXML&quot;,
				text: &quot;responseText&quot;,
				json: &quot;responseJSON&quot;
			},

			// Data converters
			// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
			converters: {

				// Convert anything to text
				&quot;* text&quot;: String,

				// Text to html (true &#x3D; no transformation)
				&quot;text html&quot;: true,

				// Evaluate text as a json expression
				&quot;text json&quot;: JSON.parse,

				// Parse text as xml
				&quot;text xml&quot;: jQuery.parseXML
			},

			// For options that shouldn&#x27;t be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn&#x27;t be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {
				options &#x3D; url;
				url &#x3D; undefined;
			}

			// Force options to be an object
			options &#x3D; options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s &#x3D; jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext &#x3D; s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext &#x3D; s.context &amp;&amp;
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred &#x3D; jQuery.Deferred(),
				completeDeferred &#x3D; jQuery.Callbacks( &quot;once memory&quot; ),

				// Status-dependent callbacks
				statusCode &#x3D; s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders &#x3D; {},
				requestHeadersNames &#x3D; {},

				// Default abort message
				strAbort &#x3D; &quot;canceled&quot;,

				// Fake xhr
				jqXHR &#x3D; {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders &#x3D; {};
								while ( ( match &#x3D; rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] &#x3D; match[ 2 ];
								}
							}
							match &#x3D; responseHeaders[ key.toLowerCase() ];
						}
						return match &#x3D;&#x3D; null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed &#x3D;&#x3D; null ) {
							name &#x3D; requestHeadersNames[ name.toLowerCase() ] &#x3D;
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] &#x3D; value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed &#x3D;&#x3D; null ) {
							s.mimeType &#x3D; type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] &#x3D; [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText &#x3D; statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url &#x3D; ( ( url || s.url || location.href ) + &quot;&quot; )
				.replace( rprotocol, location.protocol + &quot;//&quot; );

			// Alias method option to type as per ticket #12004
			s.type &#x3D; options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes &#x3D; ( s.dataType || &quot;*&quot; ).toLowerCase().match( rnothtmlwhite ) || [ &quot;&quot; ];

			// A cross-domain request is in order when the origin doesn&#x27;t match the current origin.
			if ( s.crossDomain &#x3D;&#x3D; null ) {
				urlAnchor &#x3D; document.createElement( &quot;a&quot; );

				// Support: IE &lt;&#x3D;8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href &#x3D; s.url;

					// Support: IE &lt;&#x3D;8 - 11 only
					// Anchor&#x27;s host property isn&#x27;t correctly set when s.url is relative
					urlAnchor.href &#x3D; urlAnchor.href;
					s.crossDomain &#x3D; originAnchor.protocol + &quot;//&quot; + originAnchor.host !&#x3D;&#x3D;
						urlAnchor.protocol + &quot;//&quot; + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain &#x3D; true;
				}
			}

			// Convert data if not already a string
			if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !&#x3D;&#x3D; &quot;string&quot; ) {
				s.data &#x3D; jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don&#x27;t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals &#x3D; jQuery.event &amp;&amp; s.global;

			// Watch for a new set of requests
			if ( fireGlobals &amp;&amp; jQuery.active++ &#x3D;&#x3D;&#x3D; 0 ) {
				jQuery.event.trigger( &quot;ajaxStart&quot; );
			}

			// Uppercase the type
			s.type &#x3D; s.type.toUpperCase();

			// Determine if request has content
			s.hasContent &#x3D; !rnoContent.test( s.type );

			// Save the URL in case we&#x27;re toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL &#x3D; s.url.replace( rhash, &quot;&quot; );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached &#x3D; s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data &amp;&amp; ( s.processData || typeof s.data &#x3D;&#x3D;&#x3D; &quot;string&quot; ) ) {
					cacheURL +&#x3D; ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data;

					// #9682: remove data so that it&#x27;s not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache &#x3D;&#x3D;&#x3D; false ) {
					cacheURL &#x3D; cacheURL.replace( rantiCache, &quot;$1&quot; );
					uncached &#x3D; ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_&#x3D;&quot; + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url &#x3D; cacheURL + uncached;

			// Change &#x27;%20&#x27; to &#x27;+&#x27; if this is encoded form body content (gh-2658)
			} else if ( s.data &amp;&amp; s.processData &amp;&amp;
				( s.contentType || &quot;&quot; ).indexOf( &quot;application/x-www-form-urlencoded&quot; ) &#x3D;&#x3D;&#x3D; 0 ) {
				s.data &#x3D; s.data.replace( r20, &quot;+&quot; );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !&#x3D;&#x3D; false || options.contentType ) {
				jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				&quot;Accept&quot;,
				s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !&#x3D;&#x3D; &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q&#x3D;0.01&quot; : &quot;&quot; ) :
					s.accepts[ &quot;*&quot; ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &amp;&amp;
				( s.beforeSend.call( callbackContext, jqXHR, s ) &#x3D;&#x3D;&#x3D; false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort &#x3D; &quot;abort&quot;;

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport &#x3D; inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, &quot;No Transport&quot; );
			} else {
				jqXHR.readyState &#x3D; 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
					timeoutTimer &#x3D; window.setTimeout( function() {
						jqXHR.abort( &quot;timeout&quot; );
					}, s.timeout );
				}

				try {
					completed &#x3D; false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText &#x3D; nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed &#x3D; true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport &#x3D; undefined;

				// Cache response headers
				responseHeadersString &#x3D; headers || &quot;&quot;;

				// Set readyState
				jqXHR.readyState &#x3D; status &gt; 0 ? 4 : 0;

				// Determine if successful
				isSuccess &#x3D; status &gt;&#x3D; 200 &amp;&amp; status &lt; 300 || status &#x3D;&#x3D;&#x3D; 304;

				// Get response data
				if ( responses ) {
					response &#x3D; ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response &#x3D; ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified &#x3D; jqXHR.getResponseHeader( &quot;Last-Modified&quot; );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] &#x3D; modified;
						}
						modified &#x3D; jqXHR.getResponseHeader( &quot;etag&quot; );
						if ( modified ) {
							jQuery.etag[ cacheURL ] &#x3D; modified;
						}
					}

					// if no content
					if ( status &#x3D;&#x3D;&#x3D; 204 || s.type &#x3D;&#x3D;&#x3D; &quot;HEAD&quot; ) {
						statusText &#x3D; &quot;nocontent&quot;;

					// if not modified
					} else if ( status &#x3D;&#x3D;&#x3D; 304 ) {
						statusText &#x3D; &quot;notmodified&quot;;

					// If we have data, let&#x27;s convert it
					} else {
						statusText &#x3D; response.state;
						success &#x3D; response.data;
						error &#x3D; response.error;
						isSuccess &#x3D; !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error &#x3D; statusText;
					if ( status || !statusText ) {
						statusText &#x3D; &quot;error&quot;;
						if ( status &lt; 0 ) {
							status &#x3D; 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status &#x3D; status;
				jqXHR.statusText &#x3D; ( nativeStatusText || statusText ) + &quot;&quot;;

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode &#x3D; undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( &quot;ajaxStop&quot; );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, &quot;json&quot; );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, &quot;script&quot; );
		}
	} );

	jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
		jQuery[ method ] &#x3D; function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type &#x3D; type || callback;
				callback &#x3D; data;
				data &#x3D; undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) &amp;&amp; url ) );
		};
	} );


	jQuery._evalUrl &#x3D; function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: &quot;GET&quot;,
			dataType: &quot;script&quot;,
			cache: true,
			async: false,
			global: false,
			&quot;throws&quot;: true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html &#x3D; html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap &#x3D; jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem &#x3D; this;

					while ( elem.firstElementChild ) {
						elem &#x3D; elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self &#x3D; jQuery( this ),
					contents &#x3D; self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction &#x3D; isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( &quot;body&quot; ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden &#x3D; function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible &#x3D; function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr &#x3D; function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus &#x3D; {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE &lt;&#x3D;9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported &#x3D; jQuery.ajaxSettings.xhr();

	support.cors &#x3D; !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported );
	support.ajax &#x3D; xhrSupported &#x3D; !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr &#x3D; options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] &#x3D; options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won&#x27;t change header if already provided.
					if ( !options.crossDomain &amp;&amp; !headers[ &quot;X-Requested-With&quot; ] ) {
						headers[ &quot;X-Requested-With&quot; ] &#x3D; &quot;XMLHttpRequest&quot;;
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback &#x3D; function( type ) {
						return function() {
							if ( callback ) {
								callback &#x3D; errorCallback &#x3D; xhr.onload &#x3D;
									xhr.onerror &#x3D; xhr.onabort &#x3D; xhr.ontimeout &#x3D;
										xhr.onreadystatechange &#x3D; null;

								if ( type &#x3D;&#x3D;&#x3D; &quot;abort&quot; ) {
									xhr.abort();
								} else if ( type &#x3D;&#x3D;&#x3D; &quot;error&quot; ) {

									// Support: IE &lt;&#x3D;9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !&#x3D;&#x3D; &quot;number&quot; ) {
										complete( 0, &quot;error&quot; );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE &lt;&#x3D;9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || &quot;text&quot; ) !&#x3D;&#x3D; &quot;text&quot;  ||
										typeof xhr.responseText !&#x3D;&#x3D; &quot;string&quot; ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload &#x3D; callback();
					errorCallback &#x3D; xhr.onerror &#x3D; xhr.ontimeout &#x3D; callback( &quot;error&quot; );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !&#x3D;&#x3D; undefined ) {
						xhr.onabort &#x3D; errorCallback;
					} else {
						xhr.onreadystatechange &#x3D; function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState &#x3D;&#x3D;&#x3D; 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback &#x3D; callback( &quot;abort&quot; );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent &amp;&amp; options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn&#x27;t been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script &#x3D; false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: &quot;text/javascript, application/javascript, &quot; +
				&quot;application/ecmascript, application/x-ecmascript&quot;
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			&quot;text script&quot;: function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache&#x27;s special case and crossDomain
	jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
		if ( s.cache &#x3D;&#x3D;&#x3D; undefined ) {
			s.cache &#x3D; false;
		}
		if ( s.crossDomain ) {
			s.type &#x3D; &quot;GET&quot;;
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( &quot;script&quot;, function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script &#x3D; jQuery( &quot;&lt;script&gt;&quot; ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						&quot;load error&quot;,
						callback &#x3D; function( evt ) {
							script.remove();
							callback &#x3D; null;
							if ( evt ) {
								complete( evt.type &#x3D;&#x3D;&#x3D; &quot;error&quot; ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks &#x3D; [],
		rjsonp &#x3D; /(&#x3D;)\?(?&#x3D;&amp;|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: &quot;callback&quot;,
		jsonpCallback: function() {
			var callback &#x3D; oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
			this[ callback ] &#x3D; true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp &#x3D; s.jsonp !&#x3D;&#x3D; false &amp;&amp; ( rjsonp.test( s.url ) ?
				&quot;url&quot; :
				typeof s.data &#x3D;&#x3D;&#x3D; &quot;string&quot; &amp;&amp;
					( s.contentType || &quot;&quot; )
						.indexOf( &quot;application/x-www-form-urlencoded&quot; ) &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
					rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
			);

		// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] &#x3D;&#x3D;&#x3D; &quot;jsonp&quot; ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName &#x3D; s.jsonpCallback &#x3D; isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] &#x3D; s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
			} else if ( s.jsonp !&#x3D;&#x3D; false ) {
				s.url +&#x3D; ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;&#x3D;&quot; + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ &quot;script json&quot; ] &#x3D; function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + &quot; was not called&quot; );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] &#x3D; &quot;json&quot;;

			// Install callback
			overwritten &#x3D; window[ callbackName ];
			window[ callbackName ] &#x3D; function() {
				responseContainer &#x3D; arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn&#x27;t exist - remove it
				if ( overwritten &#x3D;&#x3D;&#x3D; undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] &#x3D; overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn&#x27;t screw things around
					s.jsonpCallback &#x3D; originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer &amp;&amp; isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer &#x3D; overwritten &#x3D; undefined;
			} );

			// Delegate to script
			return &quot;script&quot;;
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id&#x3D;137337
	support.createHTMLDocument &#x3D; ( function() {
		var body &#x3D; document.implementation.createHTMLDocument( &quot;&quot; ).body;
		body.innerHTML &#x3D; &quot;&lt;form&gt;&lt;/form&gt;&lt;form&gt;&lt;/form&gt;&quot;;
		return body.childNodes.length &#x3D;&#x3D;&#x3D; 2;
	} )();


	// Argument &quot;data&quot; should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML &#x3D; function( data, context, keepScripts ) {
		if ( typeof data !&#x3D;&#x3D; &quot;string&quot; ) {
			return [];
		}
		if ( typeof context &#x3D;&#x3D;&#x3D; &quot;boolean&quot; ) {
			keepScripts &#x3D; context;
			context &#x3D; false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context &#x3D; document.implementation.createHTMLDocument( &quot;&quot; );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document&#x27;s URL (gh-2965)
				base &#x3D; context.createElement( &quot;base&quot; );
				base.href &#x3D; document.location.href;
				context.head.appendChild( base );
			} else {
				context &#x3D; document;
			}
		}

		parsed &#x3D; rsingleTag.exec( data );
		scripts &#x3D; !keepScripts &amp;&amp; [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed &#x3D; buildFragment( [ data ], context, scripts );

		if ( scripts &amp;&amp; scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load &#x3D; function( url, params, callback ) {
		var selector, type, response,
			self &#x3D; this,
			off &#x3D; url.indexOf( &quot; &quot; );

		if ( off &gt; -1 ) {
			selector &#x3D; stripAndCollapse( url.slice( off ) );
			url &#x3D; url.slice( 0, off );
		}

		// If it&#x27;s a function
		if ( isFunction( params ) ) {

			// We assume that it&#x27;s the callback
			callback &#x3D; params;
			params &#x3D; undefined;

		// Otherwise, build a param string
		} else if ( params &amp;&amp; typeof params &#x3D;&#x3D;&#x3D; &quot;object&quot; ) {
			type &#x3D; &quot;POST&quot;;
		}

		// If we have elements to modify, make the request
		if ( self.length &gt; 0 ) {
			jQuery.ajax( {
				url: url,

				// If &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || &quot;GET&quot;,
				dataType: &quot;html&quot;,
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response &#x3D; arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE &#x27;Permission Denied&#x27; errors
					jQuery( &quot;&lt;div&gt;&quot; ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets &quot;data&quot;, &quot;status&quot;, &quot;jqXHR&quot;
			// but they are ignored because response was set above.
			// If it fails, this function gets &quot;jqXHR&quot;, &quot;status&quot;, &quot;error&quot;
			} ).always( callback &amp;&amp; function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		&quot;ajaxStart&quot;,
		&quot;ajaxStop&quot;,
		&quot;ajaxComplete&quot;,
		&quot;ajaxError&quot;,
		&quot;ajaxSuccess&quot;,
		&quot;ajaxSend&quot;
	], function( i, type ) {
		jQuery.fn[ type ] &#x3D; function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated &#x3D; function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem &#x3D;&#x3D;&#x3D; fn.elem;
		} ).length;
	};




	jQuery.offset &#x3D; {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position &#x3D; jQuery.css( elem, &quot;position&quot; ),
				curElem &#x3D; jQuery( elem ),
				props &#x3D; {};

			// Set position first, in-case top/left are set even on static elem
			if ( position &#x3D;&#x3D;&#x3D; &quot;static&quot; ) {
				elem.style.position &#x3D; &quot;relative&quot;;
			}

			curOffset &#x3D; curElem.offset();
			curCSSTop &#x3D; jQuery.css( elem, &quot;top&quot; );
			curCSSLeft &#x3D; jQuery.css( elem, &quot;left&quot; );
			calculatePosition &#x3D; ( position &#x3D;&#x3D;&#x3D; &quot;absolute&quot; || position &#x3D;&#x3D;&#x3D; &quot;fixed&quot; ) &amp;&amp;
				( curCSSTop + curCSSLeft ).indexOf( &quot;auto&quot; ) &gt; -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition &#x3D; curElem.position();
				curTop &#x3D; curPosition.top;
				curLeft &#x3D; curPosition.left;

			} else {
				curTop &#x3D; parseFloat( curCSSTop ) || 0;
				curLeft &#x3D; parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options &#x3D; options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top !&#x3D; null ) {
				props.top &#x3D; ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left !&#x3D; null ) {
				props.left &#x3D; ( options.left - curOffset.left ) + curLeft;
			}

			if ( &quot;using&quot; in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element&#x27;s border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options &#x3D;&#x3D;&#x3D; undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem &#x3D; this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE &lt;&#x3D;11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect &#x3D; elem.getBoundingClientRect();
			win &#x3D; elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element&#x27;s margin box to its offset parent&#x27;s padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem &#x3D; this[ 0 ],
				parentOffset &#x3D; { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, &quot;position&quot; ) &#x3D;&#x3D;&#x3D; &quot;fixed&quot; ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset &#x3D; elem.getBoundingClientRect();

			} else {
				offset &#x3D; this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc &#x3D; elem.ownerDocument;
				offsetParent &#x3D; elem.offsetParent || doc.documentElement;
				while ( offsetParent &amp;&amp;
					( offsetParent &#x3D;&#x3D;&#x3D; doc.body || offsetParent &#x3D;&#x3D;&#x3D; doc.documentElement ) &amp;&amp;
					jQuery.css( offsetParent, &quot;position&quot; ) &#x3D;&#x3D;&#x3D; &quot;static&quot; ) {

					offsetParent &#x3D; offsetParent.parentNode;
				}
				if ( offsetParent &amp;&amp; offsetParent !&#x3D;&#x3D; elem &amp;&amp; offsetParent.nodeType &#x3D;&#x3D;&#x3D; 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset &#x3D; jQuery( offsetParent ).offset();
					parentOffset.top +&#x3D; jQuery.css( offsetParent, &quot;borderTopWidth&quot;, true );
					parentOffset.left +&#x3D; jQuery.css( offsetParent, &quot;borderLeftWidth&quot;, true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent &#x3D; this.offsetParent;

				while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) &#x3D;&#x3D;&#x3D; &quot;static&quot; ) {
					offsetParent &#x3D; offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot; }, function( method, prop ) {
		var top &#x3D; &quot;pageYOffset&quot; &#x3D;&#x3D;&#x3D; prop;

		jQuery.fn[ method ] &#x3D; function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win &#x3D; elem;
				} else if ( elem.nodeType &#x3D;&#x3D;&#x3D; 9 ) {
					win &#x3D; elem.defaultView;
				}

				if ( val &#x3D;&#x3D;&#x3D; undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] &#x3D; val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari &lt;&#x3D;7 - 9.1, Chrome &lt;&#x3D;37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id&#x3D;29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id&#x3D;589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
		jQuery.cssHooks[ prop ] &#x3D; addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed &#x3D; curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + &quot;px&quot; :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
		jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] &#x3D; function( margin, value ) {
				var chainable &#x3D; arguments.length &amp;&amp; ( defaultExtra || typeof margin !&#x3D;&#x3D; &quot;boolean&quot; ),
					extra &#x3D; defaultExtra || ( margin &#x3D;&#x3D;&#x3D; true || value &#x3D;&#x3D;&#x3D; true ? &quot;margin&quot; : &quot;border&quot; );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( &quot;outer&quot; ) &#x3D;&#x3D;&#x3D; 0 ?
							elem[ &quot;inner&quot; + name ] :
							elem.document.documentElement[ &quot;client&quot; + name ];
					}

					// Get document width or height
					if ( elem.nodeType &#x3D;&#x3D;&#x3D; 9 ) {
						doc &#x3D; elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
							elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
							doc[ &quot;client&quot; + name ]
						);
					}

					return value &#x3D;&#x3D;&#x3D; undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( &quot;blur focus focusin focusout resize scroll click dblclick &quot; +
		&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
		&quot;change select submit keydown keypress keyup contextmenu&quot; ).split( &quot; &quot; ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] &#x3D; function( data, fn ) {
			return arguments.length &gt; 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length &#x3D;&#x3D;&#x3D; 1 ?
				this.off( selector, &quot;**&quot; ) :
				this.off( types, selector || &quot;**&quot;, fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy &#x3D; function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context &#x3D;&#x3D;&#x3D; &quot;string&quot; ) {
			tmp &#x3D; fn[ context ];
			context &#x3D; fn;
			fn &#x3D; tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args &#x3D; slice.call( arguments, 2 );
		proxy &#x3D; function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid &#x3D; fn.guid &#x3D; fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady &#x3D; function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray &#x3D; Array.isArray;
	jQuery.parseJSON &#x3D; JSON.parse;
	jQuery.nodeName &#x3D; nodeName;
	jQuery.isFunction &#x3D; isFunction;
	jQuery.isWindow &#x3D; isWindow;
	jQuery.camelCase &#x3D; camelCase;
	jQuery.type &#x3D; toType;

	jQuery.now &#x3D; Date.now;

	jQuery.isNumeric &#x3D; function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type &#x3D; jQuery.type( obj );
		return ( type &#x3D;&#x3D;&#x3D; &quot;number&quot; || type &#x3D;&#x3D;&#x3D; &quot;string&quot; ) &amp;&amp;

			// parseFloat NaNs numeric-cast false positives (&quot;&quot;)
			// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [], __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery &#x3D; window.jQuery,

		// Map over the $ in case of overwrite
		_$ &#x3D; window.$;

	jQuery.noConflict &#x3D; function( deep ) {
		if ( window.$ &#x3D;&#x3D;&#x3D; jQuery ) {
			window.$ &#x3D; _$;
		}

		if ( deep &amp;&amp; window.jQuery &#x3D;&#x3D;&#x3D; jQuery ) {
			window.jQuery &#x3D; _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery &#x3D; window.$ &#x3D; jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/*! modernizr 3.5.0 (Custom Build) | MIT *
	 * https://modernizr.com/download/?-applicationcache-backgrounds-borderimage-borderradius-boxshadow-cors-cssanimations-csscolumns-cssgradients-cssreflections-cssremunit-cssscrollbar-csstransforms-csstransforms3d-csstransitions-devicemotion_deviceorientation-fileinput-filereader-filesystem-flexbox-flexboxlegacy-fontface-formattribute-formvalidation-fullscreen-generatedcontent-hashchange-history-hsla-ie8compat-input-inputtypes-json-localstorage-multiplebgs-opacity-overflowscrolling-placeholder-postmessage-rgba-sessionstorage-strictmode-textshadow-domprefixes-hasevent-prefixed-prefixes-setclasses-testallprops-testprop-teststyles !*/
	!function(e,t,n){function r(e){var t&#x3D;S.className,n&#x3D;Modernizr._config.classPrefix||&quot;&quot;;if(C&amp;&amp;(t&#x3D;t.baseVal),Modernizr._config.enableJSClass){var r&#x3D;new RegExp(&quot;(^|\\s)&quot;+n+&quot;no-js(\\s|$)&quot;);t&#x3D;t.replace(r,&quot;$1&quot;+n+&quot;js$2&quot;)}Modernizr._config.enableClasses&amp;&amp;(t+&#x3D;&quot; &quot;+n+e.join(&quot; &quot;+n),C?S.className.baseVal&#x3D;t:S.className&#x3D;t)}function i(e,t){return typeof e&#x3D;&#x3D;&#x3D;t}function o(){var e,t,n,r,o,s,a;for(var d in x)if(x.hasOwnProperty(d)){if(e&#x3D;[],t&#x3D;x[d],t.name&amp;&amp;(e.push(t.name.toLowerCase()),t.options&amp;&amp;t.options.aliases&amp;&amp;t.options.aliases.length))for(n&#x3D;0;n&lt;t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(r&#x3D;i(t.fn,&quot;function&quot;)?t.fn():t.fn,o&#x3D;0;o&lt;e.length;o++)s&#x3D;e[o],a&#x3D;s.split(&quot;.&quot;),1&#x3D;&#x3D;&#x3D;a.length?Modernizr[a[0]]&#x3D;r:(!Modernizr[a[0]]||Modernizr[a[0]]instanceof Boolean||(Modernizr[a[0]]&#x3D;new Boolean(Modernizr[a[0]])),Modernizr[a[0]][a[1]]&#x3D;r),b.push((r?&quot;&quot;:&quot;no-&quot;)+a.join(&quot;-&quot;))}}function s(){return&quot;function&quot;!&#x3D;typeof t.createElement?t.createElement(arguments[0]):C?t.createElementNS.call(t,&quot;http://www.w3.org/2000/svg&quot;,arguments[0]):t.createElement.apply(t,arguments)}function a(e){return e.replace(/([a-z])-([a-z])/g,function(e,t,n){return t+n.toUpperCase()}).replace(/^-/,&quot;&quot;)}function d(e,t){return!!~(&quot;&quot;+e).indexOf(t)}function l(){var e&#x3D;t.body;return e||(e&#x3D;s(C?&quot;svg&quot;:&quot;body&quot;),e.fake&#x3D;!0),e}function u(e,n,r,i){var o,a,d,u,c&#x3D;&quot;modernizr&quot;,f&#x3D;s(&quot;div&quot;),p&#x3D;l();if(parseInt(r,10))for(;r--;)d&#x3D;s(&quot;div&quot;),d.id&#x3D;i?i[r]:c+(r+1),f.appendChild(d);return o&#x3D;s(&quot;style&quot;),o.type&#x3D;&quot;text/css&quot;,o.id&#x3D;&quot;s&quot;+c,(p.fake?p:f).appendChild(o),p.appendChild(f),o.styleSheet?o.styleSheet.cssText&#x3D;e:o.appendChild(t.createTextNode(e)),f.id&#x3D;c,p.fake&amp;&amp;(p.style.background&#x3D;&quot;&quot;,p.style.overflow&#x3D;&quot;hidden&quot;,u&#x3D;S.style.overflow,S.style.overflow&#x3D;&quot;hidden&quot;,S.appendChild(p)),a&#x3D;n(f,e),p.fake?(p.parentNode.removeChild(p),S.style.overflow&#x3D;u,S.offsetHeight):f.parentNode.removeChild(f),!!a}function c(e,t){return function(){return e.apply(t,arguments)}}function f(e,t,n){var r;for(var o in e)if(e[o]in t)return n&#x3D;&#x3D;&#x3D;!1?e[o]:(r&#x3D;t[e[o]],i(r,&quot;function&quot;)?c(r,n||t):r);return!1}function p(t,n,r){var i;if(&quot;getComputedStyle&quot;in e){i&#x3D;getComputedStyle.call(e,t,n);var o&#x3D;e.console;if(null!&#x3D;&#x3D;i)r&amp;&amp;(i&#x3D;i.getPropertyValue(r));else if(o){var s&#x3D;o.error?&quot;error&quot;:&quot;log&quot;;o[s].call(o,&quot;getComputedStyle returning null, its possible modernizr test results are inaccurate&quot;)}}else i&#x3D;!n&amp;&amp;t.currentStyle&amp;&amp;t.currentStyle[r];return i}function m(e){return e.replace(/([A-Z])/g,function(e,t){return&quot;-&quot;+t.toLowerCase()}).replace(/^ms-/,&quot;-ms-&quot;)}function h(t,r){var i&#x3D;t.length;if(&quot;CSS&quot;in e&amp;&amp;&quot;supports&quot;in e.CSS){for(;i--;)if(e.CSS.supports(m(t[i]),r))return!0;return!1}if(&quot;CSSSupportsRule&quot;in e){for(var o&#x3D;[];i--;)o.push(&quot;(&quot;+m(t[i])+&quot;:&quot;+r+&quot;)&quot;);return o&#x3D;o.join(&quot; or &quot;),u(&quot;@supports (&quot;+o+&quot;) { #modernizr { position: absolute; } }&quot;,function(e){return&quot;absolute&quot;&#x3D;&#x3D;p(e,null,&quot;position&quot;)})}return n}function g(e,t,r,o){function l(){c&amp;&amp;(delete I.style,delete I.modElem)}if(o&#x3D;i(o,&quot;undefined&quot;)?!1:o,!i(r,&quot;undefined&quot;)){var u&#x3D;h(e,r);if(!i(u,&quot;undefined&quot;))return u}for(var c,f,p,m,g,v&#x3D;[&quot;modernizr&quot;,&quot;tspan&quot;,&quot;samp&quot;];!I.style&amp;&amp;v.length;)c&#x3D;!0,I.modElem&#x3D;s(v.shift()),I.style&#x3D;I.modElem.style;for(p&#x3D;e.length,f&#x3D;0;p&gt;f;f++)if(m&#x3D;e[f],g&#x3D;I.style[m],d(m,&quot;-&quot;)&amp;&amp;(m&#x3D;a(m)),I.style[m]!&#x3D;&#x3D;n){if(o||i(r,&quot;undefined&quot;))return l(),&quot;pfx&quot;&#x3D;&#x3D;t?m:!0;try{I.style[m]&#x3D;r}catch(y){}if(I.style[m]!&#x3D;g)return l(),&quot;pfx&quot;&#x3D;&#x3D;t?m:!0}return l(),!1}function v(e,t,n,r,o){var s&#x3D;e.charAt(0).toUpperCase()+e.slice(1),a&#x3D;(e+&quot; &quot;+M.join(s+&quot; &quot;)+s).split(&quot; &quot;);return i(t,&quot;string&quot;)||i(t,&quot;undefined&quot;)?g(a,t,r,o):(a&#x3D;(e+&quot; &quot;+z.join(s+&quot; &quot;)+s).split(&quot; &quot;),f(a,t,n))}function y(e,t,r){return v(e,n,n,t,r)}var b&#x3D;[],x&#x3D;[],T&#x3D;{_version:&quot;3.5.0&quot;,_config:{classPrefix:&quot;&quot;,enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n&#x3D;this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){x.push({name:e,fn:t,options:n})},addAsyncTest:function(e){x.push({name:null,fn:e})}},Modernizr&#x3D;function(){};Modernizr.prototype&#x3D;T,Modernizr&#x3D;new Modernizr,Modernizr.addTest(&quot;applicationcache&quot;,&quot;applicationCache&quot;in e),Modernizr.addTest(&quot;cors&quot;,&quot;XMLHttpRequest&quot;in e&amp;&amp;&quot;withCredentials&quot;in new XMLHttpRequest),Modernizr.addTest(&quot;ie8compat&quot;,!e.addEventListener&amp;&amp;!!t.documentMode&amp;&amp;7&#x3D;&#x3D;&#x3D;t.documentMode),Modernizr.addTest(&quot;history&quot;,function(){var t&#x3D;navigator.userAgent;return-1&#x3D;&#x3D;&#x3D;t.indexOf(&quot;Android 2.&quot;)&amp;&amp;-1&#x3D;&#x3D;&#x3D;t.indexOf(&quot;Android 4.0&quot;)||-1&#x3D;&#x3D;&#x3D;t.indexOf(&quot;Mobile Safari&quot;)||-1!&#x3D;&#x3D;t.indexOf(&quot;Chrome&quot;)||-1!&#x3D;&#x3D;t.indexOf(&quot;Windows Phone&quot;)||&quot;file:&quot;&#x3D;&#x3D;&#x3D;location.protocol?e.history&amp;&amp;&quot;pushState&quot;in e.history:!1}),Modernizr.addTest(&quot;json&quot;,&quot;JSON&quot;in e&amp;&amp;&quot;parse&quot;in JSON&amp;&amp;&quot;stringify&quot;in JSON),Modernizr.addTest(&quot;postmessage&quot;,&quot;postMessage&quot;in e),Modernizr.addTest(&quot;strictmode&quot;,function(){&quot;use strict&quot;;return!this}()),Modernizr.addTest(&quot;devicemotion&quot;,&quot;DeviceMotionEvent&quot;in e),Modernizr.addTest(&quot;deviceorientation&quot;,&quot;DeviceOrientationEvent&quot;in e),Modernizr.addTest(&quot;filereader&quot;,!!(e.File&amp;&amp;e.FileList&amp;&amp;e.FileReader)),Modernizr.addTest(&quot;localstorage&quot;,function(){var e&#x3D;&quot;modernizr&quot;;try{return localStorage.setItem(e,e),localStorage.removeItem(e),!0}catch(t){return!1}}),Modernizr.addTest(&quot;sessionstorage&quot;,function(){var e&#x3D;&quot;modernizr&quot;;try{return sessionStorage.setItem(e,e),sessionStorage.removeItem(e),!0}catch(t){return!1}});var w&#x3D;T._config.usePrefixes?&quot; -webkit- -moz- -o- -ms- &quot;.split(&quot; &quot;):[&quot;&quot;,&quot;&quot;];T._prefixes&#x3D;w;var S&#x3D;t.documentElement,C&#x3D;&quot;svg&quot;&#x3D;&#x3D;&#x3D;S.nodeName.toLowerCase(),k&#x3D;&quot;Moz O ms Webkit&quot;,z&#x3D;T._config.usePrefixes?k.toLowerCase().split(&quot; &quot;):[];T._domPrefixes&#x3D;z;var A&#x3D;function(){function e(e,t){var i;return e?(t&amp;&amp;&quot;string&quot;!&#x3D;typeof t||(t&#x3D;s(t||&quot;div&quot;)),e&#x3D;&quot;on&quot;+e,i&#x3D;e in t,!i&amp;&amp;r&amp;&amp;(t.setAttribute||(t&#x3D;s(&quot;div&quot;)),t.setAttribute(e,&quot;&quot;),i&#x3D;&quot;function&quot;&#x3D;&#x3D;typeof t[e],t[e]!&#x3D;&#x3D;n&amp;&amp;(t[e]&#x3D;n),t.removeAttribute(e)),i):!1}var r&#x3D;!(&quot;onblur&quot;in t.documentElement);return e}();T.hasEvent&#x3D;A,Modernizr.addTest(&quot;hashchange&quot;,function(){return A(&quot;hashchange&quot;,e)&#x3D;&#x3D;&#x3D;!1?!1:t.documentMode&#x3D;&#x3D;&#x3D;n||t.documentMode&gt;7}),Modernizr.addTest(&quot;cssgradients&quot;,function(){for(var e,t&#x3D;&quot;background-image:&quot;,n&#x3D;&quot;gradient(linear,left top,right bottom,from(#9f9),to(white));&quot;,r&#x3D;&quot;&quot;,i&#x3D;0,o&#x3D;w.length-1;o&gt;i;i++)e&#x3D;0&#x3D;&#x3D;&#x3D;i?&quot;to &quot;:&quot;&quot;,r+&#x3D;t+w[i]+&quot;linear-gradient(&quot;+e+&quot;left top, #9f9, white);&quot;;Modernizr._config.usePrefixes&amp;&amp;(r+&#x3D;t+&quot;-webkit-&quot;+n);var a&#x3D;s(&quot;a&quot;),d&#x3D;a.style;return d.cssText&#x3D;r,(&quot;&quot;+d.backgroundImage).indexOf(&quot;gradient&quot;)&gt;-1}),Modernizr.addTest(&quot;multiplebgs&quot;,function(){var e&#x3D;s(&quot;a&quot;).style;return e.cssText&#x3D;&quot;background:url(https://),url(https://),red url(https://)&quot;,/(url\s*\(.*?){3}/.test(e.background)}),Modernizr.addTest(&quot;opacity&quot;,function(){var e&#x3D;s(&quot;a&quot;).style;return e.cssText&#x3D;w.join(&quot;opacity:.55;&quot;),/^0.55$/.test(e.opacity)}),Modernizr.addTest(&quot;cssremunit&quot;,function(){var e&#x3D;s(&quot;a&quot;).style;try{e.fontSize&#x3D;&quot;3rem&quot;}catch(t){}return/rem/.test(e.fontSize)}),Modernizr.addTest(&quot;rgba&quot;,function(){var e&#x3D;s(&quot;a&quot;).style;return e.cssText&#x3D;&quot;background-color:rgba(150,255,150,.5)&quot;,(&quot;&quot;+e.backgroundColor).indexOf(&quot;rgba&quot;)&gt;-1}),Modernizr.addTest(&quot;fileinput&quot;,function(){if(navigator.userAgent.match(/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\/(1.0|2.0|2.5|3.0))/))return!1;var e&#x3D;s(&quot;input&quot;);return e.type&#x3D;&quot;file&quot;,!e.disabled}),Modernizr.addTest(&quot;formattribute&quot;,function(){var e,n&#x3D;s(&quot;form&quot;),r&#x3D;s(&quot;input&quot;),i&#x3D;s(&quot;div&quot;),o&#x3D;&quot;formtest&quot;+(new Date).getTime(),a&#x3D;!1;n.id&#x3D;o;try{r.setAttribute(&quot;form&quot;,o)}catch(d){t.createAttribute&amp;&amp;(e&#x3D;t.createAttribute(&quot;form&quot;),e.nodeValue&#x3D;o,r.setAttributeNode(e))}return i.appendChild(n),i.appendChild(r),S.appendChild(i),a&#x3D;n.elements&amp;&amp;1&#x3D;&#x3D;&#x3D;n.elements.length&amp;&amp;r.form&#x3D;&#x3D;n,i.parentNode.removeChild(i),a}),Modernizr.addTest(&quot;placeholder&quot;,&quot;placeholder&quot;in s(&quot;input&quot;)&amp;&amp;&quot;placeholder&quot;in s(&quot;textarea&quot;));var _&#x3D;s(&quot;input&quot;),E&#x3D;&quot;autocomplete autofocus list placeholder max min multiple pattern required step&quot;.split(&quot; &quot;),O&#x3D;{};Modernizr.input&#x3D;function(t){for(var n&#x3D;0,r&#x3D;t.length;r&gt;n;n++)O[t[n]]&#x3D;!!(t[n]in _);return O.list&amp;&amp;(O.list&#x3D;!(!s(&quot;datalist&quot;)||!e.HTMLDataListElement)),O}(E);var P&#x3D;&quot;search tel url email datetime date month week time datetime-local number range color&quot;.split(&quot; &quot;),L&#x3D;{};Modernizr.inputtypes&#x3D;function(e){for(var r,i,o,s&#x3D;e.length,a&#x3D;&quot;1)&quot;,d&#x3D;0;s&gt;d;d++)_.setAttribute(&quot;type&quot;,r&#x3D;e[d]),o&#x3D;&quot;text&quot;!&#x3D;&#x3D;_.type&amp;&amp;&quot;style&quot;in _,o&amp;&amp;(_.value&#x3D;a,_.style.cssText&#x3D;&quot;position:absolute;visibility:hidden;&quot;,/^range$/.test(r)&amp;&amp;_.style.WebkitAppearance!&#x3D;&#x3D;n?(S.appendChild(_),i&#x3D;t.defaultView,o&#x3D;i.getComputedStyle&amp;&amp;&quot;textfield&quot;!&#x3D;&#x3D;i.getComputedStyle(_,null).WebkitAppearance&amp;&amp;0!&#x3D;&#x3D;_.offsetHeight,S.removeChild(_)):/^(search|tel)$/.test(r)||(o&#x3D;/^(url|email)$/.test(r)?_.checkValidity&amp;&amp;_.checkValidity()&#x3D;&#x3D;&#x3D;!1:_.value!&#x3D;a)),L[e[d]]&#x3D;!!o;return L}(P),Modernizr.addTest(&quot;hsla&quot;,function(){var e&#x3D;s(&quot;a&quot;).style;return e.cssText&#x3D;&quot;background-color:hsla(120,40%,100%,.5)&quot;,d(e.backgroundColor,&quot;rgba&quot;)||d(e.backgroundColor,&quot;hsla&quot;)});var R&#x3D;&quot;CSS&quot;in e&amp;&amp;&quot;supports&quot;in e.CSS,N&#x3D;&quot;supportsCSS&quot;in e;Modernizr.addTest(&quot;supports&quot;,R||N);var M&#x3D;T._config.usePrefixes?k.split(&quot; &quot;):[];T._cssomPrefixes&#x3D;M;var B&#x3D;function(t){var r,i&#x3D;w.length,o&#x3D;e.CSSRule;if(&quot;undefined&quot;&#x3D;&#x3D;typeof o)return n;if(!t)return!1;if(t&#x3D;t.replace(/^@/,&quot;&quot;),r&#x3D;t.replace(/-/g,&quot;_&quot;).toUpperCase()+&quot;_RULE&quot;,r in o)return&quot;@&quot;+t;for(var s&#x3D;0;i&gt;s;s++){var a&#x3D;w[s],d&#x3D;a.toUpperCase()+&quot;_&quot;+r;if(d in o)return&quot;@-&quot;+a.toLowerCase()+&quot;-&quot;+t}return!1};T.atRule&#x3D;B;var W&#x3D;T.testStyles&#x3D;u,j&#x3D;function(){var e&#x3D;navigator.userAgent,t&#x3D;e.match(/w(eb)?osbrowser/gi),n&#x3D;e.match(/windows phone/gi)&amp;&amp;e.match(/iemobile\/([0-9])+/gi)&amp;&amp;parseFloat(RegExp.$1)&gt;&#x3D;9;return t||n}();j?Modernizr.addTest(&quot;fontface&quot;,!1):W(&#x27;@font-face {font-family:&quot;font&quot;;src:url(&quot;https://&quot;)}&#x27;,function(e,n){var r&#x3D;t.getElementById(&quot;smodernizr&quot;),i&#x3D;r.sheet||r.styleSheet,o&#x3D;i?i.cssRules&amp;&amp;i.cssRules[0]?i.cssRules[0].cssText:i.cssText||&quot;&quot;:&quot;&quot;,s&#x3D;/src/i.test(o)&amp;&amp;0&#x3D;&#x3D;&#x3D;o.indexOf(n.split(&quot; &quot;)[0]);Modernizr.addTest(&quot;fontface&quot;,s)}),W(&#x27;#modernizr{font:0/0 a}#modernizr:after{content:&quot;:)&quot;;visibility:hidden;font:7px/1 a}&#x27;,function(e){Modernizr.addTest(&quot;generatedcontent&quot;,e.offsetHeight&gt;&#x3D;6)}),W(&quot;#modernizr{overflow: scroll; width: 40px; height: 40px; }#&quot;+w.join(&quot;scrollbar{width:10px} #modernizr::&quot;).split(&quot;#&quot;).slice(1).join(&quot;#&quot;)+&quot;scrollbar{width:10px}&quot;,function(e){Modernizr.addTest(&quot;cssscrollbar&quot;,&quot;scrollWidth&quot;in e&amp;&amp;30&#x3D;&#x3D;e.scrollWidth)}),Modernizr.addTest(&quot;formvalidation&quot;,function(){var t&#x3D;s(&quot;form&quot;);if(!(&quot;checkValidity&quot;in t&amp;&amp;&quot;addEventListener&quot;in t))return!1;if(&quot;reportValidity&quot;in t)return!0;var n,r&#x3D;!1;return Modernizr.formvalidationapi&#x3D;!0,t.addEventListener(&quot;submit&quot;,function(t){(!e.opera||e.operamini)&amp;&amp;t.preventDefault(),t.stopPropagation()},!1),t.innerHTML&#x3D;&#x27;&lt;input name&#x3D;&quot;modTest&quot; required&#x3D;&quot;required&quot; /&gt;&lt;button&gt;&lt;/button&gt;&#x27;,W(&quot;#modernizr form{position:absolute;top:-99999em}&quot;,function(e){e.appendChild(t),n&#x3D;t.getElementsByTagName(&quot;input&quot;)[0],n.addEventListener(&quot;invalid&quot;,function(e){r&#x3D;!0,e.preventDefault(),e.stopPropagation()},!1),Modernizr.formvalidationmessage&#x3D;!!n.validationMessage,t.getElementsByTagName(&quot;button&quot;)[0].click()}),r});var q&#x3D;{elem:s(&quot;modernizr&quot;)};Modernizr._q.push(function(){delete q.elem});var I&#x3D;{style:q.elem.style};Modernizr._q.unshift(function(){delete I.style});var V&#x3D;T.testProp&#x3D;function(e,t,r){return g([e],n,t,r)};Modernizr.addTest(&quot;textshadow&quot;,V(&quot;textShadow&quot;,&quot;1px 1px&quot;)),T.testAllProps&#x3D;v;var F&#x3D;T.prefixed&#x3D;function(e,t,n){return 0&#x3D;&#x3D;&#x3D;e.indexOf(&quot;@&quot;)?B(e):(-1!&#x3D;e.indexOf(&quot;-&quot;)&amp;&amp;(e&#x3D;a(e)),t?v(e,t,n):v(e,&quot;pfx&quot;))};Modernizr.addTest(&quot;fullscreen&quot;,!(!F(&quot;exitFullscreen&quot;,t,!1)&amp;&amp;!F(&quot;cancelFullScreen&quot;,t,!1))),Modernizr.addTest(&quot;filesystem&quot;,!!F(&quot;requestFileSystem&quot;,e)),T.testAllProps&#x3D;y,Modernizr.addTest(&quot;cssanimations&quot;,y(&quot;animationName&quot;,&quot;a&quot;,!0)),Modernizr.addTest(&quot;backgroundsize&quot;,y(&quot;backgroundSize&quot;,&quot;100%&quot;,!0)),Modernizr.addTest(&quot;borderradius&quot;,y(&quot;borderRadius&quot;,&quot;0px&quot;,!0)),Modernizr.addTest(&quot;borderimage&quot;,y(&quot;borderImage&quot;,&quot;url() 1&quot;,!0)),Modernizr.addTest(&quot;boxshadow&quot;,y(&quot;boxShadow&quot;,&quot;1px 1px&quot;,!0)),function(){Modernizr.addTest(&quot;csscolumns&quot;,function(){var e&#x3D;!1,t&#x3D;y(&quot;columnCount&quot;);try{e&#x3D;!!t,e&amp;&amp;(e&#x3D;new Boolean(e))}catch(n){}return e});for(var e,t,n&#x3D;[&quot;Width&quot;,&quot;Span&quot;,&quot;Fill&quot;,&quot;Gap&quot;,&quot;Rule&quot;,&quot;RuleColor&quot;,&quot;RuleStyle&quot;,&quot;RuleWidth&quot;,&quot;BreakBefore&quot;,&quot;BreakAfter&quot;,&quot;BreakInside&quot;],r&#x3D;0;r&lt;n.length;r++)e&#x3D;n[r].toLowerCase(),t&#x3D;y(&quot;column&quot;+n[r]),(&quot;breakbefore&quot;&#x3D;&#x3D;&#x3D;e||&quot;breakafter&quot;&#x3D;&#x3D;&#x3D;e||&quot;breakinside&quot;&#x3D;&#x3D;e)&amp;&amp;(t&#x3D;t||y(n[r])),Modernizr.addTest(&quot;csscolumns.&quot;+e,t)}(),Modernizr.addTest(&quot;flexbox&quot;,y(&quot;flexBasis&quot;,&quot;1px&quot;,!0)),Modernizr.addTest(&quot;flexboxlegacy&quot;,y(&quot;boxDirection&quot;,&quot;reverse&quot;,!0)),Modernizr.addTest(&quot;overflowscrolling&quot;,y(&quot;overflowScrolling&quot;,&quot;touch&quot;,!0)),Modernizr.addTest(&quot;cssreflections&quot;,y(&quot;boxReflect&quot;,&quot;above&quot;,!0)),Modernizr.addTest(&quot;csstransforms&quot;,function(){return-1&#x3D;&#x3D;&#x3D;navigator.userAgent.indexOf(&quot;Android 2.&quot;)&amp;&amp;y(&quot;transform&quot;,&quot;scale(1)&quot;,!0)}),Modernizr.addTest(&quot;csstransforms3d&quot;,function(){var e&#x3D;!!y(&quot;perspective&quot;,&quot;1px&quot;,!0),t&#x3D;Modernizr._config.usePrefixes;if(e&amp;&amp;(!t||&quot;webkitPerspective&quot;in S.style)){var n,r&#x3D;&quot;#modernizr{width:0;height:0}&quot;;Modernizr.supports?n&#x3D;&quot;@supports (perspective: 1px)&quot;:(n&#x3D;&quot;@media (transform-3d)&quot;,t&amp;&amp;(n+&#x3D;&quot;,(-webkit-transform-3d)&quot;)),n+&#x3D;&quot;{#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}&quot;,W(r+n,function(t){e&#x3D;7&#x3D;&#x3D;&#x3D;t.offsetWidth&amp;&amp;18&#x3D;&#x3D;&#x3D;t.offsetHeight})}return e}),Modernizr.addTest(&quot;csstransitions&quot;,y(&quot;transition&quot;,&quot;all&quot;,!0)),o(),r(b),delete T.addTest,delete T.addAsyncTest;for(var H&#x3D;0;H&lt;Modernizr._q.length;H++)Modernizr._q[H]();e.Modernizr&#x3D;Modernizr}(window,document);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * jQuery Easing v1.4.1 - http://gsgd.co.uk/sandbox/jquery/easing/
	 * Open source under the BSD License.
	 * Copyright © 2008 George McGinley Smith
	 * All rights reserved.
	 * https://raw.github.com/gdsmith/jquery-easing/master/LICENSE
	 */

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; function ($) {
	            return factory($);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof module.exports &#x3D;&#x3D;&#x3D; &quot;object&quot;) {
	        exports &#x3D; factory(require(&#x27;jquery&#x27;));
	    } else {
	        factory(jQuery);
	    }
	})(function ($) {

	// Preserve the original jQuery &quot;swing&quot; easing as &quot;jswing&quot;
	    $.easing.jswing &#x3D; $.easing.swing;

	    var pow &#x3D; Math.pow,
	        sqrt &#x3D; Math.sqrt,
	        sin &#x3D; Math.sin,
	        cos &#x3D; Math.cos,
	        PI &#x3D; Math.PI,
	        c1 &#x3D; 1.70158,
	        c2 &#x3D; c1 * 1.525,
	        c3 &#x3D; c1 + 1,
	        c4 &#x3D; ( 2 * PI ) / 3,
	        c5 &#x3D; ( 2 * PI ) / 4.5;

	// x is the fraction of animation progress, in the range 0..1
	    function bounceOut(x) {
	        var n1 &#x3D; 7.5625,
	            d1 &#x3D; 2.75;
	        if (x &lt; 1 / d1) {
	            return n1 * x * x;
	        } else if (x &lt; 2 / d1) {
	            return n1 * (x -&#x3D; (1.5 / d1)) * x + 0.75;
	        } else if (x &lt; 2.5 / d1) {
	            return n1 * (x -&#x3D; (2.25 / d1)) * x + 0.9375;
	        } else {
	            return n1 * (x -&#x3D; (2.625 / d1)) * x + 0.984375;
	        }
	    }

	    $.extend($.easing,
	        {
	            def: &#x27;easeOutQuad&#x27;,
	            swing: function (x) {
	                return $.easing[$.easing.def](x);
	            },
	            easeInQuad: function (x) {
	                return x * x;
	            },
	            easeOutQuad: function (x) {
	                return 1 - ( 1 - x ) * ( 1 - x );
	            },
	            easeInOutQuad: function (x) {
	                return x &lt; 0.5 ?
	                    2 * x * x :
	                    1 - pow(-2 * x + 2, 2) / 2;
	            },
	            easeInCubic: function (x) {
	                return x * x * x;
	            },
	            easeOutCubic: function (x) {
	                return 1 - pow(1 - x, 3);
	            },
	            easeInOutCubic: function (x) {
	                return x &lt; 0.5 ?
	                    4 * x * x * x :
	                    1 - pow(-2 * x + 2, 3) / 2;
	            },
	            easeInQuart: function (x) {
	                return x * x * x * x;
	            },
	            easeOutQuart: function (x) {
	                return 1 - pow(1 - x, 4);
	            },
	            easeInOutQuart: function (x) {
	                return x &lt; 0.5 ?
	                    8 * x * x * x * x :
	                    1 - pow(-2 * x + 2, 4) / 2;
	            },
	            easeInQuint: function (x) {
	                return x * x * x * x * x;
	            },
	            easeOutQuint: function (x) {
	                return 1 - pow(1 - x, 5);
	            },
	            easeInOutQuint: function (x) {
	                return x &lt; 0.5 ?
	                    16 * x * x * x * x * x :
	                    1 - pow(-2 * x + 2, 5) / 2;
	            },
	            easeInSine: function (x) {
	                return 1 - cos(x * PI / 2);
	            },
	            easeOutSine: function (x) {
	                return sin(x * PI / 2);
	            },
	            easeInOutSine: function (x) {
	                return -( cos(PI * x) - 1 ) / 2;
	            },
	            easeInExpo: function (x) {
	                return x &#x3D;&#x3D;&#x3D; 0 ? 0 : pow(2, 10 * x - 10);
	            },
	            easeOutExpo: function (x) {
	                return x &#x3D;&#x3D;&#x3D; 1 ? 1 : 1 - pow(2, -10 * x);
	            },
	            easeInOutExpo: function (x) {
	                return x &#x3D;&#x3D;&#x3D; 0 ? 0 : x &#x3D;&#x3D;&#x3D; 1 ? 1 : x &lt; 0.5 ?
	                    pow(2, 20 * x - 10) / 2 :
	                    ( 2 - pow(2, -20 * x + 10) ) / 2;
	            },
	            easeInCirc: function (x) {
	                return 1 - sqrt(1 - pow(x, 2));
	            },
	            easeOutCirc: function (x) {
	                return sqrt(1 - pow(x - 1, 2));
	            },
	            easeInOutCirc: function (x) {
	                return x &lt; 0.5 ?
	                    ( 1 - sqrt(1 - pow(2 * x, 2)) ) / 2 :
	                    ( sqrt(1 - pow(-2 * x + 2, 2)) + 1 ) / 2;
	            },
	            easeInElastic: function (x) {
	                return x &#x3D;&#x3D;&#x3D; 0 ? 0 : x &#x3D;&#x3D;&#x3D; 1 ? 1 :
	                    -pow(2, 10 * x - 10) * sin(( x * 10 - 10.75 ) * c4);
	            },
	            easeOutElastic: function (x) {
	                return x &#x3D;&#x3D;&#x3D; 0 ? 0 : x &#x3D;&#x3D;&#x3D; 1 ? 1 :
	                    pow(2, -10 * x) * sin(( x * 10 - 0.75 ) * c4) + 1;
	            },
	            easeInOutElastic: function (x) {
	                return x &#x3D;&#x3D;&#x3D; 0 ? 0 : x &#x3D;&#x3D;&#x3D; 1 ? 1 : x &lt; 0.5 ?
	                    -( pow(2, 20 * x - 10) * sin(( 20 * x - 11.125 ) * c5)) / 2 :
	                    pow(2, -20 * x + 10) * sin(( 20 * x - 11.125 ) * c5) / 2 + 1;
	            },
	            easeInBack: function (x) {
	                return c3 * x * x * x - c1 * x * x;
	            },
	            easeOutBack: function (x) {
	                return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
	            },
	            easeInOutBack: function (x) {
	                return x &lt; 0.5 ?
	                    ( pow(2 * x, 2) * ( ( c2 + 1 ) * 2 * x - c2 ) ) / 2 :
	                    ( pow(2 * x - 2, 2) * ( ( c2 + 1 ) * ( x * 2 - 2 ) + c2 ) + 2 ) / 2;
	            },
	            easeInBounce: function (x) {
	                return 1 - bounceOut(1 - x);
	            },
	            easeOutBounce: bounceOut,
	            easeInOutBounce: function (x) {
	                return x &lt; 0.5 ?
	                    ( 1 - bounceOut(1 - 2 * x) ) / 2 :
	                    ( 1 + bounceOut(2 * x - 1) ) / 2;
	            }
	        });

	});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**!
	 * @fileOverview Kickass library to create and place poppers near their reference elements.
	 * @version 1.14.1
	 * @license
	 * Copyright (c) 2016 Federico Zivolo and contributors
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the &quot;Software&quot;), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	(function (global, factory) {
		 true ? module.exports &#x3D; factory() :
		typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define(factory) :
		(global.Popper &#x3D; factory());
	}(this, (function () { &#x27;use strict&#x27;;

	var isBrowser &#x3D; typeof window !&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; typeof document !&#x3D;&#x3D; &#x27;undefined&#x27;;
	var longerTimeoutBrowsers &#x3D; [&#x27;Edge&#x27;, &#x27;Trident&#x27;, &#x27;Firefox&#x27;];
	var timeoutDuration &#x3D; 0;
	for (var i &#x3D; 0; i &lt; longerTimeoutBrowsers.length; i +&#x3D; 1) {
	  if (isBrowser &amp;&amp; navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) &gt;&#x3D; 0) {
	    timeoutDuration &#x3D; 1;
	    break;
	  }
	}

	function microtaskDebounce(fn) {
	  var called &#x3D; false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called &#x3D; true;
	    window.Promise.resolve().then(function () {
	      called &#x3D; false;
	      fn();
	    });
	  };
	}

	function taskDebounce(fn) {
	  var scheduled &#x3D; false;
	  return function () {
	    if (!scheduled) {
	      scheduled &#x3D; true;
	      setTimeout(function () {
	        scheduled &#x3D; false;
	        fn();
	      }, timeoutDuration);
	    }
	  };
	}

	var supportsMicroTasks &#x3D; isBrowser &amp;&amp; window.Promise;

	/**
	* Create a debounced version of a method, that&#x27;s asynchronously deferred
	* but called in the minimum time possible.
	*
	* @method
	* @memberof Popper.Utils
	* @argument {Function} fn
	* @returns {Function}
	*/
	var debounce &#x3D; supportsMicroTasks ? microtaskDebounce : taskDebounce;

	/**
	 * Check if the given variable is a function
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Any} functionToCheck - variable to check
	 * @returns {Boolean} answer to: is a function?
	 */
	function isFunction(functionToCheck) {
	  var getType &#x3D; {};
	  return functionToCheck &amp;&amp; getType.toString.call(functionToCheck) &#x3D;&#x3D;&#x3D; &#x27;[object Function]&#x27;;
	}

	/**
	 * Get CSS computed property of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Eement} element
	 * @argument {String} property
	 */
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !&#x3D;&#x3D; 1) {
	    return [];
	  }
	  // NOTE: 1 DOM access here
	  var css &#x3D; getComputedStyle(element, null);
	  return property ? css[property] : css;
	}

	/**
	 * Returns the parentNode or the host of the element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} parent
	 */
	function getParentNode(element) {
	  if (element.nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27;) {
	    return element;
	  }
	  return element.parentNode || element.host;
	}

	/**
	 * Returns the scrolling parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} scroll parent
	 */
	function getScrollParent(element) {
	  // Return body, &#x60;getScroll&#x60; will take care to get the correct &#x60;scrollTop&#x60; from it
	  if (!element) {
	    return document.body;
	  }

	  switch (element.nodeName) {
	    case &#x27;HTML&#x27;:
	    case &#x27;BODY&#x27;:
	      return element.ownerDocument.body;
	    case &#x27;#document&#x27;:
	      return element.body;
	  }

	  // Firefox want us to check &#x60;-x&#x60; and &#x60;-y&#x60; variations as well

	  var _getStyleComputedProp &#x3D; getStyleComputedProperty(element),
	      overflow &#x3D; _getStyleComputedProp.overflow,
	      overflowX &#x3D; _getStyleComputedProp.overflowX,
	      overflowY &#x3D; _getStyleComputedProp.overflowY;

	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }

	  return getScrollParent(getParentNode(element));
	}

	/**
	 * Tells if you are running Internet Explorer
	 * @method
	 * @memberof Popper.Utils
	 * @argument {number} version to check
	 * @returns {Boolean} isIE
	 */
	var cache &#x3D; {};

	var isIE &#x3D; function () {
	  var version &#x3D; arguments.length &gt; 0 &amp;&amp; arguments[0] !&#x3D;&#x3D; undefined ? arguments[0] : &#x27;all&#x27;;

	  version &#x3D; version.toString();
	  if (cache.hasOwnProperty(version)) {
	    return cache[version];
	  }
	  switch (version) {
	    case &#x27;11&#x27;:
	      cache[version] &#x3D; navigator.userAgent.indexOf(&#x27;Trident&#x27;) !&#x3D;&#x3D; -1;
	      break;
	    case &#x27;10&#x27;:
	      cache[version] &#x3D; navigator.appVersion.indexOf(&#x27;MSIE 10&#x27;) !&#x3D;&#x3D; -1;
	      break;
	    case &#x27;all&#x27;:
	      cache[version] &#x3D; navigator.userAgent.indexOf(&#x27;Trident&#x27;) !&#x3D;&#x3D; -1 || navigator.userAgent.indexOf(&#x27;MSIE&#x27;) !&#x3D;&#x3D; -1;
	      break;
	  }

	  //Set IE
	  cache.all &#x3D; cache.all || Object.keys(cache).some(function (key) {
	    return cache[key];
	  });
	  return cache[version];
	};

	/**
	 * Returns the offset parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} offset parent
	 */
	function getOffsetParent(element) {
	  if (!element) {
	    return document.documentElement;
	  }

	  var noOffsetParent &#x3D; isIE(10) ? document.body : null;

	  // NOTE: 1 DOM access here
	  var offsetParent &#x3D; element.offsetParent;
	  // Skip hidden elements which don&#x27;t have an offsetParent
	  while (offsetParent &#x3D;&#x3D;&#x3D; noOffsetParent &amp;&amp; element.nextElementSibling) {
	    offsetParent &#x3D; (element &#x3D; element.nextElementSibling).offsetParent;
	  }

	  var nodeName &#x3D; offsetParent &amp;&amp; offsetParent.nodeName;

	  if (!nodeName || nodeName &#x3D;&#x3D;&#x3D; &#x27;BODY&#x27; || nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27;) {
	    return element ? element.ownerDocument.documentElement : document.documentElement;
	  }

	  // .offsetParent will return the closest TD or TABLE in case
	  // no offsetParent is present, I hate this job...
	  if ([&#x27;TD&#x27;, &#x27;TABLE&#x27;].indexOf(offsetParent.nodeName) !&#x3D;&#x3D; -1 &amp;&amp; getStyleComputedProperty(offsetParent, &#x27;position&#x27;) &#x3D;&#x3D;&#x3D; &#x27;static&#x27;) {
	    return getOffsetParent(offsetParent);
	  }

	  return offsetParent;
	}

	function isOffsetContainer(element) {
	  var nodeName &#x3D; element.nodeName;

	  if (nodeName &#x3D;&#x3D;&#x3D; &#x27;BODY&#x27;) {
	    return false;
	  }
	  return nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27; || getOffsetParent(element.firstElementChild) &#x3D;&#x3D;&#x3D; element;
	}

	/**
	 * Finds the root node (document, shadowDOM root) of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} node
	 * @returns {Element} root node
	 */
	function getRoot(node) {
	  if (node.parentNode !&#x3D;&#x3D; null) {
	    return getRoot(node.parentNode);
	  }

	  return node;
	}

	/**
	 * Finds the offset parent common to the two provided nodes
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element1
	 * @argument {Element} element2
	 * @returns {Element} common offset parent
	 */
	function findCommonOffsetParent(element1, element2) {
	  // This check is needed to avoid errors in case one of the elements isn&#x27;t defined for any reason
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }

	  // Here we make sure to give as &quot;start&quot; the element that comes first in the DOM
	  var order &#x3D; element1.compareDocumentPosition(element2) &amp; Node.DOCUMENT_POSITION_FOLLOWING;
	  var start &#x3D; order ? element1 : element2;
	  var end &#x3D; order ? element2 : element1;

	  // Get common ancestor container
	  var range &#x3D; document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer &#x3D; range.commonAncestorContainer;

	  // Both nodes are inside #document

	  if (element1 !&#x3D;&#x3D; commonAncestorContainer &amp;&amp; element2 !&#x3D;&#x3D; commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }

	    return getOffsetParent(commonAncestorContainer);
	  }

	  // one of the nodes is inside shadowDOM, find which one
	  var element1root &#x3D; getRoot(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}

	/**
	 * Gets the scroll value of the given element in the given side (top and left)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {String} side &#x60;top&#x60; or &#x60;left&#x60;
	 * @returns {number} amount of scrolled pixels
	 */
	function getScroll(element) {
	  var side &#x3D; arguments.length &gt; 1 &amp;&amp; arguments[1] !&#x3D;&#x3D; undefined ? arguments[1] : &#x27;top&#x27;;

	  var upperSide &#x3D; side &#x3D;&#x3D;&#x3D; &#x27;top&#x27; ? &#x27;scrollTop&#x27; : &#x27;scrollLeft&#x27;;
	  var nodeName &#x3D; element.nodeName;

	  if (nodeName &#x3D;&#x3D;&#x3D; &#x27;BODY&#x27; || nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27;) {
	    var html &#x3D; element.ownerDocument.documentElement;
	    var scrollingElement &#x3D; element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }

	  return element[upperSide];
	}

	/*
	 * Sum or subtract the element scroll values (left and top) from a given rect object
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} rect - Rect object you want to change
	 * @param {HTMLElement} element - The element from the function reads the scroll values
	 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
	 * @return {Object} rect - The modifier rect object
	 */
	function includeScroll(rect, element) {
	  var subtract &#x3D; arguments.length &gt; 2 &amp;&amp; arguments[2] !&#x3D;&#x3D; undefined ? arguments[2] : false;

	  var scrollTop &#x3D; getScroll(element, &#x27;top&#x27;);
	  var scrollLeft &#x3D; getScroll(element, &#x27;left&#x27;);
	  var modifier &#x3D; subtract ? -1 : 1;
	  rect.top +&#x3D; scrollTop * modifier;
	  rect.bottom +&#x3D; scrollTop * modifier;
	  rect.left +&#x3D; scrollLeft * modifier;
	  rect.right +&#x3D; scrollLeft * modifier;
	  return rect;
	}

	/*
	 * Helper to detect borders of a given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {CSSStyleDeclaration} styles
	 * Result of &#x60;getStyleComputedProperty&#x60; on the given element
	 * @param {String} axis - &#x60;x&#x60; or &#x60;y&#x60;
	 * @return {number} borders - The borders size of the given axis
	 */

	function getBordersSize(styles, axis) {
	  var sideA &#x3D; axis &#x3D;&#x3D;&#x3D; &#x27;x&#x27; ? &#x27;Left&#x27; : &#x27;Top&#x27;;
	  var sideB &#x3D; sideA &#x3D;&#x3D;&#x3D; &#x27;Left&#x27; ? &#x27;Right&#x27; : &#x27;Bottom&#x27;;

	  return parseFloat(styles[&#x27;border&#x27; + sideA + &#x27;Width&#x27;], 10) + parseFloat(styles[&#x27;border&#x27; + sideB + &#x27;Width&#x27;], 10);
	}

	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body[&#x27;offset&#x27; + axis], body[&#x27;scroll&#x27; + axis], html[&#x27;client&#x27; + axis], html[&#x27;offset&#x27; + axis], html[&#x27;scroll&#x27; + axis], isIE(10) ? html[&#x27;offset&#x27; + axis] + computedStyle[&#x27;margin&#x27; + (axis &#x3D;&#x3D;&#x3D; &#x27;Height&#x27; ? &#x27;Top&#x27; : &#x27;Left&#x27;)] + computedStyle[&#x27;margin&#x27; + (axis &#x3D;&#x3D;&#x3D; &#x27;Height&#x27; ? &#x27;Bottom&#x27; : &#x27;Right&#x27;)] : 0);
	}

	function getWindowSizes() {
	  var body &#x3D; document.body;
	  var html &#x3D; document.documentElement;
	  var computedStyle &#x3D; isIE(10) &amp;&amp; getComputedStyle(html);

	  return {
	    height: getSize(&#x27;Height&#x27;, body, html, computedStyle),
	    width: getSize(&#x27;Width&#x27;, body, html, computedStyle)
	  };
	}

	var classCallCheck &#x3D; function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError(&quot;Cannot call a class as a function&quot;);
	  }
	};

	var createClass &#x3D; function () {
	  function defineProperties(target, props) {
	    for (var i &#x3D; 0; i &lt; props.length; i++) {
	      var descriptor &#x3D; props[i];
	      descriptor.enumerable &#x3D; descriptor.enumerable || false;
	      descriptor.configurable &#x3D; true;
	      if (&quot;value&quot; in descriptor) descriptor.writable &#x3D; true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();





	var defineProperty &#x3D; function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] &#x3D; value;
	  }

	  return obj;
	};

	var _extends &#x3D; Object.assign || function (target) {
	  for (var i &#x3D; 1; i &lt; arguments.length; i++) {
	    var source &#x3D; arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] &#x3D; source[key];
	      }
	    }
	  }

	  return target;
	};

	/**
	 * Given element offsets, generate an output similar to getBoundingClientRect
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} offsets
	 * @returns {Object} ClientRect like output
	 */
	function getClientRect(offsets) {
	  return _extends({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}

	/**
	 * Get bounding client rect of given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} element
	 * @return {Object} client rect
	 */
	function getBoundingClientRect(element) {
	  var rect &#x3D; {};

	  // IE10 10 FIX: Please, don&#x27;t ask, the element isn&#x27;t
	  // considered in DOM in some circumstances...
	  // This isn&#x27;t reproducible in IE10 compatibility mode of IE11
	  try {
	    if (isIE(10)) {
	      rect &#x3D; element.getBoundingClientRect();
	      var scrollTop &#x3D; getScroll(element, &#x27;top&#x27;);
	      var scrollLeft &#x3D; getScroll(element, &#x27;left&#x27;);
	      rect.top +&#x3D; scrollTop;
	      rect.left +&#x3D; scrollLeft;
	      rect.bottom +&#x3D; scrollTop;
	      rect.right +&#x3D; scrollLeft;
	    } else {
	      rect &#x3D; element.getBoundingClientRect();
	    }
	  } catch (e) {}

	  var result &#x3D; {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };

	  // subtract scrollbar size from sizes
	  var sizes &#x3D; element.nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27; ? getWindowSizes() : {};
	  var width &#x3D; sizes.width || element.clientWidth || result.right - result.left;
	  var height &#x3D; sizes.height || element.clientHeight || result.bottom - result.top;

	  var horizScrollbar &#x3D; element.offsetWidth - width;
	  var vertScrollbar &#x3D; element.offsetHeight - height;

	  // if an hypothetical scrollbar is detected, we must be sure it&#x27;s not a &#x60;border&#x60;
	  // we make this check conditional for performance reasons
	  if (horizScrollbar || vertScrollbar) {
	    var styles &#x3D; getStyleComputedProperty(element);
	    horizScrollbar -&#x3D; getBordersSize(styles, &#x27;x&#x27;);
	    vertScrollbar -&#x3D; getBordersSize(styles, &#x27;y&#x27;);

	    result.width -&#x3D; horizScrollbar;
	    result.height -&#x3D; vertScrollbar;
	  }

	  return getClientRect(result);
	}

	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var fixedPosition &#x3D; arguments.length &gt; 2 &amp;&amp; arguments[2] !&#x3D;&#x3D; undefined ? arguments[2] : false;

	  var isIE10 &#x3D; isIE(10);
	  var isHTML &#x3D; parent.nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27;;
	  var childrenRect &#x3D; getBoundingClientRect(children);
	  var parentRect &#x3D; getBoundingClientRect(parent);
	  var scrollParent &#x3D; getScrollParent(children);

	  var styles &#x3D; getStyleComputedProperty(parent);
	  var borderTopWidth &#x3D; parseFloat(styles.borderTopWidth, 10);
	  var borderLeftWidth &#x3D; parseFloat(styles.borderLeftWidth, 10);

	  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
	  if (fixedPosition &amp;&amp; parent.nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27;) {
	    parentRect.top &#x3D; Math.max(parentRect.top, 0);
	    parentRect.left &#x3D; Math.max(parentRect.left, 0);
	  }
	  var offsets &#x3D; getClientRect({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop &#x3D; 0;
	  offsets.marginLeft &#x3D; 0;

	  // Subtract margins of documentElement in case it&#x27;s being used as parent
	  // we do this only on HTML because it&#x27;s the only element that behaves
	  // differently when margins are applied to it. The margins are included in
	  // the box of the documentElement, in the other cases not.
	  if (!isIE10 &amp;&amp; isHTML) {
	    var marginTop &#x3D; parseFloat(styles.marginTop, 10);
	    var marginLeft &#x3D; parseFloat(styles.marginLeft, 10);

	    offsets.top -&#x3D; borderTopWidth - marginTop;
	    offsets.bottom -&#x3D; borderTopWidth - marginTop;
	    offsets.left -&#x3D; borderLeftWidth - marginLeft;
	    offsets.right -&#x3D; borderLeftWidth - marginLeft;

	    // Attach marginTop and marginLeft because in some circumstances we may need them
	    offsets.marginTop &#x3D; marginTop;
	    offsets.marginLeft &#x3D; marginLeft;
	  }

	  if (isIE10 &amp;&amp; !fixedPosition ? parent.contains(scrollParent) : parent &#x3D;&#x3D;&#x3D; scrollParent &amp;&amp; scrollParent.nodeName !&#x3D;&#x3D; &#x27;BODY&#x27;) {
	    offsets &#x3D; includeScroll(offsets, parent);
	  }

	  return offsets;
	}

	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var excludeScroll &#x3D; arguments.length &gt; 1 &amp;&amp; arguments[1] !&#x3D;&#x3D; undefined ? arguments[1] : false;

	  var html &#x3D; element.ownerDocument.documentElement;
	  var relativeOffset &#x3D; getOffsetRectRelativeToArbitraryNode(element, html);
	  var width &#x3D; Math.max(html.clientWidth, window.innerWidth || 0);
	  var height &#x3D; Math.max(html.clientHeight, window.innerHeight || 0);

	  var scrollTop &#x3D; !excludeScroll ? getScroll(html) : 0;
	  var scrollLeft &#x3D; !excludeScroll ? getScroll(html, &#x27;left&#x27;) : 0;

	  var offset &#x3D; {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };

	  return getClientRect(offset);
	}

	/**
	 * Check if the given element is fixed or is inside a fixed parent
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {Element} customContainer
	 * @returns {Boolean} answer to &quot;isFixed?&quot;
	 */
	function isFixed(element) {
	  var nodeName &#x3D; element.nodeName;
	  if (nodeName &#x3D;&#x3D;&#x3D; &#x27;BODY&#x27; || nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27;) {
	    return false;
	  }
	  if (getStyleComputedProperty(element, &#x27;position&#x27;) &#x3D;&#x3D;&#x3D; &#x27;fixed&#x27;) {
	    return true;
	  }
	  return isFixed(getParentNode(element));
	}

	/**
	 * Finds the first parent of an element that has a transformed property defined
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} first transformed parent or documentElement
	 */

	function getFixedPositionOffsetParent(element) {
	  // This check is needed to avoid errors in case one of the elements isn&#x27;t defined for any reason
	  if (!element || !element.parentElement || isIE()) {
	    return document.documentElement;
	  }
	  var el &#x3D; element.parentElement;
	  while (el &amp;&amp; getStyleComputedProperty(el, &#x27;transform&#x27;) &#x3D;&#x3D;&#x3D; &#x27;none&#x27;) {
	    el &#x3D; el.parentElement;
	  }
	  return el || document.documentElement;
	}

	/**
	 * Computed the boundaries limits and return them
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} popper
	 * @param {HTMLElement} reference
	 * @param {number} padding
	 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
	 * @param {Boolean} fixedPosition - Is in fixed position mode
	 * @returns {Object} Coordinates of the boundaries
	 */
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  var fixedPosition &#x3D; arguments.length &gt; 4 &amp;&amp; arguments[4] !&#x3D;&#x3D; undefined ? arguments[4] : false;

	  // NOTE: 1 DOM access here

	  var boundaries &#x3D; { top: 0, left: 0 };
	  var offsetParent &#x3D; fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

	  // Handle viewport case
	  if (boundariesElement &#x3D;&#x3D;&#x3D; &#x27;viewport&#x27;) {
	    boundaries &#x3D; getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
	  } else {
	    // Handle other cases based on DOM element used as boundaries
	    var boundariesNode &#x3D; void 0;
	    if (boundariesElement &#x3D;&#x3D;&#x3D; &#x27;scrollParent&#x27;) {
	      boundariesNode &#x3D; getScrollParent(getParentNode(reference));
	      if (boundariesNode.nodeName &#x3D;&#x3D;&#x3D; &#x27;BODY&#x27;) {
	        boundariesNode &#x3D; popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement &#x3D;&#x3D;&#x3D; &#x27;window&#x27;) {
	      boundariesNode &#x3D; popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode &#x3D; boundariesElement;
	    }

	    var offsets &#x3D; getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

	    // In case of HTML, we need a different computation
	    if (boundariesNode.nodeName &#x3D;&#x3D;&#x3D; &#x27;HTML&#x27; &amp;&amp; !isFixed(offsetParent)) {
	      var _getWindowSizes &#x3D; getWindowSizes(),
	          height &#x3D; _getWindowSizes.height,
	          width &#x3D; _getWindowSizes.width;

	      boundaries.top +&#x3D; offsets.top - offsets.marginTop;
	      boundaries.bottom &#x3D; height + offsets.top;
	      boundaries.left +&#x3D; offsets.left - offsets.marginLeft;
	      boundaries.right &#x3D; width + offsets.left;
	    } else {
	      // for all the other DOM elements, this one is good
	      boundaries &#x3D; offsets;
	    }
	  }

	  // Add paddings
	  boundaries.left +&#x3D; padding;
	  boundaries.top +&#x3D; padding;
	  boundaries.right -&#x3D; padding;
	  boundaries.bottom -&#x3D; padding;

	  return boundaries;
	}

	function getArea(_ref) {
	  var width &#x3D; _ref.width,
	      height &#x3D; _ref.height;

	  return width * height;
	}

	/**
	 * Utility used to transform the &#x60;auto&#x60; placement to the placement with more
	 * available space.
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding &#x3D; arguments.length &gt; 5 &amp;&amp; arguments[5] !&#x3D;&#x3D; undefined ? arguments[5] : 0;

	  if (placement.indexOf(&#x27;auto&#x27;) &#x3D;&#x3D;&#x3D; -1) {
	    return placement;
	  }

	  var boundaries &#x3D; getBoundaries(popper, reference, padding, boundariesElement);

	  var rects &#x3D; {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };

	  var sortedAreas &#x3D; Object.keys(rects).map(function (key) {
	    return _extends({
	      key: key
	    }, rects[key], {
	      area: getArea(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });

	  var filteredAreas &#x3D; sortedAreas.filter(function (_ref2) {
	    var width &#x3D; _ref2.width,
	        height &#x3D; _ref2.height;
	    return width &gt;&#x3D; popper.clientWidth &amp;&amp; height &gt;&#x3D; popper.clientHeight;
	  });

	  var computedPlacement &#x3D; filteredAreas.length &gt; 0 ? filteredAreas[0].key : sortedAreas[0].key;

	  var variation &#x3D; placement.split(&#x27;-&#x27;)[1];

	  return computedPlacement + (variation ? &#x27;-&#x27; + variation : &#x27;&#x27;);
	}

	/**
	 * Get offsets to the reference element
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} state
	 * @param {Element} popper - the popper element
	 * @param {Element} reference - the reference element (the popper will be relative to this)
	 * @param {Element} fixedPosition - is in fixed position mode
	 * @returns {Object} An object containing the offsets which will be applied to the popper
	 */
	function getReferenceOffsets(state, popper, reference) {
	  var fixedPosition &#x3D; arguments.length &gt; 3 &amp;&amp; arguments[3] !&#x3D;&#x3D; undefined ? arguments[3] : null;

	  var commonOffsetParent &#x3D; fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
	}

	/**
	 * Get the outer sizes of the given element (offset size + margins)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Object} object containing width and height properties
	 */
	function getOuterSizes(element) {
	  var styles &#x3D; getComputedStyle(element);
	  var x &#x3D; parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
	  var y &#x3D; parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
	  var result &#x3D; {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}

	/**
	 * Get the opposite placement of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement
	 * @returns {String} flipped placement
	 */
	function getOppositePlacement(placement) {
	  var hash &#x3D; { left: &#x27;right&#x27;, right: &#x27;left&#x27;, bottom: &#x27;top&#x27;, top: &#x27;bottom&#x27; };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}

	/**
	 * Get offsets to the popper
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} position - CSS position the Popper will get applied
	 * @param {HTMLElement} popper - the popper element
	 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
	 * @param {String} placement - one of the valid placement options
	 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
	 */
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement &#x3D; placement.split(&#x27;-&#x27;)[0];

	  // Get popper node sizes
	  var popperRect &#x3D; getOuterSizes(popper);

	  // Add position, width and height to our offsets object
	  var popperOffsets &#x3D; {
	    width: popperRect.width,
	    height: popperRect.height
	  };

	  // depending by the popper placement we have to compute its offsets slightly differently
	  var isHoriz &#x3D; [&#x27;right&#x27;, &#x27;left&#x27;].indexOf(placement) !&#x3D;&#x3D; -1;
	  var mainSide &#x3D; isHoriz ? &#x27;top&#x27; : &#x27;left&#x27;;
	  var secondarySide &#x3D; isHoriz ? &#x27;left&#x27; : &#x27;top&#x27;;
	  var measurement &#x3D; isHoriz ? &#x27;height&#x27; : &#x27;width&#x27;;
	  var secondaryMeasurement &#x3D; !isHoriz ? &#x27;height&#x27; : &#x27;width&#x27;;

	  popperOffsets[mainSide] &#x3D; referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement &#x3D;&#x3D;&#x3D; secondarySide) {
	    popperOffsets[secondarySide] &#x3D; referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] &#x3D; referenceOffsets[getOppositePlacement(secondarySide)];
	  }

	  return popperOffsets;
	}

	/**
	 * Mimics the &#x60;find&#x60; method of Array
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function find(arr, check) {
	  // use native find if supported
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }

	  // use &#x60;filter&#x60; to obtain the same behavior of &#x60;find&#x60;
	  return arr.filter(check)[0];
	}

	/**
	 * Return the index of the matching object
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function findIndex(arr, prop, value) {
	  // use native findIndex if supported
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] &#x3D;&#x3D;&#x3D; value;
	    });
	  }

	  // use &#x60;find&#x60; + &#x60;indexOf&#x60; if &#x60;findIndex&#x60; isn&#x27;t supported
	  var match &#x3D; find(arr, function (obj) {
	    return obj[prop] &#x3D;&#x3D;&#x3D; value;
	  });
	  return arr.indexOf(match);
	}

	/**
	 * Loop trough the list of modifiers and run them in order,
	 * each of them will then edit the data object.
	 * @method
	 * @memberof Popper.Utils
	 * @param {dataObject} data
	 * @param {Array} modifiers
	 * @param {String} ends - Optional modifier name used as stopper
	 * @returns {dataObject}
	 */
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun &#x3D; ends &#x3D;&#x3D;&#x3D; undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, &#x27;name&#x27;, ends));

	  modifiersToRun.forEach(function (modifier) {
	    if (modifier[&#x27;function&#x27;]) {
	      // eslint-disable-line dot-notation
	      console.warn(&#x27;&#x60;modifier.function&#x60; is deprecated, use &#x60;modifier.fn&#x60;!&#x27;);
	    }
	    var fn &#x3D; modifier[&#x27;function&#x27;] || modifier.fn; // eslint-disable-line dot-notation
	    if (modifier.enabled &amp;&amp; isFunction(fn)) {
	      // Add properties to offsets to make them a complete clientRect object
	      // we do this before each modifier to make sure the previous one doesn&#x27;t
	      // mess with these values
	      data.offsets.popper &#x3D; getClientRect(data.offsets.popper);
	      data.offsets.reference &#x3D; getClientRect(data.offsets.reference);

	      data &#x3D; fn(data, modifier);
	    }
	  });

	  return data;
	}

	/**
	 * Updates the position of the popper, computing the new offsets and applying
	 * the new style.&lt;br /&gt;
	 * Prefer &#x60;scheduleUpdate&#x60; over &#x60;update&#x60; because of performance reasons.
	 * @method
	 * @memberof Popper
	 */
	function update() {
	  // if popper is destroyed, don&#x27;t perform any further update
	  if (this.state.isDestroyed) {
	    return;
	  }

	  var data &#x3D; {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };

	  // compute reference element offsets
	  data.offsets.reference &#x3D; getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit &#x60;placement&#x60; if needed
	  // and refer to originalPlacement to know the original value
	  data.placement &#x3D; computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

	  // store the computed placement inside &#x60;originalPlacement&#x60;
	  data.originalPlacement &#x3D; data.placement;

	  data.positionFixed &#x3D; this.options.positionFixed;

	  // compute the popper offsets
	  data.offsets.popper &#x3D; getPopperOffsets(this.popper, data.offsets.reference, data.placement);
	  data.offsets.popper.position &#x3D; this.options.positionFixed ? &#x27;fixed&#x27; : &#x27;absolute&#x27;;

	  // run the modifiers
	  data &#x3D; runModifiers(this.modifiers, data);

	  // the first &#x60;update&#x60; will call &#x60;onCreate&#x60; callback
	  // the other ones will call &#x60;onUpdate&#x60; callback
	  if (!this.state.isCreated) {
	    this.state.isCreated &#x3D; true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}

	/**
	 * Helper used to know if the given modifier is enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @returns {Boolean}
	 */
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref) {
	    var name &#x3D; _ref.name,
	        enabled &#x3D; _ref.enabled;
	    return enabled &amp;&amp; name &#x3D;&#x3D;&#x3D; modifierName;
	  });
	}

	/**
	 * Get the prefixed supported property name
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} property (camelCase)
	 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
	 */
	function getSupportedPropertyName(property) {
	  var prefixes &#x3D; [false, &#x27;ms&#x27;, &#x27;Webkit&#x27;, &#x27;Moz&#x27;, &#x27;O&#x27;];
	  var upperProp &#x3D; property.charAt(0).toUpperCase() + property.slice(1);

	  for (var i &#x3D; 0; i &lt; prefixes.length; i++) {
	    var prefix &#x3D; prefixes[i];
	    var toCheck &#x3D; prefix ? &#x27;&#x27; + prefix + upperProp : property;
	    if (typeof document.body.style[toCheck] !&#x3D;&#x3D; &#x27;undefined&#x27;) {
	      return toCheck;
	    }
	  }
	  return null;
	}

	/**
	 * Destroy the popper
	 * @method
	 * @memberof Popper
	 */
	function destroy() {
	  this.state.isDestroyed &#x3D; true;

	  // touch DOM only if &#x60;applyStyle&#x60; modifier is enabled
	  if (isModifierEnabled(this.modifiers, &#x27;applyStyle&#x27;)) {
	    this.popper.removeAttribute(&#x27;x-placement&#x27;);
	    this.popper.style.position &#x3D; &#x27;&#x27;;
	    this.popper.style.top &#x3D; &#x27;&#x27;;
	    this.popper.style.left &#x3D; &#x27;&#x27;;
	    this.popper.style.right &#x3D; &#x27;&#x27;;
	    this.popper.style.bottom &#x3D; &#x27;&#x27;;
	    this.popper.style.willChange &#x3D; &#x27;&#x27;;
	    this.popper.style[getSupportedPropertyName(&#x27;transform&#x27;)] &#x3D; &#x27;&#x27;;
	  }

	  this.disableEventListeners();

	  // remove the popper if user explicity asked for the deletion on destroy
	  // do not use &#x60;remove&#x60; because IE11 doesn&#x27;t support it
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}

	/**
	 * Get the window associated with the element
	 * @argument {Element} element
	 * @returns {Window}
	 */
	function getWindow(element) {
	  var ownerDocument &#x3D; element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}

	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody &#x3D; scrollParent.nodeName &#x3D;&#x3D;&#x3D; &#x27;BODY&#x27;;
	  var target &#x3D; isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, { passive: true });

	  if (!isBody) {
	    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}

	/**
	 * Setup needed event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function setupEventListeners(reference, options, state, updateBound) {
	  // Resize event listener on window
	  state.updateBound &#x3D; updateBound;
	  getWindow(reference).addEventListener(&#x27;resize&#x27;, state.updateBound, { passive: true });

	  // Scroll event listener on scroll parents
	  var scrollElement &#x3D; getScrollParent(reference);
	  attachToScrollParents(scrollElement, &#x27;scroll&#x27;, state.updateBound, state.scrollParents);
	  state.scrollElement &#x3D; scrollElement;
	  state.eventsEnabled &#x3D; true;

	  return state;
	}

	/**
	 * It will add resize/scroll events and start recalculating
	 * position of the popper element when they are triggered.
	 * @method
	 * @memberof Popper
	 */
	function enableEventListeners() {
	  if (!this.state.eventsEnabled) {
	    this.state &#x3D; setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}

	/**
	 * Remove event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function removeEventListeners(reference, state) {
	  // Remove resize event listener on window
	  getWindow(reference).removeEventListener(&#x27;resize&#x27;, state.updateBound);

	  // Remove scroll event listener on scroll parents
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener(&#x27;scroll&#x27;, state.updateBound);
	  });

	  // Reset state
	  state.updateBound &#x3D; null;
	  state.scrollParents &#x3D; [];
	  state.scrollElement &#x3D; null;
	  state.eventsEnabled &#x3D; false;
	  return state;
	}

	/**
	 * It will remove resize/scroll events and won&#x27;t recalculate popper position
	 * when they are triggered. It also won&#x27;t trigger onUpdate callback anymore,
	 * unless you call &#x60;update&#x60; method manually.
	 * @method
	 * @memberof Popper
	 */
	function disableEventListeners() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state &#x3D; removeEventListeners(this.reference, this.state);
	  }
	}

	/**
	 * Tells if a given input is a number
	 * @method
	 * @memberof Popper.Utils
	 * @param {*} input to check
	 * @return {Boolean}
	 */
	function isNumeric(n) {
	  return n !&#x3D;&#x3D; &#x27;&#x27; &amp;&amp; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
	}

	/**
	 * Set the style to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the style to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setStyles(element, styles) {
	  Object.keys(styles).forEach(function (prop) {
	    var unit &#x3D; &#x27;&#x27;;
	    // add unit if the value is numeric and is one of the following
	    if ([&#x27;width&#x27;, &#x27;height&#x27;, &#x27;top&#x27;, &#x27;right&#x27;, &#x27;bottom&#x27;, &#x27;left&#x27;].indexOf(prop) !&#x3D;&#x3D; -1 &amp;&amp; isNumeric(styles[prop])) {
	      unit &#x3D; &#x27;px&#x27;;
	    }
	    element.style[prop] &#x3D; styles[prop] + unit;
	  });
	}

	/**
	 * Set the attributes to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the attributes to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setAttributes(element, attributes) {
	  Object.keys(attributes).forEach(function (prop) {
	    var value &#x3D; attributes[prop];
	    if (value !&#x3D;&#x3D; false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} data.styles - List of style properties - values to apply to popper element
	 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The same data object
	 */
	function applyStyle(data) {
	  // any property present in &#x60;data.styles&#x60; will be applied to the popper,
	  // in this way we can make the 3rd party modifiers add custom styles to it
	  // Be aware, modifiers could override the properties defined in the previous
	  // lines of this modifier!
	  setStyles(data.instance.popper, data.styles);

	  // any property present in &#x60;data.attributes&#x60; will be applied to the popper,
	  // they will be set as HTML attributes of the element
	  setAttributes(data.instance.popper, data.attributes);

	  // if arrowElement is defined and arrowStyles has some properties
	  if (data.arrowElement &amp;&amp; Object.keys(data.arrowStyles).length) {
	    setStyles(data.arrowElement, data.arrowStyles);
	  }

	  return data;
	}

	/**
	 * Set the x-placement attribute before everything else because it could be used
	 * to add margins to the popper margins needs to be calculated to get the
	 * correct popper offsets.
	 * @method
	 * @memberof Popper.modifiers
	 * @param {HTMLElement} reference - The reference element used to position the popper
	 * @param {HTMLElement} popper - The HTML element used as popper
	 * @param {Object} options - Popper.js options
	 */
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  // compute reference element offsets
	  var referenceOffsets &#x3D; getReferenceOffsets(state, popper, reference, options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit &#x60;placement&#x60; if needed
	  // and refer to originalPlacement to know the original value
	  var placement &#x3D; computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

	  popper.setAttribute(&#x27;x-placement&#x27;, placement);

	  // Apply &#x60;position&#x60; to popper before anything else because
	  // without the position applied we can&#x27;t guarantee correct computations
	  setStyles(popper, { position: options.positionFixed ? &#x27;fixed&#x27; : &#x27;absolute&#x27; });

	  return options;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeStyle(data, options) {
	  var x &#x3D; options.x,
	      y &#x3D; options.y;
	  var popper &#x3D; data.offsets.popper;

	  // Remove this legacy support in Popper.js v2

	  var legacyGpuAccelerationOption &#x3D; find(data.instance.modifiers, function (modifier) {
	    return modifier.name &#x3D;&#x3D;&#x3D; &#x27;applyStyle&#x27;;
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !&#x3D;&#x3D; undefined) {
	    console.warn(&#x27;WARNING: &#x60;gpuAcceleration&#x60; option moved to &#x60;computeStyle&#x60; modifier and will not be supported in future versions of Popper.js!&#x27;);
	  }
	  var gpuAcceleration &#x3D; legacyGpuAccelerationOption !&#x3D;&#x3D; undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

	  var offsetParent &#x3D; getOffsetParent(data.instance.popper);
	  var offsetParentRect &#x3D; getBoundingClientRect(offsetParent);

	  // Styles
	  var styles &#x3D; {
	    position: popper.position
	  };

	  // floor sides to avoid blurry text
	  var offsets &#x3D; {
	    left: Math.floor(popper.left),
	    top: Math.floor(popper.top),
	    bottom: Math.floor(popper.bottom),
	    right: Math.floor(popper.right)
	  };

	  var sideA &#x3D; x &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; ? &#x27;top&#x27; : &#x27;bottom&#x27;;
	  var sideB &#x3D; y &#x3D;&#x3D;&#x3D; &#x27;right&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;

	  // if gpuAcceleration is set to &#x60;true&#x60; and transform is supported,
	  //  we use &#x60;translate3d&#x60; to apply the position to the popper we
	  // automatically use the supported prefixed version if needed
	  var prefixedProperty &#x3D; getSupportedPropertyName(&#x27;transform&#x27;);

	  // now, let&#x27;s make a step back and look at this code closely (wtf?)
	  // If the content of the popper grows once it&#x27;s been positioned, it
	  // may happen that the popper gets misplaced because of the new content
	  // overflowing its reference element
	  // To avoid this problem, we provide two options (x and y), which allow
	  // the consumer to define the offset origin.
	  // If we position a popper on top of a reference element, we can set
	  // &#x60;x&#x60; to &#x60;top&#x60; to make the popper grow towards its top instead of
	  // its bottom.
	  var left &#x3D; void 0,
	      top &#x3D; void 0;
	  if (sideA &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;) {
	    top &#x3D; -offsetParentRect.height + offsets.bottom;
	  } else {
	    top &#x3D; offsets.top;
	  }
	  if (sideB &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
	    left &#x3D; -offsetParentRect.width + offsets.right;
	  } else {
	    left &#x3D; offsets.left;
	  }
	  if (gpuAcceleration &amp;&amp; prefixedProperty) {
	    styles[prefixedProperty] &#x3D; &#x27;translate3d(&#x27; + left + &#x27;px, &#x27; + top + &#x27;px, 0)&#x27;;
	    styles[sideA] &#x3D; 0;
	    styles[sideB] &#x3D; 0;
	    styles.willChange &#x3D; &#x27;transform&#x27;;
	  } else {
	    // othwerise, we use the standard &#x60;top&#x60;, &#x60;left&#x60;, &#x60;bottom&#x60; and &#x60;right&#x60; properties
	    var invertTop &#x3D; sideA &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; ? -1 : 1;
	    var invertLeft &#x3D; sideB &#x3D;&#x3D;&#x3D; &#x27;right&#x27; ? -1 : 1;
	    styles[sideA] &#x3D; top * invertTop;
	    styles[sideB] &#x3D; left * invertLeft;
	    styles.willChange &#x3D; sideA + &#x27;, &#x27; + sideB;
	  }

	  // Attributes
	  var attributes &#x3D; {
	    &#x27;x-placement&#x27;: data.placement
	  };

	  // Update &#x60;data&#x60; attributes, styles and arrowStyles
	  data.attributes &#x3D; _extends({}, attributes, data.attributes);
	  data.styles &#x3D; _extends({}, styles, data.styles);
	  data.arrowStyles &#x3D; _extends({}, data.offsets.arrow, data.arrowStyles);

	  return data;
	}

	/**
	 * Helper used to know if the given modifier depends from another one.&lt;br /&gt;
	 * It checks if the needed modifier is listed and enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Array} modifiers - list of modifiers
	 * @param {String} requestingName - name of requesting modifier
	 * @param {String} requestedName - name of requested modifier
	 * @returns {Boolean}
	 */
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting &#x3D; find(modifiers, function (_ref) {
	    var name &#x3D; _ref.name;
	    return name &#x3D;&#x3D;&#x3D; requestingName;
	  });

	  var isRequired &#x3D; !!requesting &amp;&amp; modifiers.some(function (modifier) {
	    return modifier.name &#x3D;&#x3D;&#x3D; requestedName &amp;&amp; modifier.enabled &amp;&amp; modifier.order &lt; requesting.order;
	  });

	  if (!isRequired) {
	    var _requesting &#x3D; &#x27;&#x60;&#x27; + requestingName + &#x27;&#x60;&#x27;;
	    var requested &#x3D; &#x27;&#x60;&#x27; + requestedName + &#x27;&#x60;&#x27;;
	    console.warn(requested + &#x27; modifier is required by &#x27; + _requesting + &#x27; modifier in order to work, be sure to include it before &#x27; + _requesting + &#x27;!&#x27;);
	  }
	  return isRequired;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function arrow(data, options) {
	  var _data$offsets$arrow;

	  // arrow depends on keepTogether in order to work
	  if (!isModifierRequired(data.instance.modifiers, &#x27;arrow&#x27;, &#x27;keepTogether&#x27;)) {
	    return data;
	  }

	  var arrowElement &#x3D; options.element;

	  // if arrowElement is a string, suppose it&#x27;s a CSS selector
	  if (typeof arrowElement &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	    arrowElement &#x3D; data.instance.popper.querySelector(arrowElement);

	    // if arrowElement is not found, don&#x27;t run the modifier
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    // if the arrowElement isn&#x27;t a query selector we must check that the
	    // provided DOM node is child of its popper node
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn(&#x27;WARNING: &#x60;arrow.element&#x60; must be child of its popper element!&#x27;);
	      return data;
	    }
	  }

	  var placement &#x3D; data.placement.split(&#x27;-&#x27;)[0];
	  var _data$offsets &#x3D; data.offsets,
	      popper &#x3D; _data$offsets.popper,
	      reference &#x3D; _data$offsets.reference;

	  var isVertical &#x3D; [&#x27;left&#x27;, &#x27;right&#x27;].indexOf(placement) !&#x3D;&#x3D; -1;

	  var len &#x3D; isVertical ? &#x27;height&#x27; : &#x27;width&#x27;;
	  var sideCapitalized &#x3D; isVertical ? &#x27;Top&#x27; : &#x27;Left&#x27;;
	  var side &#x3D; sideCapitalized.toLowerCase();
	  var altSide &#x3D; isVertical ? &#x27;left&#x27; : &#x27;top&#x27;;
	  var opSide &#x3D; isVertical ? &#x27;bottom&#x27; : &#x27;right&#x27;;
	  var arrowElementSize &#x3D; getOuterSizes(arrowElement)[len];

	  //
	  // extends keepTogether behavior making sure the popper and its
	  // reference have enough pixels in conjuction
	  //

	  // top/left side
	  if (reference[opSide] - arrowElementSize &lt; popper[side]) {
	    data.offsets.popper[side] -&#x3D; popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  // bottom/right side
	  if (reference[side] + arrowElementSize &gt; popper[opSide]) {
	    data.offsets.popper[side] +&#x3D; reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper &#x3D; getClientRect(data.offsets.popper);

	  // compute center of the popper
	  var center &#x3D; reference[side] + reference[len] / 2 - arrowElementSize / 2;

	  // Compute the sideValue using the updated popper offsets
	  // take popper margin in account because we don&#x27;t have this info available
	  var css &#x3D; getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide &#x3D; parseFloat(css[&#x27;margin&#x27; + sideCapitalized], 10);
	  var popperBorderSide &#x3D; parseFloat(css[&#x27;border&#x27; + sideCapitalized + &#x27;Width&#x27;], 10);
	  var sideValue &#x3D; center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

	  // prevent arrowElement from being placed not contiguously to its popper
	  sideValue &#x3D; Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

	  data.arrowElement &#x3D; arrowElement;
	  data.offsets.arrow &#x3D; (_data$offsets$arrow &#x3D; {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, &#x27;&#x27;), _data$offsets$arrow);

	  return data;
	}

	/**
	 * Get the opposite placement variation of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement variation
	 * @returns {String} flipped placement variation
	 */
	function getOppositeVariation(variation) {
	  if (variation &#x3D;&#x3D;&#x3D; &#x27;end&#x27;) {
	    return &#x27;start&#x27;;
	  } else if (variation &#x3D;&#x3D;&#x3D; &#x27;start&#x27;) {
	    return &#x27;end&#x27;;
	  }
	  return variation;
	}

	/**
	 * List of accepted placements to use as values of the &#x60;placement&#x60; option.&lt;br /&gt;
	 * Valid placements are:
	 * - &#x60;auto&#x60;
	 * - &#x60;top&#x60;
	 * - &#x60;right&#x60;
	 * - &#x60;bottom&#x60;
	 * - &#x60;left&#x60;
	 *
	 * Each placement can have a variation from this list:
	 * - &#x60;-start&#x60;
	 * - &#x60;-end&#x60;
	 *
	 * Variations are interpreted easily if you think of them as the left to right
	 * written languages. Horizontally (&#x60;top&#x60; and &#x60;bottom&#x60;), &#x60;start&#x60; is left and &#x60;end&#x60;
	 * is right.&lt;br /&gt;
	 * Vertically (&#x60;left&#x60; and &#x60;right&#x60;), &#x60;start&#x60; is top and &#x60;end&#x60; is bottom.
	 *
	 * Some valid examples are:
	 * - &#x60;top-end&#x60; (on top of reference, right aligned)
	 * - &#x60;right-start&#x60; (on right of reference, top aligned)
	 * - &#x60;bottom&#x60; (on bottom, centered)
	 * - &#x60;auto-right&#x60; (on the side with more space available, alignment depends by placement)
	 *
	 * @static
	 * @type {Array}
	 * @enum {String}
	 * @readonly
	 * @method placements
	 * @memberof Popper
	 */
	var placements &#x3D; [&#x27;auto-start&#x27;, &#x27;auto&#x27;, &#x27;auto-end&#x27;, &#x27;top-start&#x27;, &#x27;top&#x27;, &#x27;top-end&#x27;, &#x27;right-start&#x27;, &#x27;right&#x27;, &#x27;right-end&#x27;, &#x27;bottom-end&#x27;, &#x27;bottom&#x27;, &#x27;bottom-start&#x27;, &#x27;left-end&#x27;, &#x27;left&#x27;, &#x27;left-start&#x27;];

	// Get rid of &#x60;auto&#x60; &#x60;auto-start&#x60; and &#x60;auto-end&#x60;
	var validPlacements &#x3D; placements.slice(3);

	/**
	 * Given an initial placement, returns all the subsequent placements
	 * clockwise (or counter-clockwise).
	 *
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement - A valid placement (it accepts variations)
	 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
	 * @returns {Array} placements including their variations
	 */
	function clockwise(placement) {
	  var counter &#x3D; arguments.length &gt; 1 &amp;&amp; arguments[1] !&#x3D;&#x3D; undefined ? arguments[1] : false;

	  var index &#x3D; validPlacements.indexOf(placement);
	  var arr &#x3D; validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}

	var BEHAVIORS &#x3D; {
	  FLIP: &#x27;flip&#x27;,
	  CLOCKWISE: &#x27;clockwise&#x27;,
	  COUNTERCLOCKWISE: &#x27;counterclockwise&#x27;
	};

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function flip(data, options) {
	  // if &#x60;inner&#x60; modifier is enabled, we can&#x27;t use the &#x60;flip&#x60; modifier
	  if (isModifierEnabled(data.instance.modifiers, &#x27;inner&#x27;)) {
	    return data;
	  }

	  if (data.flipped &amp;&amp; data.placement &#x3D;&#x3D;&#x3D; data.originalPlacement) {
	    // seems like flip is trying to loop, probably there&#x27;s not enough space on any of the flippable sides
	    return data;
	  }

	  var boundaries &#x3D; getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

	  var placement &#x3D; data.placement.split(&#x27;-&#x27;)[0];
	  var placementOpposite &#x3D; getOppositePlacement(placement);
	  var variation &#x3D; data.placement.split(&#x27;-&#x27;)[1] || &#x27;&#x27;;

	  var flipOrder &#x3D; [];

	  switch (options.behavior) {
	    case BEHAVIORS.FLIP:
	      flipOrder &#x3D; [placement, placementOpposite];
	      break;
	    case BEHAVIORS.CLOCKWISE:
	      flipOrder &#x3D; clockwise(placement);
	      break;
	    case BEHAVIORS.COUNTERCLOCKWISE:
	      flipOrder &#x3D; clockwise(placement, true);
	      break;
	    default:
	      flipOrder &#x3D; options.behavior;
	  }

	  flipOrder.forEach(function (step, index) {
	    if (placement !&#x3D;&#x3D; step || flipOrder.length &#x3D;&#x3D;&#x3D; index + 1) {
	      return data;
	    }

	    placement &#x3D; data.placement.split(&#x27;-&#x27;)[0];
	    placementOpposite &#x3D; getOppositePlacement(placement);

	    var popperOffsets &#x3D; data.offsets.popper;
	    var refOffsets &#x3D; data.offsets.reference;

	    // using floor because the reference offsets may contain decimals we are not going to consider here
	    var floor &#x3D; Math.floor;
	    var overlapsRef &#x3D; placement &#x3D;&#x3D;&#x3D; &#x27;left&#x27; &amp;&amp; floor(popperOffsets.right) &gt; floor(refOffsets.left) || placement &#x3D;&#x3D;&#x3D; &#x27;right&#x27; &amp;&amp; floor(popperOffsets.left) &lt; floor(refOffsets.right) || placement &#x3D;&#x3D;&#x3D; &#x27;top&#x27; &amp;&amp; floor(popperOffsets.bottom) &gt; floor(refOffsets.top) || placement &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; &amp;&amp; floor(popperOffsets.top) &lt; floor(refOffsets.bottom);

	    var overflowsLeft &#x3D; floor(popperOffsets.left) &lt; floor(boundaries.left);
	    var overflowsRight &#x3D; floor(popperOffsets.right) &gt; floor(boundaries.right);
	    var overflowsTop &#x3D; floor(popperOffsets.top) &lt; floor(boundaries.top);
	    var overflowsBottom &#x3D; floor(popperOffsets.bottom) &gt; floor(boundaries.bottom);

	    var overflowsBoundaries &#x3D; placement &#x3D;&#x3D;&#x3D; &#x27;left&#x27; &amp;&amp; overflowsLeft || placement &#x3D;&#x3D;&#x3D; &#x27;right&#x27; &amp;&amp; overflowsRight || placement &#x3D;&#x3D;&#x3D; &#x27;top&#x27; &amp;&amp; overflowsTop || placement &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; &amp;&amp; overflowsBottom;

	    // flip the variation if required
	    var isVertical &#x3D; [&#x27;top&#x27;, &#x27;bottom&#x27;].indexOf(placement) !&#x3D;&#x3D; -1;
	    var flippedVariation &#x3D; !!options.flipVariations &amp;&amp; (isVertical &amp;&amp; variation &#x3D;&#x3D;&#x3D; &#x27;start&#x27; &amp;&amp; overflowsLeft || isVertical &amp;&amp; variation &#x3D;&#x3D;&#x3D; &#x27;end&#x27; &amp;&amp; overflowsRight || !isVertical &amp;&amp; variation &#x3D;&#x3D;&#x3D; &#x27;start&#x27; &amp;&amp; overflowsTop || !isVertical &amp;&amp; variation &#x3D;&#x3D;&#x3D; &#x27;end&#x27; &amp;&amp; overflowsBottom);

	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      // this boolean to detect any flip loop
	      data.flipped &#x3D; true;

	      if (overlapsRef || overflowsBoundaries) {
	        placement &#x3D; flipOrder[index + 1];
	      }

	      if (flippedVariation) {
	        variation &#x3D; getOppositeVariation(variation);
	      }

	      data.placement &#x3D; placement + (variation ? &#x27;-&#x27; + variation : &#x27;&#x27;);

	      // this object contains &#x60;position&#x60;, we want to preserve it along with
	      // any additional property we may add in the future
	      data.offsets.popper &#x3D; _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

	      data &#x3D; runModifiers(data.instance.modifiers, data, &#x27;flip&#x27;);
	    }
	  });
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function keepTogether(data) {
	  var _data$offsets &#x3D; data.offsets,
	      popper &#x3D; _data$offsets.popper,
	      reference &#x3D; _data$offsets.reference;

	  var placement &#x3D; data.placement.split(&#x27;-&#x27;)[0];
	  var floor &#x3D; Math.floor;
	  var isVertical &#x3D; [&#x27;top&#x27;, &#x27;bottom&#x27;].indexOf(placement) !&#x3D;&#x3D; -1;
	  var side &#x3D; isVertical ? &#x27;right&#x27; : &#x27;bottom&#x27;;
	  var opSide &#x3D; isVertical ? &#x27;left&#x27; : &#x27;top&#x27;;
	  var measurement &#x3D; isVertical ? &#x27;width&#x27; : &#x27;height&#x27;;

	  if (popper[side] &lt; floor(reference[opSide])) {
	    data.offsets.popper[opSide] &#x3D; floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] &gt; floor(reference[side])) {
	    data.offsets.popper[opSide] &#x3D; floor(reference[side]);
	  }

	  return data;
	}

	/**
	 * Converts a string containing value + unit into a px value number
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} str - Value + unit string
	 * @argument {String} measurement - &#x60;height&#x60; or &#x60;width&#x60;
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @returns {Number|String}
	 * Value in pixels, or original string if no values were extracted
	 */
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  // separate value from unit
	  var split &#x3D; str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value &#x3D; +split[1];
	  var unit &#x3D; split[2];

	  // If it&#x27;s not a number it&#x27;s an operator, I guess
	  if (!value) {
	    return str;
	  }

	  if (unit.indexOf(&#x27;%&#x27;) &#x3D;&#x3D;&#x3D; 0) {
	    var element &#x3D; void 0;
	    switch (unit) {
	      case &#x27;%p&#x27;:
	        element &#x3D; popperOffsets;
	        break;
	      case &#x27;%&#x27;:
	      case &#x27;%r&#x27;:
	      default:
	        element &#x3D; referenceOffsets;
	    }

	    var rect &#x3D; getClientRect(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit &#x3D;&#x3D;&#x3D; &#x27;vh&#x27; || unit &#x3D;&#x3D;&#x3D; &#x27;vw&#x27;) {
	    // if is a vh or vw, we calculate the size based on the viewport
	    var size &#x3D; void 0;
	    if (unit &#x3D;&#x3D;&#x3D; &#x27;vh&#x27;) {
	      size &#x3D; Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size &#x3D; Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    // if is an explicit pixel unit, we get rid of the unit and keep the value
	    // if is an implicit unit, it&#x27;s px, and we return just the value
	    return value;
	  }
	}

	/**
	 * Parse an &#x60;offset&#x60; string to extrapolate &#x60;x&#x60; and &#x60;y&#x60; numeric offsets.
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} offset
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @argument {String} basePlacement
	 * @returns {Array} a two cells array with x and y offsets in numbers
	 */
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets &#x3D; [0, 0];

	  // Use height if placement is left or right and index is 0 otherwise use width
	  // in this way the first offset will use an axis and the second one
	  // will use the other one
	  var useHeight &#x3D; [&#x27;right&#x27;, &#x27;left&#x27;].indexOf(basePlacement) !&#x3D;&#x3D; -1;

	  // Split the offset string to obtain a list of values and operands
	  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
	  var fragments &#x3D; offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });

	  // Detect if the offset string contains a pair of values or a single one
	  // they could be separated by comma or space
	  var divider &#x3D; fragments.indexOf(find(fragments, function (frag) {
	    return frag.search(/,|\s/) !&#x3D;&#x3D; -1;
	  }));

	  if (fragments[divider] &amp;&amp; fragments[divider].indexOf(&#x27;,&#x27;) &#x3D;&#x3D;&#x3D; -1) {
	    console.warn(&#x27;Offsets separated by white space(s) are deprecated, use a comma (,) instead.&#x27;);
	  }

	  // If divider is found, we divide the list of values and operands to divide
	  // them by ofset X and Y.
	  var splitRegex &#x3D; /\s*,\s*|\s+/;
	  var ops &#x3D; divider !&#x3D;&#x3D; -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

	  // Convert the values with units to absolute pixels to allow our computations
	  ops &#x3D; ops.map(function (op, index) {
	    // Most of the units rely on the orientation of the popper
	    var measurement &#x3D; (index &#x3D;&#x3D;&#x3D; 1 ? !useHeight : useHeight) ? &#x27;height&#x27; : &#x27;width&#x27;;
	    var mergeWithPrevious &#x3D; false;
	    return op
	    // This aggregates any &#x60;+&#x60; or &#x60;-&#x60; sign that aren&#x27;t considered operators
	    // e.g.: 10 + +5 &#x3D;&gt; [10, +, +5]
	    .reduce(function (a, b) {
	      if (a[a.length - 1] &#x3D;&#x3D;&#x3D; &#x27;&#x27; &amp;&amp; [&#x27;+&#x27;, &#x27;-&#x27;].indexOf(b) !&#x3D;&#x3D; -1) {
	        a[a.length - 1] &#x3D; b;
	        mergeWithPrevious &#x3D; true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] +&#x3D; b;
	        mergeWithPrevious &#x3D; false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    // Here we convert the string values into number values (in px)
	    .map(function (str) {
	      return toValue(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });

	  // Loop trough the offsets arrays and execute the operations
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric(frag)) {
	        offsets[index] +&#x3D; frag * (op[index2 - 1] &#x3D;&#x3D;&#x3D; &#x27;-&#x27; ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @argument {Number|String} options.offset&#x3D;0
	 * The offset value as described in the modifier description
	 * @returns {Object} The data object, properly modified
	 */
	function offset(data, _ref) {
	  var offset &#x3D; _ref.offset;
	  var placement &#x3D; data.placement,
	      _data$offsets &#x3D; data.offsets,
	      popper &#x3D; _data$offsets.popper,
	      reference &#x3D; _data$offsets.reference;

	  var basePlacement &#x3D; placement.split(&#x27;-&#x27;)[0];

	  var offsets &#x3D; void 0;
	  if (isNumeric(+offset)) {
	    offsets &#x3D; [+offset, 0];
	  } else {
	    offsets &#x3D; parseOffset(offset, popper, reference, basePlacement);
	  }

	  if (basePlacement &#x3D;&#x3D;&#x3D; &#x27;left&#x27;) {
	    popper.top +&#x3D; offsets[0];
	    popper.left -&#x3D; offsets[1];
	  } else if (basePlacement &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
	    popper.top +&#x3D; offsets[0];
	    popper.left +&#x3D; offsets[1];
	  } else if (basePlacement &#x3D;&#x3D;&#x3D; &#x27;top&#x27;) {
	    popper.left +&#x3D; offsets[0];
	    popper.top -&#x3D; offsets[1];
	  } else if (basePlacement &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;) {
	    popper.left +&#x3D; offsets[0];
	    popper.top +&#x3D; offsets[1];
	  }

	  data.popper &#x3D; popper;
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function preventOverflow(data, options) {
	  var boundariesElement &#x3D; options.boundariesElement || getOffsetParent(data.instance.popper);

	  // If offsetParent is the reference element, we really want to
	  // go one step up and use the next offsetParent as reference to
	  // avoid to make this modifier completely useless and look like broken
	  if (data.instance.reference &#x3D;&#x3D;&#x3D; boundariesElement) {
	    boundariesElement &#x3D; getOffsetParent(boundariesElement);
	  }

	  var boundaries &#x3D; getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
	  options.boundaries &#x3D; boundaries;

	  var order &#x3D; options.priority;
	  var popper &#x3D; data.offsets.popper;

	  var check &#x3D; {
	    primary: function primary(placement) {
	      var value &#x3D; popper[placement];
	      if (popper[placement] &lt; boundaries[placement] &amp;&amp; !options.escapeWithReference) {
	        value &#x3D; Math.max(popper[placement], boundaries[placement]);
	      }
	      return defineProperty({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide &#x3D; placement &#x3D;&#x3D;&#x3D; &#x27;right&#x27; ? &#x27;left&#x27; : &#x27;top&#x27;;
	      var value &#x3D; popper[mainSide];
	      if (popper[placement] &gt; boundaries[placement] &amp;&amp; !options.escapeWithReference) {
	        value &#x3D; Math.min(popper[mainSide], boundaries[placement] - (placement &#x3D;&#x3D;&#x3D; &#x27;right&#x27; ? popper.width : popper.height));
	      }
	      return defineProperty({}, mainSide, value);
	    }
	  };

	  order.forEach(function (placement) {
	    var side &#x3D; [&#x27;left&#x27;, &#x27;top&#x27;].indexOf(placement) !&#x3D;&#x3D; -1 ? &#x27;primary&#x27; : &#x27;secondary&#x27;;
	    popper &#x3D; _extends({}, popper, check[side](placement));
	  });

	  data.offsets.popper &#x3D; popper;

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function shift(data) {
	  var placement &#x3D; data.placement;
	  var basePlacement &#x3D; placement.split(&#x27;-&#x27;)[0];
	  var shiftvariation &#x3D; placement.split(&#x27;-&#x27;)[1];

	  // if shift shiftvariation is specified, run the modifier
	  if (shiftvariation) {
	    var _data$offsets &#x3D; data.offsets,
	        reference &#x3D; _data$offsets.reference,
	        popper &#x3D; _data$offsets.popper;

	    var isVertical &#x3D; [&#x27;bottom&#x27;, &#x27;top&#x27;].indexOf(basePlacement) !&#x3D;&#x3D; -1;
	    var side &#x3D; isVertical ? &#x27;left&#x27; : &#x27;top&#x27;;
	    var measurement &#x3D; isVertical ? &#x27;width&#x27; : &#x27;height&#x27;;

	    var shiftOffsets &#x3D; {
	      start: defineProperty({}, side, reference[side]),
	      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };

	    data.offsets.popper &#x3D; _extends({}, popper, shiftOffsets[shiftvariation]);
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, &#x27;hide&#x27;, &#x27;preventOverflow&#x27;)) {
	    return data;
	  }

	  var refRect &#x3D; data.offsets.reference;
	  var bound &#x3D; find(data.instance.modifiers, function (modifier) {
	    return modifier.name &#x3D;&#x3D;&#x3D; &#x27;preventOverflow&#x27;;
	  }).boundaries;

	  if (refRect.bottom &lt; bound.top || refRect.left &gt; bound.right || refRect.top &gt; bound.bottom || refRect.right &lt; bound.left) {
	    // Avoid unnecessary DOM access if visibility hasn&#x27;t changed
	    if (data.hide &#x3D;&#x3D;&#x3D; true) {
	      return data;
	    }

	    data.hide &#x3D; true;
	    data.attributes[&#x27;x-out-of-boundaries&#x27;] &#x3D; &#x27;&#x27;;
	  } else {
	    // Avoid unnecessary DOM access if visibility hasn&#x27;t changed
	    if (data.hide &#x3D;&#x3D;&#x3D; false) {
	      return data;
	    }

	    data.hide &#x3D; false;
	    data.attributes[&#x27;x-out-of-boundaries&#x27;] &#x3D; false;
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function inner(data) {
	  var placement &#x3D; data.placement;
	  var basePlacement &#x3D; placement.split(&#x27;-&#x27;)[0];
	  var _data$offsets &#x3D; data.offsets,
	      popper &#x3D; _data$offsets.popper,
	      reference &#x3D; _data$offsets.reference;

	  var isHoriz &#x3D; [&#x27;left&#x27;, &#x27;right&#x27;].indexOf(basePlacement) !&#x3D;&#x3D; -1;

	  var subtractLength &#x3D; [&#x27;top&#x27;, &#x27;left&#x27;].indexOf(basePlacement) &#x3D;&#x3D;&#x3D; -1;

	  popper[isHoriz ? &#x27;left&#x27; : &#x27;top&#x27;] &#x3D; reference[basePlacement] - (subtractLength ? popper[isHoriz ? &#x27;width&#x27; : &#x27;height&#x27;] : 0);

	  data.placement &#x3D; getOppositePlacement(placement);
	  data.offsets.popper &#x3D; getClientRect(popper);

	  return data;
	}

	/**
	 * Modifier function, each modifier can have a function of this type assigned
	 * to its &#x60;fn&#x60; property.&lt;br /&gt;
	 * These functions will be called on each update, this means that you must
	 * make sure they are performant enough to avoid performance bottlenecks.
	 *
	 * @function ModifierFn
	 * @argument {dataObject} data - The data object generated by &#x60;update&#x60; method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {dataObject} The data object, properly modified
	 */

	/**
	 * Modifiers are plugins used to alter the behavior of your poppers.&lt;br /&gt;
	 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
	 * needed by the library.
	 *
	 * Usually you don&#x27;t want to override the &#x60;order&#x60;, &#x60;fn&#x60; and &#x60;onLoad&#x60; props.
	 * All the other properties are configurations that could be tweaked.
	 * @namespace modifiers
	 */
	var modifiers &#x3D; {
	  /**
	   * Modifier used to shift the popper on the start or end of its reference
	   * element.&lt;br /&gt;
	   * It will read the variation of the &#x60;placement&#x60; property.&lt;br /&gt;
	   * It can be one either &#x60;-end&#x60; or &#x60;-start&#x60;.
	   * @memberof modifiers
	   * @inner
	   */
	  shift: {
	    /** @prop {number} order&#x3D;100 - Index used to define the order of execution */
	    order: 100,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: shift
	  },

	  /**
	   * The &#x60;offset&#x60; modifier can shift your popper on both its axis.
	   *
	   * It accepts the following units:
	   * - &#x60;px&#x60; or unitless, interpreted as pixels
	   * - &#x60;%&#x60; or &#x60;%r&#x60;, percentage relative to the length of the reference element
	   * - &#x60;%p&#x60;, percentage relative to the length of the popper element
	   * - &#x60;vw&#x60;, CSS viewport width unit
	   * - &#x60;vh&#x60;, CSS viewport height unit
	   *
	   * For length is intended the main axis relative to the placement of the popper.&lt;br /&gt;
	   * This means that if the placement is &#x60;top&#x60; or &#x60;bottom&#x60;, the length will be the
	   * &#x60;width&#x60;. In case of &#x60;left&#x60; or &#x60;right&#x60;, it will be the height.
	   *
	   * You can provide a single value (as &#x60;Number&#x60; or &#x60;String&#x60;), or a pair of values
	   * as &#x60;String&#x60; divided by a comma or one (or more) white spaces.&lt;br /&gt;
	   * The latter is a deprecated method because it leads to confusion and will be
	   * removed in v2.&lt;br /&gt;
	   * Additionally, it accepts additions and subtractions between different units.
	   * Note that multiplications and divisions aren&#x27;t supported.
	   *
	   * Valid examples are:
	   * &#x60;&#x60;&#x60;
	   * 10
	   * &#x27;10%&#x27;
	   * &#x27;10, 10&#x27;
	   * &#x27;10%, 10&#x27;
	   * &#x27;10 + 10%&#x27;
	   * &#x27;10 - 5vh + 3%&#x27;
	   * &#x27;-10px + 5vh, 5px - 6%&#x27;
	   * &#x60;&#x60;&#x60;
	   * &gt; **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
	   * &gt; with their reference element, unfortunately, you will have to disable the &#x60;flip&#x60; modifier.
	   * &gt; More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  offset: {
	    /** @prop {number} order&#x3D;200 - Index used to define the order of execution */
	    order: 200,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: offset,
	    /** @prop {Number|String} offset&#x3D;0
	     * The offset value as described in the modifier description
	     */
	    offset: 0
	  },

	  /**
	   * Modifier used to prevent the popper from being positioned outside the boundary.
	   *
	   * An scenario exists where the reference itself is not within the boundaries.&lt;br /&gt;
	   * We can say it has &quot;escaped the boundaries&quot; — or just &quot;escaped&quot;.&lt;br /&gt;
	   * In this case we need to decide whether the popper should either:
	   *
	   * - detach from the reference and remain &quot;trapped&quot; in the boundaries, or
	   * - if it should ignore the boundary and &quot;escape with its reference&quot;
	   *
	   * When &#x60;escapeWithReference&#x60; is set to&#x60;true&#x60; and reference is completely
	   * outside its boundaries, the popper will overflow (or completely leave)
	   * the boundaries in order to remain attached to the edge of the reference.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  preventOverflow: {
	    /** @prop {number} order&#x3D;300 - Index used to define the order of execution */
	    order: 300,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: preventOverflow,
	    /**
	     * @prop {Array} [priority&#x3D;[&#x27;left&#x27;,&#x27;right&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;]]
	     * Popper will try to prevent overflow following these priorities by default,
	     * then, it could overflow on the left and on top of the &#x60;boundariesElement&#x60;
	     */
	    priority: [&#x27;left&#x27;, &#x27;right&#x27;, &#x27;top&#x27;, &#x27;bottom&#x27;],
	    /**
	     * @prop {number} padding&#x3D;5
	     * Amount of pixel used to define a minimum distance between the boundaries
	     * and the popper this makes sure the popper has always a little padding
	     * between the edges of its container
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement&#x3D;&#x27;scrollParent&#x27;
	     * Boundaries used by the modifier, can be &#x60;scrollParent&#x60;, &#x60;window&#x60;,
	     * &#x60;viewport&#x60; or any DOM element.
	     */
	    boundariesElement: &#x27;scrollParent&#x27;
	  },

	  /**
	   * Modifier used to make sure the reference and its popper stay near eachothers
	   * without leaving any gap between the two. Expecially useful when the arrow is
	   * enabled and you want to assure it to point to its reference element.
	   * It cares only about the first axis, you can still have poppers with margin
	   * between the popper and its reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  keepTogether: {
	    /** @prop {number} order&#x3D;400 - Index used to define the order of execution */
	    order: 400,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: keepTogether
	  },

	  /**
	   * This modifier is used to move the &#x60;arrowElement&#x60; of the popper to make
	   * sure it is positioned between the reference element and its popper element.
	   * It will read the outer size of the &#x60;arrowElement&#x60; node to detect how many
	   * pixels of conjuction are needed.
	   *
	   * It has no effect if no &#x60;arrowElement&#x60; is provided.
	   * @memberof modifiers
	   * @inner
	   */
	  arrow: {
	    /** @prop {number} order&#x3D;500 - Index used to define the order of execution */
	    order: 500,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: arrow,
	    /** @prop {String|HTMLElement} element&#x3D;&#x27;[x-arrow]&#x27; - Selector or node used as arrow */
	    element: &#x27;[x-arrow]&#x27;
	  },

	  /**
	   * Modifier used to flip the popper&#x27;s placement when it starts to overlap its
	   * reference element.
	   *
	   * Requires the &#x60;preventOverflow&#x60; modifier before it in order to work.
	   *
	   * **NOTE:** this modifier will interrupt the current update cycle and will
	   * restart it if it detects the need to flip the placement.
	   * @memberof modifiers
	   * @inner
	   */
	  flip: {
	    /** @prop {number} order&#x3D;600 - Index used to define the order of execution */
	    order: 600,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: flip,
	    /**
	     * @prop {String|Array} behavior&#x3D;&#x27;flip&#x27;
	     * The behavior used to change the popper&#x27;s placement. It can be one of
	     * &#x60;flip&#x60;, &#x60;clockwise&#x60;, &#x60;counterclockwise&#x60; or an array with a list of valid
	     * placements (with optional variations).
	     */
	    behavior: &#x27;flip&#x27;,
	    /**
	     * @prop {number} padding&#x3D;5
	     * The popper will flip if it hits the edges of the &#x60;boundariesElement&#x60;
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement&#x3D;&#x27;viewport&#x27;
	     * The element which will define the boundaries of the popper position,
	     * the popper will never be placed outside of the defined boundaries
	     * (except if keepTogether is enabled)
	     */
	    boundariesElement: &#x27;viewport&#x27;
	  },

	  /**
	   * Modifier used to make the popper flow toward the inner of the reference element.
	   * By default, when this modifier is disabled, the popper will be placed outside
	   * the reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  inner: {
	    /** @prop {number} order&#x3D;700 - Index used to define the order of execution */
	    order: 700,
	    /** @prop {Boolean} enabled&#x3D;false - Whether the modifier is enabled or not */
	    enabled: false,
	    /** @prop {ModifierFn} */
	    fn: inner
	  },

	  /**
	   * Modifier used to hide the popper when its reference element is outside of the
	   * popper boundaries. It will set a &#x60;x-out-of-boundaries&#x60; attribute which can
	   * be used to hide with a CSS selector the popper when its reference is
	   * out of boundaries.
	   *
	   * Requires the &#x60;preventOverflow&#x60; modifier before it in order to work.
	   * @memberof modifiers
	   * @inner
	   */
	  hide: {
	    /** @prop {number} order&#x3D;800 - Index used to define the order of execution */
	    order: 800,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: hide
	  },

	  /**
	   * Computes the style that will be applied to the popper element to gets
	   * properly positioned.
	   *
	   * Note that this modifier will not touch the DOM, it just prepares the styles
	   * so that &#x60;applyStyle&#x60; modifier can apply it. This separation is useful
	   * in case you need to replace &#x60;applyStyle&#x60; with a custom implementation.
	   *
	   * This modifier has &#x60;850&#x60; as &#x60;order&#x60; value to maintain backward compatibility
	   * with previous versions of Popper.js. Expect the modifiers ordering method
	   * to change in future major versions of the library.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  computeStyle: {
	    /** @prop {number} order&#x3D;850 - Index used to define the order of execution */
	    order: 850,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: computeStyle,
	    /**
	     * @prop {Boolean} gpuAcceleration&#x3D;true
	     * If true, it uses the CSS 3d transformation to position the popper.
	     * Otherwise, it will use the &#x60;top&#x60; and &#x60;left&#x60; properties.
	     */
	    gpuAcceleration: true,
	    /**
	     * @prop {string} [x&#x3D;&#x27;bottom&#x27;]
	     * Where to anchor the X axis (&#x60;bottom&#x60; or &#x60;top&#x60;). AKA X offset origin.
	     * Change this if your popper should grow in a direction different from &#x60;bottom&#x60;
	     */
	    x: &#x27;bottom&#x27;,
	    /**
	     * @prop {string} [x&#x3D;&#x27;left&#x27;]
	     * Where to anchor the Y axis (&#x60;left&#x60; or &#x60;right&#x60;). AKA Y offset origin.
	     * Change this if your popper should grow in a direction different from &#x60;right&#x60;
	     */
	    y: &#x27;right&#x27;
	  },

	  /**
	   * Applies the computed styles to the popper element.
	   *
	   * All the DOM manipulations are limited to this modifier. This is useful in case
	   * you want to integrate Popper.js inside a framework or view library and you
	   * want to delegate all the DOM manipulations to it.
	   *
	   * Note that if you disable this modifier, you must make sure the popper element
	   * has its position set to &#x60;absolute&#x60; before Popper.js can do its work!
	   *
	   * Just disable this modifier and define you own to achieve the desired effect.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  applyStyle: {
	    /** @prop {number} order&#x3D;900 - Index used to define the order of execution */
	    order: 900,
	    /** @prop {Boolean} enabled&#x3D;true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: applyStyle,
	    /** @prop {Function} */
	    onLoad: applyStyleOnLoad,
	    /**
	     * @deprecated since version 1.10.0, the property moved to &#x60;computeStyle&#x60; modifier
	     * @prop {Boolean} gpuAcceleration&#x3D;true
	     * If true, it uses the CSS 3d transformation to position the popper.
	     * Otherwise, it will use the &#x60;top&#x60; and &#x60;left&#x60; properties.
	     */
	    gpuAcceleration: undefined
	  }
	};

	/**
	 * The &#x60;dataObject&#x60; is an object containing all the informations used by Popper.js
	 * this object get passed to modifiers and to the &#x60;onCreate&#x60; and &#x60;onUpdate&#x60; callbacks.
	 * @name dataObject
	 * @property {Object} data.instance The Popper.js instance
	 * @property {String} data.placement Placement applied to popper
	 * @property {String} data.originalPlacement Placement originally defined on init
	 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
	 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
	 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
	 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. &#x60;marginBottom&#x60;)
	 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. &#x60;marginBottom&#x60;)
	 * @property {Object} data.boundaries Offsets of the popper boundaries
	 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
	 * @property {Object} data.offsets.popper &#x60;top&#x60;, &#x60;left&#x60;, &#x60;width&#x60;, &#x60;height&#x60; values
	 * @property {Object} data.offsets.reference &#x60;top&#x60;, &#x60;left&#x60;, &#x60;width&#x60;, &#x60;height&#x60; values
	 * @property {Object} data.offsets.arrow] &#x60;top&#x60; and &#x60;left&#x60; offsets, only one of them will be different from 0
	 */

	/**
	 * Default options provided to Popper.js constructor.&lt;br /&gt;
	 * These can be overriden using the &#x60;options&#x60; argument of Popper.js.&lt;br /&gt;
	 * To override an option, simply pass as 3rd argument an object with the same
	 * structure of this object, example:
	 * &#x60;&#x60;&#x60;
	 * new Popper(ref, pop, {
	 *   modifiers: {
	 *     preventOverflow: { enabled: false }
	 *   }
	 * })
	 * &#x60;&#x60;&#x60;
	 * @type {Object}
	 * @static
	 * @memberof Popper
	 */
	var Defaults &#x3D; {
	  /**
	   * Popper&#x27;s placement
	   * @prop {Popper.placements} placement&#x3D;&#x27;bottom&#x27;
	   */
	  placement: &#x27;bottom&#x27;,

	  /**
	   * Set this to true if you want popper to position it self in &#x27;fixed&#x27; mode
	   * @prop {Boolean} positionFixed&#x3D;false
	   */
	  positionFixed: false,

	  /**
	   * Whether events (resize, scroll) are initially enabled
	   * @prop {Boolean} eventsEnabled&#x3D;true
	   */
	  eventsEnabled: true,

	  /**
	   * Set to true if you want to automatically remove the popper when
	   * you call the &#x60;destroy&#x60; method.
	   * @prop {Boolean} removeOnDestroy&#x3D;false
	   */
	  removeOnDestroy: false,

	  /**
	   * Callback called when the popper is created.&lt;br /&gt;
	   * By default, is set to no-op.&lt;br /&gt;
	   * Access Popper.js instance with &#x60;data.instance&#x60;.
	   * @prop {onCreate}
	   */
	  onCreate: function onCreate() {},

	  /**
	   * Callback called when the popper is updated, this callback is not called
	   * on the initialization/creation of the popper, but only on subsequent
	   * updates.&lt;br /&gt;
	   * By default, is set to no-op.&lt;br /&gt;
	   * Access Popper.js instance with &#x60;data.instance&#x60;.
	   * @prop {onUpdate}
	   */
	  onUpdate: function onUpdate() {},

	  /**
	   * List of modifiers used to modify the offsets before they are applied to the popper.
	   * They provide most of the functionalities of Popper.js
	   * @prop {modifiers}
	   */
	  modifiers: modifiers
	};

	/**
	 * @callback onCreate
	 * @param {dataObject} data
	 */

	/**
	 * @callback onUpdate
	 * @param {dataObject} data
	 */

	// Utils
	// Methods
	var Popper &#x3D; function () {
	  /**
	   * Create a new Popper.js instance
	   * @class Popper
	   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
	   * @param {HTMLElement} popper - The HTML element used as popper.
	   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
	   * @return {Object} instance - The generated Popper.js instance
	   */
	  function Popper(reference, popper) {
	    var _this &#x3D; this;

	    var options &#x3D; arguments.length &gt; 2 &amp;&amp; arguments[2] !&#x3D;&#x3D; undefined ? arguments[2] : {};
	    classCallCheck(this, Popper);

	    this.scheduleUpdate &#x3D; function () {
	      return requestAnimationFrame(_this.update);
	    };

	    // make update() debounced, so that it only runs at most once-per-tick
	    this.update &#x3D; debounce(this.update.bind(this));

	    // with {} we create a new object with the options inside it
	    this.options &#x3D; _extends({}, Popper.Defaults, options);

	    // init state
	    this.state &#x3D; {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };

	    // get reference and popper elements (allow jQuery wrappers)
	    this.reference &#x3D; reference &amp;&amp; reference.jquery ? reference[0] : reference;
	    this.popper &#x3D; popper &amp;&amp; popper.jquery ? popper[0] : popper;

	    // Deep merge modifiers options
	    this.options.modifiers &#x3D; {};
	    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] &#x3D; _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });

	    // Refactoring modifiers&#x27; list (Object &#x3D;&gt; Array)
	    this.modifiers &#x3D; Object.keys(this.options.modifiers).map(function (name) {
	      return _extends({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    // sort the modifiers by order
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });

	    // modifiers have the ability to execute arbitrary code when Popper.js get inited
	    // such code is executed in the same order of its modifier
	    // they could add new properties to their options configuration
	    // BE AWARE: don&#x27;t add options to &#x60;options.modifiers.name&#x60; but to &#x60;modifierOptions&#x60;!
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled &amp;&amp; isFunction(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });

	    // fire the first update to position the popper in the right place
	    this.update();

	    var eventsEnabled &#x3D; this.options.eventsEnabled;
	    if (eventsEnabled) {
	      // setup event listeners, they will take care of update the position in specific situations
	      this.enableEventListeners();
	    }

	    this.state.eventsEnabled &#x3D; eventsEnabled;
	  }

	  // We can&#x27;t use class properties because they don&#x27;t get listed in the
	  // class prototype and break stuff like Sinon stubs


	  createClass(Popper, [{
	    key: &#x27;update&#x27;,
	    value: function update$$1() {
	      return update.call(this);
	    }
	  }, {
	    key: &#x27;destroy&#x27;,
	    value: function destroy$$1() {
	      return destroy.call(this);
	    }
	  }, {
	    key: &#x27;enableEventListeners&#x27;,
	    value: function enableEventListeners$$1() {
	      return enableEventListeners.call(this);
	    }
	  }, {
	    key: &#x27;disableEventListeners&#x27;,
	    value: function disableEventListeners$$1() {
	      return disableEventListeners.call(this);
	    }

	    /**
	     * Schedule an update, it will run on the next UI update available
	     * @method scheduleUpdate
	     * @memberof Popper
	     */


	    /**
	     * Collection of utilities useful when writing custom modifiers.
	     * Starting from version 1.7, this method is available only if you
	     * include &#x60;popper-utils.js&#x60; before &#x60;popper.js&#x60;.
	     *
	     * **DEPRECATION**: This way to access PopperUtils is deprecated
	     * and will be removed in v2! Use the PopperUtils module directly instead.
	     * Due to the high instability of the methods contained in Utils, we can&#x27;t
	     * guarantee them to follow semver. Use them at your own risk!
	     * @static
	     * @private
	     * @type {Object}
	     * @deprecated since version 1.8
	     * @member Utils
	     * @memberof Popper
	     */

	  }]);
	  return Popper;
	}();

	/**
	 * The &#x60;referenceObject&#x60; is an object that provides an interface compatible with Popper.js
	 * and lets you use it as replacement of a real DOM node.&lt;br /&gt;
	 * You can use this method to position a popper relatively to a set of coordinates
	 * in case you don&#x27;t have a DOM node to use as reference.
	 *
	 * &#x60;&#x60;&#x60;
	 * new Popper(referenceObject, popperNode);
	 * &#x60;&#x60;&#x60;
	 *
	 * NB: This feature isn&#x27;t supported in Internet Explorer 10
	 * @name referenceObject
	 * @property {Function} data.getBoundingClientRect
	 * A function that returns a set of coordinates compatible with the native &#x60;getBoundingClientRect&#x60; method.
	 * @property {number} data.clientWidth
	 * An ES6 getter that will return the width of the virtual reference element.
	 * @property {number} data.clientHeight
	 * An ES6 getter that will return the height of the virtual reference element.
	 */


	Popper.Utils &#x3D; (typeof window !&#x3D;&#x3D; &#x27;undefined&#x27; ? window : global).PopperUtils;
	Popper.placements &#x3D; placements;
	Popper.Defaults &#x3D; Defaults;

	return Popper;

	})));
	//# sourceMappingURL&#x3D;popper.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	  * Bootstrap v4.0.0 (https://getbootstrap.com)
	  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	  */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(5), __webpack_require__(8)) :
		typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;exports&#x27;, &#x27;jquery&#x27;, &#x27;popper.js&#x27;], factory) :
		(factory((global.bootstrap &#x3D; {}),global.jQuery,global.Popper));
	}(this, (function (exports,$,Popper) { &#x27;use strict&#x27;;

	$ &#x3D; $ &amp;&amp; $.hasOwnProperty(&#x27;default&#x27;) ? $[&#x27;default&#x27;] : $;
	Popper &#x3D; Popper &amp;&amp; Popper.hasOwnProperty(&#x27;default&#x27;) ? Popper[&#x27;default&#x27;] : Popper;

	function _defineProperties(target, props) {
	  for (var i &#x3D; 0; i &lt; props.length; i++) {
	    var descriptor &#x3D; props[i];
	    descriptor.enumerable &#x3D; descriptor.enumerable || false;
	    descriptor.configurable &#x3D; true;
	    if (&quot;value&quot; in descriptor) descriptor.writable &#x3D; true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _extends() {
	  _extends &#x3D; Object.assign || function (target) {
	    for (var i &#x3D; 1; i &lt; arguments.length; i++) {
	      var source &#x3D; arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] &#x3D; source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype &#x3D; Object.create(superClass.prototype);
	  subClass.prototype.constructor &#x3D; subClass;
	  subClass.__proto__ &#x3D; superClass;
	}

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): util.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Util &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Private TransitionEnd Helpers
	   * ------------------------------------------------------------------------
	   */
	  var transition &#x3D; false;
	  var MAX_UID &#x3D; 1000000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

	  function toType(obj) {
	    return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
	  }

	  function getSpecialTransitionEndEvent() {
	    return {
	      bindType: transition.end,
	      delegateType: transition.end,
	      handle: function handle(event) {
	        if ($$$1(event.target).is(this)) {
	          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
	        }

	        return undefined; // eslint-disable-line no-undefined
	      }
	    };
	  }

	  function transitionEndTest() {
	    if (typeof window !&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; window.QUnit) {
	      return false;
	    }

	    return {
	      end: &#x27;transitionend&#x27;
	    };
	  }

	  function transitionEndEmulator(duration) {
	    var _this &#x3D; this;

	    var called &#x3D; false;
	    $$$1(this).one(Util.TRANSITION_END, function () {
	      called &#x3D; true;
	    });
	    setTimeout(function () {
	      if (!called) {
	        Util.triggerTransitionEnd(_this);
	      }
	    }, duration);
	    return this;
	  }

	  function setTransitionEndSupport() {
	    transition &#x3D; transitionEndTest();
	    $$$1.fn.emulateTransitionEnd &#x3D; transitionEndEmulator;

	    if (Util.supportsTransitionEnd()) {
	      $$$1.event.special[Util.TRANSITION_END] &#x3D; getSpecialTransitionEndEvent();
	    }
	  }

	  function escapeId(selector) {
	    // We escape IDs in case of special selectors (selector &#x3D; &#x27;#myId:something&#x27;)
	    // $.escapeSelector does not exist in jQuery &lt; 3
	    selector &#x3D; typeof $$$1.escapeSelector &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? $$$1.escapeSelector(selector).substr(1) : selector.replace(/(:|\.|\[|\]|,|&#x3D;|@)/g, &#x27;\\$1&#x27;);
	    return selector;
	  }
	  /**
	   * --------------------------------------------------------------------------
	   * Public Util Api
	   * --------------------------------------------------------------------------
	   */


	  var Util &#x3D; {
	    TRANSITION_END: &#x27;bsTransitionEnd&#x27;,
	    getUID: function getUID(prefix) {
	      do {
	        // eslint-disable-next-line no-bitwise
	        prefix +&#x3D; ~~(Math.random() * MAX_UID); // &quot;~~&quot; acts like a faster Math.floor() here
	      } while (document.getElementById(prefix));

	      return prefix;
	    },
	    getSelectorFromElement: function getSelectorFromElement(element) {
	      var selector &#x3D; element.getAttribute(&#x27;data-target&#x27;);

	      if (!selector || selector &#x3D;&#x3D;&#x3D; &#x27;#&#x27;) {
	        selector &#x3D; element.getAttribute(&#x27;href&#x27;) || &#x27;&#x27;;
	      } // If it&#x27;s an ID


	      if (selector.charAt(0) &#x3D;&#x3D;&#x3D; &#x27;#&#x27;) {
	        selector &#x3D; escapeId(selector);
	      }

	      try {
	        var $selector &#x3D; $$$1(document).find(selector);
	        return $selector.length &gt; 0 ? selector : null;
	      } catch (err) {
	        return null;
	      }
	    },
	    reflow: function reflow(element) {
	      return element.offsetHeight;
	    },
	    triggerTransitionEnd: function triggerTransitionEnd(element) {
	      $$$1(element).trigger(transition.end);
	    },
	    supportsTransitionEnd: function supportsTransitionEnd() {
	      return Boolean(transition);
	    },
	    isElement: function isElement(obj) {
	      return (obj[0] || obj).nodeType;
	    },
	    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
	      for (var property in configTypes) {
	        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
	          var expectedTypes &#x3D; configTypes[property];
	          var value &#x3D; config[property];
	          var valueType &#x3D; value &amp;&amp; Util.isElement(value) ? &#x27;element&#x27; : toType(value);

	          if (!new RegExp(expectedTypes).test(valueType)) {
	            throw new Error(componentName.toUpperCase() + &quot;: &quot; + (&quot;Option \&quot;&quot; + property + &quot;\&quot; provided type \&quot;&quot; + valueType + &quot;\&quot; &quot;) + (&quot;but expected type \&quot;&quot; + expectedTypes + &quot;\&quot;.&quot;));
	          }
	        }
	      }
	    }
	  };
	  setTransitionEndSupport();
	  return Util;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): alert.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Alert &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;alert&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.alert&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var TRANSITION_DURATION &#x3D; 150;
	  var Selector &#x3D; {
	    DISMISS: &#x27;[data-dismiss&#x3D;&quot;alert&quot;]&#x27;
	  };
	  var Event &#x3D; {
	    CLOSE: &quot;close&quot; + EVENT_KEY,
	    CLOSED: &quot;closed&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName &#x3D; {
	    ALERT: &#x27;alert&#x27;,
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Alert &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Alert(element) {
	      this._element &#x3D; element;
	    } // Getters


	    var _proto &#x3D; Alert.prototype;

	    // Public
	    _proto.close &#x3D; function close(element) {
	      element &#x3D; element || this._element;

	      var rootElement &#x3D; this._getRootElement(element);

	      var customEvent &#x3D; this._triggerCloseEvent(rootElement);

	      if (customEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._removeElement(rootElement);
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._element &#x3D; null;
	    }; // Private


	    _proto._getRootElement &#x3D; function _getRootElement(element) {
	      var selector &#x3D; Util.getSelectorFromElement(element);
	      var parent &#x3D; false;

	      if (selector) {
	        parent &#x3D; $$$1(selector)[0];
	      }

	      if (!parent) {
	        parent &#x3D; $$$1(element).closest(&quot;.&quot; + ClassName.ALERT)[0];
	      }

	      return parent;
	    };

	    _proto._triggerCloseEvent &#x3D; function _triggerCloseEvent(element) {
	      var closeEvent &#x3D; $$$1.Event(Event.CLOSE);
	      $$$1(element).trigger(closeEvent);
	      return closeEvent;
	    };

	    _proto._removeElement &#x3D; function _removeElement(element) {
	      var _this &#x3D; this;

	      $$$1(element).removeClass(ClassName.SHOW);

	      if (!Util.supportsTransitionEnd() || !$$$1(element).hasClass(ClassName.FADE)) {
	        this._destroyElement(element);

	        return;
	      }

	      $$$1(element).one(Util.TRANSITION_END, function (event) {
	        return _this._destroyElement(element, event);
	      }).emulateTransitionEnd(TRANSITION_DURATION);
	    };

	    _proto._destroyElement &#x3D; function _destroyElement(element) {
	      $$$1(element).detach().trigger(Event.CLOSED).remove();
	    }; // Static


	    Alert._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var $element &#x3D; $$$1(this);
	        var data &#x3D; $element.data(DATA_KEY);

	        if (!data) {
	          data &#x3D; new Alert(this);
	          $element.data(DATA_KEY, data);
	        }

	        if (config &#x3D;&#x3D;&#x3D; &#x27;close&#x27;) {
	          data[config](this);
	        }
	      });
	    };

	    Alert._handleDismiss &#x3D; function _handleDismiss(alertInstance) {
	      return function (event) {
	        if (event) {
	          event.preventDefault();
	        }

	        alertInstance.close(this);
	      };
	    };

	    _createClass(Alert, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Alert;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; Alert._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Alert;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Alert._jQueryInterface;
	  };

	  return Alert;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): button.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Button &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;button&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.button&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var ClassName &#x3D; {
	    ACTIVE: &#x27;active&#x27;,
	    BUTTON: &#x27;btn&#x27;,
	    FOCUS: &#x27;focus&#x27;
	  };
	  var Selector &#x3D; {
	    DATA_TOGGLE_CARROT: &#x27;[data-toggle^&#x3D;&quot;button&quot;]&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle&#x3D;&quot;buttons&quot;]&#x27;,
	    INPUT: &#x27;input&#x27;,
	    ACTIVE: &#x27;.active&#x27;,
	    BUTTON: &#x27;.btn&#x27;
	  };
	  var Event &#x3D; {
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
	    FOCUS_BLUR_DATA_API: &quot;focus&quot; + EVENT_KEY + DATA_API_KEY + &quot; &quot; + (&quot;blur&quot; + EVENT_KEY + DATA_API_KEY)
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Button &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Button(element) {
	      this._element &#x3D; element;
	    } // Getters


	    var _proto &#x3D; Button.prototype;

	    // Public
	    _proto.toggle &#x3D; function toggle() {
	      var triggerChangeEvent &#x3D; true;
	      var addAriaPressed &#x3D; true;
	      var rootElement &#x3D; $$$1(this._element).closest(Selector.DATA_TOGGLE)[0];

	      if (rootElement) {
	        var input &#x3D; $$$1(this._element).find(Selector.INPUT)[0];

	        if (input) {
	          if (input.type &#x3D;&#x3D;&#x3D; &#x27;radio&#x27;) {
	            if (input.checked &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE)) {
	              triggerChangeEvent &#x3D; false;
	            } else {
	              var activeElement &#x3D; $$$1(rootElement).find(Selector.ACTIVE)[0];

	              if (activeElement) {
	                $$$1(activeElement).removeClass(ClassName.ACTIVE);
	              }
	            }
	          }

	          if (triggerChangeEvent) {
	            if (input.hasAttribute(&#x27;disabled&#x27;) || rootElement.hasAttribute(&#x27;disabled&#x27;) || input.classList.contains(&#x27;disabled&#x27;) || rootElement.classList.contains(&#x27;disabled&#x27;)) {
	              return;
	            }

	            input.checked &#x3D; !$$$1(this._element).hasClass(ClassName.ACTIVE);
	            $$$1(input).trigger(&#x27;change&#x27;);
	          }

	          input.focus();
	          addAriaPressed &#x3D; false;
	        }
	      }

	      if (addAriaPressed) {
	        this._element.setAttribute(&#x27;aria-pressed&#x27;, !$$$1(this._element).hasClass(ClassName.ACTIVE));
	      }

	      if (triggerChangeEvent) {
	        $$$1(this._element).toggleClass(ClassName.ACTIVE);
	      }
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._element &#x3D; null;
	    }; // Static


	    Button._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var data &#x3D; $$$1(this).data(DATA_KEY);

	        if (!data) {
	          data &#x3D; new Button(this);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (config &#x3D;&#x3D;&#x3D; &#x27;toggle&#x27;) {
	          data[config]();
	        }
	      });
	    };

	    _createClass(Button, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Button;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
	    event.preventDefault();
	    var button &#x3D; event.target;

	    if (!$$$1(button).hasClass(ClassName.BUTTON)) {
	      button &#x3D; $$$1(button).closest(Selector.BUTTON);
	    }

	    Button._jQueryInterface.call($$$1(button), &#x27;toggle&#x27;);
	  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
	    var button &#x3D; $$$1(event.target).closest(Selector.BUTTON)[0];
	    $$$1(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; Button._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Button;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Button._jQueryInterface;
	  };

	  return Button;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): carousel.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Carousel &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;carousel&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.carousel&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var TRANSITION_DURATION &#x3D; 600;
	  var ARROW_LEFT_KEYCODE &#x3D; 37; // KeyboardEvent.which value for left arrow key

	  var ARROW_RIGHT_KEYCODE &#x3D; 39; // KeyboardEvent.which value for right arrow key

	  var TOUCHEVENT_COMPAT_WAIT &#x3D; 500; // Time for mouse compat events to fire after touch

	  var Default &#x3D; {
	    interval: 5000,
	    keyboard: true,
	    slide: false,
	    pause: &#x27;hover&#x27;,
	    wrap: true
	  };
	  var DefaultType &#x3D; {
	    interval: &#x27;(number|boolean)&#x27;,
	    keyboard: &#x27;boolean&#x27;,
	    slide: &#x27;(boolean|string)&#x27;,
	    pause: &#x27;(string|boolean)&#x27;,
	    wrap: &#x27;boolean&#x27;
	  };
	  var Direction &#x3D; {
	    NEXT: &#x27;next&#x27;,
	    PREV: &#x27;prev&#x27;,
	    LEFT: &#x27;left&#x27;,
	    RIGHT: &#x27;right&#x27;
	  };
	  var Event &#x3D; {
	    SLIDE: &quot;slide&quot; + EVENT_KEY,
	    SLID: &quot;slid&quot; + EVENT_KEY,
	    KEYDOWN: &quot;keydown&quot; + EVENT_KEY,
	    MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
	    MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY,
	    TOUCHEND: &quot;touchend&quot; + EVENT_KEY,
	    LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName &#x3D; {
	    CAROUSEL: &#x27;carousel&#x27;,
	    ACTIVE: &#x27;active&#x27;,
	    SLIDE: &#x27;slide&#x27;,
	    RIGHT: &#x27;carousel-item-right&#x27;,
	    LEFT: &#x27;carousel-item-left&#x27;,
	    NEXT: &#x27;carousel-item-next&#x27;,
	    PREV: &#x27;carousel-item-prev&#x27;,
	    ITEM: &#x27;carousel-item&#x27;
	  };
	  var Selector &#x3D; {
	    ACTIVE: &#x27;.active&#x27;,
	    ACTIVE_ITEM: &#x27;.active.carousel-item&#x27;,
	    ITEM: &#x27;.carousel-item&#x27;,
	    NEXT_PREV: &#x27;.carousel-item-next, .carousel-item-prev&#x27;,
	    INDICATORS: &#x27;.carousel-indicators&#x27;,
	    DATA_SLIDE: &#x27;[data-slide], [data-slide-to]&#x27;,
	    DATA_RIDE: &#x27;[data-ride&#x3D;&quot;carousel&quot;]&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Carousel &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Carousel(element, config) {
	      this._items &#x3D; null;
	      this._interval &#x3D; null;
	      this._activeElement &#x3D; null;
	      this._isPaused &#x3D; false;
	      this._isSliding &#x3D; false;
	      this.touchTimeout &#x3D; null;
	      this._config &#x3D; this._getConfig(config);
	      this._element &#x3D; $$$1(element)[0];
	      this._indicatorsElement &#x3D; $$$1(this._element).find(Selector.INDICATORS)[0];

	      this._addEventListeners();
	    } // Getters


	    var _proto &#x3D; Carousel.prototype;

	    // Public
	    _proto.next &#x3D; function next() {
	      if (!this._isSliding) {
	        this._slide(Direction.NEXT);
	      }
	    };

	    _proto.nextWhenVisible &#x3D; function nextWhenVisible() {
	      // Don&#x27;t call next when the page isn&#x27;t visible
	      // or the carousel or its parent isn&#x27;t visible
	      if (!document.hidden &amp;&amp; $$$1(this._element).is(&#x27;:visible&#x27;) &amp;&amp; $$$1(this._element).css(&#x27;visibility&#x27;) !&#x3D;&#x3D; &#x27;hidden&#x27;) {
	        this.next();
	      }
	    };

	    _proto.prev &#x3D; function prev() {
	      if (!this._isSliding) {
	        this._slide(Direction.PREV);
	      }
	    };

	    _proto.pause &#x3D; function pause(event) {
	      if (!event) {
	        this._isPaused &#x3D; true;
	      }

	      if ($$$1(this._element).find(Selector.NEXT_PREV)[0] &amp;&amp; Util.supportsTransitionEnd()) {
	        Util.triggerTransitionEnd(this._element);
	        this.cycle(true);
	      }

	      clearInterval(this._interval);
	      this._interval &#x3D; null;
	    };

	    _proto.cycle &#x3D; function cycle(event) {
	      if (!event) {
	        this._isPaused &#x3D; false;
	      }

	      if (this._interval) {
	        clearInterval(this._interval);
	        this._interval &#x3D; null;
	      }

	      if (this._config.interval &amp;&amp; !this._isPaused) {
	        this._interval &#x3D; setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
	      }
	    };

	    _proto.to &#x3D; function to(index) {
	      var _this &#x3D; this;

	      this._activeElement &#x3D; $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];

	      var activeIndex &#x3D; this._getItemIndex(this._activeElement);

	      if (index &gt; this._items.length - 1 || index &lt; 0) {
	        return;
	      }

	      if (this._isSliding) {
	        $$$1(this._element).one(Event.SLID, function () {
	          return _this.to(index);
	        });
	        return;
	      }

	      if (activeIndex &#x3D;&#x3D;&#x3D; index) {
	        this.pause();
	        this.cycle();
	        return;
	      }

	      var direction &#x3D; index &gt; activeIndex ? Direction.NEXT : Direction.PREV;

	      this._slide(direction, this._items[index]);
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1(this._element).off(EVENT_KEY);
	      $$$1.removeData(this._element, DATA_KEY);
	      this._items &#x3D; null;
	      this._config &#x3D; null;
	      this._element &#x3D; null;
	      this._interval &#x3D; null;
	      this._isPaused &#x3D; null;
	      this._isSliding &#x3D; null;
	      this._activeElement &#x3D; null;
	      this._indicatorsElement &#x3D; null;
	    }; // Private


	    _proto._getConfig &#x3D; function _getConfig(config) {
	      config &#x3D; _extends({}, Default, config);
	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._addEventListeners &#x3D; function _addEventListeners() {
	      var _this2 &#x3D; this;

	      if (this._config.keyboard) {
	        $$$1(this._element).on(Event.KEYDOWN, function (event) {
	          return _this2._keydown(event);
	        });
	      }

	      if (this._config.pause &#x3D;&#x3D;&#x3D; &#x27;hover&#x27;) {
	        $$$1(this._element).on(Event.MOUSEENTER, function (event) {
	          return _this2.pause(event);
	        }).on(Event.MOUSELEAVE, function (event) {
	          return _this2.cycle(event);
	        });

	        if (&#x27;ontouchstart&#x27; in document.documentElement) {
	          // If it&#x27;s a touch-enabled device, mouseenter/leave are fired as
	          // part of the mouse compatibility events on first tap - the carousel
	          // would stop cycling until user tapped out of it;
	          // here, we listen for touchend, explicitly pause the carousel
	          // (as if it&#x27;s the second time we tap on it, mouseenter compat event
	          // is NOT fired) and after a timeout (to allow for mouse compatibility
	          // events to fire) we explicitly restart cycling
	          $$$1(this._element).on(Event.TOUCHEND, function () {
	            _this2.pause();

	            if (_this2.touchTimeout) {
	              clearTimeout(_this2.touchTimeout);
	            }

	            _this2.touchTimeout &#x3D; setTimeout(function (event) {
	              return _this2.cycle(event);
	            }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
	          });
	        }
	      }
	    };

	    _proto._keydown &#x3D; function _keydown(event) {
	      if (/input|textarea/i.test(event.target.tagName)) {
	        return;
	      }

	      switch (event.which) {
	        case ARROW_LEFT_KEYCODE:
	          event.preventDefault();
	          this.prev();
	          break;

	        case ARROW_RIGHT_KEYCODE:
	          event.preventDefault();
	          this.next();
	          break;

	        default:
	      }
	    };

	    _proto._getItemIndex &#x3D; function _getItemIndex(element) {
	      this._items &#x3D; $$$1.makeArray($$$1(element).parent().find(Selector.ITEM));
	      return this._items.indexOf(element);
	    };

	    _proto._getItemByDirection &#x3D; function _getItemByDirection(direction, activeElement) {
	      var isNextDirection &#x3D; direction &#x3D;&#x3D;&#x3D; Direction.NEXT;
	      var isPrevDirection &#x3D; direction &#x3D;&#x3D;&#x3D; Direction.PREV;

	      var activeIndex &#x3D; this._getItemIndex(activeElement);

	      var lastItemIndex &#x3D; this._items.length - 1;
	      var isGoingToWrap &#x3D; isPrevDirection &amp;&amp; activeIndex &#x3D;&#x3D;&#x3D; 0 || isNextDirection &amp;&amp; activeIndex &#x3D;&#x3D;&#x3D; lastItemIndex;

	      if (isGoingToWrap &amp;&amp; !this._config.wrap) {
	        return activeElement;
	      }

	      var delta &#x3D; direction &#x3D;&#x3D;&#x3D; Direction.PREV ? -1 : 1;
	      var itemIndex &#x3D; (activeIndex + delta) % this._items.length;
	      return itemIndex &#x3D;&#x3D;&#x3D; -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
	    };

	    _proto._triggerSlideEvent &#x3D; function _triggerSlideEvent(relatedTarget, eventDirectionName) {
	      var targetIndex &#x3D; this._getItemIndex(relatedTarget);

	      var fromIndex &#x3D; this._getItemIndex($$$1(this._element).find(Selector.ACTIVE_ITEM)[0]);

	      var slideEvent &#x3D; $$$1.Event(Event.SLIDE, {
	        relatedTarget: relatedTarget,
	        direction: eventDirectionName,
	        from: fromIndex,
	        to: targetIndex
	      });
	      $$$1(this._element).trigger(slideEvent);
	      return slideEvent;
	    };

	    _proto._setActiveIndicatorElement &#x3D; function _setActiveIndicatorElement(element) {
	      if (this._indicatorsElement) {
	        $$$1(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);

	        var nextIndicator &#x3D; this._indicatorsElement.children[this._getItemIndex(element)];

	        if (nextIndicator) {
	          $$$1(nextIndicator).addClass(ClassName.ACTIVE);
	        }
	      }
	    };

	    _proto._slide &#x3D; function _slide(direction, element) {
	      var _this3 &#x3D; this;

	      var activeElement &#x3D; $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];

	      var activeElementIndex &#x3D; this._getItemIndex(activeElement);

	      var nextElement &#x3D; element || activeElement &amp;&amp; this._getItemByDirection(direction, activeElement);

	      var nextElementIndex &#x3D; this._getItemIndex(nextElement);

	      var isCycling &#x3D; Boolean(this._interval);
	      var directionalClassName;
	      var orderClassName;
	      var eventDirectionName;

	      if (direction &#x3D;&#x3D;&#x3D; Direction.NEXT) {
	        directionalClassName &#x3D; ClassName.LEFT;
	        orderClassName &#x3D; ClassName.NEXT;
	        eventDirectionName &#x3D; Direction.LEFT;
	      } else {
	        directionalClassName &#x3D; ClassName.RIGHT;
	        orderClassName &#x3D; ClassName.PREV;
	        eventDirectionName &#x3D; Direction.RIGHT;
	      }

	      if (nextElement &amp;&amp; $$$1(nextElement).hasClass(ClassName.ACTIVE)) {
	        this._isSliding &#x3D; false;
	        return;
	      }

	      var slideEvent &#x3D; this._triggerSlideEvent(nextElement, eventDirectionName);

	      if (slideEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (!activeElement || !nextElement) {
	        // Some weirdness is happening, so we bail
	        return;
	      }

	      this._isSliding &#x3D; true;

	      if (isCycling) {
	        this.pause();
	      }

	      this._setActiveIndicatorElement(nextElement);

	      var slidEvent &#x3D; $$$1.Event(Event.SLID, {
	        relatedTarget: nextElement,
	        direction: eventDirectionName,
	        from: activeElementIndex,
	        to: nextElementIndex
	      });

	      if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.SLIDE)) {
	        $$$1(nextElement).addClass(orderClassName);
	        Util.reflow(nextElement);
	        $$$1(activeElement).addClass(directionalClassName);
	        $$$1(nextElement).addClass(directionalClassName);
	        $$$1(activeElement).one(Util.TRANSITION_END, function () {
	          $$$1(nextElement).removeClass(directionalClassName + &quot; &quot; + orderClassName).addClass(ClassName.ACTIVE);
	          $$$1(activeElement).removeClass(ClassName.ACTIVE + &quot; &quot; + orderClassName + &quot; &quot; + directionalClassName);
	          _this3._isSliding &#x3D; false;
	          setTimeout(function () {
	            return $$$1(_this3._element).trigger(slidEvent);
	          }, 0);
	        }).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        $$$1(activeElement).removeClass(ClassName.ACTIVE);
	        $$$1(nextElement).addClass(ClassName.ACTIVE);
	        this._isSliding &#x3D; false;
	        $$$1(this._element).trigger(slidEvent);
	      }

	      if (isCycling) {
	        this.cycle();
	      }
	    }; // Static


	    Carousel._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var data &#x3D; $$$1(this).data(DATA_KEY);

	        var _config &#x3D; _extends({}, Default, $$$1(this).data());

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;object&#x27;) {
	          _config &#x3D; _extends({}, _config, config);
	        }

	        var action &#x3D; typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? config : _config.slide;

	        if (!data) {
	          data &#x3D; new Carousel(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
	          data.to(config);
	        } else if (typeof action &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[action] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + action + &quot;\&quot;&quot;);
	          }

	          data[action]();
	        } else if (_config.interval) {
	          data.pause();
	          data.cycle();
	        }
	      });
	    };

	    Carousel._dataApiClickHandler &#x3D; function _dataApiClickHandler(event) {
	      var selector &#x3D; Util.getSelectorFromElement(this);

	      if (!selector) {
	        return;
	      }

	      var target &#x3D; $$$1(selector)[0];

	      if (!target || !$$$1(target).hasClass(ClassName.CAROUSEL)) {
	        return;
	      }

	      var config &#x3D; _extends({}, $$$1(target).data(), $$$1(this).data());
	      var slideIndex &#x3D; this.getAttribute(&#x27;data-slide-to&#x27;);

	      if (slideIndex) {
	        config.interval &#x3D; false;
	      }

	      Carousel._jQueryInterface.call($$$1(target), config);

	      if (slideIndex) {
	        $$$1(target).data(DATA_KEY).to(slideIndex);
	      }

	      event.preventDefault();
	    };

	    _createClass(Carousel, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Carousel;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
	  $$$1(window).on(Event.LOAD_DATA_API, function () {
	    $$$1(Selector.DATA_RIDE).each(function () {
	      var $carousel &#x3D; $$$1(this);

	      Carousel._jQueryInterface.call($carousel, $carousel.data());
	    });
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; Carousel._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Carousel;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Carousel._jQueryInterface;
	  };

	  return Carousel;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): collapse.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Collapse &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;collapse&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.collapse&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var TRANSITION_DURATION &#x3D; 600;
	  var Default &#x3D; {
	    toggle: true,
	    parent: &#x27;&#x27;
	  };
	  var DefaultType &#x3D; {
	    toggle: &#x27;boolean&#x27;,
	    parent: &#x27;(string|element)&#x27;
	  };
	  var Event &#x3D; {
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName &#x3D; {
	    SHOW: &#x27;show&#x27;,
	    COLLAPSE: &#x27;collapse&#x27;,
	    COLLAPSING: &#x27;collapsing&#x27;,
	    COLLAPSED: &#x27;collapsed&#x27;
	  };
	  var Dimension &#x3D; {
	    WIDTH: &#x27;width&#x27;,
	    HEIGHT: &#x27;height&#x27;
	  };
	  var Selector &#x3D; {
	    ACTIVES: &#x27;.show, .collapsing&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle&#x3D;&quot;collapse&quot;]&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Collapse &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Collapse(element, config) {
	      this._isTransitioning &#x3D; false;
	      this._element &#x3D; element;
	      this._config &#x3D; this._getConfig(config);
	      this._triggerArray &#x3D; $$$1.makeArray($$$1(&quot;[data-toggle&#x3D;\&quot;collapse\&quot;][href&#x3D;\&quot;#&quot; + element.id + &quot;\&quot;],&quot; + (&quot;[data-toggle&#x3D;\&quot;collapse\&quot;][data-target&#x3D;\&quot;#&quot; + element.id + &quot;\&quot;]&quot;)));
	      var tabToggles &#x3D; $$$1(Selector.DATA_TOGGLE);

	      for (var i &#x3D; 0; i &lt; tabToggles.length; i++) {
	        var elem &#x3D; tabToggles[i];
	        var selector &#x3D; Util.getSelectorFromElement(elem);

	        if (selector !&#x3D;&#x3D; null &amp;&amp; $$$1(selector).filter(element).length &gt; 0) {
	          this._selector &#x3D; selector;

	          this._triggerArray.push(elem);
	        }
	      }

	      this._parent &#x3D; this._config.parent ? this._getParent() : null;

	      if (!this._config.parent) {
	        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
	      }

	      if (this._config.toggle) {
	        this.toggle();
	      }
	    } // Getters


	    var _proto &#x3D; Collapse.prototype;

	    // Public
	    _proto.toggle &#x3D; function toggle() {
	      if ($$$1(this._element).hasClass(ClassName.SHOW)) {
	        this.hide();
	      } else {
	        this.show();
	      }
	    };

	    _proto.show &#x3D; function show() {
	      var _this &#x3D; this;

	      if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {
	        return;
	      }

	      var actives;
	      var activesData;

	      if (this._parent) {
	        actives &#x3D; $$$1.makeArray($$$1(this._parent).find(Selector.ACTIVES).filter(&quot;[data-parent&#x3D;\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;));

	        if (actives.length &#x3D;&#x3D;&#x3D; 0) {
	          actives &#x3D; null;
	        }
	      }

	      if (actives) {
	        activesData &#x3D; $$$1(actives).not(this._selector).data(DATA_KEY);

	        if (activesData &amp;&amp; activesData._isTransitioning) {
	          return;
	        }
	      }

	      var startEvent &#x3D; $$$1.Event(Event.SHOW);
	      $$$1(this._element).trigger(startEvent);

	      if (startEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (actives) {
	        Collapse._jQueryInterface.call($$$1(actives).not(this._selector), &#x27;hide&#x27;);

	        if (!activesData) {
	          $$$1(actives).data(DATA_KEY, null);
	        }
	      }

	      var dimension &#x3D; this._getDimension();

	      $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
	      this._element.style[dimension] &#x3D; 0;

	      if (this._triggerArray.length &gt; 0) {
	        $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr(&#x27;aria-expanded&#x27;, true);
	      }

	      this.setTransitioning(true);

	      var complete &#x3D; function complete() {
	        $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
	        _this._element.style[dimension] &#x3D; &#x27;&#x27;;

	        _this.setTransitioning(false);

	        $$$1(_this._element).trigger(Event.SHOWN);
	      };

	      if (!Util.supportsTransitionEnd()) {
	        complete();
	        return;
	      }

	      var capitalizedDimension &#x3D; dimension[0].toUpperCase() + dimension.slice(1);
	      var scrollSize &#x3D; &quot;scroll&quot; + capitalizedDimension;
	      $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      this._element.style[dimension] &#x3D; this._element[scrollSize] + &quot;px&quot;;
	    };

	    _proto.hide &#x3D; function hide() {
	      var _this2 &#x3D; this;

	      if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {
	        return;
	      }

	      var startEvent &#x3D; $$$1.Event(Event.HIDE);
	      $$$1(this._element).trigger(startEvent);

	      if (startEvent.isDefaultPrevented()) {
	        return;
	      }

	      var dimension &#x3D; this._getDimension();

	      this._element.style[dimension] &#x3D; this._element.getBoundingClientRect()[dimension] + &quot;px&quot;;
	      Util.reflow(this._element);
	      $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

	      if (this._triggerArray.length &gt; 0) {
	        for (var i &#x3D; 0; i &lt; this._triggerArray.length; i++) {
	          var trigger &#x3D; this._triggerArray[i];
	          var selector &#x3D; Util.getSelectorFromElement(trigger);

	          if (selector !&#x3D;&#x3D; null) {
	            var $elem &#x3D; $$$1(selector);

	            if (!$elem.hasClass(ClassName.SHOW)) {
	              $$$1(trigger).addClass(ClassName.COLLAPSED).attr(&#x27;aria-expanded&#x27;, false);
	            }
	          }
	        }
	      }

	      this.setTransitioning(true);

	      var complete &#x3D; function complete() {
	        _this2.setTransitioning(false);

	        $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
	      };

	      this._element.style[dimension] &#x3D; &#x27;&#x27;;

	      if (!Util.supportsTransitionEnd()) {
	        complete();
	        return;
	      }

	      $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	    };

	    _proto.setTransitioning &#x3D; function setTransitioning(isTransitioning) {
	      this._isTransitioning &#x3D; isTransitioning;
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._config &#x3D; null;
	      this._parent &#x3D; null;
	      this._element &#x3D; null;
	      this._triggerArray &#x3D; null;
	      this._isTransitioning &#x3D; null;
	    }; // Private


	    _proto._getConfig &#x3D; function _getConfig(config) {
	      config &#x3D; _extends({}, Default, config);
	      config.toggle &#x3D; Boolean(config.toggle); // Coerce string values

	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._getDimension &#x3D; function _getDimension() {
	      var hasWidth &#x3D; $$$1(this._element).hasClass(Dimension.WIDTH);
	      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
	    };

	    _proto._getParent &#x3D; function _getParent() {
	      var _this3 &#x3D; this;

	      var parent &#x3D; null;

	      if (Util.isElement(this._config.parent)) {
	        parent &#x3D; this._config.parent; // It&#x27;s a jQuery object

	        if (typeof this._config.parent.jquery !&#x3D;&#x3D; &#x27;undefined&#x27;) {
	          parent &#x3D; this._config.parent[0];
	        }
	      } else {
	        parent &#x3D; $$$1(this._config.parent)[0];
	      }

	      var selector &#x3D; &quot;[data-toggle&#x3D;\&quot;collapse\&quot;][data-parent&#x3D;\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;;
	      $$$1(parent).find(selector).each(function (i, element) {
	        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
	      });
	      return parent;
	    };

	    _proto._addAriaAndCollapsedClass &#x3D; function _addAriaAndCollapsedClass(element, triggerArray) {
	      if (element) {
	        var isOpen &#x3D; $$$1(element).hasClass(ClassName.SHOW);

	        if (triggerArray.length &gt; 0) {
	          $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr(&#x27;aria-expanded&#x27;, isOpen);
	        }
	      }
	    }; // Static


	    Collapse._getTargetFromElement &#x3D; function _getTargetFromElement(element) {
	      var selector &#x3D; Util.getSelectorFromElement(element);
	      return selector ? $$$1(selector)[0] : null;
	    };

	    Collapse._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var $this &#x3D; $$$1(this);
	        var data &#x3D; $this.data(DATA_KEY);

	        var _config &#x3D; _extends({}, Default, $this.data(), typeof config &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; config);

	        if (!data &amp;&amp; _config.toggle &amp;&amp; /show|hide/.test(config)) {
	          _config.toggle &#x3D; false;
	        }

	        if (!data) {
	          data &#x3D; new Collapse(this, _config);
	          $this.data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[config] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Collapse, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Collapse;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    // preventDefault only for &lt;a&gt; elements (which change the URL) not inside the collapsible element
	    if (event.currentTarget.tagName &#x3D;&#x3D;&#x3D; &#x27;A&#x27;) {
	      event.preventDefault();
	    }

	    var $trigger &#x3D; $$$1(this);
	    var selector &#x3D; Util.getSelectorFromElement(this);
	    $$$1(selector).each(function () {
	      var $target &#x3D; $$$1(this);
	      var data &#x3D; $target.data(DATA_KEY);
	      var config &#x3D; data ? &#x27;toggle&#x27; : $trigger.data();

	      Collapse._jQueryInterface.call($target, config);
	    });
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; Collapse._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Collapse;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Collapse._jQueryInterface;
	  };

	  return Collapse;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): dropdown.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Dropdown &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;dropdown&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.dropdown&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var ESCAPE_KEYCODE &#x3D; 27; // KeyboardEvent.which value for Escape (Esc) key

	  var SPACE_KEYCODE &#x3D; 32; // KeyboardEvent.which value for space key

	  var TAB_KEYCODE &#x3D; 9; // KeyboardEvent.which value for tab key

	  var ARROW_UP_KEYCODE &#x3D; 38; // KeyboardEvent.which value for up arrow key

	  var ARROW_DOWN_KEYCODE &#x3D; 40; // KeyboardEvent.which value for down arrow key

	  var RIGHT_MOUSE_BUTTON_WHICH &#x3D; 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

	  var REGEXP_KEYDOWN &#x3D; new RegExp(ARROW_UP_KEYCODE + &quot;|&quot; + ARROW_DOWN_KEYCODE + &quot;|&quot; + ESCAPE_KEYCODE);
	  var Event &#x3D; {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    CLICK: &quot;click&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
	    KEYDOWN_DATA_API: &quot;keydown&quot; + EVENT_KEY + DATA_API_KEY,
	    KEYUP_DATA_API: &quot;keyup&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName &#x3D; {
	    DISABLED: &#x27;disabled&#x27;,
	    SHOW: &#x27;show&#x27;,
	    DROPUP: &#x27;dropup&#x27;,
	    DROPRIGHT: &#x27;dropright&#x27;,
	    DROPLEFT: &#x27;dropleft&#x27;,
	    MENURIGHT: &#x27;dropdown-menu-right&#x27;,
	    MENULEFT: &#x27;dropdown-menu-left&#x27;,
	    POSITION_STATIC: &#x27;position-static&#x27;
	  };
	  var Selector &#x3D; {
	    DATA_TOGGLE: &#x27;[data-toggle&#x3D;&quot;dropdown&quot;]&#x27;,
	    FORM_CHILD: &#x27;.dropdown form&#x27;,
	    MENU: &#x27;.dropdown-menu&#x27;,
	    NAVBAR_NAV: &#x27;.navbar-nav&#x27;,
	    VISIBLE_ITEMS: &#x27;.dropdown-menu .dropdown-item:not(.disabled)&#x27;
	  };
	  var AttachmentMap &#x3D; {
	    TOP: &#x27;top-start&#x27;,
	    TOPEND: &#x27;top-end&#x27;,
	    BOTTOM: &#x27;bottom-start&#x27;,
	    BOTTOMEND: &#x27;bottom-end&#x27;,
	    RIGHT: &#x27;right-start&#x27;,
	    RIGHTEND: &#x27;right-end&#x27;,
	    LEFT: &#x27;left-start&#x27;,
	    LEFTEND: &#x27;left-end&#x27;
	  };
	  var Default &#x3D; {
	    offset: 0,
	    flip: true,
	    boundary: &#x27;scrollParent&#x27;
	  };
	  var DefaultType &#x3D; {
	    offset: &#x27;(number|string|function)&#x27;,
	    flip: &#x27;boolean&#x27;,
	    boundary: &#x27;(string|element)&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Dropdown &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Dropdown(element, config) {
	      this._element &#x3D; element;
	      this._popper &#x3D; null;
	      this._config &#x3D; this._getConfig(config);
	      this._menu &#x3D; this._getMenuElement();
	      this._inNavbar &#x3D; this._detectNavbar();

	      this._addEventListeners();
	    } // Getters


	    var _proto &#x3D; Dropdown.prototype;

	    // Public
	    _proto.toggle &#x3D; function toggle() {
	      if (this._element.disabled || $$$1(this._element).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var parent &#x3D; Dropdown._getParentFromElement(this._element);

	      var isActive &#x3D; $$$1(this._menu).hasClass(ClassName.SHOW);

	      Dropdown._clearMenus();

	      if (isActive) {
	        return;
	      }

	      var relatedTarget &#x3D; {
	        relatedTarget: this._element
	      };
	      var showEvent &#x3D; $$$1.Event(Event.SHOW, relatedTarget);
	      $$$1(parent).trigger(showEvent);

	      if (showEvent.isDefaultPrevented()) {
	        return;
	      } // Disable totally Popper.js for Dropdown in Navbar


	      if (!this._inNavbar) {
	        /**
	         * Check for Popper dependency
	         * Popper - https://popper.js.org
	         */
	        if (typeof Popper &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	          throw new TypeError(&#x27;Bootstrap dropdown require Popper.js (https://popper.js.org)&#x27;);
	        }

	        var element &#x3D; this._element; // For dropup with alignment we use the parent as popper container

	        if ($$$1(parent).hasClass(ClassName.DROPUP)) {
	          if ($$$1(this._menu).hasClass(ClassName.MENULEFT) || $$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
	            element &#x3D; parent;
	          }
	        } // If boundary is not &#x60;scrollParent&#x60;, then set position to &#x60;static&#x60;
	        // to allow the menu to &quot;escape&quot; the scroll parent&#x27;s boundaries
	        // https://github.com/twbs/bootstrap/issues/24251


	        if (this._config.boundary !&#x3D;&#x3D; &#x27;scrollParent&#x27;) {
	          $$$1(parent).addClass(ClassName.POSITION_STATIC);
	        }

	        this._popper &#x3D; new Popper(element, this._menu, this._getPopperConfig());
	      } // If this is a touch-enabled device we add extra
	      // empty mouseover listeners to the body&#x27;s immediate children;
	      // only needed because of broken event delegation on iOS
	      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


	      if (&#x27;ontouchstart&#x27; in document.documentElement &amp;&amp; $$$1(parent).closest(Selector.NAVBAR_NAV).length &#x3D;&#x3D;&#x3D; 0) {
	        $$$1(&#x27;body&#x27;).children().on(&#x27;mouseover&#x27;, null, $$$1.noop);
	      }

	      this._element.focus();

	      this._element.setAttribute(&#x27;aria-expanded&#x27;, true);

	      $$$1(this._menu).toggleClass(ClassName.SHOW);
	      $$$1(parent).toggleClass(ClassName.SHOW).trigger($$$1.Event(Event.SHOWN, relatedTarget));
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      $$$1(this._element).off(EVENT_KEY);
	      this._element &#x3D; null;
	      this._menu &#x3D; null;

	      if (this._popper !&#x3D;&#x3D; null) {
	        this._popper.destroy();

	        this._popper &#x3D; null;
	      }
	    };

	    _proto.update &#x3D; function update() {
	      this._inNavbar &#x3D; this._detectNavbar();

	      if (this._popper !&#x3D;&#x3D; null) {
	        this._popper.scheduleUpdate();
	      }
	    }; // Private


	    _proto._addEventListeners &#x3D; function _addEventListeners() {
	      var _this &#x3D; this;

	      $$$1(this._element).on(Event.CLICK, function (event) {
	        event.preventDefault();
	        event.stopPropagation();

	        _this.toggle();
	      });
	    };

	    _proto._getConfig &#x3D; function _getConfig(config) {
	      config &#x3D; _extends({}, this.constructor.Default, $$$1(this._element).data(), config);
	      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
	      return config;
	    };

	    _proto._getMenuElement &#x3D; function _getMenuElement() {
	      if (!this._menu) {
	        var parent &#x3D; Dropdown._getParentFromElement(this._element);

	        this._menu &#x3D; $$$1(parent).find(Selector.MENU)[0];
	      }

	      return this._menu;
	    };

	    _proto._getPlacement &#x3D; function _getPlacement() {
	      var $parentDropdown &#x3D; $$$1(this._element).parent();
	      var placement &#x3D; AttachmentMap.BOTTOM; // Handle dropup

	      if ($parentDropdown.hasClass(ClassName.DROPUP)) {
	        placement &#x3D; AttachmentMap.TOP;

	        if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
	          placement &#x3D; AttachmentMap.TOPEND;
	        }
	      } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {
	        placement &#x3D; AttachmentMap.RIGHT;
	      } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {
	        placement &#x3D; AttachmentMap.LEFT;
	      } else if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
	        placement &#x3D; AttachmentMap.BOTTOMEND;
	      }

	      return placement;
	    };

	    _proto._detectNavbar &#x3D; function _detectNavbar() {
	      return $$$1(this._element).closest(&#x27;.navbar&#x27;).length &gt; 0;
	    };

	    _proto._getPopperConfig &#x3D; function _getPopperConfig() {
	      var _this2 &#x3D; this;

	      var offsetConf &#x3D; {};

	      if (typeof this._config.offset &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
	        offsetConf.fn &#x3D; function (data) {
	          data.offsets &#x3D; _extends({}, data.offsets, _this2._config.offset(data.offsets) || {});
	          return data;
	        };
	      } else {
	        offsetConf.offset &#x3D; this._config.offset;
	      }

	      var popperConfig &#x3D; {
	        placement: this._getPlacement(),
	        modifiers: {
	          offset: offsetConf,
	          flip: {
	            enabled: this._config.flip
	          },
	          preventOverflow: {
	            boundariesElement: this._config.boundary
	          }
	        }
	      };
	      return popperConfig;
	    }; // Static


	    Dropdown._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var data &#x3D; $$$1(this).data(DATA_KEY);

	        var _config &#x3D; typeof config &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? config : null;

	        if (!data) {
	          data &#x3D; new Dropdown(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[config] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    Dropdown._clearMenus &#x3D; function _clearMenus(event) {
	      if (event &amp;&amp; (event.which &#x3D;&#x3D;&#x3D; RIGHT_MOUSE_BUTTON_WHICH || event.type &#x3D;&#x3D;&#x3D; &#x27;keyup&#x27; &amp;&amp; event.which !&#x3D;&#x3D; TAB_KEYCODE)) {
	        return;
	      }

	      var toggles &#x3D; $$$1.makeArray($$$1(Selector.DATA_TOGGLE));

	      for (var i &#x3D; 0; i &lt; toggles.length; i++) {
	        var parent &#x3D; Dropdown._getParentFromElement(toggles[i]);

	        var context &#x3D; $$$1(toggles[i]).data(DATA_KEY);
	        var relatedTarget &#x3D; {
	          relatedTarget: toggles[i]
	        };

	        if (!context) {
	          continue;
	        }

	        var dropdownMenu &#x3D; context._menu;

	        if (!$$$1(parent).hasClass(ClassName.SHOW)) {
	          continue;
	        }

	        if (event &amp;&amp; (event.type &#x3D;&#x3D;&#x3D; &#x27;click&#x27; &amp;&amp; /input|textarea/i.test(event.target.tagName) || event.type &#x3D;&#x3D;&#x3D; &#x27;keyup&#x27; &amp;&amp; event.which &#x3D;&#x3D;&#x3D; TAB_KEYCODE) &amp;&amp; $$$1.contains(parent, event.target)) {
	          continue;
	        }

	        var hideEvent &#x3D; $$$1.Event(Event.HIDE, relatedTarget);
	        $$$1(parent).trigger(hideEvent);

	        if (hideEvent.isDefaultPrevented()) {
	          continue;
	        } // If this is a touch-enabled device we remove the extra
	        // empty mouseover listeners we added for iOS support


	        if (&#x27;ontouchstart&#x27; in document.documentElement) {
	          $$$1(&#x27;body&#x27;).children().off(&#x27;mouseover&#x27;, null, $$$1.noop);
	        }

	        toggles[i].setAttribute(&#x27;aria-expanded&#x27;, &#x27;false&#x27;);
	        $$$1(dropdownMenu).removeClass(ClassName.SHOW);
	        $$$1(parent).removeClass(ClassName.SHOW).trigger($$$1.Event(Event.HIDDEN, relatedTarget));
	      }
	    };

	    Dropdown._getParentFromElement &#x3D; function _getParentFromElement(element) {
	      var parent;
	      var selector &#x3D; Util.getSelectorFromElement(element);

	      if (selector) {
	        parent &#x3D; $$$1(selector)[0];
	      }

	      return parent || element.parentNode;
	    }; // eslint-disable-next-line complexity


	    Dropdown._dataApiKeydownHandler &#x3D; function _dataApiKeydownHandler(event) {
	      // If not input/textarea:
	      //  - And not a key in REGEXP_KEYDOWN &#x3D;&gt; not a dropdown command
	      // If input/textarea:
	      //  - If space key &#x3D;&gt; not a dropdown command
	      //  - If key is other than escape
	      //    - If key is not up or down &#x3D;&gt; not a dropdown command
	      //    - If trigger inside the menu &#x3D;&gt; not a dropdown command
	      if (/input|textarea/i.test(event.target.tagName) ? event.which &#x3D;&#x3D;&#x3D; SPACE_KEYCODE || event.which !&#x3D;&#x3D; ESCAPE_KEYCODE &amp;&amp; (event.which !&#x3D;&#x3D; ARROW_DOWN_KEYCODE &amp;&amp; event.which !&#x3D;&#x3D; ARROW_UP_KEYCODE || $$$1(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
	        return;
	      }

	      event.preventDefault();
	      event.stopPropagation();

	      if (this.disabled || $$$1(this).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var parent &#x3D; Dropdown._getParentFromElement(this);

	      var isActive &#x3D; $$$1(parent).hasClass(ClassName.SHOW);

	      if (!isActive &amp;&amp; (event.which !&#x3D;&#x3D; ESCAPE_KEYCODE || event.which !&#x3D;&#x3D; SPACE_KEYCODE) || isActive &amp;&amp; (event.which &#x3D;&#x3D;&#x3D; ESCAPE_KEYCODE || event.which &#x3D;&#x3D;&#x3D; SPACE_KEYCODE)) {
	        if (event.which &#x3D;&#x3D;&#x3D; ESCAPE_KEYCODE) {
	          var toggle &#x3D; $$$1(parent).find(Selector.DATA_TOGGLE)[0];
	          $$$1(toggle).trigger(&#x27;focus&#x27;);
	        }

	        $$$1(this).trigger(&#x27;click&#x27;);
	        return;
	      }

	      var items &#x3D; $$$1(parent).find(Selector.VISIBLE_ITEMS).get();

	      if (items.length &#x3D;&#x3D;&#x3D; 0) {
	        return;
	      }

	      var index &#x3D; items.indexOf(event.target);

	      if (event.which &#x3D;&#x3D;&#x3D; ARROW_UP_KEYCODE &amp;&amp; index &gt; 0) {
	        // Up
	        index--;
	      }

	      if (event.which &#x3D;&#x3D;&#x3D; ARROW_DOWN_KEYCODE &amp;&amp; index &lt; items.length - 1) {
	        // Down
	        index++;
	      }

	      if (index &lt; 0) {
	        index &#x3D; 0;
	      }

	      items[index].focus();
	    };

	    _createClass(Dropdown, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: &quot;DefaultType&quot;,
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Dropdown;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + &quot; &quot; + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    event.preventDefault();
	    event.stopPropagation();

	    Dropdown._jQueryInterface.call($$$1(this), &#x27;toggle&#x27;);
	  }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
	    e.stopPropagation();
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; Dropdown._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Dropdown;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Dropdown._jQueryInterface;
	  };

	  return Dropdown;
	}($, Popper);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): modal.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Modal &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;modal&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.modal&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var TRANSITION_DURATION &#x3D; 300;
	  var BACKDROP_TRANSITION_DURATION &#x3D; 150;
	  var ESCAPE_KEYCODE &#x3D; 27; // KeyboardEvent.which value for Escape (Esc) key

	  var Default &#x3D; {
	    backdrop: true,
	    keyboard: true,
	    focus: true,
	    show: true
	  };
	  var DefaultType &#x3D; {
	    backdrop: &#x27;(boolean|string)&#x27;,
	    keyboard: &#x27;boolean&#x27;,
	    focus: &#x27;boolean&#x27;,
	    show: &#x27;boolean&#x27;
	  };
	  var Event &#x3D; {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
	    RESIZE: &quot;resize&quot; + EVENT_KEY,
	    CLICK_DISMISS: &quot;click.dismiss&quot; + EVENT_KEY,
	    KEYDOWN_DISMISS: &quot;keydown.dismiss&quot; + EVENT_KEY,
	    MOUSEUP_DISMISS: &quot;mouseup.dismiss&quot; + EVENT_KEY,
	    MOUSEDOWN_DISMISS: &quot;mousedown.dismiss&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName &#x3D; {
	    SCROLLBAR_MEASURER: &#x27;modal-scrollbar-measure&#x27;,
	    BACKDROP: &#x27;modal-backdrop&#x27;,
	    OPEN: &#x27;modal-open&#x27;,
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector &#x3D; {
	    DIALOG: &#x27;.modal-dialog&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle&#x3D;&quot;modal&quot;]&#x27;,
	    DATA_DISMISS: &#x27;[data-dismiss&#x3D;&quot;modal&quot;]&#x27;,
	    FIXED_CONTENT: &#x27;.fixed-top, .fixed-bottom, .is-fixed, .sticky-top&#x27;,
	    STICKY_CONTENT: &#x27;.sticky-top&#x27;,
	    NAVBAR_TOGGLER: &#x27;.navbar-toggler&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Modal &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Modal(element, config) {
	      this._config &#x3D; this._getConfig(config);
	      this._element &#x3D; element;
	      this._dialog &#x3D; $$$1(element).find(Selector.DIALOG)[0];
	      this._backdrop &#x3D; null;
	      this._isShown &#x3D; false;
	      this._isBodyOverflowing &#x3D; false;
	      this._ignoreBackdropClick &#x3D; false;
	      this._originalBodyPadding &#x3D; 0;
	      this._scrollbarWidth &#x3D; 0;
	    } // Getters


	    var _proto &#x3D; Modal.prototype;

	    // Public
	    _proto.toggle &#x3D; function toggle(relatedTarget) {
	      return this._isShown ? this.hide() : this.show(relatedTarget);
	    };

	    _proto.show &#x3D; function show(relatedTarget) {
	      var _this &#x3D; this;

	      if (this._isTransitioning || this._isShown) {
	        return;
	      }

	      if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE)) {
	        this._isTransitioning &#x3D; true;
	      }

	      var showEvent &#x3D; $$$1.Event(Event.SHOW, {
	        relatedTarget: relatedTarget
	      });
	      $$$1(this._element).trigger(showEvent);

	      if (this._isShown || showEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._isShown &#x3D; true;

	      this._checkScrollbar();

	      this._setScrollbar();

	      this._adjustDialog();

	      $$$1(document.body).addClass(ClassName.OPEN);

	      this._setEscapeEvent();

	      this._setResizeEvent();

	      $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
	        return _this.hide(event);
	      });
	      $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
	        $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
	          if ($$$1(event.target).is(_this._element)) {
	            _this._ignoreBackdropClick &#x3D; true;
	          }
	        });
	      });

	      this._showBackdrop(function () {
	        return _this._showElement(relatedTarget);
	      });
	    };

	    _proto.hide &#x3D; function hide(event) {
	      var _this2 &#x3D; this;

	      if (event) {
	        event.preventDefault();
	      }

	      if (this._isTransitioning || !this._isShown) {
	        return;
	      }

	      var hideEvent &#x3D; $$$1.Event(Event.HIDE);
	      $$$1(this._element).trigger(hideEvent);

	      if (!this._isShown || hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._isShown &#x3D; false;
	      var transition &#x3D; Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE);

	      if (transition) {
	        this._isTransitioning &#x3D; true;
	      }

	      this._setEscapeEvent();

	      this._setResizeEvent();

	      $$$1(document).off(Event.FOCUSIN);
	      $$$1(this._element).removeClass(ClassName.SHOW);
	      $$$1(this._element).off(Event.CLICK_DISMISS);
	      $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);

	      if (transition) {
	        $$$1(this._element).one(Util.TRANSITION_END, function (event) {
	          return _this2._hideModal(event);
	        }).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        this._hideModal();
	      }
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);
	      this._config &#x3D; null;
	      this._element &#x3D; null;
	      this._dialog &#x3D; null;
	      this._backdrop &#x3D; null;
	      this._isShown &#x3D; null;
	      this._isBodyOverflowing &#x3D; null;
	      this._ignoreBackdropClick &#x3D; null;
	      this._scrollbarWidth &#x3D; null;
	    };

	    _proto.handleUpdate &#x3D; function handleUpdate() {
	      this._adjustDialog();
	    }; // Private


	    _proto._getConfig &#x3D; function _getConfig(config) {
	      config &#x3D; _extends({}, Default, config);
	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._showElement &#x3D; function _showElement(relatedTarget) {
	      var _this3 &#x3D; this;

	      var transition &#x3D; Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE);

	      if (!this._element.parentNode || this._element.parentNode.nodeType !&#x3D;&#x3D; Node.ELEMENT_NODE) {
	        // Don&#x27;t move modal&#x27;s DOM position
	        document.body.appendChild(this._element);
	      }

	      this._element.style.display &#x3D; &#x27;block&#x27;;

	      this._element.removeAttribute(&#x27;aria-hidden&#x27;);

	      this._element.scrollTop &#x3D; 0;

	      if (transition) {
	        Util.reflow(this._element);
	      }

	      $$$1(this._element).addClass(ClassName.SHOW);

	      if (this._config.focus) {
	        this._enforceFocus();
	      }

	      var shownEvent &#x3D; $$$1.Event(Event.SHOWN, {
	        relatedTarget: relatedTarget
	      });

	      var transitionComplete &#x3D; function transitionComplete() {
	        if (_this3._config.focus) {
	          _this3._element.focus();
	        }

	        _this3._isTransitioning &#x3D; false;
	        $$$1(_this3._element).trigger(shownEvent);
	      };

	      if (transition) {
	        $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        transitionComplete();
	      }
	    };

	    _proto._enforceFocus &#x3D; function _enforceFocus() {
	      var _this4 &#x3D; this;

	      $$$1(document).off(Event.FOCUSIN) // Guard against infinite focus loop
	      .on(Event.FOCUSIN, function (event) {
	        if (document !&#x3D;&#x3D; event.target &amp;&amp; _this4._element !&#x3D;&#x3D; event.target &amp;&amp; $$$1(_this4._element).has(event.target).length &#x3D;&#x3D;&#x3D; 0) {
	          _this4._element.focus();
	        }
	      });
	    };

	    _proto._setEscapeEvent &#x3D; function _setEscapeEvent() {
	      var _this5 &#x3D; this;

	      if (this._isShown &amp;&amp; this._config.keyboard) {
	        $$$1(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
	          if (event.which &#x3D;&#x3D;&#x3D; ESCAPE_KEYCODE) {
	            event.preventDefault();

	            _this5.hide();
	          }
	        });
	      } else if (!this._isShown) {
	        $$$1(this._element).off(Event.KEYDOWN_DISMISS);
	      }
	    };

	    _proto._setResizeEvent &#x3D; function _setResizeEvent() {
	      var _this6 &#x3D; this;

	      if (this._isShown) {
	        $$$1(window).on(Event.RESIZE, function (event) {
	          return _this6.handleUpdate(event);
	        });
	      } else {
	        $$$1(window).off(Event.RESIZE);
	      }
	    };

	    _proto._hideModal &#x3D; function _hideModal() {
	      var _this7 &#x3D; this;

	      this._element.style.display &#x3D; &#x27;none&#x27;;

	      this._element.setAttribute(&#x27;aria-hidden&#x27;, true);

	      this._isTransitioning &#x3D; false;

	      this._showBackdrop(function () {
	        $$$1(document.body).removeClass(ClassName.OPEN);

	        _this7._resetAdjustments();

	        _this7._resetScrollbar();

	        $$$1(_this7._element).trigger(Event.HIDDEN);
	      });
	    };

	    _proto._removeBackdrop &#x3D; function _removeBackdrop() {
	      if (this._backdrop) {
	        $$$1(this._backdrop).remove();
	        this._backdrop &#x3D; null;
	      }
	    };

	    _proto._showBackdrop &#x3D; function _showBackdrop(callback) {
	      var _this8 &#x3D; this;

	      var animate &#x3D; $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : &#x27;&#x27;;

	      if (this._isShown &amp;&amp; this._config.backdrop) {
	        var doAnimate &#x3D; Util.supportsTransitionEnd() &amp;&amp; animate;
	        this._backdrop &#x3D; document.createElement(&#x27;div&#x27;);
	        this._backdrop.className &#x3D; ClassName.BACKDROP;

	        if (animate) {
	          $$$1(this._backdrop).addClass(animate);
	        }

	        $$$1(this._backdrop).appendTo(document.body);
	        $$$1(this._element).on(Event.CLICK_DISMISS, function (event) {
	          if (_this8._ignoreBackdropClick) {
	            _this8._ignoreBackdropClick &#x3D; false;
	            return;
	          }

	          if (event.target !&#x3D;&#x3D; event.currentTarget) {
	            return;
	          }

	          if (_this8._config.backdrop &#x3D;&#x3D;&#x3D; &#x27;static&#x27;) {
	            _this8._element.focus();
	          } else {
	            _this8.hide();
	          }
	        });

	        if (doAnimate) {
	          Util.reflow(this._backdrop);
	        }

	        $$$1(this._backdrop).addClass(ClassName.SHOW);

	        if (!callback) {
	          return;
	        }

	        if (!doAnimate) {
	          callback();
	          return;
	        }

	        $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
	      } else if (!this._isShown &amp;&amp; this._backdrop) {
	        $$$1(this._backdrop).removeClass(ClassName.SHOW);

	        var callbackRemove &#x3D; function callbackRemove() {
	          _this8._removeBackdrop();

	          if (callback) {
	            callback();
	          }
	        };

	        if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE)) {
	          $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
	        } else {
	          callbackRemove();
	        }
	      } else if (callback) {
	        callback();
	      }
	    }; // ----------------------------------------------------------------------
	    // the following methods are used to handle overflowing modals
	    // todo (fat): these should probably be refactored out of modal.js
	    // ----------------------------------------------------------------------


	    _proto._adjustDialog &#x3D; function _adjustDialog() {
	      var isModalOverflowing &#x3D; this._element.scrollHeight &gt; document.documentElement.clientHeight;

	      if (!this._isBodyOverflowing &amp;&amp; isModalOverflowing) {
	        this._element.style.paddingLeft &#x3D; this._scrollbarWidth + &quot;px&quot;;
	      }

	      if (this._isBodyOverflowing &amp;&amp; !isModalOverflowing) {
	        this._element.style.paddingRight &#x3D; this._scrollbarWidth + &quot;px&quot;;
	      }
	    };

	    _proto._resetAdjustments &#x3D; function _resetAdjustments() {
	      this._element.style.paddingLeft &#x3D; &#x27;&#x27;;
	      this._element.style.paddingRight &#x3D; &#x27;&#x27;;
	    };

	    _proto._checkScrollbar &#x3D; function _checkScrollbar() {
	      var rect &#x3D; document.body.getBoundingClientRect();
	      this._isBodyOverflowing &#x3D; rect.left + rect.right &lt; window.innerWidth;
	      this._scrollbarWidth &#x3D; this._getScrollbarWidth();
	    };

	    _proto._setScrollbar &#x3D; function _setScrollbar() {
	      var _this9 &#x3D; this;

	      if (this._isBodyOverflowing) {
	        // Note: DOMNode.style.paddingRight returns the actual value or &#x27;&#x27; if not set
	        //   while $(DOMNode).css(&#x27;padding-right&#x27;) returns the calculated value or 0 if not set
	        // Adjust fixed content padding
	        $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
	          var actualPadding &#x3D; $$$1(element)[0].style.paddingRight;
	          var calculatedPadding &#x3D; $$$1(element).css(&#x27;padding-right&#x27;);
	          $$$1(element).data(&#x27;padding-right&#x27;, actualPadding).css(&#x27;padding-right&#x27;, parseFloat(calculatedPadding) + _this9._scrollbarWidth + &quot;px&quot;);
	        }); // Adjust sticky content margin

	        $$$1(Selector.STICKY_CONTENT).each(function (index, element) {
	          var actualMargin &#x3D; $$$1(element)[0].style.marginRight;
	          var calculatedMargin &#x3D; $$$1(element).css(&#x27;margin-right&#x27;);
	          $$$1(element).data(&#x27;margin-right&#x27;, actualMargin).css(&#x27;margin-right&#x27;, parseFloat(calculatedMargin) - _this9._scrollbarWidth + &quot;px&quot;);
	        }); // Adjust navbar-toggler margin

	        $$$1(Selector.NAVBAR_TOGGLER).each(function (index, element) {
	          var actualMargin &#x3D; $$$1(element)[0].style.marginRight;
	          var calculatedMargin &#x3D; $$$1(element).css(&#x27;margin-right&#x27;);
	          $$$1(element).data(&#x27;margin-right&#x27;, actualMargin).css(&#x27;margin-right&#x27;, parseFloat(calculatedMargin) + _this9._scrollbarWidth + &quot;px&quot;);
	        }); // Adjust body padding

	        var actualPadding &#x3D; document.body.style.paddingRight;
	        var calculatedPadding &#x3D; $$$1(&#x27;body&#x27;).css(&#x27;padding-right&#x27;);
	        $$$1(&#x27;body&#x27;).data(&#x27;padding-right&#x27;, actualPadding).css(&#x27;padding-right&#x27;, parseFloat(calculatedPadding) + this._scrollbarWidth + &quot;px&quot;);
	      }
	    };

	    _proto._resetScrollbar &#x3D; function _resetScrollbar() {
	      // Restore fixed content padding
	      $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
	        var padding &#x3D; $$$1(element).data(&#x27;padding-right&#x27;);

	        if (typeof padding !&#x3D;&#x3D; &#x27;undefined&#x27;) {
	          $$$1(element).css(&#x27;padding-right&#x27;, padding).removeData(&#x27;padding-right&#x27;);
	        }
	      }); // Restore sticky content and navbar-toggler margin

	      $$$1(Selector.STICKY_CONTENT + &quot;, &quot; + Selector.NAVBAR_TOGGLER).each(function (index, element) {
	        var margin &#x3D; $$$1(element).data(&#x27;margin-right&#x27;);

	        if (typeof margin !&#x3D;&#x3D; &#x27;undefined&#x27;) {
	          $$$1(element).css(&#x27;margin-right&#x27;, margin).removeData(&#x27;margin-right&#x27;);
	        }
	      }); // Restore body padding

	      var padding &#x3D; $$$1(&#x27;body&#x27;).data(&#x27;padding-right&#x27;);

	      if (typeof padding !&#x3D;&#x3D; &#x27;undefined&#x27;) {
	        $$$1(&#x27;body&#x27;).css(&#x27;padding-right&#x27;, padding).removeData(&#x27;padding-right&#x27;);
	      }
	    };

	    _proto._getScrollbarWidth &#x3D; function _getScrollbarWidth() {
	      // thx d.walsh
	      var scrollDiv &#x3D; document.createElement(&#x27;div&#x27;);
	      scrollDiv.className &#x3D; ClassName.SCROLLBAR_MEASURER;
	      document.body.appendChild(scrollDiv);
	      var scrollbarWidth &#x3D; scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
	      document.body.removeChild(scrollDiv);
	      return scrollbarWidth;
	    }; // Static


	    Modal._jQueryInterface &#x3D; function _jQueryInterface(config, relatedTarget) {
	      return this.each(function () {
	        var data &#x3D; $$$1(this).data(DATA_KEY);

	        var _config &#x3D; _extends({}, Modal.Default, $$$1(this).data(), typeof config &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; config);

	        if (!data) {
	          data &#x3D; new Modal(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[config] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config](relatedTarget);
	        } else if (_config.show) {
	          data.show(relatedTarget);
	        }
	      });
	    };

	    _createClass(Modal, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Modal;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    var _this10 &#x3D; this;

	    var target;
	    var selector &#x3D; Util.getSelectorFromElement(this);

	    if (selector) {
	      target &#x3D; $$$1(selector)[0];
	    }

	    var config &#x3D; $$$1(target).data(DATA_KEY) ? &#x27;toggle&#x27; : _extends({}, $$$1(target).data(), $$$1(this).data());

	    if (this.tagName &#x3D;&#x3D;&#x3D; &#x27;A&#x27; || this.tagName &#x3D;&#x3D;&#x3D; &#x27;AREA&#x27;) {
	      event.preventDefault();
	    }

	    var $target &#x3D; $$$1(target).one(Event.SHOW, function (showEvent) {
	      if (showEvent.isDefaultPrevented()) {
	        // Only register focus restorer if modal will actually get shown
	        return;
	      }

	      $target.one(Event.HIDDEN, function () {
	        if ($$$1(_this10).is(&#x27;:visible&#x27;)) {
	          _this10.focus();
	        }
	      });
	    });

	    Modal._jQueryInterface.call($$$1(target), config, this);
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; Modal._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Modal;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Modal._jQueryInterface;
	  };

	  return Modal;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): tooltip.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Tooltip &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;tooltip&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.tooltip&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var TRANSITION_DURATION &#x3D; 150;
	  var CLASS_PREFIX &#x3D; &#x27;bs-tooltip&#x27;;
	  var BSCLS_PREFIX_REGEX &#x3D; new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, &#x27;g&#x27;);
	  var DefaultType &#x3D; {
	    animation: &#x27;boolean&#x27;,
	    template: &#x27;string&#x27;,
	    title: &#x27;(string|element|function)&#x27;,
	    trigger: &#x27;string&#x27;,
	    delay: &#x27;(number|object)&#x27;,
	    html: &#x27;boolean&#x27;,
	    selector: &#x27;(string|boolean)&#x27;,
	    placement: &#x27;(string|function)&#x27;,
	    offset: &#x27;(number|string)&#x27;,
	    container: &#x27;(string|element|boolean)&#x27;,
	    fallbackPlacement: &#x27;(string|array)&#x27;,
	    boundary: &#x27;(string|element)&#x27;
	  };
	  var AttachmentMap &#x3D; {
	    AUTO: &#x27;auto&#x27;,
	    TOP: &#x27;top&#x27;,
	    RIGHT: &#x27;right&#x27;,
	    BOTTOM: &#x27;bottom&#x27;,
	    LEFT: &#x27;left&#x27;
	  };
	  var Default &#x3D; {
	    animation: true,
	    template: &#x27;&lt;div class&#x3D;&quot;tooltip&quot; role&#x3D;&quot;tooltip&quot;&gt;&#x27; + &#x27;&lt;div class&#x3D;&quot;arrow&quot;&gt;&lt;/div&gt;&#x27; + &#x27;&lt;div class&#x3D;&quot;tooltip-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;,
	    trigger: &#x27;hover focus&#x27;,
	    title: &#x27;&#x27;,
	    delay: 0,
	    html: false,
	    selector: false,
	    placement: &#x27;top&#x27;,
	    offset: 0,
	    container: false,
	    fallbackPlacement: &#x27;flip&#x27;,
	    boundary: &#x27;scrollParent&#x27;
	  };
	  var HoverState &#x3D; {
	    SHOW: &#x27;show&#x27;,
	    OUT: &#x27;out&#x27;
	  };
	  var Event &#x3D; {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    INSERTED: &quot;inserted&quot; + EVENT_KEY,
	    CLICK: &quot;click&quot; + EVENT_KEY,
	    FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
	    FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
	    MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
	    MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
	  };
	  var ClassName &#x3D; {
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector &#x3D; {
	    TOOLTIP: &#x27;.tooltip&#x27;,
	    TOOLTIP_INNER: &#x27;.tooltip-inner&#x27;,
	    ARROW: &#x27;.arrow&#x27;
	  };
	  var Trigger &#x3D; {
	    HOVER: &#x27;hover&#x27;,
	    FOCUS: &#x27;focus&#x27;,
	    CLICK: &#x27;click&#x27;,
	    MANUAL: &#x27;manual&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Tooltip &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Tooltip(element, config) {
	      /**
	       * Check for Popper dependency
	       * Popper - https://popper.js.org
	       */
	      if (typeof Popper &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	        throw new TypeError(&#x27;Bootstrap tooltips require Popper.js (https://popper.js.org)&#x27;);
	      } // private


	      this._isEnabled &#x3D; true;
	      this._timeout &#x3D; 0;
	      this._hoverState &#x3D; &#x27;&#x27;;
	      this._activeTrigger &#x3D; {};
	      this._popper &#x3D; null; // Protected

	      this.element &#x3D; element;
	      this.config &#x3D; this._getConfig(config);
	      this.tip &#x3D; null;

	      this._setListeners();
	    } // Getters


	    var _proto &#x3D; Tooltip.prototype;

	    // Public
	    _proto.enable &#x3D; function enable() {
	      this._isEnabled &#x3D; true;
	    };

	    _proto.disable &#x3D; function disable() {
	      this._isEnabled &#x3D; false;
	    };

	    _proto.toggleEnabled &#x3D; function toggleEnabled() {
	      this._isEnabled &#x3D; !this._isEnabled;
	    };

	    _proto.toggle &#x3D; function toggle(event) {
	      if (!this._isEnabled) {
	        return;
	      }

	      if (event) {
	        var dataKey &#x3D; this.constructor.DATA_KEY;
	        var context &#x3D; $$$1(event.currentTarget).data(dataKey);

	        if (!context) {
	          context &#x3D; new this.constructor(event.currentTarget, this._getDelegateConfig());
	          $$$1(event.currentTarget).data(dataKey, context);
	        }

	        context._activeTrigger.click &#x3D; !context._activeTrigger.click;

	        if (context._isWithActiveTrigger()) {
	          context._enter(null, context);
	        } else {
	          context._leave(null, context);
	        }
	      } else {
	        if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {
	          this._leave(null, this);

	          return;
	        }

	        this._enter(null, this);
	      }
	    };

	    _proto.dispose &#x3D; function dispose() {
	      clearTimeout(this._timeout);
	      $$$1.removeData(this.element, this.constructor.DATA_KEY);
	      $$$1(this.element).off(this.constructor.EVENT_KEY);
	      $$$1(this.element).closest(&#x27;.modal&#x27;).off(&#x27;hide.bs.modal&#x27;);

	      if (this.tip) {
	        $$$1(this.tip).remove();
	      }

	      this._isEnabled &#x3D; null;
	      this._timeout &#x3D; null;
	      this._hoverState &#x3D; null;
	      this._activeTrigger &#x3D; null;

	      if (this._popper !&#x3D;&#x3D; null) {
	        this._popper.destroy();
	      }

	      this._popper &#x3D; null;
	      this.element &#x3D; null;
	      this.config &#x3D; null;
	      this.tip &#x3D; null;
	    };

	    _proto.show &#x3D; function show() {
	      var _this &#x3D; this;

	      if ($$$1(this.element).css(&#x27;display&#x27;) &#x3D;&#x3D;&#x3D; &#x27;none&#x27;) {
	        throw new Error(&#x27;Please use show on visible elements&#x27;);
	      }

	      var showEvent &#x3D; $$$1.Event(this.constructor.Event.SHOW);

	      if (this.isWithContent() &amp;&amp; this._isEnabled) {
	        $$$1(this.element).trigger(showEvent);
	        var isInTheDom &#x3D; $$$1.contains(this.element.ownerDocument.documentElement, this.element);

	        if (showEvent.isDefaultPrevented() || !isInTheDom) {
	          return;
	        }

	        var tip &#x3D; this.getTipElement();
	        var tipId &#x3D; Util.getUID(this.constructor.NAME);
	        tip.setAttribute(&#x27;id&#x27;, tipId);
	        this.element.setAttribute(&#x27;aria-describedby&#x27;, tipId);
	        this.setContent();

	        if (this.config.animation) {
	          $$$1(tip).addClass(ClassName.FADE);
	        }

	        var placement &#x3D; typeof this.config.placement &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? this.config.placement.call(this, tip, this.element) : this.config.placement;

	        var attachment &#x3D; this._getAttachment(placement);

	        this.addAttachmentClass(attachment);
	        var container &#x3D; this.config.container &#x3D;&#x3D;&#x3D; false ? document.body : $$$1(this.config.container);
	        $$$1(tip).data(this.constructor.DATA_KEY, this);

	        if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {
	          $$$1(tip).appendTo(container);
	        }

	        $$$1(this.element).trigger(this.constructor.Event.INSERTED);
	        this._popper &#x3D; new Popper(this.element, tip, {
	          placement: attachment,
	          modifiers: {
	            offset: {
	              offset: this.config.offset
	            },
	            flip: {
	              behavior: this.config.fallbackPlacement
	            },
	            arrow: {
	              element: Selector.ARROW
	            },
	            preventOverflow: {
	              boundariesElement: this.config.boundary
	            }
	          },
	          onCreate: function onCreate(data) {
	            if (data.originalPlacement !&#x3D;&#x3D; data.placement) {
	              _this._handlePopperPlacementChange(data);
	            }
	          },
	          onUpdate: function onUpdate(data) {
	            _this._handlePopperPlacementChange(data);
	          }
	        });
	        $$$1(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra
	        // empty mouseover listeners to the body&#x27;s immediate children;
	        // only needed because of broken event delegation on iOS
	        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

	        if (&#x27;ontouchstart&#x27; in document.documentElement) {
	          $$$1(&#x27;body&#x27;).children().on(&#x27;mouseover&#x27;, null, $$$1.noop);
	        }

	        var complete &#x3D; function complete() {
	          if (_this.config.animation) {
	            _this._fixTransition();
	          }

	          var prevHoverState &#x3D; _this._hoverState;
	          _this._hoverState &#x3D; null;
	          $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);

	          if (prevHoverState &#x3D;&#x3D;&#x3D; HoverState.OUT) {
	            _this._leave(null, _this);
	          }
	        };

	        if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this.tip).hasClass(ClassName.FADE)) {
	          $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
	        } else {
	          complete();
	        }
	      }
	    };

	    _proto.hide &#x3D; function hide(callback) {
	      var _this2 &#x3D; this;

	      var tip &#x3D; this.getTipElement();
	      var hideEvent &#x3D; $$$1.Event(this.constructor.Event.HIDE);

	      var complete &#x3D; function complete() {
	        if (_this2._hoverState !&#x3D;&#x3D; HoverState.SHOW &amp;&amp; tip.parentNode) {
	          tip.parentNode.removeChild(tip);
	        }

	        _this2._cleanTipClass();

	        _this2.element.removeAttribute(&#x27;aria-describedby&#x27;);

	        $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

	        if (_this2._popper !&#x3D;&#x3D; null) {
	          _this2._popper.destroy();
	        }

	        if (callback) {
	          callback();
	        }
	      };

	      $$$1(this.element).trigger(hideEvent);

	      if (hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      $$$1(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra
	      // empty mouseover listeners we added for iOS support

	      if (&#x27;ontouchstart&#x27; in document.documentElement) {
	        $$$1(&#x27;body&#x27;).children().off(&#x27;mouseover&#x27;, null, $$$1.noop);
	      }

	      this._activeTrigger[Trigger.CLICK] &#x3D; false;
	      this._activeTrigger[Trigger.FOCUS] &#x3D; false;
	      this._activeTrigger[Trigger.HOVER] &#x3D; false;

	      if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this.tip).hasClass(ClassName.FADE)) {
	        $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        complete();
	      }

	      this._hoverState &#x3D; &#x27;&#x27;;
	    };

	    _proto.update &#x3D; function update() {
	      if (this._popper !&#x3D;&#x3D; null) {
	        this._popper.scheduleUpdate();
	      }
	    }; // Protected


	    _proto.isWithContent &#x3D; function isWithContent() {
	      return Boolean(this.getTitle());
	    };

	    _proto.addAttachmentClass &#x3D; function addAttachmentClass(attachment) {
	      $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
	    };

	    _proto.getTipElement &#x3D; function getTipElement() {
	      this.tip &#x3D; this.tip || $$$1(this.config.template)[0];
	      return this.tip;
	    };

	    _proto.setContent &#x3D; function setContent() {
	      var $tip &#x3D; $$$1(this.getTipElement());
	      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
	      $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
	    };

	    _proto.setElementContent &#x3D; function setElementContent($element, content) {
	      var html &#x3D; this.config.html;

	      if (typeof content &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; (content.nodeType || content.jquery)) {
	        // Content is a DOM node or a jQuery
	        if (html) {
	          if (!$$$1(content).parent().is($element)) {
	            $element.empty().append(content);
	          }
	        } else {
	          $element.text($$$1(content).text());
	        }
	      } else {
	        $element[html ? &#x27;html&#x27; : &#x27;text&#x27;](content);
	      }
	    };

	    _proto.getTitle &#x3D; function getTitle() {
	      var title &#x3D; this.element.getAttribute(&#x27;data-original-title&#x27;);

	      if (!title) {
	        title &#x3D; typeof this.config.title &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? this.config.title.call(this.element) : this.config.title;
	      }

	      return title;
	    }; // Private


	    _proto._getAttachment &#x3D; function _getAttachment(placement) {
	      return AttachmentMap[placement.toUpperCase()];
	    };

	    _proto._setListeners &#x3D; function _setListeners() {
	      var _this3 &#x3D; this;

	      var triggers &#x3D; this.config.trigger.split(&#x27; &#x27;);
	      triggers.forEach(function (trigger) {
	        if (trigger &#x3D;&#x3D;&#x3D; &#x27;click&#x27;) {
	          $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
	            return _this3.toggle(event);
	          });
	        } else if (trigger !&#x3D;&#x3D; Trigger.MANUAL) {
	          var eventIn &#x3D; trigger &#x3D;&#x3D;&#x3D; Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
	          var eventOut &#x3D; trigger &#x3D;&#x3D;&#x3D; Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
	          $$$1(_this3.element).on(eventIn, _this3.config.selector, function (event) {
	            return _this3._enter(event);
	          }).on(eventOut, _this3.config.selector, function (event) {
	            return _this3._leave(event);
	          });
	        }

	        $$$1(_this3.element).closest(&#x27;.modal&#x27;).on(&#x27;hide.bs.modal&#x27;, function () {
	          return _this3.hide();
	        });
	      });

	      if (this.config.selector) {
	        this.config &#x3D; _extends({}, this.config, {
	          trigger: &#x27;manual&#x27;,
	          selector: &#x27;&#x27;
	        });
	      } else {
	        this._fixTitle();
	      }
	    };

	    _proto._fixTitle &#x3D; function _fixTitle() {
	      var titleType &#x3D; typeof this.element.getAttribute(&#x27;data-original-title&#x27;);

	      if (this.element.getAttribute(&#x27;title&#x27;) || titleType !&#x3D;&#x3D; &#x27;string&#x27;) {
	        this.element.setAttribute(&#x27;data-original-title&#x27;, this.element.getAttribute(&#x27;title&#x27;) || &#x27;&#x27;);
	        this.element.setAttribute(&#x27;title&#x27;, &#x27;&#x27;);
	      }
	    };

	    _proto._enter &#x3D; function _enter(event, context) {
	      var dataKey &#x3D; this.constructor.DATA_KEY;
	      context &#x3D; context || $$$1(event.currentTarget).data(dataKey);

	      if (!context) {
	        context &#x3D; new this.constructor(event.currentTarget, this._getDelegateConfig());
	        $$$1(event.currentTarget).data(dataKey, context);
	      }

	      if (event) {
	        context._activeTrigger[event.type &#x3D;&#x3D;&#x3D; &#x27;focusin&#x27; ? Trigger.FOCUS : Trigger.HOVER] &#x3D; true;
	      }

	      if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState &#x3D;&#x3D;&#x3D; HoverState.SHOW) {
	        context._hoverState &#x3D; HoverState.SHOW;
	        return;
	      }

	      clearTimeout(context._timeout);
	      context._hoverState &#x3D; HoverState.SHOW;

	      if (!context.config.delay || !context.config.delay.show) {
	        context.show();
	        return;
	      }

	      context._timeout &#x3D; setTimeout(function () {
	        if (context._hoverState &#x3D;&#x3D;&#x3D; HoverState.SHOW) {
	          context.show();
	        }
	      }, context.config.delay.show);
	    };

	    _proto._leave &#x3D; function _leave(event, context) {
	      var dataKey &#x3D; this.constructor.DATA_KEY;
	      context &#x3D; context || $$$1(event.currentTarget).data(dataKey);

	      if (!context) {
	        context &#x3D; new this.constructor(event.currentTarget, this._getDelegateConfig());
	        $$$1(event.currentTarget).data(dataKey, context);
	      }

	      if (event) {
	        context._activeTrigger[event.type &#x3D;&#x3D;&#x3D; &#x27;focusout&#x27; ? Trigger.FOCUS : Trigger.HOVER] &#x3D; false;
	      }

	      if (context._isWithActiveTrigger()) {
	        return;
	      }

	      clearTimeout(context._timeout);
	      context._hoverState &#x3D; HoverState.OUT;

	      if (!context.config.delay || !context.config.delay.hide) {
	        context.hide();
	        return;
	      }

	      context._timeout &#x3D; setTimeout(function () {
	        if (context._hoverState &#x3D;&#x3D;&#x3D; HoverState.OUT) {
	          context.hide();
	        }
	      }, context.config.delay.hide);
	    };

	    _proto._isWithActiveTrigger &#x3D; function _isWithActiveTrigger() {
	      for (var trigger in this._activeTrigger) {
	        if (this._activeTrigger[trigger]) {
	          return true;
	        }
	      }

	      return false;
	    };

	    _proto._getConfig &#x3D; function _getConfig(config) {
	      config &#x3D; _extends({}, this.constructor.Default, $$$1(this.element).data(), config);

	      if (typeof config.delay &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
	        config.delay &#x3D; {
	          show: config.delay,
	          hide: config.delay
	        };
	      }

	      if (typeof config.title &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
	        config.title &#x3D; config.title.toString();
	      }

	      if (typeof config.content &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
	        config.content &#x3D; config.content.toString();
	      }

	      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
	      return config;
	    };

	    _proto._getDelegateConfig &#x3D; function _getDelegateConfig() {
	      var config &#x3D; {};

	      if (this.config) {
	        for (var key in this.config) {
	          if (this.constructor.Default[key] !&#x3D;&#x3D; this.config[key]) {
	            config[key] &#x3D; this.config[key];
	          }
	        }
	      }

	      return config;
	    };

	    _proto._cleanTipClass &#x3D; function _cleanTipClass() {
	      var $tip &#x3D; $$$1(this.getTipElement());
	      var tabClass &#x3D; $tip.attr(&#x27;class&#x27;).match(BSCLS_PREFIX_REGEX);

	      if (tabClass !&#x3D;&#x3D; null &amp;&amp; tabClass.length &gt; 0) {
	        $tip.removeClass(tabClass.join(&#x27;&#x27;));
	      }
	    };

	    _proto._handlePopperPlacementChange &#x3D; function _handlePopperPlacementChange(data) {
	      this._cleanTipClass();

	      this.addAttachmentClass(this._getAttachment(data.placement));
	    };

	    _proto._fixTransition &#x3D; function _fixTransition() {
	      var tip &#x3D; this.getTipElement();
	      var initConfigAnimation &#x3D; this.config.animation;

	      if (tip.getAttribute(&#x27;x-placement&#x27;) !&#x3D;&#x3D; null) {
	        return;
	      }

	      $$$1(tip).removeClass(ClassName.FADE);
	      this.config.animation &#x3D; false;
	      this.hide();
	      this.show();
	      this.config.animation &#x3D; initConfigAnimation;
	    }; // Static


	    Tooltip._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var data &#x3D; $$$1(this).data(DATA_KEY);

	        var _config &#x3D; typeof config &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; config;

	        if (!data &amp;&amp; /dispose|hide/.test(config)) {
	          return;
	        }

	        if (!data) {
	          data &#x3D; new Tooltip(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[config] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Tooltip, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: &quot;NAME&quot;,
	      get: function get() {
	        return NAME;
	      }
	    }, {
	      key: &quot;DATA_KEY&quot;,
	      get: function get() {
	        return DATA_KEY;
	      }
	    }, {
	      key: &quot;Event&quot;,
	      get: function get() {
	        return Event;
	      }
	    }, {
	      key: &quot;EVENT_KEY&quot;,
	      get: function get() {
	        return EVENT_KEY;
	      }
	    }, {
	      key: &quot;DefaultType&quot;,
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Tooltip;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */


	  $$$1.fn[NAME] &#x3D; Tooltip._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Tooltip;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Tooltip._jQueryInterface;
	  };

	  return Tooltip;
	}($, Popper);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): popover.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Popover &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;popover&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.popover&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var CLASS_PREFIX &#x3D; &#x27;bs-popover&#x27;;
	  var BSCLS_PREFIX_REGEX &#x3D; new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, &#x27;g&#x27;);
	  var Default &#x3D; _extends({}, Tooltip.Default, {
	    placement: &#x27;right&#x27;,
	    trigger: &#x27;click&#x27;,
	    content: &#x27;&#x27;,
	    template: &#x27;&lt;div class&#x3D;&quot;popover&quot; role&#x3D;&quot;tooltip&quot;&gt;&#x27; + &#x27;&lt;div class&#x3D;&quot;arrow&quot;&gt;&lt;/div&gt;&#x27; + &#x27;&lt;h3 class&#x3D;&quot;popover-header&quot;&gt;&lt;/h3&gt;&#x27; + &#x27;&lt;div class&#x3D;&quot;popover-body&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;
	  });
	  var DefaultType &#x3D; _extends({}, Tooltip.DefaultType, {
	    content: &#x27;(string|element|function)&#x27;
	  });
	  var ClassName &#x3D; {
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector &#x3D; {
	    TITLE: &#x27;.popover-header&#x27;,
	    CONTENT: &#x27;.popover-body&#x27;
	  };
	  var Event &#x3D; {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    INSERTED: &quot;inserted&quot; + EVENT_KEY,
	    CLICK: &quot;click&quot; + EVENT_KEY,
	    FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
	    FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
	    MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
	    MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Popover &#x3D;
	  /*#__PURE__*/
	  function (_Tooltip) {
	    _inheritsLoose(Popover, _Tooltip);

	    function Popover() {
	      return _Tooltip.apply(this, arguments) || this;
	    }

	    var _proto &#x3D; Popover.prototype;

	    // Overrides
	    _proto.isWithContent &#x3D; function isWithContent() {
	      return this.getTitle() || this._getContent();
	    };

	    _proto.addAttachmentClass &#x3D; function addAttachmentClass(attachment) {
	      $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
	    };

	    _proto.getTipElement &#x3D; function getTipElement() {
	      this.tip &#x3D; this.tip || $$$1(this.config.template)[0];
	      return this.tip;
	    };

	    _proto.setContent &#x3D; function setContent() {
	      var $tip &#x3D; $$$1(this.getTipElement()); // We use append for html objects to maintain js events

	      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());

	      var content &#x3D; this._getContent();

	      if (typeof content &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
	        content &#x3D; content.call(this.element);
	      }

	      this.setElementContent($tip.find(Selector.CONTENT), content);
	      $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
	    }; // Private


	    _proto._getContent &#x3D; function _getContent() {
	      return this.element.getAttribute(&#x27;data-content&#x27;) || this.config.content;
	    };

	    _proto._cleanTipClass &#x3D; function _cleanTipClass() {
	      var $tip &#x3D; $$$1(this.getTipElement());
	      var tabClass &#x3D; $tip.attr(&#x27;class&#x27;).match(BSCLS_PREFIX_REGEX);

	      if (tabClass !&#x3D;&#x3D; null &amp;&amp; tabClass.length &gt; 0) {
	        $tip.removeClass(tabClass.join(&#x27;&#x27;));
	      }
	    }; // Static


	    Popover._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var data &#x3D; $$$1(this).data(DATA_KEY);

	        var _config &#x3D; typeof config &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? config : null;

	        if (!data &amp;&amp; /destroy|hide/.test(config)) {
	          return;
	        }

	        if (!data) {
	          data &#x3D; new Popover(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[config] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Popover, null, [{
	      key: &quot;VERSION&quot;,
	      // Getters
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: &quot;NAME&quot;,
	      get: function get() {
	        return NAME;
	      }
	    }, {
	      key: &quot;DATA_KEY&quot;,
	      get: function get() {
	        return DATA_KEY;
	      }
	    }, {
	      key: &quot;Event&quot;,
	      get: function get() {
	        return Event;
	      }
	    }, {
	      key: &quot;EVENT_KEY&quot;,
	      get: function get() {
	        return EVENT_KEY;
	      }
	    }, {
	      key: &quot;DefaultType&quot;,
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Popover;
	  }(Tooltip);
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */


	  $$$1.fn[NAME] &#x3D; Popover._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Popover;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Popover._jQueryInterface;
	  };

	  return Popover;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): scrollspy.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var ScrollSpy &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;scrollspy&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.scrollspy&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var Default &#x3D; {
	    offset: 10,
	    method: &#x27;auto&#x27;,
	    target: &#x27;&#x27;
	  };
	  var DefaultType &#x3D; {
	    offset: &#x27;number&#x27;,
	    method: &#x27;string&#x27;,
	    target: &#x27;(string|element)&#x27;
	  };
	  var Event &#x3D; {
	    ACTIVATE: &quot;activate&quot; + EVENT_KEY,
	    SCROLL: &quot;scroll&quot; + EVENT_KEY,
	    LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName &#x3D; {
	    DROPDOWN_ITEM: &#x27;dropdown-item&#x27;,
	    DROPDOWN_MENU: &#x27;dropdown-menu&#x27;,
	    ACTIVE: &#x27;active&#x27;
	  };
	  var Selector &#x3D; {
	    DATA_SPY: &#x27;[data-spy&#x3D;&quot;scroll&quot;]&#x27;,
	    ACTIVE: &#x27;.active&#x27;,
	    NAV_LIST_GROUP: &#x27;.nav, .list-group&#x27;,
	    NAV_LINKS: &#x27;.nav-link&#x27;,
	    NAV_ITEMS: &#x27;.nav-item&#x27;,
	    LIST_ITEMS: &#x27;.list-group-item&#x27;,
	    DROPDOWN: &#x27;.dropdown&#x27;,
	    DROPDOWN_ITEMS: &#x27;.dropdown-item&#x27;,
	    DROPDOWN_TOGGLE: &#x27;.dropdown-toggle&#x27;
	  };
	  var OffsetMethod &#x3D; {
	    OFFSET: &#x27;offset&#x27;,
	    POSITION: &#x27;position&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var ScrollSpy &#x3D;
	  /*#__PURE__*/
	  function () {
	    function ScrollSpy(element, config) {
	      var _this &#x3D; this;

	      this._element &#x3D; element;
	      this._scrollElement &#x3D; element.tagName &#x3D;&#x3D;&#x3D; &#x27;BODY&#x27; ? window : element;
	      this._config &#x3D; this._getConfig(config);
	      this._selector &#x3D; this._config.target + &quot; &quot; + Selector.NAV_LINKS + &quot;,&quot; + (this._config.target + &quot; &quot; + Selector.LIST_ITEMS + &quot;,&quot;) + (this._config.target + &quot; &quot; + Selector.DROPDOWN_ITEMS);
	      this._offsets &#x3D; [];
	      this._targets &#x3D; [];
	      this._activeTarget &#x3D; null;
	      this._scrollHeight &#x3D; 0;
	      $$$1(this._scrollElement).on(Event.SCROLL, function (event) {
	        return _this._process(event);
	      });
	      this.refresh();

	      this._process();
	    } // Getters


	    var _proto &#x3D; ScrollSpy.prototype;

	    // Public
	    _proto.refresh &#x3D; function refresh() {
	      var _this2 &#x3D; this;

	      var autoMethod &#x3D; this._scrollElement &#x3D;&#x3D;&#x3D; this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
	      var offsetMethod &#x3D; this._config.method &#x3D;&#x3D;&#x3D; &#x27;auto&#x27; ? autoMethod : this._config.method;
	      var offsetBase &#x3D; offsetMethod &#x3D;&#x3D;&#x3D; OffsetMethod.POSITION ? this._getScrollTop() : 0;
	      this._offsets &#x3D; [];
	      this._targets &#x3D; [];
	      this._scrollHeight &#x3D; this._getScrollHeight();
	      var targets &#x3D; $$$1.makeArray($$$1(this._selector));
	      targets.map(function (element) {
	        var target;
	        var targetSelector &#x3D; Util.getSelectorFromElement(element);

	        if (targetSelector) {
	          target &#x3D; $$$1(targetSelector)[0];
	        }

	        if (target) {
	          var targetBCR &#x3D; target.getBoundingClientRect();

	          if (targetBCR.width || targetBCR.height) {
	            // TODO (fat): remove sketch reliance on jQuery position/offset
	            return [$$$1(target)[offsetMethod]().top + offsetBase, targetSelector];
	          }
	        }

	        return null;
	      }).filter(function (item) {
	        return item;
	      }).sort(function (a, b) {
	        return a[0] - b[0];
	      }).forEach(function (item) {
	        _this2._offsets.push(item[0]);

	        _this2._targets.push(item[1]);
	      });
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      $$$1(this._scrollElement).off(EVENT_KEY);
	      this._element &#x3D; null;
	      this._scrollElement &#x3D; null;
	      this._config &#x3D; null;
	      this._selector &#x3D; null;
	      this._offsets &#x3D; null;
	      this._targets &#x3D; null;
	      this._activeTarget &#x3D; null;
	      this._scrollHeight &#x3D; null;
	    }; // Private


	    _proto._getConfig &#x3D; function _getConfig(config) {
	      config &#x3D; _extends({}, Default, config);

	      if (typeof config.target !&#x3D;&#x3D; &#x27;string&#x27;) {
	        var id &#x3D; $$$1(config.target).attr(&#x27;id&#x27;);

	        if (!id) {
	          id &#x3D; Util.getUID(NAME);
	          $$$1(config.target).attr(&#x27;id&#x27;, id);
	        }

	        config.target &#x3D; &quot;#&quot; + id;
	      }

	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._getScrollTop &#x3D; function _getScrollTop() {
	      return this._scrollElement &#x3D;&#x3D;&#x3D; window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
	    };

	    _proto._getScrollHeight &#x3D; function _getScrollHeight() {
	      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
	    };

	    _proto._getOffsetHeight &#x3D; function _getOffsetHeight() {
	      return this._scrollElement &#x3D;&#x3D;&#x3D; window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
	    };

	    _proto._process &#x3D; function _process() {
	      var scrollTop &#x3D; this._getScrollTop() + this._config.offset;

	      var scrollHeight &#x3D; this._getScrollHeight();

	      var maxScroll &#x3D; this._config.offset + scrollHeight - this._getOffsetHeight();

	      if (this._scrollHeight !&#x3D;&#x3D; scrollHeight) {
	        this.refresh();
	      }

	      if (scrollTop &gt;&#x3D; maxScroll) {
	        var target &#x3D; this._targets[this._targets.length - 1];

	        if (this._activeTarget !&#x3D;&#x3D; target) {
	          this._activate(target);
	        }

	        return;
	      }

	      if (this._activeTarget &amp;&amp; scrollTop &lt; this._offsets[0] &amp;&amp; this._offsets[0] &gt; 0) {
	        this._activeTarget &#x3D; null;

	        this._clear();

	        return;
	      }

	      for (var i &#x3D; this._offsets.length; i--;) {
	        var isActiveTarget &#x3D; this._activeTarget !&#x3D;&#x3D; this._targets[i] &amp;&amp; scrollTop &gt;&#x3D; this._offsets[i] &amp;&amp; (typeof this._offsets[i + 1] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; || scrollTop &lt; this._offsets[i + 1]);

	        if (isActiveTarget) {
	          this._activate(this._targets[i]);
	        }
	      }
	    };

	    _proto._activate &#x3D; function _activate(target) {
	      this._activeTarget &#x3D; target;

	      this._clear();

	      var queries &#x3D; this._selector.split(&#x27;,&#x27;); // eslint-disable-next-line arrow-body-style


	      queries &#x3D; queries.map(function (selector) {
	        return selector + &quot;[data-target&#x3D;\&quot;&quot; + target + &quot;\&quot;],&quot; + (selector + &quot;[href&#x3D;\&quot;&quot; + target + &quot;\&quot;]&quot;);
	      });
	      var $link &#x3D; $$$1(queries.join(&#x27;,&#x27;));

	      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
	        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
	        $link.addClass(ClassName.ACTIVE);
	      } else {
	        // Set triggered link as active
	        $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
	        // With both &lt;ul&gt; and &lt;nav&gt; markup a parent is the previous sibling of any nav ancestor

	        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + &quot;, &quot; + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

	        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
	      }

	      $$$1(this._scrollElement).trigger(Event.ACTIVATE, {
	        relatedTarget: target
	      });
	    };

	    _proto._clear &#x3D; function _clear() {
	      $$$1(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
	    }; // Static


	    ScrollSpy._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var data &#x3D; $$$1(this).data(DATA_KEY);

	        var _config &#x3D; typeof config &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; config;

	        if (!data) {
	          data &#x3D; new ScrollSpy(this, _config);
	          $$$1(this).data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[config] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(ScrollSpy, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: &quot;Default&quot;,
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return ScrollSpy;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(window).on(Event.LOAD_DATA_API, function () {
	    var scrollSpys &#x3D; $$$1.makeArray($$$1(Selector.DATA_SPY));

	    for (var i &#x3D; scrollSpys.length; i--;) {
	      var $spy &#x3D; $$$1(scrollSpys[i]);

	      ScrollSpy._jQueryInterface.call($spy, $spy.data());
	    }
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; ScrollSpy._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; ScrollSpy;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return ScrollSpy._jQueryInterface;
	  };

	  return ScrollSpy;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0): tab.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Tab &#x3D; function ($$$1) {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME &#x3D; &#x27;tab&#x27;;
	  var VERSION &#x3D; &#x27;4.0.0&#x27;;
	  var DATA_KEY &#x3D; &#x27;bs.tab&#x27;;
	  var EVENT_KEY &#x3D; &quot;.&quot; + DATA_KEY;
	  var DATA_API_KEY &#x3D; &#x27;.data-api&#x27;;
	  var JQUERY_NO_CONFLICT &#x3D; $$$1.fn[NAME];
	  var TRANSITION_DURATION &#x3D; 150;
	  var Event &#x3D; {
	    HIDE: &quot;hide&quot; + EVENT_KEY,
	    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
	    SHOW: &quot;show&quot; + EVENT_KEY,
	    SHOWN: &quot;shown&quot; + EVENT_KEY,
	    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName &#x3D; {
	    DROPDOWN_MENU: &#x27;dropdown-menu&#x27;,
	    ACTIVE: &#x27;active&#x27;,
	    DISABLED: &#x27;disabled&#x27;,
	    FADE: &#x27;fade&#x27;,
	    SHOW: &#x27;show&#x27;
	  };
	  var Selector &#x3D; {
	    DROPDOWN: &#x27;.dropdown&#x27;,
	    NAV_LIST_GROUP: &#x27;.nav, .list-group&#x27;,
	    ACTIVE: &#x27;.active&#x27;,
	    ACTIVE_UL: &#x27;&gt; li &gt; .active&#x27;,
	    DATA_TOGGLE: &#x27;[data-toggle&#x3D;&quot;tab&quot;], [data-toggle&#x3D;&quot;pill&quot;], [data-toggle&#x3D;&quot;list&quot;]&#x27;,
	    DROPDOWN_TOGGLE: &#x27;.dropdown-toggle&#x27;,
	    DROPDOWN_ACTIVE_CHILD: &#x27;&gt; .dropdown-menu .active&#x27;
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Tab &#x3D;
	  /*#__PURE__*/
	  function () {
	    function Tab(element) {
	      this._element &#x3D; element;
	    } // Getters


	    var _proto &#x3D; Tab.prototype;

	    // Public
	    _proto.show &#x3D; function show() {
	      var _this &#x3D; this;

	      if (this._element.parentNode &amp;&amp; this._element.parentNode.nodeType &#x3D;&#x3D;&#x3D; Node.ELEMENT_NODE &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var target;
	      var previous;
	      var listElement &#x3D; $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];
	      var selector &#x3D; Util.getSelectorFromElement(this._element);

	      if (listElement) {
	        var itemSelector &#x3D; listElement.nodeName &#x3D;&#x3D;&#x3D; &#x27;UL&#x27; ? Selector.ACTIVE_UL : Selector.ACTIVE;
	        previous &#x3D; $$$1.makeArray($$$1(listElement).find(itemSelector));
	        previous &#x3D; previous[previous.length - 1];
	      }

	      var hideEvent &#x3D; $$$1.Event(Event.HIDE, {
	        relatedTarget: this._element
	      });
	      var showEvent &#x3D; $$$1.Event(Event.SHOW, {
	        relatedTarget: previous
	      });

	      if (previous) {
	        $$$1(previous).trigger(hideEvent);
	      }

	      $$$1(this._element).trigger(showEvent);

	      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (selector) {
	        target &#x3D; $$$1(selector)[0];
	      }

	      this._activate(this._element, listElement);

	      var complete &#x3D; function complete() {
	        var hiddenEvent &#x3D; $$$1.Event(Event.HIDDEN, {
	          relatedTarget: _this._element
	        });
	        var shownEvent &#x3D; $$$1.Event(Event.SHOWN, {
	          relatedTarget: previous
	        });
	        $$$1(previous).trigger(hiddenEvent);
	        $$$1(_this._element).trigger(shownEvent);
	      };

	      if (target) {
	        this._activate(target, target.parentNode, complete);
	      } else {
	        complete();
	      }
	    };

	    _proto.dispose &#x3D; function dispose() {
	      $$$1.removeData(this._element, DATA_KEY);
	      this._element &#x3D; null;
	    }; // Private


	    _proto._activate &#x3D; function _activate(element, container, callback) {
	      var _this2 &#x3D; this;

	      var activeElements;

	      if (container.nodeName &#x3D;&#x3D;&#x3D; &#x27;UL&#x27;) {
	        activeElements &#x3D; $$$1(container).find(Selector.ACTIVE_UL);
	      } else {
	        activeElements &#x3D; $$$1(container).children(Selector.ACTIVE);
	      }

	      var active &#x3D; activeElements[0];
	      var isTransitioning &#x3D; callback &amp;&amp; Util.supportsTransitionEnd() &amp;&amp; active &amp;&amp; $$$1(active).hasClass(ClassName.FADE);

	      var complete &#x3D; function complete() {
	        return _this2._transitionComplete(element, active, callback);
	      };

	      if (active &amp;&amp; isTransitioning) {
	        $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        complete();
	      }
	    };

	    _proto._transitionComplete &#x3D; function _transitionComplete(element, active, callback) {
	      if (active) {
	        $$$1(active).removeClass(ClassName.SHOW + &quot; &quot; + ClassName.ACTIVE);
	        var dropdownChild &#x3D; $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

	        if (dropdownChild) {
	          $$$1(dropdownChild).removeClass(ClassName.ACTIVE);
	        }

	        if (active.getAttribute(&#x27;role&#x27;) &#x3D;&#x3D;&#x3D; &#x27;tab&#x27;) {
	          active.setAttribute(&#x27;aria-selected&#x27;, false);
	        }
	      }

	      $$$1(element).addClass(ClassName.ACTIVE);

	      if (element.getAttribute(&#x27;role&#x27;) &#x3D;&#x3D;&#x3D; &#x27;tab&#x27;) {
	        element.setAttribute(&#x27;aria-selected&#x27;, true);
	      }

	      Util.reflow(element);
	      $$$1(element).addClass(ClassName.SHOW);

	      if (element.parentNode &amp;&amp; $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
	        var dropdownElement &#x3D; $$$1(element).closest(Selector.DROPDOWN)[0];

	        if (dropdownElement) {
	          $$$1(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
	        }

	        element.setAttribute(&#x27;aria-expanded&#x27;, true);
	      }

	      if (callback) {
	        callback();
	      }
	    }; // Static


	    Tab._jQueryInterface &#x3D; function _jQueryInterface(config) {
	      return this.each(function () {
	        var $this &#x3D; $$$1(this);
	        var data &#x3D; $this.data(DATA_KEY);

	        if (!data) {
	          data &#x3D; new Tab(this);
	          $this.data(DATA_KEY, data);
	        }

	        if (typeof config &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	          if (typeof data[config] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
	          }

	          data[config]();
	        }
	      });
	    };

	    _createClass(Tab, null, [{
	      key: &quot;VERSION&quot;,
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Tab;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    event.preventDefault();

	    Tab._jQueryInterface.call($$$1(this), &#x27;show&#x27;);
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $$$1.fn[NAME] &#x3D; Tab._jQueryInterface;
	  $$$1.fn[NAME].Constructor &#x3D; Tab;

	  $$$1.fn[NAME].noConflict &#x3D; function () {
	    $$$1.fn[NAME] &#x3D; JQUERY_NO_CONFLICT;
	    return Tab._jQueryInterface;
	  };

	  return Tab;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-alpha.6): index.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	(function ($$$1) {
	  if (typeof $$$1 &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
	    throw new TypeError(&#x27;Bootstrap\&#x27;s JavaScript requires jQuery. jQuery must be included before Bootstrap\&#x27;s JavaScript.&#x27;);
	  }

	  var version &#x3D; $$$1.fn.jquery.split(&#x27; &#x27;)[0].split(&#x27;.&#x27;);
	  var minMajor &#x3D; 1;
	  var ltMajor &#x3D; 2;
	  var minMinor &#x3D; 9;
	  var minPatch &#x3D; 1;
	  var maxMajor &#x3D; 4;

	  if (version[0] &lt; ltMajor &amp;&amp; version[1] &lt; minMinor || version[0] &#x3D;&#x3D;&#x3D; minMajor &amp;&amp; version[1] &#x3D;&#x3D;&#x3D; minMinor &amp;&amp; version[2] &lt; minPatch || version[0] &gt;&#x3D; maxMajor) {
	    throw new Error(&#x27;Bootstrap\&#x27;s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0&#x27;);
	  }
	})($);

	exports.Util &#x3D; Util;
	exports.Alert &#x3D; Alert;
	exports.Button &#x3D; Button;
	exports.Carousel &#x3D; Carousel;
	exports.Collapse &#x3D; Collapse;
	exports.Dropdown &#x3D; Dropdown;
	exports.Modal &#x3D; Modal;
	exports.Popover &#x3D; Popover;
	exports.Scrollspy &#x3D; ScrollSpy;
	exports.Tab &#x3D; Tab;
	exports.Tooltip &#x3D; Tooltip;

	Object.defineProperty(exports, &#x27;__esModule&#x27;, { value: true });

	})));
	//# sourceMappingURL&#x3D;bootstrap.js.map


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/*! waitForImages jQuery Plugin 2013-07-20 */
	!function(a){var b&#x3D;&quot;waitForImages&quot;;a.waitForImages&#x3D;{hasImageProperties:[&quot;backgroundImage&quot;,&quot;listStyleImage&quot;,&quot;borderImage&quot;,&quot;borderCornerImage&quot;,&quot;cursor&quot;]},a.expr[&quot;:&quot;].uncached&#x3D;function(b){if(!a(b).is(&#x27;img[src!&#x3D;&quot;&quot;]&#x27;))return!1;var c&#x3D;new Image;return c.src&#x3D;b.src,!c.complete},a.fn.waitForImages&#x3D;function(c,d,e){var f&#x3D;0,g&#x3D;0;if(a.isPlainObject(arguments[0])&amp;&amp;(e&#x3D;arguments[0].waitForAll,d&#x3D;arguments[0].each,c&#x3D;arguments[0].finished),c&#x3D;c||a.noop,d&#x3D;d||a.noop,e&#x3D;!!e,!a.isFunction(c)||!a.isFunction(d))throw new TypeError(&quot;An invalid callback was supplied.&quot;);return this.each(function(){var h&#x3D;a(this),i&#x3D;[],j&#x3D;a.waitForImages.hasImageProperties||[],k&#x3D;/url\(\s*([&#x27;&quot;]?)(.*?)\1\s*\)/g;e?h.find(&quot;*&quot;).addBack().each(function(){var b&#x3D;a(this);b.is(&quot;img:uncached&quot;)&amp;&amp;i.push({src:b.attr(&quot;src&quot;),element:b[0]}),a.each(j,function(a,c){var d,e&#x3D;b.css(c);if(!e)return!0;for(;d&#x3D;k.exec(e);)i.push({src:d[2],element:b[0]})})}):h.find(&quot;img:uncached&quot;).each(function(){i.push({src:this.src,element:this})}),f&#x3D;i.length,g&#x3D;0,0&#x3D;&#x3D;&#x3D;f&amp;&amp;c.call(h[0]),a.each(i,function(e,i){var j&#x3D;new Image;a(j).on(&quot;load.&quot;+b+&quot; error.&quot;+b,function(a){return g++,d.call(i.element,g,f,&quot;load&quot;&#x3D;&#x3D;a.type),g&#x3D;&#x3D;f?(c.call(h[0]),!1):void 0}),j.src&#x3D;i.src})})}}(jQuery);

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/*
	 * CSS3 Animate it
	 * Copyright (c) 2014 Jack McCourt
	 * https://github.com/kriegar/css3-animate-it
	 * Version: 0.1.0
	 * 
	 * I utilise the jQuery.appear plugin within this javascript file so here is a link to that too
	 * https://github.com/morr/jquery.appear
	 *
	 * I also utilise the jQuery.doTimeout plugin for the data-sequence functionality so here is a link back to them.
	 * http://benalman.com/projects/jquery-dotimeout-plugin/
	 */
	(function ($) {
	    var selectors &#x3D; [];

	    var check_binded &#x3D; false;
	    var check_lock &#x3D; false;
	    var defaults &#x3D; {
	        interval: 250,
	        force_process: false
	    };
	    var $window &#x3D; $(window);

	    var $prior_appeared;

	    function process() {
	        check_lock &#x3D; false;
	        for (var index &#x3D; 0; index &lt; selectors.length; index++) {
	            var $appeared &#x3D; $(selectors[index]).filter(function () {
	                return $(this).is(&#x27;:appeared&#x27;);
	            });

	            $appeared.trigger(&#x27;appear&#x27;, [$appeared]);

	            if ($prior_appeared) {

	                var $disappeared &#x3D; $prior_appeared.not($appeared);
	                $disappeared.trigger(&#x27;disappear&#x27;, [$disappeared]);
	            }
	            $prior_appeared &#x3D; $appeared;
	        }
	    }

	    // &quot;appeared&quot; custom filter
	    $.expr[&#x27;:&#x27;][&#x27;appeared&#x27;] &#x3D; function (element) {
	        var $element &#x3D; $(element);
	        if (!$element.is(&#x27;:visible&#x27;)) {
	            return false;
	        }

	        var window_left &#x3D; $window.scrollLeft();
	        var window_top &#x3D; $window.scrollTop();
	        var offset &#x3D; $element.offset();
	        var left &#x3D; offset.left;
	        var top &#x3D; offset.top;

	        if (top + $element.height() &gt;&#x3D; window_top &amp;&amp;
	            top - ($element.data(&#x27;appear-top-offset&#x27;) || 0) &lt;&#x3D; window_top + $window.height() &amp;&amp;
	            left + $element.width() &gt;&#x3D; window_left &amp;&amp;
	            left - ($element.data(&#x27;appear-left-offset&#x27;) || 0) &lt;&#x3D; window_left + $window.width()) {
	            return true;
	        } else {
	            return false;
	        }
	    };

	    $.fn.extend({
	        // watching for element&#x27;s appearance in browser viewport
	        appear: function (options) {
	            var opts &#x3D; $.extend({}, defaults, options || {});
	            var selector &#x3D; this.selector || this;
	            if (!check_binded) {
	                var on_check &#x3D; function () {
	                    if (check_lock) {
	                        return;
	                    }
	                    check_lock &#x3D; true;

	                    setTimeout(process, opts.interval);
	                };

	                $(window).scroll(on_check).resize(on_check);
	                check_binded &#x3D; true;
	            }

	            if (opts.force_process) {
	                setTimeout(process, opts.interval);
	            }
	            selectors.push(selector);
	            return $(selector);
	        }
	    });

	    $.extend({
	        // force elements&#x27;s appearance check
	        force_appear: function () {
	            if (check_binded) {
	                process();
	                return true;
	            }
	            return false;
	        }
	    });
	})(jQuery);


	/*!
	 * jQuery doTimeout: Like setTimeout, but better! - v1.0 - 3/3/2010
	 * http://benalman.com/projects/jquery-dotimeout-plugin/
	 * 
	 * Copyright (c) 2010 &quot;Cowboy&quot; Ben Alman
	 * Dual licensed under the MIT and GPL licenses.
	 * http://benalman.com/about/license/
	 */

	// Script: jQuery doTimeout: Like setTimeout, but better!
	//
	// *Version: 1.0, Last updated: 3/3/2010*
	// 
	// Project Home - http://benalman.com/projects/jquery-dotimeout-plugin/
	// GitHub       - http://github.com/cowboy/jquery-dotimeout/
	// Source       - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.js
	// (Minified)   - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.min.js (1.0kb)
	// 
	// About: License
	// 
	// Copyright (c) 2010 &quot;Cowboy&quot; Ben Alman,
	// Dual licensed under the MIT and GPL licenses.
	// http://benalman.com/about/license/
	// 
	// About: Examples
	// 
	// These working examples, complete with fully commented code, illustrate a few
	// ways in which this plugin can be used.
	// 
	// Debouncing      - http://benalman.com/code/projects/jquery-dotimeout/examples/debouncing/
	// Delays, Polling - http://benalman.com/code/projects/jquery-dotimeout/examples/delay-poll/
	// Hover Intent    - http://benalman.com/code/projects/jquery-dotimeout/examples/hoverintent/
	// 
	// About: Support and Testing
	// 
	// Information about what version or versions of jQuery this plugin has been
	// tested with, what browsers it has been tested in, and where the unit tests
	// reside (so you can test it yourself).
	// 
	// jQuery Versions - 1.3.2, 1.4.2
	// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
	// Unit Tests      - http://benalman.com/code/projects/jquery-dotimeout/unit/
	// 
	// About: Release History
	// 
	// 1.0 - (3/3/2010) Callback can now be a string, in which case it will call
	//       the appropriate $.method or $.fn.method, depending on where .doTimeout
	//       was called. Callback must now return &#x60;true&#x60; (not just a truthy value)
	//       to poll.
	// 0.4 - (7/15/2009) Made the &quot;id&quot; argument optional, some other minor tweaks
	// 0.3 - (6/25/2009) Initial release

	(function ($) {
	    &#x27;$:nomunge&#x27;; // Used by YUI compressor.

	    var cache &#x3D; {},

	        // Reused internal string.
	        doTimeout &#x3D; &#x27;doTimeout&#x27;,

	        // A convenient shortcut.
	        aps &#x3D; Array.prototype.slice;

	    // Method: jQuery.doTimeout
	    // 
	    // Initialize, cancel, or force execution of a callback after a delay.
	    // 
	    // If delay and callback are specified, a doTimeout is initialized. The
	    // callback will execute, asynchronously, after the delay. If an id is
	    // specified, this doTimeout will override and cancel any existing doTimeout
	    // with the same id. Any additional arguments will be passed into callback
	    // when it is executed.
	    // 
	    // If the callback returns true, the doTimeout loop will execute again, after
	    // the delay, creating a polling loop until the callback returns a non-true
	    // value.
	    // 
	    // Note that if an id is not passed as the first argument, this doTimeout will
	    // NOT be able to be manually canceled or forced. (for debouncing, be sure to
	    // specify an id).
	    // 
	    // If id is specified, but delay and callback are not, the doTimeout will be
	    // canceled without executing the callback. If force_mode is specified, the
	    // callback will be executed, synchronously, but will only be allowed to
	    // continue a polling loop if force_mode is true (provided the callback
	    // returns true, of course). If force_mode is false, no polling loop will
	    // continue, even if the callback returns true.
	    // 
	    // Usage:
	    // 
	    // &gt; jQuery.doTimeout( [ id, ] delay, callback [, arg ... ] );
	    // &gt; jQuery.doTimeout( id [, force_mode ] );
	    // 
	    // Arguments:
	    // 
	    //  id - (String) An optional unique identifier for this doTimeout. If id is
	    //    not specified, the doTimeout will NOT be able to be manually canceled or
	    //    forced.
	    //  delay - (Number) A zero-or-greater delay in milliseconds after which
	    //    callback will be executed. 
	    //  callback - (Function) A function to be executed after delay milliseconds.
	    //  callback - (String) A jQuery method to be executed after delay
	    //    milliseconds. This method will only poll if it explicitly returns
	    //    true.
	    //  force_mode - (Boolean) If true, execute that id&#x27;s doTimeout callback
	    //    immediately and synchronously, continuing any callback return-true
	    //    polling loop. If false, execute the callback immediately and
	    //    synchronously but do NOT continue a callback return-true polling loop.
	    //    If omitted, cancel that id&#x27;s doTimeout.
	    // 
	    // Returns:
	    // 
	    //  If force_mode is true, false or undefined and there is a
	    //  yet-to-be-executed callback to cancel, true is returned, but if no
	    //  callback remains to be executed, undefined is returned.

	    $[doTimeout] &#x3D; function () {
	        return p_doTimeout.apply(window, [0].concat(aps.call(arguments)));
	    };

	    // Method: jQuery.fn.doTimeout
	    // 
	    // Initialize, cancel, or force execution of a callback after a delay.
	    // Operates like &lt;jQuery.doTimeout&gt;, but the passed callback executes in the
	    // context of the jQuery collection of elements, and the id is stored as data
	    // on the first element in that collection.
	    // 
	    // If delay and callback are specified, a doTimeout is initialized. The
	    // callback will execute, asynchronously, after the delay. If an id is
	    // specified, this doTimeout will override and cancel any existing doTimeout
	    // with the same id. Any additional arguments will be passed into callback
	    // when it is executed.
	    // 
	    // If the callback returns true, the doTimeout loop will execute again, after
	    // the delay, creating a polling loop until the callback returns a non-true
	    // value.
	    // 
	    // Note that if an id is not passed as the first argument, this doTimeout will
	    // NOT be able to be manually canceled or forced (for debouncing, be sure to
	    // specify an id).
	    // 
	    // If id is specified, but delay and callback are not, the doTimeout will be
	    // canceled without executing the callback. If force_mode is specified, the
	    // callback will be executed, synchronously, but will only be allowed to
	    // continue a polling loop if force_mode is true (provided the callback
	    // returns true, of course). If force_mode is false, no polling loop will
	    // continue, even if the callback returns true.
	    // 
	    // Usage:
	    // 
	    // &gt; jQuery(&#x27;selector&#x27;).doTimeout( [ id, ] delay, callback [, arg ... ] );
	    // &gt; jQuery(&#x27;selector&#x27;).doTimeout( id [, force_mode ] );
	    // 
	    // Arguments:
	    // 
	    //  id - (String) An optional unique identifier for this doTimeout, stored as
	    //    jQuery data on the element. If id is not specified, the doTimeout will
	    //    NOT be able to be manually canceled or forced.
	    //  delay - (Number) A zero-or-greater delay in milliseconds after which
	    //    callback will be executed. 
	    //  callback - (Function) A function to be executed after delay milliseconds.
	    //  callback - (String) A jQuery.fn method to be executed after delay
	    //    milliseconds. This method will only poll if it explicitly returns
	    //    true (most jQuery.fn methods return a jQuery object, and not &#x60;true&#x60;,
	    //    which allows them to be chained and prevents polling).
	    //  force_mode - (Boolean) If true, execute that id&#x27;s doTimeout callback
	    //    immediately and synchronously, continuing any callback return-true
	    //    polling loop. If false, execute the callback immediately and
	    //    synchronously but do NOT continue a callback return-true polling loop.
	    //    If omitted, cancel that id&#x27;s doTimeout.
	    // 
	    // Returns:
	    // 
	    //  When creating a &lt;jQuery.fn.doTimeout&gt;, the initial jQuery collection of
	    //  elements is returned. Otherwise, if force_mode is true, false or undefined
	    //  and there is a yet-to-be-executed callback to cancel, true is returned,
	    //  but if no callback remains to be executed, undefined is returned.

	    $.fn[doTimeout] &#x3D; function () {
	        var args &#x3D; aps.call(arguments),
	            result &#x3D; p_doTimeout.apply(this, [doTimeout + args[0]].concat(args));

	        return typeof args[0] &#x3D;&#x3D;&#x3D; &#x27;number&#x27; || typeof args[1] &#x3D;&#x3D;&#x3D; &#x27;number&#x27; ?
	            this :
	            result;
	    };

	    function p_doTimeout(jquery_data_key) {
	        var that &#x3D; this,
	            elem,
	            data &#x3D; {},

	            // Allows the plugin to call a string callback method.
	            method_base &#x3D; jquery_data_key ? $.fn : $,

	            // Any additional arguments will be passed to the callback.
	            args &#x3D; arguments,
	            slice_args &#x3D; 4,

	            id &#x3D; args[1],
	            delay &#x3D; args[2],
	            callback &#x3D; args[3];

	        if (typeof id !&#x3D;&#x3D; &#x27;string&#x27;) {
	            slice_args--;

	            id &#x3D; jquery_data_key &#x3D; 0;
	            delay &#x3D; args[1];
	            callback &#x3D; args[2];
	        }

	        // If id is passed, store a data reference either as .data on the first
	        // element in a jQuery collection, or in the internal cache.
	        if (jquery_data_key) { // Note: key is &#x27;doTimeout&#x27; + id

	            // Get id-object from the first element&#x27;s data, otherwise initialize it to {}.
	            elem &#x3D; that.eq(0);
	            elem.data(jquery_data_key, data &#x3D; elem.data(jquery_data_key) || {});

	        } else if (id) {
	            // Get id-object from the cache, otherwise initialize it to {}.
	            data &#x3D; cache[id] || (cache[id] &#x3D; {});
	        }

	        // Clear any existing timeout for this id.
	        data.id &amp;&amp; clearTimeout(data.id);
	        delete data.id;

	        // Clean up when necessary.
	        function cleanup() {
	            if (jquery_data_key) {
	                elem.removeData(jquery_data_key);
	            } else if (id) {
	                delete cache[id];
	            }
	        }
	        // Yes, there actually is a setTimeout call in here!
	        function actually_setTimeout() {
	            data.id &#x3D; setTimeout(function () {
	                data.fn();
	            }, delay);
	        }
	        if (callback) {
	            // A callback (and delay) were specified. Store the callback reference for
	            // possible later use, and then setTimeout.
	            data.fn &#x3D; function (no_polling_loop) {

	                // If the callback value is a string, it is assumed to be the name of a
	                // method on $ or $.fn depending on where doTimeout was executed.
	                if (typeof callback &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	                    callback &#x3D; method_base[callback];
	                }

	                callback.apply(that, aps.call(args, slice_args)) &#x3D;&#x3D;&#x3D; true &amp;&amp; !no_polling_loop

	                    // Since the callback returned true, and we&#x27;re not specifically
	                    // canceling a polling loop, do it again!
	                    ?
	                    actually_setTimeout()

	                    // Otherwise, clean up and quit.
	                    : cleanup();
	            };

	            // Set that timeout!
	            actually_setTimeout();

	        } else if (data.fn) {
	            // No callback passed. If force_mode (delay) is true, execute the data.fn
	            // callback immediately, continuing any callback return-true polling loop.
	            // If force_mode is false, execute the data.fn callback immediately but do
	            // NOT continue a callback return-true polling loop. If force_mode is
	            // undefined, simply clean up. Since data.fn was still defined, whatever
	            // was supposed to happen hadn&#x27;t yet, so return true.
	            delay &#x3D;&#x3D;&#x3D; undefined ? cleanup() : data.fn(delay &#x3D;&#x3D;&#x3D; false);
	            return true;

	        } else {
	            // Since no callback was passed, and data.fn isn&#x27;t defined, it looks like
	            // whatever was supposed to happen already did. Clean up and quit!
	            cleanup();
	        }

	    }
	})(jQuery);


	//CSS3 Animate-it
	$(&#x27;.animatedParent&#x27;).appear();
	$(&#x27;.animatedClick&#x27;).click(function () {
	    var target &#x3D; $(this).attr(&#x27;data-target&#x27;);


	    if ($(this).attr(&#x27;data-sequence&#x27;) !&#x3D; undefined) {
	        var firstId &#x3D; $(&quot;.&quot; + target + &quot;:first&quot;).attr(&#x27;data-id&#x27;);
	        var lastId &#x3D; $(&quot;.&quot; + target + &quot;:last&quot;).attr(&#x27;data-id&#x27;);
	        var number &#x3D; firstId;

	        //Add or remove the class
	        if ($(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).hasClass(&#x27;go&#x27;)) {
	            $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).addClass(&#x27;goAway&#x27;);
	            $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).removeClass(&#x27;go&#x27;);
	        } else {
	            $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	            $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).removeClass(&#x27;goAway&#x27;);
	        }
	        number++;
	        delay &#x3D; Number($(this).attr(&#x27;data-sequence&#x27;));
	        $.doTimeout(delay, function () {
	            console.log(lastId);

	            //Add or remove the class
	            if ($(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).hasClass(&#x27;go&#x27;)) {
	                $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).addClass(&#x27;goAway&#x27;);
	                $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).removeClass(&#x27;go&#x27;);
	            } else {
	                $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	                $(&quot;.&quot; + target + &quot;[data-id&#x3D;&quot; + number + &quot;]&quot;).removeClass(&#x27;goAway&#x27;);
	            }

	            //increment
	            ++number;

	            //continute looping till reached last ID
	            if (number &lt;&#x3D; lastId) {
	                return true;
	            }
	        });
	    } else {
	        if ($(&#x27;.&#x27; + target).hasClass(&#x27;go&#x27;)) {
	            $(&#x27;.&#x27; + target).addClass(&#x27;goAway&#x27;);
	            $(&#x27;.&#x27; + target).removeClass(&#x27;go&#x27;);
	        } else {
	            $(&#x27;.&#x27; + target).addClass(&#x27;go&#x27;);
	            $(&#x27;.&#x27; + target).removeClass(&#x27;goAway&#x27;);
	        }
	    }
	});

	$(document.body).on(&#x27;appear&#x27;, &#x27;.animatedParent&#x27;, function (e, $affected) {
	    var ele &#x3D; $(this).find(&#x27;.animated&#x27;);
	    var parent &#x3D; $(this);


	    if (parent.attr(&#x27;data-sequence&#x27;) !&#x3D; undefined) {

	        var firstId &#x3D; $(this).find(&#x27;.animated:first&#x27;).attr(&#x27;data-id&#x27;);
	        var number &#x3D; firstId;
	        var lastId &#x3D; $(this).find(&#x27;.animated:last&#x27;).attr(&#x27;data-id&#x27;);

	        $(parent).find(&quot;.animated[data-id&#x3D;&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	        number++;
	        delay &#x3D; Number(parent.attr(&#x27;data-sequence&#x27;));

	        $.doTimeout(delay, function () {
	            $(parent).find(&quot;.animated[data-id&#x3D;&quot; + number + &quot;]&quot;).addClass(&#x27;go&#x27;);
	            ++number;
	            if (number &lt;&#x3D; lastId) {
	                return true;
	            }
	        });
	    } else {
	        ele.addClass(&#x27;go&#x27;);
	    }

	});

	$(document.body).on(&#x27;disappear&#x27;, &#x27;.animatedParent&#x27;, function (e, $affected) {
	    if (!$(this).hasClass(&#x27;animateOnce&#x27;)) {
	        $(this).find(&#x27;.animated&#x27;).removeClass(&#x27;go&#x27;);
	    }
	});

	$(window).on(&#x27;load&#x27;, function () {
	    $.force_appear();
	});

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(13);

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ($(&#x27;.sticky&#x27;).length) {
	        $(&#x27;.sticky&#x27;).Stickyfill();
	    }
	});



/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/*!
	 * Stickyfill -- &#x60;position: sticky&#x60; polyfill
	 * v. 1.1.4 | https://github.com/wilddeer/stickyfill
	 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
	 *
	 * MIT License
	 */
	!function(a,b){function c(){y&#x3D;D&#x3D;z&#x3D;A&#x3D;B&#x3D;C&#x3D;K}function d(a,b){for(var c in b)b.hasOwnProperty(c)&amp;&amp;(a[c]&#x3D;b[c])}function e(a){return parseFloat(a)||0}function f(){F&#x3D;{top:b.pageYOffset,left:b.pageXOffset}}function g(){return b.pageXOffset!&#x3D;F.left?(f(),void z()):void(b.pageYOffset!&#x3D;F.top&amp;&amp;(f(),i()))}function h(a){setTimeout(function(){b.pageYOffset!&#x3D;F.top&amp;&amp;(F.top&#x3D;b.pageYOffset,i())},0)}function i(){for(var a&#x3D;H.length-1;a&gt;&#x3D;0;a--)j(H[a])}function j(a){if(a.inited){var b&#x3D;F.top&lt;&#x3D;a.limit.start?0:F.top&gt;&#x3D;a.limit.end?2:1;a.mode!&#x3D;b&amp;&amp;p(a,b)}}function k(){for(var a&#x3D;H.length-1;a&gt;&#x3D;0;a--)if(H[a].inited){var b&#x3D;Math.abs(t(H[a].clone)-H[a].docOffsetTop),c&#x3D;Math.abs(H[a].parent.node.offsetHeight-H[a].parent.height);if(b&gt;&#x3D;2||c&gt;&#x3D;2)return!1}return!0}function l(a){isNaN(parseFloat(a.computed.top))||a.isCell||&quot;none&quot;&#x3D;&#x3D;a.computed.display||(a.inited&#x3D;!0,a.clone||q(a),&quot;absolute&quot;!&#x3D;a.parent.computed.position&amp;&amp;&quot;relative&quot;!&#x3D;a.parent.computed.position&amp;&amp;(a.parent.node.style.position&#x3D;&quot;relative&quot;),j(a),a.parent.height&#x3D;a.parent.node.offsetHeight,a.docOffsetTop&#x3D;t(a.clone))}function m(a){var b&#x3D;!0;a.clone&amp;&amp;r(a),d(a.node.style,a.css);for(var c&#x3D;H.length-1;c&gt;&#x3D;0;c--)if(H[c].node!&#x3D;&#x3D;a.node&amp;&amp;H[c].parent.node&#x3D;&#x3D;&#x3D;a.parent.node){b&#x3D;!1;break}b&amp;&amp;(a.parent.node.style.position&#x3D;a.parent.css.position),a.mode&#x3D;-1}function n(){for(var a&#x3D;H.length-1;a&gt;&#x3D;0;a--)l(H[a])}function o(){for(var a&#x3D;H.length-1;a&gt;&#x3D;0;a--)m(H[a])}function p(a,b){var c&#x3D;a.node.style;switch(b){case 0:c.position&#x3D;&quot;absolute&quot;,c.left&#x3D;a.offset.left+&quot;px&quot;,c.right&#x3D;a.offset.right+&quot;px&quot;,c.top&#x3D;a.offset.top+&quot;px&quot;,c.bottom&#x3D;&quot;auto&quot;,c.width&#x3D;&quot;auto&quot;,c.marginLeft&#x3D;0,c.marginRight&#x3D;0,c.marginTop&#x3D;0;break;case 1:c.position&#x3D;&quot;fixed&quot;,c.left&#x3D;a.box.left+&quot;px&quot;,c.right&#x3D;a.box.right+&quot;px&quot;,c.top&#x3D;a.css.top,c.bottom&#x3D;&quot;auto&quot;,c.width&#x3D;&quot;auto&quot;,c.marginLeft&#x3D;0,c.marginRight&#x3D;0,c.marginTop&#x3D;0;break;case 2:c.position&#x3D;&quot;absolute&quot;,c.left&#x3D;a.offset.left+&quot;px&quot;,c.right&#x3D;a.offset.right+&quot;px&quot;,c.top&#x3D;&quot;auto&quot;,c.bottom&#x3D;0,c.width&#x3D;&quot;auto&quot;,c.marginLeft&#x3D;0,c.marginRight&#x3D;0}a.mode&#x3D;b}function q(a){a.clone&#x3D;document.createElement(&quot;div&quot;);var b&#x3D;a.node.nextSibling||a.node,c&#x3D;a.clone.style;c.height&#x3D;a.height+&quot;px&quot;,c.width&#x3D;a.width+&quot;px&quot;,c.marginTop&#x3D;a.computed.marginTop,c.marginBottom&#x3D;a.computed.marginBottom,c.marginLeft&#x3D;a.computed.marginLeft,c.marginRight&#x3D;a.computed.marginRight,c.padding&#x3D;c.border&#x3D;c.borderSpacing&#x3D;0,c.fontSize&#x3D;&quot;1em&quot;,c.position&#x3D;&quot;static&quot;,c.cssFloat&#x3D;a.computed.cssFloat,a.node.parentNode.insertBefore(a.clone,b)}function r(a){a.clone.parentNode.removeChild(a.clone),a.clone&#x3D;void 0}function s(a){var b&#x3D;getComputedStyle(a),c&#x3D;a.parentNode,d&#x3D;getComputedStyle(c),f&#x3D;a.style.position;a.style.position&#x3D;&quot;relative&quot;;var g&#x3D;{top:b.top,marginTop:b.marginTop,marginBottom:b.marginBottom,marginLeft:b.marginLeft,marginRight:b.marginRight,cssFloat:b.cssFloat,display:b.display},h&#x3D;{top:e(b.top),marginBottom:e(b.marginBottom),paddingLeft:e(b.paddingLeft),paddingRight:e(b.paddingRight),borderLeftWidth:e(b.borderLeftWidth),borderRightWidth:e(b.borderRightWidth)};a.style.position&#x3D;f;var i&#x3D;{position:a.style.position,top:a.style.top,bottom:a.style.bottom,left:a.style.left,right:a.style.right,width:a.style.width,marginTop:a.style.marginTop,marginLeft:a.style.marginLeft,marginRight:a.style.marginRight},j&#x3D;u(a),k&#x3D;u(c),l&#x3D;{node:c,css:{position:c.style.position},computed:{position:d.position},numeric:{borderLeftWidth:e(d.borderLeftWidth),borderRightWidth:e(d.borderRightWidth),borderTopWidth:e(d.borderTopWidth),borderBottomWidth:e(d.borderBottomWidth)}},m&#x3D;{node:a,box:{left:j.win.left,right:J.clientWidth-j.win.right},offset:{top:j.win.top-k.win.top-l.numeric.borderTopWidth,left:j.win.left-k.win.left-l.numeric.borderLeftWidth,right:-j.win.right+k.win.right-l.numeric.borderRightWidth},css:i,isCell:&quot;table-cell&quot;&#x3D;&#x3D;b.display,computed:g,numeric:h,width:j.win.right-j.win.left,height:j.win.bottom-j.win.top,mode:-1,inited:!1,parent:l,limit:{start:j.doc.top-h.top,end:k.doc.top+c.offsetHeight-l.numeric.borderBottomWidth-a.offsetHeight-h.top-h.marginBottom}};return m}function t(a){for(var b&#x3D;0;a;)b+&#x3D;a.offsetTop,a&#x3D;a.offsetParent;return b}function u(a){var c&#x3D;a.getBoundingClientRect();return{doc:{top:c.top+b.pageYOffset,left:c.left+b.pageXOffset},win:c}}function v(){G&#x3D;setInterval(function(){!k()&amp;&amp;z()},500)}function w(){clearInterval(G)}function x(){I&amp;&amp;(document[L]?w():v())}function y(){I||(f(),n(),b.addEventListener(&quot;scroll&quot;,g),b.addEventListener(&quot;wheel&quot;,h),b.addEventListener(&quot;resize&quot;,z),b.addEventListener(&quot;orientationchange&quot;,z),a.addEventListener(M,x),v(),I&#x3D;!0)}function z(){if(I){o();for(var a&#x3D;H.length-1;a&gt;&#x3D;0;a--)H[a]&#x3D;s(H[a].node);n()}}function A(){b.removeEventListener(&quot;scroll&quot;,g),b.removeEventListener(&quot;wheel&quot;,h),b.removeEventListener(&quot;resize&quot;,z),b.removeEventListener(&quot;orientationchange&quot;,z),a.removeEventListener(M,x),w(),I&#x3D;!1}function B(){A(),o()}function C(){for(B();H.length;)H.pop()}function D(a){for(var b&#x3D;H.length-1;b&gt;&#x3D;0;b--)if(H[b].node&#x3D;&#x3D;&#x3D;a)return;var c&#x3D;s(a);H.push(c),I?l(c):y()}function E(a){for(var b&#x3D;H.length-1;b&gt;&#x3D;0;b--)H[b].node&#x3D;&#x3D;&#x3D;a&amp;&amp;(m(H[b]),H.splice(b,1))}var F,G,H&#x3D;[],I&#x3D;!1,J&#x3D;a.documentElement,K&#x3D;function(){},L&#x3D;&quot;hidden&quot;,M&#x3D;&quot;visibilitychange&quot;;void 0!&#x3D;&#x3D;a.webkitHidden&amp;&amp;(L&#x3D;&quot;webkitHidden&quot;,M&#x3D;&quot;webkitvisibilitychange&quot;),b.getComputedStyle||c();for(var N&#x3D;[&quot;&quot;,&quot;-webkit-&quot;,&quot;-moz-&quot;,&quot;-ms-&quot;],O&#x3D;document.createElement(&quot;div&quot;),P&#x3D;N.length-1;P&gt;&#x3D;0;P--){try{O.style.position&#x3D;N[P]+&quot;sticky&quot;}catch(Q){}&quot;&quot;!&#x3D;O.style.position&amp;&amp;c()}f(),b.Stickyfill&#x3D;{stickies:H,add:D,remove:E,init:y,rebuild:z,pause:A,stop:B,kill:C}}(document,window),window.jQuery&amp;&amp;!function($){$.fn.Stickyfill&#x3D;function(a){return this.each(function(){Stickyfill.add(this)}),this}}(window.jQuery);

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	// Format Number With Commas
	getNumberWithCommas &#x3D; function (x) {
	    return x.toString().replace(/\B(?&#x3D;(\d{3})+(?!\d))/g, &quot;,&quot;);
	};

	isElementInViewport &#x3D; function isElementInViewport(el) {

	    //special bonus for those using jQuery
	    if (typeof jQuery &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; el instanceof jQuery) {
	        el &#x3D; el[0];
	    }

	    var rect &#x3D; el.getBoundingClientRect();

	    return (
	        rect.top &gt;&#x3D; 0 &amp;&amp;
	        rect.left &gt;&#x3D; 0 &amp;&amp;
	        rect.bottom &lt;&#x3D; (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; /*or $(window).height() */
	        rect.right &lt;&#x3D; (window.innerWidth || document.documentElement.clientWidth) /*or $(window).width() */
	    );
	};


	goToTop &#x3D; function () {
	    if($(&#x27;.js-gotop&#x27;).length) {
	        $(&#x27;.js-gotop&#x27;).on(&#x27;click&#x27;, function (event) {
	            event.preventDefault();
	            $(&#x27;html, body&#x27;).animate({
	                scrollTop: $(&#x27;html&#x27;).offset().top
	            }, 500, &#x27;easeInOutExpo&#x27;);
	            return false;
	        });

	        $(window).scroll(function () {
	            var $win &#x3D; $(window);
	            if ($win.scrollTop() &gt; 200) {
	                $(&#x27;.js-top&#x27;).addClass(&#x27;active&#x27;);
	            } else {
	                $(&#x27;.js-top&#x27;).removeClass(&#x27;active&#x27;);
	            }
	        });
	    }
	};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	(function () {

	    &#x27;use strict&#x27;;

	    /*-------------------------------------
	     window...
	     --------------------------------------*/

	    var window_w &#x3D; $(window).width(); // Window Width
	    var window_h &#x3D; $(window).height(); // Window Height
	    var window_s &#x3D; $(window).scrollTop(); // Window Scroll Top

	    var $html &#x3D; $(&#x27;html&#x27;); // HTML
	    var $body &#x3D; $(&#x27;body&#x27;); // Body


	    if ($(&quot;#docs&quot;).length) {
	        $(&#x27;#docs&#x27;).popover(&#x27;show&#x27;);
	    }

	    /*-------------------------------------
	     Smooth Scroll
	     --------------------------------------*/

	    if ($(&quot;.scroll&quot;).length &gt; 0 || $(&quot;.scroll a[href^&#x3D;&#x27;#&#x27;]&quot;).length &gt; 0) {
	        $(&#x27;.scroll, .scroll a[href^&#x3D;&quot;#&quot;]&#x27;).on(&#x27;click&#x27;, function () {
	            $(&#x27;html, body&#x27;).animate({
	                scrollTop: $($.attr(this, &#x27;href&#x27;)).offset().top - 30
	            }, 1500, function () {
	            });
	            return false;
	        });
	    }

	    /*-------------------------------------
	     Woo-Quantity
	     --------------------------------------*/

	    $(&quot;body&quot;).on(&quot;click&quot;, &quot;.xv-qyt&quot;, function (e) {
	        e.preventDefault();
	        var $add &#x3D; parseInt($(this).attr(&quot;data-value&quot;)),
	            $input &#x3D; $(this).siblings(&quot;input.qty&quot;),
	            cVal &#x3D; parseInt($input.val());
	        if (cVal &gt;&#x3D; 1) {
	            if ($add &#x3D;&#x3D;&#x3D; -1 &amp;&amp; cVal &#x3D;&#x3D;&#x3D; 1)
	                return false;
	            $input.val(cVal + $add);
	        }
	    });

	    /*-------------------------------------
	     Custom Select
	     --------------------------------------*/
	    $(&#x27;.custome-select select&#x27;).on(&#x27;change&#x27;, function () {
	        var p &#x3D; $(this).parent(&quot;.custome-select&quot;);
	        p.find(&#x27;span&#x27;).html($(this).val());
	    });


	    goToTop();

	}());

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(17);
	jQuery(function ($) {
	    &quot;use strict&quot;;
	    lightSlider();
	});
	var lightSlider &#x3D; function () {
	    var clientSlider &#x3D; $(&#x27;#clientSlider&#x27;).lightSlider({
	        adaptiveHeight: true,
	        item: 5,
	        slideMargin: 0,
	        auto: true,
	        loop: false,
	        pauseOnHover: true,
	    });

	    var light &#x3D; $(&quot;.lightSlider&quot;);
	    light.each(function () {
	        var $this &#x3D; $(this);
	        $this.lightSlider({
	            verticalHeight: $this.data(&#x27;vertical-height&#x27;),
	            autoWidth: $this.data(&#x27;auto-width&#x27;),
	            slideWidth: $this.data(&#x27;slide-width&#x27;),
	            centerSlide: $this.data(&#x27;center-slide&#x27;),
	            gallery: $this.data(&#x27;gallery&#x27;),
	            thumbItem: $this.data(&#x27;thumbs&#x27;),
	            thumbMargin: $this.data(&#x27;margin&#x27;),
	            item: $this.data(&#x27;item&#x27;),
	            loop: $this.data(&#x27;loop&#x27;),
	            mode: $this.data(&#x27;mode&#x27;),
	            adaptiveHeight: $this.data(&#x27;adaptive-height&#x27;),
	            speed: $this.data(&#x27;speed&#x27;),
	            auto: $this.data(&#x27;auto&#x27;),
	            pause: $this.data(&#x27;pause&#x27;),
	            pauseOnHover: $this.data(&#x27;pause-on-hover&#x27;),
	            pager: $this.data(&#x27;pager&#x27;),
	            slideMargin: $this.data(&#x27;slide-margin&#x27;),
	            vThumbWidth: 80,
	            currentPagerPosition: $this.data(&#x27;position&#x27;),
	            controls: $this.data(&#x27;controls&#x27;),
	            prevHtml: &#x27;&lt;span class&#x3D;&quot;icon-left-arrow&quot;&gt;&lt;/span&gt;&#x27;,
	            nextHtml: &#x27;&lt;span class&#x3D;&quot;icon-right-arrow&quot;&gt;&lt;/span&gt;&#x27;,
	            responsive: [
	                {
	                    breakpoint: 1024,
	                    settings: {
	                        item: $this.data(&#x27;item-lg&#x27;),
	                        slideMove: 1,
	                        slideMargin: 6,
	                    }
	                },
	                {
	                    breakpoint: 768,
	                    settings: {
	                        item: $this.data(&#x27;item-md&#x27;),
	                        slideMove: 1,
	                        slideMargin: 6,
	                    }
	                },
	                {
	                    breakpoint: 480,
	                    settings: {
	                        item: $this.data(&#x27;item-sm&#x27;),
	                        slideMove: 1
	                    }
	                }
	            ],
	            onSliderLoad: function (el) {
	                if ($this.data(&#x27;start&#x27;)) {
	                    $this.goToSlide($this.data(&#x27;start&#x27;));
	                }
	                $this.addClass(&#x27;showSlider&#x27;);


	                el.find(&#x27;.lslide .animated&#x27;).addClass(&quot;go&quot;);
	            },

	            onBeforeNextSlide: function (el) {
	                el.find(&#x27;.lslide .animated&#x27;).removeClass(&quot;go&quot;);
	            },
	            onAfterSlide: function (el) {
	                el.find(&#x27;.lslide .animated&#x27;).addClass(&quot;go&quot;);
	            }
	        });
	    });

	};

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/*! lightslider - v1.1.6 - 2016-10-25
	* https://github.com/sachinchoolur/lightslider
	* Copyright (c) 2016 Sachin N; Licensed MIT */
	(function ($, undefined) {
	    &#x27;use strict&#x27;;
	    var defaults &#x3D; {
	        item: 3,
	        autoWidth: false,
	        slideMove: 1,
	        slideMargin: 10,
	        addClass: &#x27;&#x27;,
	        mode: &#x27;slide&#x27;,
	        useCSS: true,
	        cssEasing: &#x27;ease&#x27;, //&#x27;cubic-bezier(0.25, 0, 0.25, 1)&#x27;,
	        easing: &#x27;linear&#x27;, //&#x27;for jquery animation&#x27;,//
	        speed: 400, //ms&#x27;
	        auto: false,
	        pauseOnHover: false,
	        loop: false,
	        slideEndAnimation: true,
	        pause: 2000,
	        keyPress: false,
	        controls: true,
	        prevHtml: &#x27;&#x27;,
	        nextHtml: &#x27;&#x27;,
	        rtl: false,
	        adaptiveHeight: false,
	        vertical: false,
	        verticalHeight: 500,
	        vThumbWidth: 100,
	        thumbItem: 10,
	        pager: true,
	        gallery: false,
	        galleryMargin: 5,
	        thumbMargin: 5,
	        currentPagerPosition: &#x27;middle&#x27;,
	        enableTouch: true,
	        enableDrag: true,
	        freeMove: true,
	        swipeThreshold: 40,
	        responsive: [],
	        /* jshint ignore:start */
	        onBeforeStart: function ($el) {},
	        onSliderLoad: function ($el) {},
	        onBeforeSlide: function ($el, scene) {},
	        onAfterSlide: function ($el, scene) {},
	        onBeforeNextSlide: function ($el, scene) {},
	        onBeforePrevSlide: function ($el, scene) {}
	        /* jshint ignore:end */
	    };
	    $.fn.lightSlider &#x3D; function (options) {
	        if (this.length &#x3D;&#x3D;&#x3D; 0) {
	            return this;
	        }

	        if (this.length &gt; 1) {
	            this.each(function () {
	                $(this).lightSlider(options);
	            });
	            return this;
	        }

	        var plugin &#x3D; {},
	            settings &#x3D; $.extend(true, {}, defaults, options),
	            settingsTemp &#x3D; {},
	            $el &#x3D; this;
	        plugin.$el &#x3D; this;

	        if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;fade&#x27;) {
	            settings.vertical &#x3D; false;
	        }
	        var $children &#x3D; $el.children(),
	            windowW &#x3D; $(window).width(),
	            breakpoint &#x3D; null,
	            resposiveObj &#x3D; null,
	            length &#x3D; 0,
	            w &#x3D; 0,
	            on &#x3D; false,
	            elSize &#x3D; 0,
	            $slide &#x3D; &#x27;&#x27;,
	            scene &#x3D; 0,
	            property &#x3D; (settings.vertical &#x3D;&#x3D;&#x3D; true) ? &#x27;height&#x27; : &#x27;width&#x27;,
	            gutter &#x3D; (settings.vertical &#x3D;&#x3D;&#x3D; true) ? &#x27;margin-bottom&#x27; : &#x27;margin-right&#x27;,
	            slideValue &#x3D; 0,
	            pagerWidth &#x3D; 0,
	            slideWidth &#x3D; 0,
	            thumbWidth &#x3D; 0,
	            interval &#x3D; null,
	            isTouch &#x3D; (&#x27;ontouchstart&#x27; in document.documentElement);
	        var refresh &#x3D; {};

	        refresh.chbreakpoint &#x3D; function () {
	            windowW &#x3D; $(window).width();
	            if (settings.responsive.length) {
	                var item;
	                if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                    item &#x3D; settings.item;
	                }
	                if (windowW &lt; settings.responsive[0].breakpoint) {
	                    for (var i &#x3D; 0; i &lt; settings.responsive.length; i++) {
	                        if (windowW &lt; settings.responsive[i].breakpoint) {
	                            breakpoint &#x3D; settings.responsive[i].breakpoint;
	                            resposiveObj &#x3D; settings.responsive[i];
	                        }
	                    }
	                }
	                if (typeof resposiveObj !&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; resposiveObj !&#x3D;&#x3D; null) {
	                    for (var j in resposiveObj.settings) {
	                        if (resposiveObj.settings.hasOwnProperty(j)) {
	                            if (typeof settingsTemp[j] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; || settingsTemp[j] &#x3D;&#x3D;&#x3D; null) {
	                                settingsTemp[j] &#x3D; settings[j];
	                            }
	                            settings[j] &#x3D; resposiveObj.settings[j];
	                        }
	                    }
	                }
	                if (!$.isEmptyObject(settingsTemp) &amp;&amp; windowW &gt; settings.responsive[0].breakpoint) {
	                    for (var k in settingsTemp) {
	                        if (settingsTemp.hasOwnProperty(k)) {
	                            settings[k] &#x3D; settingsTemp[k];
	                        }
	                    }
	                }
	                if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                    if (slideValue &gt; 0 &amp;&amp; slideWidth &gt; 0) {
	                        if (item !&#x3D;&#x3D; settings.item) {
	                            scene &#x3D; Math.round(slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove));
	                        }
	                    }
	                }
	            }
	        };

	        refresh.calSW &#x3D; function () {
	            if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                slideWidth &#x3D; (elSize - ((settings.item * (settings.slideMargin)) - settings.slideMargin)) / settings.item;
	            }
	        };

	        refresh.calWidth &#x3D; function (cln) {
	            var ln &#x3D; cln &#x3D;&#x3D;&#x3D; true ? $slide.find(&#x27;.lslide&#x27;).length : $children.length;
	            if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                w &#x3D; ln * (slideWidth + settings.slideMargin);
	            } else {
	                w &#x3D; 0;
	                for (var i &#x3D; 0; i &lt; ln; i++) {
	                    w +&#x3D; (parseInt($children.eq(i).width()) + settings.slideMargin);
	                }
	            }
	            return w;
	        };
	        plugin &#x3D; {
	            doCss: function () {
	                var support &#x3D; function () {
	                    var transition &#x3D; [&#x27;transition&#x27;, &#x27;MozTransition&#x27;, &#x27;WebkitTransition&#x27;, &#x27;OTransition&#x27;, &#x27;msTransition&#x27;, &#x27;KhtmlTransition&#x27;];
	                    var root &#x3D; document.documentElement;
	                    for (var i &#x3D; 0; i &lt; transition.length; i++) {
	                        if (transition[i] in root.style) {
	                            return true;
	                        }
	                    }
	                };
	                if (settings.useCSS &amp;&amp; support()) {
	                    return true;
	                }
	                return false;
	            },
	            keyPress: function () {
	                if (settings.keyPress) {
	                    $(document).on(&#x27;keyup.lightslider&#x27;, function (e) {
	                        if (!$(&#x27;:focus&#x27;).is(&#x27;input, textarea&#x27;)) {
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            } else {
	                                e.returnValue &#x3D; false;
	                            }
	                            if (e.keyCode &#x3D;&#x3D;&#x3D; 37) {
	                                $el.goToPrevSlide();
	                            } else if (e.keyCode &#x3D;&#x3D;&#x3D; 39) {
	                                $el.goToNextSlide();
	                            }
	                        }
	                    });
	                }
	            },
	            controls: function () {
	                if (settings.controls) {
	                    $el.after(&#x27;&lt;div class&#x3D;&quot;lSAction&quot;&gt;&lt;a class&#x3D;&quot;lSPrev&quot;&gt;&#x27; + settings.prevHtml + &#x27;&lt;/a&gt;&lt;a class&#x3D;&quot;lSNext&quot;&gt;&#x27; + settings.nextHtml + &#x27;&lt;/a&gt;&lt;/div&gt;&#x27;);
	                    if (!settings.autoWidth) {
	                        if (length &lt;&#x3D; settings.item) {
	                            $slide.find(&#x27;.lSAction&#x27;).hide();
	                        }
	                    } else {
	                        if (refresh.calWidth(false) &lt; elSize) {
	                            $slide.find(&#x27;.lSAction&#x27;).hide();
	                        }
	                    }
	                    $slide.find(&#x27;.lSAction a&#x27;).on(&#x27;click&#x27;, function (e) {
	                        if (e.preventDefault) {
	                            e.preventDefault();
	                        } else {
	                            e.returnValue &#x3D; false;
	                        }
	                        if ($(this).attr(&#x27;class&#x27;) &#x3D;&#x3D;&#x3D; &#x27;lSPrev&#x27;) {
	                            $el.goToPrevSlide();
	                        } else {
	                            $el.goToNextSlide();
	                        }
	                        return false;
	                    });
	                }
	            },
	            initialStyle: function () {
	                var $this &#x3D; this;
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;fade&#x27;) {
	                    settings.autoWidth &#x3D; false;
	                    settings.slideEndAnimation &#x3D; false;
	                }
	                if (settings.auto) {
	                    settings.slideEndAnimation &#x3D; false;
	                }
	                if (settings.autoWidth) {
	                    settings.slideMove &#x3D; 1;
	                    settings.item &#x3D; 1;
	                }
	                if (settings.loop) {
	                    settings.slideMove &#x3D; 1;
	                    settings.freeMove &#x3D; false;
	                }
	                settings.onBeforeStart.call(this, $el);
	                refresh.chbreakpoint();
	                $el.addClass(&#x27;lightSlider&#x27;).wrap(&#x27;&lt;div class&#x3D;&quot;lSSlideOuter &#x27; + settings.addClass + &#x27;&quot;&gt;&lt;div class&#x3D;&quot;lSSlideWrapper&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;);
	                $slide &#x3D; $el.parent(&#x27;.lSSlideWrapper&#x27;);
	                if (settings.rtl &#x3D;&#x3D;&#x3D; true) {
	                    $slide.parent().addClass(&#x27;lSrtl&#x27;);
	                }
	                if (settings.vertical) {
	                    $slide.parent().addClass(&#x27;vertical&#x27;);
	                    elSize &#x3D; settings.verticalHeight;
	                    $slide.css(&#x27;height&#x27;, elSize + &#x27;px&#x27;);
	                } else {
	                    elSize &#x3D; $el.outerWidth();
	                }
	                $children.addClass(&#x27;lslide&#x27;);
	                if (settings.loop &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    refresh.calSW();
	                    refresh.clone &#x3D; function () {
	                        if (refresh.calWidth(true) &gt; elSize) {
	                            /**/
	                            var tWr &#x3D; 0,
	                                tI &#x3D; 0;
	                            for (var k &#x3D; 0; k &lt; $children.length; k++) {
	                                tWr +&#x3D; (parseInt($el.find(&#x27;.lslide&#x27;).eq(k).width()) + settings.slideMargin);
	                                tI++;
	                                if (tWr &gt;&#x3D; (elSize + settings.slideMargin)) {
	                                    break;
	                                }
	                            }
	                            var tItem &#x3D; settings.autoWidth &#x3D;&#x3D;&#x3D; true ? tI : settings.item;

	                            /**/
	                            if (tItem &lt; $el.find(&#x27;.clone.left&#x27;).length) {
	                                for (var i &#x3D; 0; i &lt; $el.find(&#x27;.clone.left&#x27;).length - tItem; i++) {
	                                    $children.eq(i).remove();
	                                }
	                            }
	                            if (tItem &lt; $el.find(&#x27;.clone.right&#x27;).length) {
	                                for (var j &#x3D; $children.length - 1; j &gt; ($children.length - 1 - $el.find(&#x27;.clone.right&#x27;).length); j--) {
	                                    scene--;
	                                    $children.eq(j).remove();
	                                }
	                            }
	                            /**/
	                            for (var n &#x3D; $el.find(&#x27;.clone.right&#x27;).length; n &lt; tItem; n++) {
	                                $el.find(&#x27;.lslide&#x27;).eq(n).clone().removeClass(&#x27;lslide&#x27;).addClass(&#x27;clone right&#x27;).appendTo($el);
	                                scene++;
	                            }
	                            for (var m &#x3D; $el.find(&#x27;.lslide&#x27;).length - $el.find(&#x27;.clone.left&#x27;).length; m &gt; ($el.find(&#x27;.lslide&#x27;).length - tItem); m--) {
	                                $el.find(&#x27;.lslide&#x27;).eq(m - 1).clone().removeClass(&#x27;lslide&#x27;).addClass(&#x27;clone left&#x27;).prependTo($el);
	                            }
	                            $children &#x3D; $el.children();
	                        } else {
	                            if ($children.hasClass(&#x27;clone&#x27;)) {
	                                $el.find(&#x27;.clone&#x27;).remove();
	                                $this.move($el, 0);
	                            }
	                        }
	                    };
	                    refresh.clone();
	                }
	                refresh.sSW &#x3D; function () {
	                    length &#x3D; $children.length;
	                    if (settings.rtl &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.vertical &#x3D;&#x3D;&#x3D; false) {
	                        gutter &#x3D; &#x27;margin-left&#x27;;
	                    }
	                    if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                        $children.css(property, slideWidth + &#x27;px&#x27;);
	                    }
	                    $children.css(gutter, settings.slideMargin + &#x27;px&#x27;);
	                    w &#x3D; refresh.calWidth(false);
	                    $el.css(property, w + &#x27;px&#x27;);
	                    if (settings.loop &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                        if (on &#x3D;&#x3D;&#x3D; false) {
	                            scene &#x3D; $el.find(&#x27;.clone.left&#x27;).length;
	                        }
	                    }
	                };
	                refresh.calL &#x3D; function () {
	                    $children &#x3D; $el.children();
	                    length &#x3D; $children.length;
	                };
	                if (this.doCss()) {
	                    $slide.addClass(&#x27;usingCss&#x27;);
	                }
	                refresh.calL();
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    refresh.calSW();
	                    refresh.sSW();
	                    if (settings.loop &#x3D;&#x3D;&#x3D; true) {
	                        slideValue &#x3D; $this.slideValue();
	                        this.move($el, slideValue);
	                    }
	                    if (settings.vertical &#x3D;&#x3D;&#x3D; false) {
	                        this.setHeight($el, false);
	                    }

	                } else {
	                    this.setHeight($el, true);
	                    $el.addClass(&#x27;lSFade&#x27;);
	                    if (!this.doCss()) {
	                        $children.fadeOut(0);
	                        $children.eq(scene).fadeIn(0);
	                    }
	                }
	                if (settings.loop &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    $children.eq(scene).addClass(&#x27;active&#x27;);
	                } else {
	                    $children.first().addClass(&#x27;active&#x27;);
	                }
	            },
	            pager: function () {
	                var $this &#x3D; this;
	                refresh.createPager &#x3D; function () {
	                    thumbWidth &#x3D; (elSize - ((settings.thumbItem * (settings.thumbMargin)) - settings.thumbMargin)) / settings.thumbItem;
	                    var $children &#x3D; $slide.find(&#x27;.lslide&#x27;);
	                    var length &#x3D; $slide.find(&#x27;.lslide&#x27;).length;
	                    var i &#x3D; 0,
	                        pagers &#x3D; &#x27;&#x27;,
	                        v &#x3D; 0;
	                    for (i &#x3D; 0; i &lt; length; i++) {
	                        if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                            // calculate scene * slide value
	                            if (!settings.autoWidth) {
	                                v &#x3D; i * ((slideWidth + settings.slideMargin) * settings.slideMove);
	                            } else {
	                                v +&#x3D; ((parseInt($children.eq(i).width()) + settings.slideMargin) * settings.slideMove);
	                            }
	                        }
	                        var thumb &#x3D; $children.eq(i * settings.slideMove).attr(&#x27;data-thumb&#x27;);
	                        if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                            pagers +&#x3D; &#x27;&lt;li style&#x3D;&quot;width:100%;&#x27; + property + &#x27;:&#x27; + thumbWidth + &#x27;px;&#x27; + gutter + &#x27;:&#x27; + settings.thumbMargin + &#x27;px&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;&lt;img src&#x3D;&quot;&#x27; + thumb + &#x27;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;&#x27;;
	                        } else {
	                            pagers +&#x3D; &#x27;&lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;&#x27; + (i + 1) + &#x27;&lt;/a&gt;&lt;/li&gt;&#x27;;
	                        }
	                        if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                            if ((v) &gt;&#x3D; w - elSize - settings.slideMargin) {
	                                i &#x3D; i + 1;
	                                var minPgr &#x3D; 2;
	                                if (settings.autoWidth) {
	                                    pagers +&#x3D; &#x27;&lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;&#x27; + (i + 1) + &#x27;&lt;/a&gt;&lt;/li&gt;&#x27;;
	                                    minPgr &#x3D; 1;
	                                }
	                                if (i &lt; minPgr) {
	                                    pagers &#x3D; null;
	                                    $slide.parent().addClass(&#x27;noPager&#x27;);
	                                } else {
	                                    $slide.parent().removeClass(&#x27;noPager&#x27;);
	                                }
	                                break;
	                            }
	                        }
	                    }
	                    var $cSouter &#x3D; $slide.parent();
	                    $cSouter.find(&#x27;.lSPager&#x27;).html(pagers); 
	                    if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                        if (settings.vertical &#x3D;&#x3D;&#x3D; true) {
	                            // set Gallery thumbnail width
	                            $cSouter.find(&#x27;.lSPager&#x27;).css(&#x27;width&#x27;, settings.vThumbWidth + &#x27;px&#x27;);
	                        }
	                        pagerWidth &#x3D; (i * (settings.thumbMargin + thumbWidth)) + 0.5;
	                        $cSouter.find(&#x27;.lSPager&#x27;).css({
	                            property: pagerWidth + &#x27;px&#x27;,
	                            &#x27;transition-duration&#x27;: settings.speed + &#x27;ms&#x27;
	                        });
	                        if (settings.vertical &#x3D;&#x3D;&#x3D; true) {
	                            $slide.parent().css(&#x27;padding-right&#x27;, (settings.vThumbWidth + settings.galleryMargin) + &#x27;px&#x27;);
	                        }
	                        $cSouter.find(&#x27;.lSPager&#x27;).css(property, pagerWidth + &#x27;px&#x27;);
	                    }
	                    var $pager &#x3D; $cSouter.find(&#x27;.lSPager&#x27;).find(&#x27;li&#x27;);
	                    $pager.first().addClass(&#x27;active&#x27;);
	                    $pager.on(&#x27;click&#x27;, function () {
	                        if (settings.loop &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                            scene &#x3D; scene + ($pager.index(this) - $cSouter.find(&#x27;.lSPager&#x27;).find(&#x27;li.active&#x27;).index());
	                        } else {
	                            scene &#x3D; $pager.index(this);
	                        }
	                        $el.mode(false);
	                        if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                            $this.slideThumb();
	                        }
	                        return false;
	                    });
	                };
	                if (settings.pager) {
	                    var cl &#x3D; &#x27;lSpg&#x27;;
	                    if (settings.gallery) {
	                        cl &#x3D; &#x27;lSGallery&#x27;;
	                    }
	                    $slide.after(&#x27;&lt;ul class&#x3D;&quot;lSPager &#x27; + cl + &#x27;&quot;&gt;&lt;/ul&gt;&#x27;);
	                    var gMargin &#x3D; (settings.vertical) ? &#x27;margin-left&#x27; : &#x27;margin-top&#x27;;
	                    $slide.parent().find(&#x27;.lSPager&#x27;).css(gMargin, settings.galleryMargin + &#x27;px&#x27;);
	                    refresh.createPager();
	                }

	                setTimeout(function () {
	                    refresh.init();
	                }, 0);
	            },
	            setHeight: function (ob, fade) {
	                var obj &#x3D; null,
	                    $this &#x3D; this;
	                if (settings.loop) {
	                    obj &#x3D; ob.children(&#x27;.lslide &#x27;).first();
	                } else {
	                    obj &#x3D; ob.children().first();
	                }
	                var setCss &#x3D; function () {
	                    var tH &#x3D; obj.outerHeight(),
	                        tP &#x3D; 0,
	                        tHT &#x3D; tH;
	                    if (fade) {
	                        tH &#x3D; 0;
	                        tP &#x3D; ((tHT) * 100) / elSize;
	                    }
	                    ob.css({
	                        &#x27;height&#x27;: tH + &#x27;px&#x27;,
	                        &#x27;padding-bottom&#x27;: tP + &#x27;%&#x27;
	                    });
	                };
	                setCss();
	                if (obj.find(&#x27;img&#x27;).length) {
	                    if ( obj.find(&#x27;img&#x27;)[0].complete) {
	                        setCss();
	                        if (!interval) {
	                            $this.auto();
	                        }   
	                    }else{
	                        obj.find(&#x27;img&#x27;).on(&#x27;load&#x27;, function () {
	                            setTimeout(function () {
	                                setCss();
	                                if (!interval) {
	                                    $this.auto();
	                                }
	                            }, 100);
	                        });
	                    }
	                }else{
	                    if (!interval) {
	                        $this.auto();
	                    }
	                }
	            },
	            active: function (ob, t) {
	                if (this.doCss() &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;fade&#x27;) {
	                    $slide.addClass(&#x27;on&#x27;);
	                }
	                var sc &#x3D; 0;
	                if (scene * settings.slideMove &lt; length) {
	                    ob.removeClass(&#x27;active&#x27;);
	                    if (!this.doCss() &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;fade&#x27; &amp;&amp; t &#x3D;&#x3D;&#x3D; false) {
	                        ob.fadeOut(settings.speed);
	                    }
	                    if (t &#x3D;&#x3D;&#x3D; true) {
	                        sc &#x3D; scene;
	                    } else {
	                        sc &#x3D; scene * settings.slideMove;
	                    }
	                    //t &#x3D;&#x3D;&#x3D; true ? sc &#x3D; scene : sc &#x3D; scene * settings.slideMove;
	                    var l, nl;
	                    if (t &#x3D;&#x3D;&#x3D; true) {
	                        l &#x3D; ob.length;
	                        nl &#x3D; l - 1;
	                        if (sc + 1 &gt;&#x3D; l) {
	                            sc &#x3D; nl;
	                        }
	                    }
	                    if (settings.loop &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                        //t &#x3D;&#x3D;&#x3D; true ? sc &#x3D; scene - $el.find(&#x27;.clone.left&#x27;).length : sc &#x3D; scene * settings.slideMove;
	                        if (t &#x3D;&#x3D;&#x3D; true) {
	                            sc &#x3D; scene - $el.find(&#x27;.clone.left&#x27;).length;
	                        } else {
	                            sc &#x3D; scene * settings.slideMove;
	                        }
	                        if (t &#x3D;&#x3D;&#x3D; true) {
	                            l &#x3D; ob.length;
	                            nl &#x3D; l - 1;
	                            if (sc + 1 &#x3D;&#x3D;&#x3D; l) {
	                                sc &#x3D; nl;
	                            } else if (sc + 1 &gt; l) {
	                                sc &#x3D; 0;
	                            }
	                        }
	                    }

	                    if (!this.doCss() &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;fade&#x27; &amp;&amp; t &#x3D;&#x3D;&#x3D; false) {
	                        ob.eq(sc).fadeIn(settings.speed);
	                    }
	                    ob.eq(sc).addClass(&#x27;active&#x27;);
	                } else {
	                    ob.removeClass(&#x27;active&#x27;);
	                    ob.eq(ob.length - 1).addClass(&#x27;active&#x27;);
	                    if (!this.doCss() &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;fade&#x27; &amp;&amp; t &#x3D;&#x3D;&#x3D; false) {
	                        ob.fadeOut(settings.speed);
	                        ob.eq(sc).fadeIn(settings.speed);
	                    }
	                }
	            },
	            move: function (ob, v) {
	                if (settings.rtl &#x3D;&#x3D;&#x3D; true) {
	                    v &#x3D; -v;
	                }
	                if (this.doCss()) {
	                    if (settings.vertical &#x3D;&#x3D;&#x3D; true) {
	                        ob.css({
	                            &#x27;transform&#x27;: &#x27;translate3d(0px, &#x27; + (-v) + &#x27;px, 0px)&#x27;,
	                            &#x27;-webkit-transform&#x27;: &#x27;translate3d(0px, &#x27; + (-v) + &#x27;px, 0px)&#x27;
	                        });
	                    } else {
	                        ob.css({
	                            &#x27;transform&#x27;: &#x27;translate3d(&#x27; + (-v) + &#x27;px, 0px, 0px)&#x27;,
	                            &#x27;-webkit-transform&#x27;: &#x27;translate3d(&#x27; + (-v) + &#x27;px, 0px, 0px)&#x27;,
	                        });
	                    }
	                } else {
	                    if (settings.vertical &#x3D;&#x3D;&#x3D; true) {
	                        ob.css(&#x27;position&#x27;, &#x27;relative&#x27;).animate({
	                            top: -v + &#x27;px&#x27;
	                        }, settings.speed, settings.easing);
	                    } else {
	                        ob.css(&#x27;position&#x27;, &#x27;relative&#x27;).animate({
	                            left: -v + &#x27;px&#x27;
	                        }, settings.speed, settings.easing);
	                    }
	                }
	                var $thumb &#x3D; $slide.parent().find(&#x27;.lSPager&#x27;).find(&#x27;li&#x27;);
	                this.active($thumb, true);
	            },
	            fade: function () {
	                this.active($children, false);
	                var $thumb &#x3D; $slide.parent().find(&#x27;.lSPager&#x27;).find(&#x27;li&#x27;);
	                this.active($thumb, true);
	            },
	            slide: function () {
	                var $this &#x3D; this;
	                refresh.calSlide &#x3D; function () {
	                    if (w &gt; elSize) {
	                        slideValue &#x3D; $this.slideValue();
	                        $this.active($children, false);
	                        if ((slideValue) &gt; w - elSize - settings.slideMargin) {
	                            slideValue &#x3D; w - elSize - settings.slideMargin;
	                        } else if (slideValue &lt; 0) {
	                            slideValue &#x3D; 0;
	                        }
	                        $this.move($el, slideValue);
	                        if (settings.loop &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                            if (scene &gt;&#x3D; (length - ($el.find(&#x27;.clone.left&#x27;).length / settings.slideMove))) {
	                                $this.resetSlide($el.find(&#x27;.clone.left&#x27;).length);
	                            }
	                            if (scene &#x3D;&#x3D;&#x3D; 0) {
	                                $this.resetSlide($slide.find(&#x27;.lslide&#x27;).length);
	                            }
	                        }
	                    }
	                };
	                refresh.calSlide();
	            },
	            resetSlide: function (s) {
	                var $this &#x3D; this;
	                $slide.find(&#x27;.lSAction a&#x27;).addClass(&#x27;disabled&#x27;);
	                setTimeout(function () {
	                    scene &#x3D; s;
	                    $slide.css(&#x27;transition-duration&#x27;, &#x27;0ms&#x27;);
	                    slideValue &#x3D; $this.slideValue();
	                    $this.active($children, false);
	                    plugin.move($el, slideValue);
	                    setTimeout(function () {
	                        $slide.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                        $slide.find(&#x27;.lSAction a&#x27;).removeClass(&#x27;disabled&#x27;);
	                    }, 50);
	                }, settings.speed + 100);
	            },
	            slideValue: function () {
	                var _sV &#x3D; 0;
	                if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                    _sV &#x3D; scene * ((slideWidth + settings.slideMargin) * settings.slideMove);
	                } else {
	                    _sV &#x3D; 0;
	                    for (var i &#x3D; 0; i &lt; scene; i++) {
	                        _sV +&#x3D; (parseInt($children.eq(i).width()) + settings.slideMargin);
	                    }
	                }
	                return _sV;
	            },
	            slideThumb: function () {
	                var position;
	                switch (settings.currentPagerPosition) {
	                case &#x27;left&#x27;:
	                    position &#x3D; 0;
	                    break;
	                case &#x27;middle&#x27;:
	                    position &#x3D; (elSize / 2) - (thumbWidth / 2);
	                    break;
	                case &#x27;right&#x27;:
	                    position &#x3D; elSize - thumbWidth;
	                }
	                var sc &#x3D; scene - $el.find(&#x27;.clone.left&#x27;).length;
	                var $pager &#x3D; $slide.parent().find(&#x27;.lSPager&#x27;);
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27; &amp;&amp; settings.loop &#x3D;&#x3D;&#x3D; true) {
	                    if (sc &gt;&#x3D; $pager.children().length) {
	                        sc &#x3D; 0;
	                    } else if (sc &lt; 0) {
	                        sc &#x3D; $pager.children().length;
	                    }
	                }
	                var thumbSlide &#x3D; sc * ((thumbWidth + settings.thumbMargin)) - (position);
	                if ((thumbSlide + elSize) &gt; pagerWidth) {
	                    thumbSlide &#x3D; pagerWidth - elSize - settings.thumbMargin;
	                }
	                if (thumbSlide &lt; 0) {
	                    thumbSlide &#x3D; 0;
	                }
	                this.move($pager, thumbSlide);
	            },
	            auto: function () {
	                if (settings.auto) {
	                    clearInterval(interval);
	                    interval &#x3D; setInterval(function () {
	                        $el.goToNextSlide();
	                    }, settings.pause);
	                }
	            },
	            pauseOnHover: function(){
	                var $this &#x3D; this;
	                if (settings.auto &amp;&amp; settings.pauseOnHover) {
	                    $slide.on(&#x27;mouseenter&#x27;, function(){
	                        $(this).addClass(&#x27;ls-hover&#x27;);
	                        $el.pause();
	                        settings.auto &#x3D; true;
	                    });
	                    $slide.on(&#x27;mouseleave&#x27;,function(){
	                        $(this).removeClass(&#x27;ls-hover&#x27;);
	                        if (!$slide.find(&#x27;.lightSlider&#x27;).hasClass(&#x27;lsGrabbing&#x27;)) {
	                            $this.auto();
	                        }
	                    });
	                }
	            },
	            touchMove: function (endCoords, startCoords) {
	                $slide.css(&#x27;transition-duration&#x27;, &#x27;0ms&#x27;);
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    var distance &#x3D; endCoords - startCoords;
	                    var swipeVal &#x3D; slideValue - distance;
	                    if ((swipeVal) &gt;&#x3D; w - elSize - settings.slideMargin) {
	                        if (settings.freeMove &#x3D;&#x3D;&#x3D; false) {
	                            swipeVal &#x3D; w - elSize - settings.slideMargin;
	                        } else {
	                            var swipeValT &#x3D; w - elSize - settings.slideMargin;
	                            swipeVal &#x3D; swipeValT + ((swipeVal - swipeValT) / 5);

	                        }
	                    } else if (swipeVal &lt; 0) {
	                        if (settings.freeMove &#x3D;&#x3D;&#x3D; false) {
	                            swipeVal &#x3D; 0;
	                        } else {
	                            swipeVal &#x3D; swipeVal / 5;
	                        }
	                    }
	                    this.move($el, swipeVal);
	                }
	            },

	            touchEnd: function (distance) {
	                $slide.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    var mxVal &#x3D; false;
	                    var _next &#x3D; true;
	                    slideValue &#x3D; slideValue - distance;
	                    if ((slideValue) &gt; w - elSize - settings.slideMargin) {
	                        slideValue &#x3D; w - elSize - settings.slideMargin;
	                        if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                            mxVal &#x3D; true;
	                        }
	                    } else if (slideValue &lt; 0) {
	                        slideValue &#x3D; 0;
	                    }
	                    var gC &#x3D; function (next) {
	                        var ad &#x3D; 0;
	                        if (!mxVal) {
	                            if (next) {
	                                ad &#x3D; 1;
	                            }
	                        }
	                        if (!settings.autoWidth) {
	                            var num &#x3D; slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove);
	                            scene &#x3D; parseInt(num) + ad;
	                            if (slideValue &gt;&#x3D; (w - elSize - settings.slideMargin)) {
	                                if (num % 1 !&#x3D;&#x3D; 0) {
	                                    scene++;
	                                }
	                            }
	                        } else {
	                            var tW &#x3D; 0;
	                            for (var i &#x3D; 0; i &lt; $children.length; i++) {
	                                tW +&#x3D; (parseInt($children.eq(i).width()) + settings.slideMargin);
	                                scene &#x3D; i + ad;
	                                if (tW &gt;&#x3D; slideValue) {
	                                    break;
	                                }
	                            }
	                        }
	                    };
	                    if (distance &gt;&#x3D; settings.swipeThreshold) {
	                        gC(false);
	                        _next &#x3D; false;
	                    } else if (distance &lt;&#x3D; -settings.swipeThreshold) {
	                        gC(true);
	                        _next &#x3D; false;
	                    }
	                    $el.mode(_next);
	                    this.slideThumb();
	                } else {
	                    if (distance &gt;&#x3D; settings.swipeThreshold) {
	                        $el.goToPrevSlide();
	                    } else if (distance &lt;&#x3D; -settings.swipeThreshold) {
	                        $el.goToNextSlide();
	                    }
	                }
	            },



	            enableDrag: function () {
	                var $this &#x3D; this;
	                if (!isTouch) {
	                    var startCoords &#x3D; 0,
	                        endCoords &#x3D; 0,
	                        isDraging &#x3D; false;
	                    $slide.find(&#x27;.lightSlider&#x27;).addClass(&#x27;lsGrab&#x27;);
	                    $slide.on(&#x27;mousedown&#x27;, function (e) {
	                        if (w &lt; elSize) {
	                            if (w !&#x3D;&#x3D; 0) {
	                                return false;
	                            }
	                        }
	                        if ($(e.target).attr(&#x27;class&#x27;) !&#x3D;&#x3D; (&#x27;lSPrev&#x27;) &amp;&amp; $(e.target).attr(&#x27;class&#x27;) !&#x3D;&#x3D; (&#x27;lSNext&#x27;)) {
	                            startCoords &#x3D; (settings.vertical &#x3D;&#x3D;&#x3D; true) ? e.pageY : e.pageX;
	                            isDraging &#x3D; true;
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            } else {
	                                e.returnValue &#x3D; false;
	                            }
	                            // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id&#x3D;26723
	                            $slide.scrollLeft +&#x3D; 1;
	                            $slide.scrollLeft -&#x3D; 1;
	                            // *
	                            $slide.find(&#x27;.lightSlider&#x27;).removeClass(&#x27;lsGrab&#x27;).addClass(&#x27;lsGrabbing&#x27;);
	                            clearInterval(interval);
	                        }
	                    });
	                    $(window).on(&#x27;mousemove&#x27;, function (e) {
	                        if (isDraging) {
	                            endCoords &#x3D; (settings.vertical &#x3D;&#x3D;&#x3D; true) ? e.pageY : e.pageX;
	                            $this.touchMove(endCoords, startCoords);
	                        }
	                    });
	                    $(window).on(&#x27;mouseup&#x27;, function (e) {
	                        if (isDraging) {
	                            $slide.find(&#x27;.lightSlider&#x27;).removeClass(&#x27;lsGrabbing&#x27;).addClass(&#x27;lsGrab&#x27;);
	                            isDraging &#x3D; false;
	                            endCoords &#x3D; (settings.vertical &#x3D;&#x3D;&#x3D; true) ? e.pageY : e.pageX;
	                            var distance &#x3D; endCoords - startCoords;
	                            if (Math.abs(distance) &gt;&#x3D; settings.swipeThreshold) {
	                                $(window).on(&#x27;click.ls&#x27;, function (e) {
	                                    if (e.preventDefault) {
	                                        e.preventDefault();
	                                    } else {
	                                        e.returnValue &#x3D; false;
	                                    }
	                                    e.stopImmediatePropagation();
	                                    e.stopPropagation();
	                                    $(window).off(&#x27;click.ls&#x27;);
	                                });
	                            }

	                            $this.touchEnd(distance);

	                        }
	                    });
	                }
	            },




	            enableTouch: function () {
	                var $this &#x3D; this;
	                if (isTouch) {
	                    var startCoords &#x3D; {},
	                        endCoords &#x3D; {};
	                    $slide.on(&#x27;touchstart&#x27;, function (e) {
	                        endCoords &#x3D; e.originalEvent.targetTouches[0];
	                        startCoords.pageX &#x3D; e.originalEvent.targetTouches[0].pageX;
	                        startCoords.pageY &#x3D; e.originalEvent.targetTouches[0].pageY;
	                        clearInterval(interval);
	                    });
	                    $slide.on(&#x27;touchmove&#x27;, function (e) {
	                        if (w &lt; elSize) {
	                            if (w !&#x3D;&#x3D; 0) {
	                                return false;
	                            }
	                        }
	                        var orig &#x3D; e.originalEvent;
	                        endCoords &#x3D; orig.targetTouches[0];
	                        var xMovement &#x3D; Math.abs(endCoords.pageX - startCoords.pageX);
	                        var yMovement &#x3D; Math.abs(endCoords.pageY - startCoords.pageY);
	                        if (settings.vertical &#x3D;&#x3D;&#x3D; true) {
	                            if ((yMovement * 3) &gt; xMovement) {
	                                e.preventDefault();
	                            }
	                            $this.touchMove(endCoords.pageY, startCoords.pageY);
	                        } else {
	                            if ((xMovement * 3) &gt; yMovement) {
	                                e.preventDefault();
	                            }
	                            $this.touchMove(endCoords.pageX, startCoords.pageX);
	                        }

	                    });
	                    $slide.on(&#x27;touchend&#x27;, function () {
	                        if (w &lt; elSize) {
	                            if (w !&#x3D;&#x3D; 0) {
	                                return false;
	                            }
	                        }
	                        var distance;
	                        if (settings.vertical &#x3D;&#x3D;&#x3D; true) {
	                            distance &#x3D; endCoords.pageY - startCoords.pageY;
	                        } else {
	                            distance &#x3D; endCoords.pageX - startCoords.pageX;
	                        }
	                        $this.touchEnd(distance);
	                    });
	                }
	            },
	            build: function () {
	                var $this &#x3D; this;
	                $this.initialStyle();
	                if (this.doCss()) {

	                    if (settings.enableTouch &#x3D;&#x3D;&#x3D; true) {
	                        $this.enableTouch();
	                    }
	                    if (settings.enableDrag &#x3D;&#x3D;&#x3D; true) {
	                        $this.enableDrag();
	                    }
	                }

	                $(window).on(&#x27;focus&#x27;, function(){
	                    $this.auto();
	                });
	                
	                $(window).on(&#x27;blur&#x27;, function(){
	                    clearInterval(interval);
	                });

	                $this.pager();
	                $this.pauseOnHover();
	                $this.controls();
	                $this.keyPress();
	            }
	        };
	        plugin.build();
	        refresh.init &#x3D; function () {
	            refresh.chbreakpoint();
	            if (settings.vertical &#x3D;&#x3D;&#x3D; true) {
	                if (settings.item &gt; 1) {
	                    elSize &#x3D; settings.verticalHeight;
	                } else {
	                    elSize &#x3D; $children.outerHeight();
	                }
	                $slide.css(&#x27;height&#x27;, elSize + &#x27;px&#x27;);
	            } else {
	                elSize &#x3D; $slide.outerWidth();
	            }
	            if (settings.loop &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                refresh.clone();
	            }
	            refresh.calL();
	            if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                $el.removeClass(&#x27;lSSlide&#x27;);
	            }
	            if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                refresh.calSW();
	                refresh.sSW();
	            }
	            setTimeout(function () {
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    $el.addClass(&#x27;lSSlide&#x27;);
	                }
	            }, 1000);
	            if (settings.pager) {
	                refresh.createPager();
	            }
	            if (settings.adaptiveHeight &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.vertical &#x3D;&#x3D;&#x3D; false) {
	                $el.css(&#x27;height&#x27;, $children.eq(scene).outerHeight(true));
	            }
	            if (settings.adaptiveHeight &#x3D;&#x3D;&#x3D; false) {
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    if (settings.vertical &#x3D;&#x3D;&#x3D; false) {
	                        plugin.setHeight($el, false);
	                    }else{
	                        plugin.auto();
	                    }
	                } else {
	                    plugin.setHeight($el, true);
	                }
	            }
	            if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                plugin.slideThumb();
	            }
	            if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                plugin.slide();
	            }
	            if (settings.autoWidth &#x3D;&#x3D;&#x3D; false) {
	                if ($children.length &lt;&#x3D; settings.item) {
	                    $slide.find(&#x27;.lSAction&#x27;).hide();
	                } else {
	                    $slide.find(&#x27;.lSAction&#x27;).show();
	                }
	            } else {
	                if ((refresh.calWidth(false) &lt; elSize) &amp;&amp; (w !&#x3D;&#x3D; 0)) {
	                    $slide.find(&#x27;.lSAction&#x27;).hide();
	                } else {
	                    $slide.find(&#x27;.lSAction&#x27;).show();
	                }
	            }
	        };
	        $el.goToPrevSlide &#x3D; function () {
	            if (scene &gt; 0) {
	                settings.onBeforePrevSlide.call(this, $el, scene);
	                scene--;
	                $el.mode(false);
	                if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                    plugin.slideThumb();
	                }
	            } else {
	                if (settings.loop &#x3D;&#x3D;&#x3D; true) {
	                    settings.onBeforePrevSlide.call(this, $el, scene);
	                    if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;fade&#x27;) {
	                        var l &#x3D; (length - 1);
	                        scene &#x3D; parseInt(l / settings.slideMove);
	                    }
	                    $el.mode(false);
	                    if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                        plugin.slideThumb();
	                    }
	                } else if (settings.slideEndAnimation &#x3D;&#x3D;&#x3D; true) {
	                    $el.addClass(&#x27;leftEnd&#x27;);
	                    setTimeout(function () {
	                        $el.removeClass(&#x27;leftEnd&#x27;);
	                    }, 400);
	                }
	            }
	        };
	        $el.goToNextSlide &#x3D; function () {
	            var nextI &#x3D; true;
	            if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                var _slideValue &#x3D; plugin.slideValue();
	                nextI &#x3D; _slideValue &lt; w - elSize - settings.slideMargin;
	            }
	            if (((scene * settings.slideMove) &lt; length - settings.slideMove) &amp;&amp; nextI) {
	                settings.onBeforeNextSlide.call(this, $el, scene);
	                scene++;
	                $el.mode(false);
	                if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                    plugin.slideThumb();
	                }
	            } else {
	                if (settings.loop &#x3D;&#x3D;&#x3D; true) {
	                    settings.onBeforeNextSlide.call(this, $el, scene);
	                    scene &#x3D; 0;
	                    $el.mode(false);
	                    if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                        plugin.slideThumb();
	                    }
	                } else if (settings.slideEndAnimation &#x3D;&#x3D;&#x3D; true) {
	                    $el.addClass(&#x27;rightEnd&#x27;);
	                    setTimeout(function () {
	                        $el.removeClass(&#x27;rightEnd&#x27;);
	                    }, 400);
	                }
	            }
	        };
	        $el.mode &#x3D; function (_touch) {
	            if (settings.adaptiveHeight &#x3D;&#x3D;&#x3D; true &amp;&amp; settings.vertical &#x3D;&#x3D;&#x3D; false) {
	                $el.css(&#x27;height&#x27;, $children.eq(scene).outerHeight(true));
	            }
	            if (on &#x3D;&#x3D;&#x3D; false) {
	                if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                    if (plugin.doCss()) {
	                        $el.addClass(&#x27;lSSlide&#x27;);
	                        if (settings.speed !&#x3D;&#x3D; &#x27;&#x27;) {
	                            $slide.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                        }
	                        if (settings.cssEasing !&#x3D;&#x3D; &#x27;&#x27;) {
	                            $slide.css(&#x27;transition-timing-function&#x27;, settings.cssEasing);
	                        }
	                    }
	                } else {
	                    if (plugin.doCss()) {
	                        if (settings.speed !&#x3D;&#x3D; &#x27;&#x27;) {
	                            $el.css(&#x27;transition-duration&#x27;, settings.speed + &#x27;ms&#x27;);
	                        }
	                        if (settings.cssEasing !&#x3D;&#x3D; &#x27;&#x27;) {
	                            $el.css(&#x27;transition-timing-function&#x27;, settings.cssEasing);
	                        }
	                    }
	                }
	            }
	            if (!_touch) {
	                settings.onBeforeSlide.call(this, $el, scene);
	            }
	            if (settings.mode &#x3D;&#x3D;&#x3D; &#x27;slide&#x27;) {
	                plugin.slide();
	            } else {
	                plugin.fade();
	            }
	            if (!$slide.hasClass(&#x27;ls-hover&#x27;)) {
	                plugin.auto();
	            }
	            setTimeout(function () {
	                if (!_touch) {
	                    settings.onAfterSlide.call(this, $el, scene);
	                }
	            }, settings.speed);
	            on &#x3D; true;
	        };
	        $el.play &#x3D; function () {
	            $el.goToNextSlide();
	            settings.auto &#x3D; true;
	            plugin.auto();
	        };
	        $el.pause &#x3D; function () {
	            settings.auto &#x3D; false;
	            clearInterval(interval);
	        };
	        $el.refresh &#x3D; function () {
	            refresh.init();
	        };
	        $el.getCurrentSlideCount &#x3D; function () {
	            var sc &#x3D; scene;
	            if (settings.loop) {
	                var ln &#x3D; $slide.find(&#x27;.lslide&#x27;).length,
	                    cl &#x3D; $el.find(&#x27;.clone.left&#x27;).length;
	                if (scene &lt;&#x3D; cl - 1) {
	                    sc &#x3D; ln + (scene - cl);
	                } else if (scene &gt;&#x3D; (ln + cl)) {
	                    sc &#x3D; scene - ln - cl;
	                } else {
	                    sc &#x3D; scene - cl;
	                }
	            }
	            return sc + 1;
	        }; 
	        $el.getTotalSlideCount &#x3D; function () {
	            return $slide.find(&#x27;.lslide&#x27;).length;
	        };
	        $el.goToSlide &#x3D; function (s) {
	            if (settings.loop) {
	                scene &#x3D; (s + $el.find(&#x27;.clone.left&#x27;).length - 1);
	            } else {
	                scene &#x3D; s;
	            }
	            $el.mode(false);
	            if (settings.gallery &#x3D;&#x3D;&#x3D; true) {
	                plugin.slideThumb();
	            }
	        };
	        $el.destroy &#x3D; function () {
	            if ($el.lightSlider) {
	                $el.goToPrevSlide &#x3D; function(){};
	                $el.goToNextSlide &#x3D; function(){};
	                $el.mode &#x3D; function(){};
	                $el.play &#x3D; function(){};
	                $el.pause &#x3D; function(){};
	                $el.refresh &#x3D; function(){};
	                $el.getCurrentSlideCount &#x3D; function(){};
	                $el.getTotalSlideCount &#x3D; function(){};
	                $el.goToSlide &#x3D; function(){}; 
	                $el.lightSlider &#x3D; null;
	                refresh &#x3D; {
	                    init : function(){}
	                };
	                $el.parent().parent().find(&#x27;.lSAction, .lSPager&#x27;).remove();
	                $el.removeClass(&#x27;lightSlider lSFade lSSlide lsGrab lsGrabbing leftEnd right&#x27;).removeAttr(&#x27;style&#x27;).unwrap().unwrap();
	                $el.children().removeAttr(&#x27;style&#x27;);
	                $children.removeClass(&#x27;lslide active&#x27;);
	                $el.find(&#x27;.clone&#x27;).remove();
	                $children &#x3D; null;
	                interval &#x3D; null;
	                on &#x3D; false;
	                scene &#x3D; 0;
	            }

	        };
	        setTimeout(function () {
	            settings.onSliderLoad.call(this, $el);
	        }, 10);
	        $(window).on(&#x27;resize orientationchange&#x27;, function (e) {
	            setTimeout(function () {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                } else {
	                    e.returnValue &#x3D; false;
	                }
	                refresh.init();
	            }, 200);
	        });
	        return this;
	    };
	}(jQuery));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(19);
	__webpack_require__(26);

	jQuery(function ($) {
	    &quot;use strict&quot;;

	    initMasonary();


	});


	var initfilter &#x3D; function ($masonryContainer, $ele) {
	    var $filterElement &#x3D; $(&#x27;.project-filter li, .filter li&#x27;);
	    $filterElement.removeClass(&quot;active&quot;);
	    $ele.addClass(&quot;active&quot;);

	    if ($(&#x27;.masonry-container .animated&#x27;).length &gt; 0) {
	        $(&#x27;.masonry-container .animated&#x27;).addClass(&quot;go&quot;);
	    }

	    var selector &#x3D; $ele.attr(&#x27;data-filter&#x27;);
	    $masonryContainer.isotope({
	        filter: selector,
	        animationOptions: {
	            duration: 750,
	            easing: &#x27;linear&#x27;,
	            queue: false
	        }
	    });
	    return false;

	};
	function initMasonary() {

	    var $masonryContainer &#x3D; $(&#x27;.masonry-container&#x27;);
	    var $filterElement &#x3D; $(&#x27;.project-filter li, .filter li&#x27;);

	    if ($(&#x27;#filter-items&#x27;).length) {
	        $(&#x27;.filter li&#x27;).on(&#x27;click&#x27;, function () {
	            console.log(&#x27;scroll now&#x27;);
	            $(&#x27;html, body&#x27;).animate({
	                scrollTop: $(&#x27;#filter-items&#x27;).offset().top - 0
	            }, 1500, function () {
	            });
	            return false;
	        });
	    }


	    $masonryContainer.waitForImages(function () {
	        $(&#x27;.masonry-container&#x27;).show();
	        $(&#x27;.masonry-container&#x27;).masonry({
	            itemSelector: &#x27;.masonry-post&#x27;
	        });

	    });

	    $(window).on(&#x27;load&#x27;, function () {
	        var $ele &#x3D; $(&#x27;.project-filter .active&#x27;);
	        initfilter($masonryContainer, $ele);
	    });


	    $filterElement.click(function () {
	        $filterElement.removeClass(&quot;active&quot;);
	        var $ele &#x3D; $(this).addClass(&quot;active&quot;);

	        initfilter($masonryContainer, $ele, $filterElement);
	    });
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Masonry v4.2.1
	 * Cascading grid layout library
	 * https://masonry.desandro.com
	 * MIT License
	 * by David DeSandro
	 */

	( function( window, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /*globals define, module, require */
	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [
	        __webpack_require__(20),
	        __webpack_require__(22)
	      ], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (factory), __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports &#x3D; factory(
	      require(&#x27;outlayer&#x27;),
	      require(&#x27;get-size&#x27;)
	    );
	  } else {
	    // browser global
	    window.Masonry &#x3D; factory(
	      window.Outlayer,
	      window.getSize
	    );
	  }

	}( window, function factory( Outlayer, getSize ) {

	&#x27;use strict&#x27;;

	// -------------------------- masonryDefinition -------------------------- //

	  // create an Outlayer layout class
	  var Masonry &#x3D; Outlayer.create(&#x27;masonry&#x27;);
	  // isFitWidth -&gt; fitWidth
	  Masonry.compatOptions.fitWidth &#x3D; &#x27;isFitWidth&#x27;;

	  var proto &#x3D; Masonry.prototype;

	  proto._resetLayout &#x3D; function() {
	    this.getSize();
	    this._getMeasurement( &#x27;columnWidth&#x27;, &#x27;outerWidth&#x27; );
	    this._getMeasurement( &#x27;gutter&#x27;, &#x27;outerWidth&#x27; );
	    this.measureColumns();

	    // reset column Y
	    this.colYs &#x3D; [];
	    for ( var i&#x3D;0; i &lt; this.cols; i++ ) {
	      this.colYs.push( 0 );
	    }

	    this.maxY &#x3D; 0;
	    this.horizontalColIndex &#x3D; 0;
	  };

	  proto.measureColumns &#x3D; function() {
	    this.getContainerWidth();
	    // if columnWidth is 0, default to outerWidth of first item
	    if ( !this.columnWidth ) {
	      var firstItem &#x3D; this.items[0];
	      var firstItemElem &#x3D; firstItem &amp;&amp; firstItem.element;
	      // columnWidth fall back to item of first element
	      this.columnWidth &#x3D; firstItemElem &amp;&amp; getSize( firstItemElem ).outerWidth ||
	        // if first elem has no width, default to size of container
	        this.containerWidth;
	    }

	    var columnWidth &#x3D; this.columnWidth +&#x3D; this.gutter;

	    // calculate columns
	    var containerWidth &#x3D; this.containerWidth + this.gutter;
	    var cols &#x3D; containerWidth / columnWidth;
	    // fix rounding errors, typically with gutters
	    var excess &#x3D; columnWidth - containerWidth % columnWidth;
	    // if overshoot is less than a pixel, round up, otherwise floor it
	    var mathMethod &#x3D; excess &amp;&amp; excess &lt; 1 ? &#x27;round&#x27; : &#x27;floor&#x27;;
	    cols &#x3D; Math[ mathMethod ]( cols );
	    this.cols &#x3D; Math.max( cols, 1 );
	  };

	  proto.getContainerWidth &#x3D; function() {
	    // container is parent if fit width
	    var isFitWidth &#x3D; this._getOption(&#x27;fitWidth&#x27;);
	    var container &#x3D; isFitWidth ? this.element.parentNode : this.element;
	    // check that this.size and size are there
	    // IE8 triggers resize on body size change, so they might not be
	    var size &#x3D; getSize( container );
	    this.containerWidth &#x3D; size &amp;&amp; size.innerWidth;
	  };

	  proto._getItemLayoutPosition &#x3D; function( item ) {
	    item.getSize();
	    // how many columns does this brick span
	    var remainder &#x3D; item.size.outerWidth % this.columnWidth;
	    var mathMethod &#x3D; remainder &amp;&amp; remainder &lt; 1 ? &#x27;round&#x27; : &#x27;ceil&#x27;;
	    // round if off by 1 pixel, otherwise use ceil
	    var colSpan &#x3D; Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );
	    colSpan &#x3D; Math.min( colSpan, this.cols );
	    // use horizontal or top column position
	    var colPosMethod &#x3D; this.options.horizontalOrder ?
	      &#x27;_getHorizontalColPosition&#x27; : &#x27;_getTopColPosition&#x27;;
	    var colPosition &#x3D; this[ colPosMethod ]( colSpan, item );
	    // position the brick
	    var position &#x3D; {
	      x: this.columnWidth * colPosition.col,
	      y: colPosition.y
	    };
	    // apply setHeight to necessary columns
	    var setHeight &#x3D; colPosition.y + item.size.outerHeight;
	    var setMax &#x3D; colSpan + colPosition.col;
	    for ( var i &#x3D; colPosition.col; i &lt; setMax; i++ ) {
	      this.colYs[i] &#x3D; setHeight;
	    }

	    return position;
	  };

	  proto._getTopColPosition &#x3D; function( colSpan ) {
	    var colGroup &#x3D; this._getTopColGroup( colSpan );
	    // get the minimum Y value from the columns
	    var minimumY &#x3D; Math.min.apply( Math, colGroup );

	    return {
	      col: colGroup.indexOf( minimumY ),
	      y: minimumY,
	    };
	  };

	  /**
	   * @param {Number} colSpan - number of columns the element spans
	   * @returns {Array} colGroup
	   */
	  proto._getTopColGroup &#x3D; function( colSpan ) {
	    if ( colSpan &lt; 2 ) {
	      // if brick spans only one column, use all the column Ys
	      return this.colYs;
	    }

	    var colGroup &#x3D; [];
	    // how many different places could this brick fit horizontally
	    var groupCount &#x3D; this.cols + 1 - colSpan;
	    // for each group potential horizontal position
	    for ( var i &#x3D; 0; i &lt; groupCount; i++ ) {
	      colGroup[i] &#x3D; this._getColGroupY( i, colSpan );
	    }
	    return colGroup;
	  };

	  proto._getColGroupY &#x3D; function( col, colSpan ) {
	    if ( colSpan &lt; 2 ) {
	      return this.colYs[ col ];
	    }
	    // make an array of colY values for that one group
	    var groupColYs &#x3D; this.colYs.slice( col, col + colSpan );
	    // and get the max value of the array
	    return Math.max.apply( Math, groupColYs );
	  };

	  // get column position based on horizontal index. #873
	  proto._getHorizontalColPosition &#x3D; function( colSpan, item ) {
	    var col &#x3D; this.horizontalColIndex % this.cols;
	    var isOver &#x3D; colSpan &gt; 1 &amp;&amp; col + colSpan &gt; this.cols;
	    // shift to next row if item can&#x27;t fit on current row
	    col &#x3D; isOver ? 0 : col;
	    // don&#x27;t let zero-size items take up space
	    var hasSize &#x3D; item.size.outerWidth &amp;&amp; item.size.outerHeight;
	    this.horizontalColIndex &#x3D; hasSize ? col + colSpan : this.horizontalColIndex;

	    return {
	      col: col,
	      y: this._getColGroupY( col, colSpan ),
	    };
	  };

	  proto._manageStamp &#x3D; function( stamp ) {
	    var stampSize &#x3D; getSize( stamp );
	    var offset &#x3D; this._getElementOffset( stamp );
	    // get the columns that this stamp affects
	    var isOriginLeft &#x3D; this._getOption(&#x27;originLeft&#x27;);
	    var firstX &#x3D; isOriginLeft ? offset.left : offset.right;
	    var lastX &#x3D; firstX + stampSize.outerWidth;
	    var firstCol &#x3D; Math.floor( firstX / this.columnWidth );
	    firstCol &#x3D; Math.max( 0, firstCol );
	    var lastCol &#x3D; Math.floor( lastX / this.columnWidth );
	    // lastCol should not go over if multiple of columnWidth #425
	    lastCol -&#x3D; lastX % this.columnWidth ? 0 : 1;
	    lastCol &#x3D; Math.min( this.cols - 1, lastCol );
	    // set colYs to bottom of the stamp

	    var isOriginTop &#x3D; this._getOption(&#x27;originTop&#x27;);
	    var stampMaxY &#x3D; ( isOriginTop ? offset.top : offset.bottom ) +
	      stampSize.outerHeight;
	    for ( var i &#x3D; firstCol; i &lt;&#x3D; lastCol; i++ ) {
	      this.colYs[i] &#x3D; Math.max( stampMaxY, this.colYs[i] );
	    }
	  };

	  proto._getContainerSize &#x3D; function() {
	    this.maxY &#x3D; Math.max.apply( Math, this.colYs );
	    var size &#x3D; {
	      height: this.maxY
	    };

	    if ( this._getOption(&#x27;fitWidth&#x27;) ) {
	      size.width &#x3D; this._getContainerFitWidth();
	    }

	    return size;
	  };

	  proto._getContainerFitWidth &#x3D; function() {
	    var unusedCols &#x3D; 0;
	    // count unused columns
	    var i &#x3D; this.cols;
	    while ( --i ) {
	      if ( this.colYs[i] !&#x3D;&#x3D; 0 ) {
	        break;
	      }
	      unusedCols++;
	    }
	    // fit container to columns that have been used
	    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;
	  };

	  proto.needsResizeLayout &#x3D; function() {
	    var previousWidth &#x3D; this.containerWidth;
	    this.getContainerWidth();
	    return previousWidth !&#x3D; this.containerWidth;
	  };

	  return Masonry;

	}));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Outlayer v2.1.1
	 * the brains and guts of a layout library
	 * MIT license
	 */

	( function( window, factory ) {
	  &#x27;use strict&#x27;;
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, require */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [
	        __webpack_require__(21),
	        __webpack_require__(22),
	        __webpack_require__(23),
	        __webpack_require__(25)
	      ], __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; function( EvEmitter, getSize, utils, Item ) {
	        return factory( window, EvEmitter, getSize, utils, Item);
	      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports &#x3D; factory(
	      window,
	      require(&#x27;ev-emitter&#x27;),
	      require(&#x27;get-size&#x27;),
	      require(&#x27;fizzy-ui-utils&#x27;),
	      require(&#x27;./item&#x27;)
	    );
	  } else {
	    // browser global
	    window.Outlayer &#x3D; factory(
	      window,
	      window.EvEmitter,
	      window.getSize,
	      window.fizzyUIUtils,
	      window.Outlayer.Item
	    );
	  }

	}( window, function factory( window, EvEmitter, getSize, utils, Item ) {
	&#x27;use strict&#x27;;

	// ----- vars ----- //

	var console &#x3D; window.console;
	var jQuery &#x3D; window.jQuery;
	var noop &#x3D; function() {};

	// -------------------------- Outlayer -------------------------- //

	// globally unique identifiers
	var GUID &#x3D; 0;
	// internal store of all Outlayer intances
	var instances &#x3D; {};


	/**
	 * @param {Element, String} element
	 * @param {Object} options
	 * @constructor
	 */
	function Outlayer( element, options ) {
	  var queryElement &#x3D; utils.getQueryElement( element );
	  if ( !queryElement ) {
	    if ( console ) {
	      console.error( &#x27;Bad element for &#x27; + this.constructor.namespace +
	        &#x27;: &#x27; + ( queryElement || element ) );
	    }
	    return;
	  }
	  this.element &#x3D; queryElement;
	  // add jQuery
	  if ( jQuery ) {
	    this.$element &#x3D; jQuery( this.element );
	  }

	  // options
	  this.options &#x3D; utils.extend( {}, this.constructor.defaults );
	  this.option( options );

	  // add id for Outlayer.getFromElement
	  var id &#x3D; ++GUID;
	  this.element.outlayerGUID &#x3D; id; // expando
	  instances[ id ] &#x3D; this; // associate via id

	  // kick it off
	  this._create();

	  var isInitLayout &#x3D; this._getOption(&#x27;initLayout&#x27;);
	  if ( isInitLayout ) {
	    this.layout();
	  }
	}

	// settings are for internal use only
	Outlayer.namespace &#x3D; &#x27;outlayer&#x27;;
	Outlayer.Item &#x3D; Item;

	// default options
	Outlayer.defaults &#x3D; {
	  containerStyle: {
	    position: &#x27;relative&#x27;
	  },
	  initLayout: true,
	  originLeft: true,
	  originTop: true,
	  resize: true,
	  resizeContainer: true,
	  // item options
	  transitionDuration: &#x27;0.4s&#x27;,
	  hiddenStyle: {
	    opacity: 0,
	    transform: &#x27;scale(0.001)&#x27;
	  },
	  visibleStyle: {
	    opacity: 1,
	    transform: &#x27;scale(1)&#x27;
	  }
	};

	var proto &#x3D; Outlayer.prototype;
	// inherit EvEmitter
	utils.extend( proto, EvEmitter.prototype );

	/**
	 * set options
	 * @param {Object} opts
	 */
	proto.option &#x3D; function( opts ) {
	  utils.extend( this.options, opts );
	};

	/**
	 * get backwards compatible option value, check old name
	 */
	proto._getOption &#x3D; function( option ) {
	  var oldOption &#x3D; this.constructor.compatOptions[ option ];
	  return oldOption &amp;&amp; this.options[ oldOption ] !&#x3D;&#x3D; undefined ?
	    this.options[ oldOption ] : this.options[ option ];
	};

	Outlayer.compatOptions &#x3D; {
	  // currentName: oldName
	  initLayout: &#x27;isInitLayout&#x27;,
	  horizontal: &#x27;isHorizontal&#x27;,
	  layoutInstant: &#x27;isLayoutInstant&#x27;,
	  originLeft: &#x27;isOriginLeft&#x27;,
	  originTop: &#x27;isOriginTop&#x27;,
	  resize: &#x27;isResizeBound&#x27;,
	  resizeContainer: &#x27;isResizingContainer&#x27;
	};

	proto._create &#x3D; function() {
	  // get items from children
	  this.reloadItems();
	  // elements that affect layout, but are not laid out
	  this.stamps &#x3D; [];
	  this.stamp( this.options.stamp );
	  // set container style
	  utils.extend( this.element.style, this.options.containerStyle );

	  // bind resize method
	  var canBindResize &#x3D; this._getOption(&#x27;resize&#x27;);
	  if ( canBindResize ) {
	    this.bindResize();
	  }
	};

	// goes through all children again and gets bricks in proper order
	proto.reloadItems &#x3D; function() {
	  // collection of item elements
	  this.items &#x3D; this._itemize( this.element.children );
	};


	/**
	 * turn elements into Outlayer.Items to be used in layout
	 * @param {Array or NodeList or HTMLElement} elems
	 * @returns {Array} items - collection of new Outlayer Items
	 */
	proto._itemize &#x3D; function( elems ) {

	  var itemElems &#x3D; this._filterFindItemElements( elems );
	  var Item &#x3D; this.constructor.Item;

	  // create new Outlayer Items for collection
	  var items &#x3D; [];
	  for ( var i&#x3D;0; i &lt; itemElems.length; i++ ) {
	    var elem &#x3D; itemElems[i];
	    var item &#x3D; new Item( elem, this );
	    items.push( item );
	  }

	  return items;
	};

	/**
	 * get item elements to be used in layout
	 * @param {Array or NodeList or HTMLElement} elems
	 * @returns {Array} items - item elements
	 */
	proto._filterFindItemElements &#x3D; function( elems ) {
	  return utils.filterFindElements( elems, this.options.itemSelector );
	};

	/**
	 * getter method for getting item elements
	 * @returns {Array} elems - collection of item elements
	 */
	proto.getItemElements &#x3D; function() {
	  return this.items.map( function( item ) {
	    return item.element;
	  });
	};

	// ----- init &amp; layout ----- //

	/**
	 * lays out all items
	 */
	proto.layout &#x3D; function() {
	  this._resetLayout();
	  this._manageStamps();

	  // don&#x27;t animate first layout
	  var layoutInstant &#x3D; this._getOption(&#x27;layoutInstant&#x27;);
	  var isInstant &#x3D; layoutInstant !&#x3D;&#x3D; undefined ?
	    layoutInstant : !this._isLayoutInited;
	  this.layoutItems( this.items, isInstant );

	  // flag for initalized
	  this._isLayoutInited &#x3D; true;
	};

	// _init is alias for layout
	proto._init &#x3D; proto.layout;

	/**
	 * logic before any new layout
	 */
	proto._resetLayout &#x3D; function() {
	  this.getSize();
	};


	proto.getSize &#x3D; function() {
	  this.size &#x3D; getSize( this.element );
	};

	/**
	 * get measurement from option, for columnWidth, rowHeight, gutter
	 * if option is String -&gt; get element from selector string, &amp; get size of element
	 * if option is Element -&gt; get size of element
	 * else use option as a number
	 *
	 * @param {String} measurement
	 * @param {String} size - width or height
	 * @private
	 */
	proto._getMeasurement &#x3D; function( measurement, size ) {
	  var option &#x3D; this.options[ measurement ];
	  var elem;
	  if ( !option ) {
	    // default to 0
	    this[ measurement ] &#x3D; 0;
	  } else {
	    // use option as an element
	    if ( typeof option &#x3D;&#x3D; &#x27;string&#x27; ) {
	      elem &#x3D; this.element.querySelector( option );
	    } else if ( option instanceof HTMLElement ) {
	      elem &#x3D; option;
	    }
	    // use size of element, if element
	    this[ measurement ] &#x3D; elem ? getSize( elem )[ size ] : option;
	  }
	};

	/**
	 * layout a collection of item elements
	 * @api public
	 */
	proto.layoutItems &#x3D; function( items, isInstant ) {
	  items &#x3D; this._getItemsForLayout( items );

	  this._layoutItems( items, isInstant );

	  this._postLayout();
	};

	/**
	 * get the items to be laid out
	 * you may want to skip over some items
	 * @param {Array} items
	 * @returns {Array} items
	 */
	proto._getItemsForLayout &#x3D; function( items ) {
	  return items.filter( function( item ) {
	    return !item.isIgnored;
	  });
	};

	/**
	 * layout items
	 * @param {Array} items
	 * @param {Boolean} isInstant
	 */
	proto._layoutItems &#x3D; function( items, isInstant ) {
	  this._emitCompleteOnItems( &#x27;layout&#x27;, items );

	  if ( !items || !items.length ) {
	    // no items, emit event with empty array
	    return;
	  }

	  var queue &#x3D; [];

	  items.forEach( function( item ) {
	    // get x/y object from method
	    var position &#x3D; this._getItemLayoutPosition( item );
	    // enqueue
	    position.item &#x3D; item;
	    position.isInstant &#x3D; isInstant || item.isLayoutInstant;
	    queue.push( position );
	  }, this );

	  this._processLayoutQueue( queue );
	};

	/**
	 * get item layout position
	 * @param {Outlayer.Item} item
	 * @returns {Object} x and y position
	 */
	proto._getItemLayoutPosition &#x3D; function( /* item */ ) {
	  return {
	    x: 0,
	    y: 0
	  };
	};

	/**
	 * iterate over array and position each item
	 * Reason being - separating this logic prevents &#x27;layout invalidation&#x27;
	 * thx @paul_irish
	 * @param {Array} queue
	 */
	proto._processLayoutQueue &#x3D; function( queue ) {
	  this.updateStagger();
	  queue.forEach( function( obj, i ) {
	    this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );
	  }, this );
	};

	// set stagger from option in milliseconds number
	proto.updateStagger &#x3D; function() {
	  var stagger &#x3D; this.options.stagger;
	  if ( stagger &#x3D;&#x3D;&#x3D; null || stagger &#x3D;&#x3D;&#x3D; undefined ) {
	    this.stagger &#x3D; 0;
	    return;
	  }
	  this.stagger &#x3D; getMilliseconds( stagger );
	  return this.stagger;
	};

	/**
	 * Sets position of item in DOM
	 * @param {Outlayer.Item} item
	 * @param {Number} x - horizontal position
	 * @param {Number} y - vertical position
	 * @param {Boolean} isInstant - disables transitions
	 */
	proto._positionItem &#x3D; function( item, x, y, isInstant, i ) {
	  if ( isInstant ) {
	    // if not transition, just set CSS
	    item.goTo( x, y );
	  } else {
	    item.stagger( i * this.stagger );
	    item.moveTo( x, y );
	  }
	};

	/**
	 * Any logic you want to do after each layout,
	 * i.e. size the container
	 */
	proto._postLayout &#x3D; function() {
	  this.resizeContainer();
	};

	proto.resizeContainer &#x3D; function() {
	  var isResizingContainer &#x3D; this._getOption(&#x27;resizeContainer&#x27;);
	  if ( !isResizingContainer ) {
	    return;
	  }
	  var size &#x3D; this._getContainerSize();
	  if ( size ) {
	    this._setContainerMeasure( size.width, true );
	    this._setContainerMeasure( size.height, false );
	  }
	};

	/**
	 * Sets width or height of container if returned
	 * @returns {Object} size
	 *   @param {Number} width
	 *   @param {Number} height
	 */
	proto._getContainerSize &#x3D; noop;

	/**
	 * @param {Number} measure - size of width or height
	 * @param {Boolean} isWidth
	 */
	proto._setContainerMeasure &#x3D; function( measure, isWidth ) {
	  if ( measure &#x3D;&#x3D;&#x3D; undefined ) {
	    return;
	  }

	  var elemSize &#x3D; this.size;
	  // add padding and border width if border box
	  if ( elemSize.isBorderBox ) {
	    measure +&#x3D; isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
	      elemSize.borderLeftWidth + elemSize.borderRightWidth :
	      elemSize.paddingBottom + elemSize.paddingTop +
	      elemSize.borderTopWidth + elemSize.borderBottomWidth;
	  }

	  measure &#x3D; Math.max( measure, 0 );
	  this.element.style[ isWidth ? &#x27;width&#x27; : &#x27;height&#x27; ] &#x3D; measure + &#x27;px&#x27;;
	};

	/**
	 * emit eventComplete on a collection of items events
	 * @param {String} eventName
	 * @param {Array} items - Outlayer.Items
	 */
	proto._emitCompleteOnItems &#x3D; function( eventName, items ) {
	  var _this &#x3D; this;
	  function onComplete() {
	    _this.dispatchEvent( eventName + &#x27;Complete&#x27;, null, [ items ] );
	  }

	  var count &#x3D; items.length;
	  if ( !items || !count ) {
	    onComplete();
	    return;
	  }

	  var doneCount &#x3D; 0;
	  function tick() {
	    doneCount++;
	    if ( doneCount &#x3D;&#x3D; count ) {
	      onComplete();
	    }
	  }

	  // bind callback
	  items.forEach( function( item ) {
	    item.once( eventName, tick );
	  });
	};

	/**
	 * emits events via EvEmitter and jQuery events
	 * @param {String} type - name of event
	 * @param {Event} event - original event
	 * @param {Array} args - extra arguments
	 */
	proto.dispatchEvent &#x3D; function( type, event, args ) {
	  // add original event to arguments
	  var emitArgs &#x3D; event ? [ event ].concat( args ) : args;
	  this.emitEvent( type, emitArgs );

	  if ( jQuery ) {
	    // set this.$element
	    this.$element &#x3D; this.$element || jQuery( this.element );
	    if ( event ) {
	      // create jQuery event
	      var $event &#x3D; jQuery.Event( event );
	      $event.type &#x3D; type;
	      this.$element.trigger( $event, args );
	    } else {
	      // just trigger with type if no event available
	      this.$element.trigger( type, args );
	    }
	  }
	};

	// -------------------------- ignore &amp; stamps -------------------------- //


	/**
	 * keep item in collection, but do not lay it out
	 * ignored items do not get skipped in layout
	 * @param {Element} elem
	 */
	proto.ignore &#x3D; function( elem ) {
	  var item &#x3D; this.getItem( elem );
	  if ( item ) {
	    item.isIgnored &#x3D; true;
	  }
	};

	/**
	 * return item to layout collection
	 * @param {Element} elem
	 */
	proto.unignore &#x3D; function( elem ) {
	  var item &#x3D; this.getItem( elem );
	  if ( item ) {
	    delete item.isIgnored;
	  }
	};

	/**
	 * adds elements to stamps
	 * @param {NodeList, Array, Element, or String} elems
	 */
	proto.stamp &#x3D; function( elems ) {
	  elems &#x3D; this._find( elems );
	  if ( !elems ) {
	    return;
	  }

	  this.stamps &#x3D; this.stamps.concat( elems );
	  // ignore
	  elems.forEach( this.ignore, this );
	};

	/**
	 * removes elements to stamps
	 * @param {NodeList, Array, or Element} elems
	 */
	proto.unstamp &#x3D; function( elems ) {
	  elems &#x3D; this._find( elems );
	  if ( !elems ){
	    return;
	  }

	  elems.forEach( function( elem ) {
	    // filter out removed stamp elements
	    utils.removeFrom( this.stamps, elem );
	    this.unignore( elem );
	  }, this );
	};

	/**
	 * finds child elements
	 * @param {NodeList, Array, Element, or String} elems
	 * @returns {Array} elems
	 */
	proto._find &#x3D; function( elems ) {
	  if ( !elems ) {
	    return;
	  }
	  // if string, use argument as selector string
	  if ( typeof elems &#x3D;&#x3D; &#x27;string&#x27; ) {
	    elems &#x3D; this.element.querySelectorAll( elems );
	  }
	  elems &#x3D; utils.makeArray( elems );
	  return elems;
	};

	proto._manageStamps &#x3D; function() {
	  if ( !this.stamps || !this.stamps.length ) {
	    return;
	  }

	  this._getBoundingRect();

	  this.stamps.forEach( this._manageStamp, this );
	};

	// update boundingLeft / Top
	proto._getBoundingRect &#x3D; function() {
	  // get bounding rect for container element
	  var boundingRect &#x3D; this.element.getBoundingClientRect();
	  var size &#x3D; this.size;
	  this._boundingRect &#x3D; {
	    left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
	    top: boundingRect.top + size.paddingTop + size.borderTopWidth,
	    right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
	    bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
	  };
	};

	/**
	 * @param {Element} stamp
	**/
	proto._manageStamp &#x3D; noop;

	/**
	 * get x/y position of element relative to container element
	 * @param {Element} elem
	 * @returns {Object} offset - has left, top, right, bottom
	 */
	proto._getElementOffset &#x3D; function( elem ) {
	  var boundingRect &#x3D; elem.getBoundingClientRect();
	  var thisRect &#x3D; this._boundingRect;
	  var size &#x3D; getSize( elem );
	  var offset &#x3D; {
	    left: boundingRect.left - thisRect.left - size.marginLeft,
	    top: boundingRect.top - thisRect.top - size.marginTop,
	    right: thisRect.right - boundingRect.right - size.marginRight,
	    bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
	  };
	  return offset;
	};

	// -------------------------- resize -------------------------- //

	// enable event handlers for listeners
	// i.e. resize -&gt; onresize
	proto.handleEvent &#x3D; utils.handleEvent;

	/**
	 * Bind layout to window resizing
	 */
	proto.bindResize &#x3D; function() {
	  window.addEventListener( &#x27;resize&#x27;, this );
	  this.isResizeBound &#x3D; true;
	};

	/**
	 * Unbind layout to window resizing
	 */
	proto.unbindResize &#x3D; function() {
	  window.removeEventListener( &#x27;resize&#x27;, this );
	  this.isResizeBound &#x3D; false;
	};

	proto.onresize &#x3D; function() {
	  this.resize();
	};

	utils.debounceMethod( Outlayer, &#x27;onresize&#x27;, 100 );

	proto.resize &#x3D; function() {
	  // don&#x27;t trigger if size did not change
	  // or if resize was unbound. See #9
	  if ( !this.isResizeBound || !this.needsResizeLayout() ) {
	    return;
	  }

	  this.layout();
	};

	/**
	 * check if layout is needed post layout
	 * @returns Boolean
	 */
	proto.needsResizeLayout &#x3D; function() {
	  var size &#x3D; getSize( this.element );
	  // check that this.size and size are there
	  // IE8 triggers resize on body size change, so they might not be
	  var hasSizes &#x3D; this.size &amp;&amp; size;
	  return hasSizes &amp;&amp; size.innerWidth !&#x3D;&#x3D; this.size.innerWidth;
	};

	// -------------------------- methods -------------------------- //

	/**
	 * add items to Outlayer instance
	 * @param {Array or NodeList or Element} elems
	 * @returns {Array} items - Outlayer.Items
	**/
	proto.addItems &#x3D; function( elems ) {
	  var items &#x3D; this._itemize( elems );
	  // add items to collection
	  if ( items.length ) {
	    this.items &#x3D; this.items.concat( items );
	  }
	  return items;
	};

	/**
	 * Layout newly-appended item elements
	 * @param {Array or NodeList or Element} elems
	 */
	proto.appended &#x3D; function( elems ) {
	  var items &#x3D; this.addItems( elems );
	  if ( !items.length ) {
	    return;
	  }
	  // layout and reveal just the new items
	  this.layoutItems( items, true );
	  this.reveal( items );
	};

	/**
	 * Layout prepended elements
	 * @param {Array or NodeList or Element} elems
	 */
	proto.prepended &#x3D; function( elems ) {
	  var items &#x3D; this._itemize( elems );
	  if ( !items.length ) {
	    return;
	  }
	  // add items to beginning of collection
	  var previousItems &#x3D; this.items.slice(0);
	  this.items &#x3D; items.concat( previousItems );
	  // start new layout
	  this._resetLayout();
	  this._manageStamps();
	  // layout new stuff without transition
	  this.layoutItems( items, true );
	  this.reveal( items );
	  // layout previous items
	  this.layoutItems( previousItems );
	};

	/**
	 * reveal a collection of items
	 * @param {Array of Outlayer.Items} items
	 */
	proto.reveal &#x3D; function( items ) {
	  this._emitCompleteOnItems( &#x27;reveal&#x27;, items );
	  if ( !items || !items.length ) {
	    return;
	  }
	  var stagger &#x3D; this.updateStagger();
	  items.forEach( function( item, i ) {
	    item.stagger( i * stagger );
	    item.reveal();
	  });
	};

	/**
	 * hide a collection of items
	 * @param {Array of Outlayer.Items} items
	 */
	proto.hide &#x3D; function( items ) {
	  this._emitCompleteOnItems( &#x27;hide&#x27;, items );
	  if ( !items || !items.length ) {
	    return;
	  }
	  var stagger &#x3D; this.updateStagger();
	  items.forEach( function( item, i ) {
	    item.stagger( i * stagger );
	    item.hide();
	  });
	};

	/**
	 * reveal item elements
	 * @param {Array}, {Element}, {NodeList} items
	 */
	proto.revealItemElements &#x3D; function( elems ) {
	  var items &#x3D; this.getItems( elems );
	  this.reveal( items );
	};

	/**
	 * hide item elements
	 * @param {Array}, {Element}, {NodeList} items
	 */
	proto.hideItemElements &#x3D; function( elems ) {
	  var items &#x3D; this.getItems( elems );
	  this.hide( items );
	};

	/**
	 * get Outlayer.Item, given an Element
	 * @param {Element} elem
	 * @param {Function} callback
	 * @returns {Outlayer.Item} item
	 */
	proto.getItem &#x3D; function( elem ) {
	  // loop through items to get the one that matches
	  for ( var i&#x3D;0; i &lt; this.items.length; i++ ) {
	    var item &#x3D; this.items[i];
	    if ( item.element &#x3D;&#x3D; elem ) {
	      // return item
	      return item;
	    }
	  }
	};

	/**
	 * get collection of Outlayer.Items, given Elements
	 * @param {Array} elems
	 * @returns {Array} items - Outlayer.Items
	 */
	proto.getItems &#x3D; function( elems ) {
	  elems &#x3D; utils.makeArray( elems );
	  var items &#x3D; [];
	  elems.forEach( function( elem ) {
	    var item &#x3D; this.getItem( elem );
	    if ( item ) {
	      items.push( item );
	    }
	  }, this );

	  return items;
	};

	/**
	 * remove element(s) from instance and DOM
	 * @param {Array or NodeList or Element} elems
	 */
	proto.remove &#x3D; function( elems ) {
	  var removeItems &#x3D; this.getItems( elems );

	  this._emitCompleteOnItems( &#x27;remove&#x27;, removeItems );

	  // bail if no items to remove
	  if ( !removeItems || !removeItems.length ) {
	    return;
	  }

	  removeItems.forEach( function( item ) {
	    item.remove();
	    // remove item from collection
	    utils.removeFrom( this.items, item );
	  }, this );
	};

	// ----- destroy ----- //

	// remove and disable Outlayer instance
	proto.destroy &#x3D; function() {
	  // clean up dynamic styles
	  var style &#x3D; this.element.style;
	  style.height &#x3D; &#x27;&#x27;;
	  style.position &#x3D; &#x27;&#x27;;
	  style.width &#x3D; &#x27;&#x27;;
	  // destroy items
	  this.items.forEach( function( item ) {
	    item.destroy();
	  });

	  this.unbindResize();

	  var id &#x3D; this.element.outlayerGUID;
	  delete instances[ id ]; // remove reference to instance by id
	  delete this.element.outlayerGUID;
	  // remove data for jQuery
	  if ( jQuery ) {
	    jQuery.removeData( this.element, this.constructor.namespace );
	  }

	};

	// -------------------------- data -------------------------- //

	/**
	 * get Outlayer instance from element
	 * @param {Element} elem
	 * @returns {Outlayer}
	 */
	Outlayer.data &#x3D; function( elem ) {
	  elem &#x3D; utils.getQueryElement( elem );
	  var id &#x3D; elem &amp;&amp; elem.outlayerGUID;
	  return id &amp;&amp; instances[ id ];
	};


	// -------------------------- create Outlayer class -------------------------- //

	/**
	 * create a layout class
	 * @param {String} namespace
	 */
	Outlayer.create &#x3D; function( namespace, options ) {
	  // sub-class Outlayer
	  var Layout &#x3D; subclass( Outlayer );
	  // apply new options and compatOptions
	  Layout.defaults &#x3D; utils.extend( {}, Outlayer.defaults );
	  utils.extend( Layout.defaults, options );
	  Layout.compatOptions &#x3D; utils.extend( {}, Outlayer.compatOptions  );

	  Layout.namespace &#x3D; namespace;

	  Layout.data &#x3D; Outlayer.data;

	  // sub-class Item
	  Layout.Item &#x3D; subclass( Item );

	  // -------------------------- declarative -------------------------- //

	  utils.htmlInit( Layout, namespace );

	  // -------------------------- jQuery bridge -------------------------- //

	  // make into jQuery plugin
	  if ( jQuery &amp;&amp; jQuery.bridget ) {
	    jQuery.bridget( namespace, Layout );
	  }

	  return Layout;
	};

	function subclass( Parent ) {
	  function SubClass() {
	    Parent.apply( this, arguments );
	  }

	  SubClass.prototype &#x3D; Object.create( Parent.prototype );
	  SubClass.prototype.constructor &#x3D; SubClass;

	  return SubClass;
	}

	// ----- helpers ----- //

	// how many milliseconds are in each unit
	var msUnits &#x3D; {
	  ms: 1,
	  s: 1000
	};

	// munge time-like parameter into millisecond number
	// &#x27;0.4s&#x27; -&gt; 40
	function getMilliseconds( time ) {
	  if ( typeof time &#x3D;&#x3D; &#x27;number&#x27; ) {
	    return time;
	  }
	  var matches &#x3D; time.match( /(^\d*\.?\d*)(\w*)/ );
	  var num &#x3D; matches &amp;&amp; matches[1];
	  var unit &#x3D; matches &amp;&amp; matches[2];
	  if ( !num.length ) {
	    return 0;
	  }
	  num &#x3D; parseFloat( num );
	  var mult &#x3D; msUnits[ unit ] || 1;
	  return num * mult;
	}

	// ----- fin ----- //

	// back in global
	Outlayer.Item &#x3D; Item;

	return Outlayer;

	}));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * EvEmitter v1.1.0
	 * Lil&#x27; event emitter
	 * MIT License
	 */

	/* jshint unused: true, undef: true, strict: true */

	( function( global, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, window */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (factory), __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports &#x3D; factory();
	  } else {
	    // Browser globals
	    global.EvEmitter &#x3D; factory();
	  }

	}( typeof window !&#x3D; &#x27;undefined&#x27; ? window : this, function() {

	&quot;use strict&quot;;

	function EvEmitter() {}

	var proto &#x3D; EvEmitter.prototype;

	proto.on &#x3D; function( eventName, listener ) {
	  if ( !eventName || !listener ) {
	    return;
	  }
	  // set events hash
	  var events &#x3D; this._events &#x3D; this._events || {};
	  // set listeners array
	  var listeners &#x3D; events[ eventName ] &#x3D; events[ eventName ] || [];
	  // only add once
	  if ( listeners.indexOf( listener ) &#x3D;&#x3D; -1 ) {
	    listeners.push( listener );
	  }

	  return this;
	};

	proto.once &#x3D; function( eventName, listener ) {
	  if ( !eventName || !listener ) {
	    return;
	  }
	  // add event
	  this.on( eventName, listener );
	  // set once flag
	  // set onceEvents hash
	  var onceEvents &#x3D; this._onceEvents &#x3D; this._onceEvents || {};
	  // set onceListeners object
	  var onceListeners &#x3D; onceEvents[ eventName ] &#x3D; onceEvents[ eventName ] || {};
	  // set flag
	  onceListeners[ listener ] &#x3D; true;

	  return this;
	};

	proto.off &#x3D; function( eventName, listener ) {
	  var listeners &#x3D; this._events &amp;&amp; this._events[ eventName ];
	  if ( !listeners || !listeners.length ) {
	    return;
	  }
	  var index &#x3D; listeners.indexOf( listener );
	  if ( index !&#x3D; -1 ) {
	    listeners.splice( index, 1 );
	  }

	  return this;
	};

	proto.emitEvent &#x3D; function( eventName, args ) {
	  var listeners &#x3D; this._events &amp;&amp; this._events[ eventName ];
	  if ( !listeners || !listeners.length ) {
	    return;
	  }
	  // copy over to avoid interference if .off() in listener
	  listeners &#x3D; listeners.slice(0);
	  args &#x3D; args || [];
	  // once stuff
	  var onceListeners &#x3D; this._onceEvents &amp;&amp; this._onceEvents[ eventName ];

	  for ( var i&#x3D;0; i &lt; listeners.length; i++ ) {
	    var listener &#x3D; listeners[i]
	    var isOnce &#x3D; onceListeners &amp;&amp; onceListeners[ listener ];
	    if ( isOnce ) {
	      // remove listener
	      // remove before trigger to prevent recursion
	      this.off( eventName, listener );
	      // unset once flag
	      delete onceListeners[ listener ];
	    }
	    // trigger listener
	    listener.apply( this, args );
	  }

	  return this;
	};

	proto.allOff &#x3D; function() {
	  delete this._events;
	  delete this._onceEvents;
	};

	return EvEmitter;

	}));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * getSize v2.0.2
	 * measure size of elements
	 * MIT license
	 */

	/*jshint browser: true, strict: true, undef: true, unused: true */
	/*global define: false, module: false, console: false */

	( function( window, factory ) {
	  &#x27;use strict&#x27;;

	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_RESULT__ &#x3D; function() {
	      return factory();
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports &#x3D; factory();
	  } else {
	    // browser global
	    window.getSize &#x3D; factory();
	  }

	})( window, function factory() {
	&#x27;use strict&#x27;;

	// -------------------------- helpers -------------------------- //

	// get a number from a string, not a percentage
	function getStyleSize( value ) {
	  var num &#x3D; parseFloat( value );
	  // not a percent like &#x27;100%&#x27;, and a number
	  var isValid &#x3D; value.indexOf(&#x27;%&#x27;) &#x3D;&#x3D; -1 &amp;&amp; !isNaN( num );
	  return isValid &amp;&amp; num;
	}

	function noop() {}

	var logError &#x3D; typeof console &#x3D;&#x3D; &#x27;undefined&#x27; ? noop :
	  function( message ) {
	    console.error( message );
	  };

	// -------------------------- measurements -------------------------- //

	var measurements &#x3D; [
	  &#x27;paddingLeft&#x27;,
	  &#x27;paddingRight&#x27;,
	  &#x27;paddingTop&#x27;,
	  &#x27;paddingBottom&#x27;,
	  &#x27;marginLeft&#x27;,
	  &#x27;marginRight&#x27;,
	  &#x27;marginTop&#x27;,
	  &#x27;marginBottom&#x27;,
	  &#x27;borderLeftWidth&#x27;,
	  &#x27;borderRightWidth&#x27;,
	  &#x27;borderTopWidth&#x27;,
	  &#x27;borderBottomWidth&#x27;
	];

	var measurementsLength &#x3D; measurements.length;

	function getZeroSize() {
	  var size &#x3D; {
	    width: 0,
	    height: 0,
	    innerWidth: 0,
	    innerHeight: 0,
	    outerWidth: 0,
	    outerHeight: 0
	  };
	  for ( var i&#x3D;0; i &lt; measurementsLength; i++ ) {
	    var measurement &#x3D; measurements[i];
	    size[ measurement ] &#x3D; 0;
	  }
	  return size;
	}

	// -------------------------- getStyle -------------------------- //

	/**
	 * getStyle, get style of element, check for Firefox bug
	 * https://bugzilla.mozilla.org/show_bug.cgi?id&#x3D;548397
	 */
	function getStyle( elem ) {
	  var style &#x3D; getComputedStyle( elem );
	  if ( !style ) {
	    logError( &#x27;Style returned &#x27; + style +
	      &#x27;. Are you running this code in a hidden iframe on Firefox? &#x27; +
	      &#x27;See http://bit.ly/getsizebug1&#x27; );
	  }
	  return style;
	}

	// -------------------------- setup -------------------------- //

	var isSetup &#x3D; false;

	var isBoxSizeOuter;

	/**
	 * setup
	 * check isBoxSizerOuter
	 * do on first getSize() rather than on page load for Firefox bug
	 */
	function setup() {
	  // setup once
	  if ( isSetup ) {
	    return;
	  }
	  isSetup &#x3D; true;

	  // -------------------------- box sizing -------------------------- //

	  /**
	   * WebKit measures the outer-width on style.width on border-box elems
	   * IE &amp; Firefox&lt;29 measures the inner-width
	   */
	  var div &#x3D; document.createElement(&#x27;div&#x27;);
	  div.style.width &#x3D; &#x27;200px&#x27;;
	  div.style.padding &#x3D; &#x27;1px 2px 3px 4px&#x27;;
	  div.style.borderStyle &#x3D; &#x27;solid&#x27;;
	  div.style.borderWidth &#x3D; &#x27;1px 2px 3px 4px&#x27;;
	  div.style.boxSizing &#x3D; &#x27;border-box&#x27;;

	  var body &#x3D; document.body || document.documentElement;
	  body.appendChild( div );
	  var style &#x3D; getStyle( div );

	  getSize.isBoxSizeOuter &#x3D; isBoxSizeOuter &#x3D; getStyleSize( style.width ) &#x3D;&#x3D; 200;
	  body.removeChild( div );

	}

	// -------------------------- getSize -------------------------- //

	function getSize( elem ) {
	  setup();

	  // use querySeletor if elem is string
	  if ( typeof elem &#x3D;&#x3D; &#x27;string&#x27; ) {
	    elem &#x3D; document.querySelector( elem );
	  }

	  // do not proceed on non-objects
	  if ( !elem || typeof elem !&#x3D; &#x27;object&#x27; || !elem.nodeType ) {
	    return;
	  }

	  var style &#x3D; getStyle( elem );

	  // if hidden, everything is 0
	  if ( style.display &#x3D;&#x3D; &#x27;none&#x27; ) {
	    return getZeroSize();
	  }

	  var size &#x3D; {};
	  size.width &#x3D; elem.offsetWidth;
	  size.height &#x3D; elem.offsetHeight;

	  var isBorderBox &#x3D; size.isBorderBox &#x3D; style.boxSizing &#x3D;&#x3D; &#x27;border-box&#x27;;

	  // get all measurements
	  for ( var i&#x3D;0; i &lt; measurementsLength; i++ ) {
	    var measurement &#x3D; measurements[i];
	    var value &#x3D; style[ measurement ];
	    var num &#x3D; parseFloat( value );
	    // any &#x27;auto&#x27;, &#x27;medium&#x27; value will be 0
	    size[ measurement ] &#x3D; !isNaN( num ) ? num : 0;
	  }

	  var paddingWidth &#x3D; size.paddingLeft + size.paddingRight;
	  var paddingHeight &#x3D; size.paddingTop + size.paddingBottom;
	  var marginWidth &#x3D; size.marginLeft + size.marginRight;
	  var marginHeight &#x3D; size.marginTop + size.marginBottom;
	  var borderWidth &#x3D; size.borderLeftWidth + size.borderRightWidth;
	  var borderHeight &#x3D; size.borderTopWidth + size.borderBottomWidth;

	  var isBorderBoxSizeOuter &#x3D; isBorderBox &amp;&amp; isBoxSizeOuter;

	  // overwrite width and height if we can get it from style
	  var styleWidth &#x3D; getStyleSize( style.width );
	  if ( styleWidth !&#x3D;&#x3D; false ) {
	    size.width &#x3D; styleWidth +
	      // add padding and border unless it&#x27;s already including it
	      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
	  }

	  var styleHeight &#x3D; getStyleSize( style.height );
	  if ( styleHeight !&#x3D;&#x3D; false ) {
	    size.height &#x3D; styleHeight +
	      // add padding and border unless it&#x27;s already including it
	      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
	  }

	  size.innerWidth &#x3D; size.width - ( paddingWidth + borderWidth );
	  size.innerHeight &#x3D; size.height - ( paddingHeight + borderHeight );

	  size.outerWidth &#x3D; size.width + marginWidth;
	  size.outerHeight &#x3D; size.height + marginHeight;

	  return size;
	}

	return getSize;

	});


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Fizzy UI utils v2.0.7
	 * MIT license
	 */

	/*jshint browser: true, undef: true, unused: true, strict: true */

	( function( window, factory ) {
	  // universal module definition
	  /*jshint strict: false */ /*globals define, module, require */

	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [
	      __webpack_require__(24)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; function( matchesSelector ) {
	      return factory( window, matchesSelector );
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports &#x3D; factory(
	      window,
	      require(&#x27;desandro-matches-selector&#x27;)
	    );
	  } else {
	    // browser global
	    window.fizzyUIUtils &#x3D; factory(
	      window,
	      window.matchesSelector
	    );
	  }

	}( window, function factory( window, matchesSelector ) {

	&#x27;use strict&#x27;;

	var utils &#x3D; {};

	// ----- extend ----- //

	// extends objects
	utils.extend &#x3D; function( a, b ) {
	  for ( var prop in b ) {
	    a[ prop ] &#x3D; b[ prop ];
	  }
	  return a;
	};

	// ----- modulo ----- //

	utils.modulo &#x3D; function( num, div ) {
	  return ( ( num % div ) + div ) % div;
	};

	// ----- makeArray ----- //

	var arraySlice &#x3D; Array.prototype.slice;

	// turn element or nodeList into an array
	utils.makeArray &#x3D; function( obj ) {
	  if ( Array.isArray( obj ) ) {
	    // use object if already an array
	    return obj;
	  }
	  // return empty array if undefined or null. #6
	  if ( obj &#x3D;&#x3D;&#x3D; null || obj &#x3D;&#x3D;&#x3D; undefined ) {
	    return [];
	  }

	  var isArrayLike &#x3D; typeof obj &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; typeof obj.length &#x3D;&#x3D; &#x27;number&#x27;;
	  if ( isArrayLike ) {
	    // convert nodeList to array
	    return arraySlice.call( obj );
	  }

	  // array of single index
	  return [ obj ];
	};

	// ----- removeFrom ----- //

	utils.removeFrom &#x3D; function( ary, obj ) {
	  var index &#x3D; ary.indexOf( obj );
	  if ( index !&#x3D; -1 ) {
	    ary.splice( index, 1 );
	  }
	};

	// ----- getParent ----- //

	utils.getParent &#x3D; function( elem, selector ) {
	  while ( elem.parentNode &amp;&amp; elem !&#x3D; document.body ) {
	    elem &#x3D; elem.parentNode;
	    if ( matchesSelector( elem, selector ) ) {
	      return elem;
	    }
	  }
	};

	// ----- getQueryElement ----- //

	// use element as selector string
	utils.getQueryElement &#x3D; function( elem ) {
	  if ( typeof elem &#x3D;&#x3D; &#x27;string&#x27; ) {
	    return document.querySelector( elem );
	  }
	  return elem;
	};

	// ----- handleEvent ----- //

	// enable .ontype to trigger from .addEventListener( elem, &#x27;type&#x27; )
	utils.handleEvent &#x3D; function( event ) {
	  var method &#x3D; &#x27;on&#x27; + event.type;
	  if ( this[ method ] ) {
	    this[ method ]( event );
	  }
	};

	// ----- filterFindElements ----- //

	utils.filterFindElements &#x3D; function( elems, selector ) {
	  // make array of elems
	  elems &#x3D; utils.makeArray( elems );
	  var ffElems &#x3D; [];

	  elems.forEach( function( elem ) {
	    // check that elem is an actual element
	    if ( !( elem instanceof HTMLElement ) ) {
	      return;
	    }
	    // add elem if no selector
	    if ( !selector ) {
	      ffElems.push( elem );
	      return;
	    }
	    // filter &amp; find items if we have a selector
	    // filter
	    if ( matchesSelector( elem, selector ) ) {
	      ffElems.push( elem );
	    }
	    // find children
	    var childElems &#x3D; elem.querySelectorAll( selector );
	    // concat childElems to filterFound array
	    for ( var i&#x3D;0; i &lt; childElems.length; i++ ) {
	      ffElems.push( childElems[i] );
	    }
	  });

	  return ffElems;
	};

	// ----- debounceMethod ----- //

	utils.debounceMethod &#x3D; function( _class, methodName, threshold ) {
	  threshold &#x3D; threshold || 100;
	  // original method
	  var method &#x3D; _class.prototype[ methodName ];
	  var timeoutName &#x3D; methodName + &#x27;Timeout&#x27;;

	  _class.prototype[ methodName ] &#x3D; function() {
	    var timeout &#x3D; this[ timeoutName ];
	    clearTimeout( timeout );

	    var args &#x3D; arguments;
	    var _this &#x3D; this;
	    this[ timeoutName ] &#x3D; setTimeout( function() {
	      method.apply( _this, args );
	      delete _this[ timeoutName ];
	    }, threshold );
	  };
	};

	// ----- docReady ----- //

	utils.docReady &#x3D; function( callback ) {
	  var readyState &#x3D; document.readyState;
	  if ( readyState &#x3D;&#x3D; &#x27;complete&#x27; || readyState &#x3D;&#x3D; &#x27;interactive&#x27; ) {
	    // do async to allow for other scripts to run. metafizzy/flickity#441
	    setTimeout( callback );
	  } else {
	    document.addEventListener( &#x27;DOMContentLoaded&#x27;, callback );
	  }
	};

	// ----- htmlInit ----- //

	// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
	utils.toDashed &#x3D; function( str ) {
	  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
	    return $1 + &#x27;-&#x27; + $2;
	  }).toLowerCase();
	};

	var console &#x3D; window.console;
	/**
	 * allow user to initialize classes via [data-namespace] or .js-namespace class
	 * htmlInit( Widget, &#x27;widgetName&#x27; )
	 * options are parsed from data-namespace-options
	 */
	utils.htmlInit &#x3D; function( WidgetClass, namespace ) {
	  utils.docReady( function() {
	    var dashedNamespace &#x3D; utils.toDashed( namespace );
	    var dataAttr &#x3D; &#x27;data-&#x27; + dashedNamespace;
	    var dataAttrElems &#x3D; document.querySelectorAll( &#x27;[&#x27; + dataAttr + &#x27;]&#x27; );
	    var jsDashElems &#x3D; document.querySelectorAll( &#x27;.js-&#x27; + dashedNamespace );
	    var elems &#x3D; utils.makeArray( dataAttrElems )
	      .concat( utils.makeArray( jsDashElems ) );
	    var dataOptionsAttr &#x3D; dataAttr + &#x27;-options&#x27;;
	    var jQuery &#x3D; window.jQuery;

	    elems.forEach( function( elem ) {
	      var attr &#x3D; elem.getAttribute( dataAttr ) ||
	        elem.getAttribute( dataOptionsAttr );
	      var options;
	      try {
	        options &#x3D; attr &amp;&amp; JSON.parse( attr );
	      } catch ( error ) {
	        // log error, do not initialize
	        if ( console ) {
	          console.error( &#x27;Error parsing &#x27; + dataAttr + &#x27; on &#x27; + elem.className +
	          &#x27;: &#x27; + error );
	        }
	        return;
	      }
	      // initialize
	      var instance &#x3D; new WidgetClass( elem, options );
	      // make available via $().data(&#x27;namespace&#x27;)
	      if ( jQuery ) {
	        jQuery.data( elem, namespace, instance );
	      }
	    });

	  });
	};

	// -----  ----- //

	return utils;

	}));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * matchesSelector v2.0.2
	 * matchesSelector( element, &#x27;.selector&#x27; )
	 * MIT license
	 */

	/*jshint browser: true, strict: true, undef: true, unused: true */

	( function( window, factory ) {
	  /*global define: false, module: false */
	  &#x27;use strict&#x27;;
	  // universal module definition
	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (factory), __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS
	    module.exports &#x3D; factory();
	  } else {
	    // browser global
	    window.matchesSelector &#x3D; factory();
	  }

	}( window, function factory() {
	  &#x27;use strict&#x27;;

	  var matchesMethod &#x3D; ( function() {
	    var ElemProto &#x3D; window.Element.prototype;
	    // check for the standard method name first
	    if ( ElemProto.matches ) {
	      return &#x27;matches&#x27;;
	    }
	    // check un-prefixed
	    if ( ElemProto.matchesSelector ) {
	      return &#x27;matchesSelector&#x27;;
	    }
	    // check vendor prefixes
	    var prefixes &#x3D; [ &#x27;webkit&#x27;, &#x27;moz&#x27;, &#x27;ms&#x27;, &#x27;o&#x27; ];

	    for ( var i&#x3D;0; i &lt; prefixes.length; i++ ) {
	      var prefix &#x3D; prefixes[i];
	      var method &#x3D; prefix + &#x27;MatchesSelector&#x27;;
	      if ( ElemProto[ method ] ) {
	        return method;
	      }
	    }
	  })();

	  return function matchesSelector( elem, selector ) {
	    return elem[ matchesMethod ]( selector );
	  };

	}));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Outlayer Item
	 */

	( function( window, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, require */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [
	        __webpack_require__(21),
	        __webpack_require__(22)
	      ], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (factory), __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module &#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports &#x3D; factory(
	      require(&#x27;ev-emitter&#x27;),
	      require(&#x27;get-size&#x27;)
	    );
	  } else {
	    // browser global
	    window.Outlayer &#x3D; {};
	    window.Outlayer.Item &#x3D; factory(
	      window.EvEmitter,
	      window.getSize
	    );
	  }

	}( window, function factory( EvEmitter, getSize ) {
	&#x27;use strict&#x27;;

	// ----- helpers ----- //

	function isEmptyObj( obj ) {
	  for ( var prop in obj ) {
	    return false;
	  }
	  prop &#x3D; null;
	  return true;
	}

	// -------------------------- CSS3 support -------------------------- //


	var docElemStyle &#x3D; document.documentElement.style;

	var transitionProperty &#x3D; typeof docElemStyle.transition &#x3D;&#x3D; &#x27;string&#x27; ?
	  &#x27;transition&#x27; : &#x27;WebkitTransition&#x27;;
	var transformProperty &#x3D; typeof docElemStyle.transform &#x3D;&#x3D; &#x27;string&#x27; ?
	  &#x27;transform&#x27; : &#x27;WebkitTransform&#x27;;

	var transitionEndEvent &#x3D; {
	  WebkitTransition: &#x27;webkitTransitionEnd&#x27;,
	  transition: &#x27;transitionend&#x27;
	}[ transitionProperty ];

	// cache all vendor properties that could have vendor prefix
	var vendorProperties &#x3D; {
	  transform: transformProperty,
	  transition: transitionProperty,
	  transitionDuration: transitionProperty + &#x27;Duration&#x27;,
	  transitionProperty: transitionProperty + &#x27;Property&#x27;,
	  transitionDelay: transitionProperty + &#x27;Delay&#x27;
	};

	// -------------------------- Item -------------------------- //

	function Item( element, layout ) {
	  if ( !element ) {
	    return;
	  }

	  this.element &#x3D; element;
	  // parent layout class, i.e. Masonry, Isotope, or Packery
	  this.layout &#x3D; layout;
	  this.position &#x3D; {
	    x: 0,
	    y: 0
	  };

	  this._create();
	}

	// inherit EvEmitter
	var proto &#x3D; Item.prototype &#x3D; Object.create( EvEmitter.prototype );
	proto.constructor &#x3D; Item;

	proto._create &#x3D; function() {
	  // transition objects
	  this._transn &#x3D; {
	    ingProperties: {},
	    clean: {},
	    onEnd: {}
	  };

	  this.css({
	    position: &#x27;absolute&#x27;
	  });
	};

	// trigger specified handler for event type
	proto.handleEvent &#x3D; function( event ) {
	  var method &#x3D; &#x27;on&#x27; + event.type;
	  if ( this[ method ] ) {
	    this[ method ]( event );
	  }
	};

	proto.getSize &#x3D; function() {
	  this.size &#x3D; getSize( this.element );
	};

	/**
	 * apply CSS styles to element
	 * @param {Object} style
	 */
	proto.css &#x3D; function( style ) {
	  var elemStyle &#x3D; this.element.style;

	  for ( var prop in style ) {
	    // use vendor property if available
	    var supportedProp &#x3D; vendorProperties[ prop ] || prop;
	    elemStyle[ supportedProp ] &#x3D; style[ prop ];
	  }
	};

	 // measure position, and sets it
	proto.getPosition &#x3D; function() {
	  var style &#x3D; getComputedStyle( this.element );
	  var isOriginLeft &#x3D; this.layout._getOption(&#x27;originLeft&#x27;);
	  var isOriginTop &#x3D; this.layout._getOption(&#x27;originTop&#x27;);
	  var xValue &#x3D; style[ isOriginLeft ? &#x27;left&#x27; : &#x27;right&#x27; ];
	  var yValue &#x3D; style[ isOriginTop ? &#x27;top&#x27; : &#x27;bottom&#x27; ];
	  var x &#x3D; parseFloat( xValue );
	  var y &#x3D; parseFloat( yValue );
	  // convert percent to pixels
	  var layoutSize &#x3D; this.layout.size;
	  if ( xValue.indexOf(&#x27;%&#x27;) !&#x3D; -1 ) {
	    x &#x3D; ( x / 100 ) * layoutSize.width;
	  }
	  if ( yValue.indexOf(&#x27;%&#x27;) !&#x3D; -1 ) {
	    y &#x3D; ( y / 100 ) * layoutSize.height;
	  }
	  // clean up &#x27;auto&#x27; or other non-integer values
	  x &#x3D; isNaN( x ) ? 0 : x;
	  y &#x3D; isNaN( y ) ? 0 : y;
	  // remove padding from measurement
	  x -&#x3D; isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
	  y -&#x3D; isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

	  this.position.x &#x3D; x;
	  this.position.y &#x3D; y;
	};

	// set settled position, apply padding
	proto.layoutPosition &#x3D; function() {
	  var layoutSize &#x3D; this.layout.size;
	  var style &#x3D; {};
	  var isOriginLeft &#x3D; this.layout._getOption(&#x27;originLeft&#x27;);
	  var isOriginTop &#x3D; this.layout._getOption(&#x27;originTop&#x27;);

	  // x
	  var xPadding &#x3D; isOriginLeft ? &#x27;paddingLeft&#x27; : &#x27;paddingRight&#x27;;
	  var xProperty &#x3D; isOriginLeft ? &#x27;left&#x27; : &#x27;right&#x27;;
	  var xResetProperty &#x3D; isOriginLeft ? &#x27;right&#x27; : &#x27;left&#x27;;

	  var x &#x3D; this.position.x + layoutSize[ xPadding ];
	  // set in percentage or pixels
	  style[ xProperty ] &#x3D; this.getXValue( x );
	  // reset other property
	  style[ xResetProperty ] &#x3D; &#x27;&#x27;;

	  // y
	  var yPadding &#x3D; isOriginTop ? &#x27;paddingTop&#x27; : &#x27;paddingBottom&#x27;;
	  var yProperty &#x3D; isOriginTop ? &#x27;top&#x27; : &#x27;bottom&#x27;;
	  var yResetProperty &#x3D; isOriginTop ? &#x27;bottom&#x27; : &#x27;top&#x27;;

	  var y &#x3D; this.position.y + layoutSize[ yPadding ];
	  // set in percentage or pixels
	  style[ yProperty ] &#x3D; this.getYValue( y );
	  // reset other property
	  style[ yResetProperty ] &#x3D; &#x27;&#x27;;

	  this.css( style );
	  this.emitEvent( &#x27;layout&#x27;, [ this ] );
	};

	proto.getXValue &#x3D; function( x ) {
	  var isHorizontal &#x3D; this.layout._getOption(&#x27;horizontal&#x27;);
	  return this.layout.options.percentPosition &amp;&amp; !isHorizontal ?
	    ( ( x / this.layout.size.width ) * 100 ) + &#x27;%&#x27; : x + &#x27;px&#x27;;
	};

	proto.getYValue &#x3D; function( y ) {
	  var isHorizontal &#x3D; this.layout._getOption(&#x27;horizontal&#x27;);
	  return this.layout.options.percentPosition &amp;&amp; isHorizontal ?
	    ( ( y / this.layout.size.height ) * 100 ) + &#x27;%&#x27; : y + &#x27;px&#x27;;
	};

	proto._transitionTo &#x3D; function( x, y ) {
	  this.getPosition();
	  // get current x &amp; y from top/left
	  var curX &#x3D; this.position.x;
	  var curY &#x3D; this.position.y;

	  var didNotMove &#x3D; x &#x3D;&#x3D; this.position.x &amp;&amp; y &#x3D;&#x3D; this.position.y;

	  // save end position
	  this.setPosition( x, y );

	  // if did not move and not transitioning, just go to layout
	  if ( didNotMove &amp;&amp; !this.isTransitioning ) {
	    this.layoutPosition();
	    return;
	  }

	  var transX &#x3D; x - curX;
	  var transY &#x3D; y - curY;
	  var transitionStyle &#x3D; {};
	  transitionStyle.transform &#x3D; this.getTranslate( transX, transY );

	  this.transition({
	    to: transitionStyle,
	    onTransitionEnd: {
	      transform: this.layoutPosition
	    },
	    isCleaning: true
	  });
	};

	proto.getTranslate &#x3D; function( x, y ) {
	  // flip cooridinates if origin on right or bottom
	  var isOriginLeft &#x3D; this.layout._getOption(&#x27;originLeft&#x27;);
	  var isOriginTop &#x3D; this.layout._getOption(&#x27;originTop&#x27;);
	  x &#x3D; isOriginLeft ? x : -x;
	  y &#x3D; isOriginTop ? y : -y;
	  return &#x27;translate3d(&#x27; + x + &#x27;px, &#x27; + y + &#x27;px, 0)&#x27;;
	};

	// non transition + transform support
	proto.goTo &#x3D; function( x, y ) {
	  this.setPosition( x, y );
	  this.layoutPosition();
	};

	proto.moveTo &#x3D; proto._transitionTo;

	proto.setPosition &#x3D; function( x, y ) {
	  this.position.x &#x3D; parseFloat( x );
	  this.position.y &#x3D; parseFloat( y );
	};

	// ----- transition ----- //

	/**
	 * @param {Object} style - CSS
	 * @param {Function} onTransitionEnd
	 */

	// non transition, just trigger callback
	proto._nonTransition &#x3D; function( args ) {
	  this.css( args.to );
	  if ( args.isCleaning ) {
	    this._removeStyles( args.to );
	  }
	  for ( var prop in args.onTransitionEnd ) {
	    args.onTransitionEnd[ prop ].call( this );
	  }
	};

	/**
	 * proper transition
	 * @param {Object} args - arguments
	 *   @param {Object} to - style to transition to
	 *   @param {Object} from - style to start transition from
	 *   @param {Boolean} isCleaning - removes transition styles after transition
	 *   @param {Function} onTransitionEnd - callback
	 */
	proto.transition &#x3D; function( args ) {
	  // redirect to nonTransition if no transition duration
	  if ( !parseFloat( this.layout.options.transitionDuration ) ) {
	    this._nonTransition( args );
	    return;
	  }

	  var _transition &#x3D; this._transn;
	  // keep track of onTransitionEnd callback by css property
	  for ( var prop in args.onTransitionEnd ) {
	    _transition.onEnd[ prop ] &#x3D; args.onTransitionEnd[ prop ];
	  }
	  // keep track of properties that are transitioning
	  for ( prop in args.to ) {
	    _transition.ingProperties[ prop ] &#x3D; true;
	    // keep track of properties to clean up when transition is done
	    if ( args.isCleaning ) {
	      _transition.clean[ prop ] &#x3D; true;
	    }
	  }

	  // set from styles
	  if ( args.from ) {
	    this.css( args.from );
	    // force redraw. http://blog.alexmaccaw.com/css-transitions
	    var h &#x3D; this.element.offsetHeight;
	    // hack for JSHint to hush about unused var
	    h &#x3D; null;
	  }
	  // enable transition
	  this.enableTransition( args.to );
	  // set styles that are transitioning
	  this.css( args.to );

	  this.isTransitioning &#x3D; true;

	};

	// dash before all cap letters, including first for
	// WebkitTransform &#x3D;&gt; -webkit-transform
	function toDashedAll( str ) {
	  return str.replace( /([A-Z])/g, function( $1 ) {
	    return &#x27;-&#x27; + $1.toLowerCase();
	  });
	}

	var transitionProps &#x3D; &#x27;opacity,&#x27; + toDashedAll( transformProperty );

	proto.enableTransition &#x3D; function(/* style */) {
	  // HACK changing transitionProperty during a transition
	  // will cause transition to jump
	  if ( this.isTransitioning ) {
	    return;
	  }

	  // make &#x60;transition: foo, bar, baz&#x60; from style object
	  // HACK un-comment this when enableTransition can work
	  // while a transition is happening
	  // var transitionValues &#x3D; [];
	  // for ( var prop in style ) {
	  //   // dash-ify camelCased properties like WebkitTransition
	  //   prop &#x3D; vendorProperties[ prop ] || prop;
	  //   transitionValues.push( toDashedAll( prop ) );
	  // }
	  // munge number to millisecond, to match stagger
	  var duration &#x3D; this.layout.options.transitionDuration;
	  duration &#x3D; typeof duration &#x3D;&#x3D; &#x27;number&#x27; ? duration + &#x27;ms&#x27; : duration;
	  // enable transition styles
	  this.css({
	    transitionProperty: transitionProps,
	    transitionDuration: duration,
	    transitionDelay: this.staggerDelay || 0
	  });
	  // listen for transition end event
	  this.element.addEventListener( transitionEndEvent, this, false );
	};

	// ----- events ----- //

	proto.onwebkitTransitionEnd &#x3D; function( event ) {
	  this.ontransitionend( event );
	};

	proto.onotransitionend &#x3D; function( event ) {
	  this.ontransitionend( event );
	};

	// properties that I munge to make my life easier
	var dashedVendorProperties &#x3D; {
	  &#x27;-webkit-transform&#x27;: &#x27;transform&#x27;
	};

	proto.ontransitionend &#x3D; function( event ) {
	  // disregard bubbled events from children
	  if ( event.target !&#x3D;&#x3D; this.element ) {
	    return;
	  }
	  var _transition &#x3D; this._transn;
	  // get property name of transitioned property, convert to prefix-free
	  var propertyName &#x3D; dashedVendorProperties[ event.propertyName ] || event.propertyName;

	  // remove property that has completed transitioning
	  delete _transition.ingProperties[ propertyName ];
	  // check if any properties are still transitioning
	  if ( isEmptyObj( _transition.ingProperties ) ) {
	    // all properties have completed transitioning
	    this.disableTransition();
	  }
	  // clean style
	  if ( propertyName in _transition.clean ) {
	    // clean up style
	    this.element.style[ event.propertyName ] &#x3D; &#x27;&#x27;;
	    delete _transition.clean[ propertyName ];
	  }
	  // trigger onTransitionEnd callback
	  if ( propertyName in _transition.onEnd ) {
	    var onTransitionEnd &#x3D; _transition.onEnd[ propertyName ];
	    onTransitionEnd.call( this );
	    delete _transition.onEnd[ propertyName ];
	  }

	  this.emitEvent( &#x27;transitionEnd&#x27;, [ this ] );
	};

	proto.disableTransition &#x3D; function() {
	  this.removeTransitionStyles();
	  this.element.removeEventListener( transitionEndEvent, this, false );
	  this.isTransitioning &#x3D; false;
	};

	/**
	 * removes style property from element
	 * @param {Object} style
	**/
	proto._removeStyles &#x3D; function( style ) {
	  // clean up transition styles
	  var cleanStyle &#x3D; {};
	  for ( var prop in style ) {
	    cleanStyle[ prop ] &#x3D; &#x27;&#x27;;
	  }
	  this.css( cleanStyle );
	};

	var cleanTransitionStyle &#x3D; {
	  transitionProperty: &#x27;&#x27;,
	  transitionDuration: &#x27;&#x27;,
	  transitionDelay: &#x27;&#x27;
	};

	proto.removeTransitionStyles &#x3D; function() {
	  // remove transition
	  this.css( cleanTransitionStyle );
	};

	// ----- stagger ----- //

	proto.stagger &#x3D; function( delay ) {
	  delay &#x3D; isNaN( delay ) ? 0 : delay;
	  this.staggerDelay &#x3D; delay + &#x27;ms&#x27;;
	};

	// ----- show/hide/remove ----- //

	// remove element from DOM
	proto.removeElem &#x3D; function() {
	  this.element.parentNode.removeChild( this.element );
	  // remove display: none
	  this.css({ display: &#x27;&#x27; });
	  this.emitEvent( &#x27;remove&#x27;, [ this ] );
	};

	proto.remove &#x3D; function() {
	  // just remove element if no transition support or no transition
	  if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
	    this.removeElem();
	    return;
	  }

	  // start transition
	  this.once( &#x27;transitionEnd&#x27;, function() {
	    this.removeElem();
	  });
	  this.hide();
	};

	proto.reveal &#x3D; function() {
	  delete this.isHidden;
	  // remove display: none
	  this.css({ display: &#x27;&#x27; });

	  var options &#x3D; this.layout.options;

	  var onTransitionEnd &#x3D; {};
	  var transitionEndProperty &#x3D; this.getHideRevealTransitionEndProperty(&#x27;visibleStyle&#x27;);
	  onTransitionEnd[ transitionEndProperty ] &#x3D; this.onRevealTransitionEnd;

	  this.transition({
	    from: options.hiddenStyle,
	    to: options.visibleStyle,
	    isCleaning: true,
	    onTransitionEnd: onTransitionEnd
	  });
	};

	proto.onRevealTransitionEnd &#x3D; function() {
	  // check if still visible
	  // during transition, item may have been hidden
	  if ( !this.isHidden ) {
	    this.emitEvent(&#x27;reveal&#x27;);
	  }
	};

	/**
	 * get style property use for hide/reveal transition end
	 * @param {String} styleProperty - hiddenStyle/visibleStyle
	 * @returns {String}
	 */
	proto.getHideRevealTransitionEndProperty &#x3D; function( styleProperty ) {
	  var optionStyle &#x3D; this.layout.options[ styleProperty ];
	  // use opacity
	  if ( optionStyle.opacity ) {
	    return &#x27;opacity&#x27;;
	  }
	  // get first property
	  for ( var prop in optionStyle ) {
	    return prop;
	  }
	};

	proto.hide &#x3D; function() {
	  // set flag
	  this.isHidden &#x3D; true;
	  // remove display: none
	  this.css({ display: &#x27;&#x27; });

	  var options &#x3D; this.layout.options;

	  var onTransitionEnd &#x3D; {};
	  var transitionEndProperty &#x3D; this.getHideRevealTransitionEndProperty(&#x27;hiddenStyle&#x27;);
	  onTransitionEnd[ transitionEndProperty ] &#x3D; this.onHideTransitionEnd;

	  this.transition({
	    from: options.visibleStyle,
	    to: options.hiddenStyle,
	    // keep hidden stuff hidden
	    isCleaning: true,
	    onTransitionEnd: onTransitionEnd
	  });
	};

	proto.onHideTransitionEnd &#x3D; function() {
	  // check if still hidden
	  // during transition, item may have been un-hidden
	  if ( this.isHidden ) {
	    this.css({ display: &#x27;none&#x27; });
	    this.emitEvent(&#x27;hide&#x27;);
	  }
	};

	proto.destroy &#x3D; function() {
	  this.css({
	    position: &#x27;&#x27;,
	    left: &#x27;&#x27;,
	    right: &#x27;&#x27;,
	    top: &#x27;&#x27;,
	    bottom: &#x27;&#x27;,
	    transition: &#x27;&#x27;,
	    transform: &#x27;&#x27;
	  });
	};

	return Item;

	}));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_1__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_2__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_3__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_8__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_9__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_10__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_11__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_12__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Isotope PACKAGED v3.0.3
	 *
	 * Licensed GPLv3 for open source use
	 * or Isotope Commercial License for commercial use
	 *
	 * http://isotope.metafizzy.co
	 * Copyright 2017 Metafizzy
	 */

	!function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; function(i){return e(t,i)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(t,require(&quot;jquery&quot;)):t.jQueryBridget&#x3D;e(t,t.jQuery)}(window,function(t,e){&quot;use strict&quot;;function i(i,s,a){function u(t,e,n){var o,s&#x3D;&quot;$().&quot;+i+&#x27;(&quot;&#x27;+e+&#x27;&quot;)&#x27;;return t.each(function(t,u){var h&#x3D;a.data(u,i);if(!h)return void r(i+&quot; not initialized. Cannot call methods, i.e. &quot;+s);var d&#x3D;h[e];if(!d||&quot;_&quot;&#x3D;&#x3D;e.charAt(0))return void r(s+&quot; is not a valid method&quot;);var l&#x3D;d.apply(h,n);o&#x3D;void 0&#x3D;&#x3D;&#x3D;o?l:o}),void 0!&#x3D;&#x3D;o?o:t}function h(t,e){t.each(function(t,n){var o&#x3D;a.data(n,i);o?(o.option(e),o._init()):(o&#x3D;new s(n,e),a.data(n,i,o))})}a&#x3D;a||e||t.jQuery,a&amp;&amp;(s.prototype.option||(s.prototype.option&#x3D;function(t){a.isPlainObject(t)&amp;&amp;(this.options&#x3D;a.extend(!0,this.options,t))}),a.fn[i]&#x3D;function(t){if(&quot;string&quot;&#x3D;&#x3D;typeof t){var e&#x3D;o.call(arguments,1);return u(this,t,e)}return h(this,t),this},n(a))}function n(t){!t||t&amp;&amp;t.bridget||(t.bridget&#x3D;i)}var o&#x3D;Array.prototype.slice,s&#x3D;t.console,r&#x3D;&quot;undefined&quot;&#x3D;&#x3D;typeof s?function(){}:function(t){s.error(t)};return n(e||t.jQuery),i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_1__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e():t.EvEmitter&#x3D;e()}(&quot;undefined&quot;!&#x3D;typeof window?window:this,function(){function t(){}var e&#x3D;t.prototype;return e.on&#x3D;function(t,e){if(t&amp;&amp;e){var i&#x3D;this._events&#x3D;this._events||{},n&#x3D;i[t]&#x3D;i[t]||[];return n.indexOf(e)&#x3D;&#x3D;-1&amp;&amp;n.push(e),this}},e.once&#x3D;function(t,e){if(t&amp;&amp;e){this.on(t,e);var i&#x3D;this._onceEvents&#x3D;this._onceEvents||{},n&#x3D;i[t]&#x3D;i[t]||{};return n[e]&#x3D;!0,this}},e.off&#x3D;function(t,e){var i&#x3D;this._events&amp;&amp;this._events[t];if(i&amp;&amp;i.length){var n&#x3D;i.indexOf(e);return n!&#x3D;-1&amp;&amp;i.splice(n,1),this}},e.emitEvent&#x3D;function(t,e){var i&#x3D;this._events&amp;&amp;this._events[t];if(i&amp;&amp;i.length){var n&#x3D;0,o&#x3D;i[n];e&#x3D;e||[];for(var s&#x3D;this._onceEvents&amp;&amp;this._onceEvents[t];o;){var r&#x3D;s&amp;&amp;s[o];r&amp;&amp;(this.off(t,o),delete s[o]),o.apply(this,e),n+&#x3D;r?0:1,o&#x3D;i[n]}return this}},t}),function(t,e){&quot;use strict&quot;; true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [], __WEBPACK_LOCAL_MODULE_2__ &#x3D; (function(){return e()}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e():t.getSize&#x3D;e()}(window,function(){&quot;use strict&quot;;function t(t){var e&#x3D;parseFloat(t),i&#x3D;t.indexOf(&quot;%&quot;)&#x3D;&#x3D;-1&amp;&amp;!isNaN(e);return i&amp;&amp;e}function e(){}function i(){for(var t&#x3D;{width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},e&#x3D;0;e&lt;h;e++){var i&#x3D;u[e];t[i]&#x3D;0}return t}function n(t){var e&#x3D;getComputedStyle(t);return e||a(&quot;Style returned &quot;+e+&quot;. Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1&quot;),e}function o(){if(!d){d&#x3D;!0;var e&#x3D;document.createElement(&quot;div&quot;);e.style.width&#x3D;&quot;200px&quot;,e.style.padding&#x3D;&quot;1px 2px 3px 4px&quot;,e.style.borderStyle&#x3D;&quot;solid&quot;,e.style.borderWidth&#x3D;&quot;1px 2px 3px 4px&quot;,e.style.boxSizing&#x3D;&quot;border-box&quot;;var i&#x3D;document.body||document.documentElement;i.appendChild(e);var o&#x3D;n(e);s.isBoxSizeOuter&#x3D;r&#x3D;200&#x3D;&#x3D;t(o.width),i.removeChild(e)}}function s(e){if(o(),&quot;string&quot;&#x3D;&#x3D;typeof e&amp;&amp;(e&#x3D;document.querySelector(e)),e&amp;&amp;&quot;object&quot;&#x3D;&#x3D;typeof e&amp;&amp;e.nodeType){var s&#x3D;n(e);if(&quot;none&quot;&#x3D;&#x3D;s.display)return i();var a&#x3D;{};a.width&#x3D;e.offsetWidth,a.height&#x3D;e.offsetHeight;for(var d&#x3D;a.isBorderBox&#x3D;&quot;border-box&quot;&#x3D;&#x3D;s.boxSizing,l&#x3D;0;l&lt;h;l++){var f&#x3D;u[l],m&#x3D;s[f],c&#x3D;parseFloat(m);a[f]&#x3D;isNaN(c)?0:c}var p&#x3D;a.paddingLeft+a.paddingRight,y&#x3D;a.paddingTop+a.paddingBottom,g&#x3D;a.marginLeft+a.marginRight,v&#x3D;a.marginTop+a.marginBottom,_&#x3D;a.borderLeftWidth+a.borderRightWidth,I&#x3D;a.borderTopWidth+a.borderBottomWidth,z&#x3D;d&amp;&amp;r,S&#x3D;t(s.width);S!&#x3D;&#x3D;!1&amp;&amp;(a.width&#x3D;S+(z?0:p+_));var x&#x3D;t(s.height);return x!&#x3D;&#x3D;!1&amp;&amp;(a.height&#x3D;x+(z?0:y+I)),a.innerWidth&#x3D;a.width-(p+_),a.innerHeight&#x3D;a.height-(y+I),a.outerWidth&#x3D;a.width+g,a.outerHeight&#x3D;a.height+v,a}}var r,a&#x3D;&quot;undefined&quot;&#x3D;&#x3D;typeof console?e:function(t){console.error(t)},u&#x3D;[&quot;paddingLeft&quot;,&quot;paddingRight&quot;,&quot;paddingTop&quot;,&quot;paddingBottom&quot;,&quot;marginLeft&quot;,&quot;marginRight&quot;,&quot;marginTop&quot;,&quot;marginBottom&quot;,&quot;borderLeftWidth&quot;,&quot;borderRightWidth&quot;,&quot;borderTopWidth&quot;,&quot;borderBottomWidth&quot;],h&#x3D;u.length,d&#x3D;!1;return s}),function(t,e){&quot;use strict&quot;; true?!(__WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_3__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e():t.matchesSelector&#x3D;e()}(window,function(){&quot;use strict&quot;;var t&#x3D;function(){var t&#x3D;window.Element.prototype;if(t.matches)return&quot;matches&quot;;if(t.matchesSelector)return&quot;matchesSelector&quot;;for(var e&#x3D;[&quot;webkit&quot;,&quot;moz&quot;,&quot;ms&quot;,&quot;o&quot;],i&#x3D;0;i&lt;e.length;i++){var n&#x3D;e[i],o&#x3D;n+&quot;MatchesSelector&quot;;if(t[o])return o}}();return function(e,i){return e[t](i)}}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_3__], __WEBPACK_LOCAL_MODULE_4__ &#x3D; (function(i){return e(t,i)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(t,require(&quot;desandro-matches-selector&quot;)):t.fizzyUIUtils&#x3D;e(t,t.matchesSelector)}(window,function(t,e){var i&#x3D;{};i.extend&#x3D;function(t,e){for(var i in e)t[i]&#x3D;e[i];return t},i.modulo&#x3D;function(t,e){return(t%e+e)%e},i.makeArray&#x3D;function(t){var e&#x3D;[];if(Array.isArray(t))e&#x3D;t;else if(t&amp;&amp;&quot;object&quot;&#x3D;&#x3D;typeof t&amp;&amp;&quot;number&quot;&#x3D;&#x3D;typeof t.length)for(var i&#x3D;0;i&lt;t.length;i++)e.push(t[i]);else e.push(t);return e},i.removeFrom&#x3D;function(t,e){var i&#x3D;t.indexOf(e);i!&#x3D;-1&amp;&amp;t.splice(i,1)},i.getParent&#x3D;function(t,i){for(;t!&#x3D;document.body;)if(t&#x3D;t.parentNode,e(t,i))return t},i.getQueryElement&#x3D;function(t){return&quot;string&quot;&#x3D;&#x3D;typeof t?document.querySelector(t):t},i.handleEvent&#x3D;function(t){var e&#x3D;&quot;on&quot;+t.type;this[e]&amp;&amp;this[e](t)},i.filterFindElements&#x3D;function(t,n){t&#x3D;i.makeArray(t);var o&#x3D;[];return t.forEach(function(t){if(t instanceof HTMLElement){if(!n)return void o.push(t);e(t,n)&amp;&amp;o.push(t);for(var i&#x3D;t.querySelectorAll(n),s&#x3D;0;s&lt;i.length;s++)o.push(i[s])}}),o},i.debounceMethod&#x3D;function(t,e,i){var n&#x3D;t.prototype[e],o&#x3D;e+&quot;Timeout&quot;;t.prototype[e]&#x3D;function(){var t&#x3D;this[o];t&amp;&amp;clearTimeout(t);var e&#x3D;arguments,s&#x3D;this;this[o]&#x3D;setTimeout(function(){n.apply(s,e),delete s[o]},i||100)}},i.docReady&#x3D;function(t){var e&#x3D;document.readyState;&quot;complete&quot;&#x3D;&#x3D;e||&quot;interactive&quot;&#x3D;&#x3D;e?setTimeout(t):document.addEventListener(&quot;DOMContentLoaded&quot;,t)},i.toDashed&#x3D;function(t){return t.replace(/(.)([A-Z])/g,function(t,e,i){return e+&quot;-&quot;+i}).toLowerCase()};var n&#x3D;t.console;return i.htmlInit&#x3D;function(e,o){i.docReady(function(){var s&#x3D;i.toDashed(o),r&#x3D;&quot;data-&quot;+s,a&#x3D;document.querySelectorAll(&quot;[&quot;+r+&quot;]&quot;),u&#x3D;document.querySelectorAll(&quot;.js-&quot;+s),h&#x3D;i.makeArray(a).concat(i.makeArray(u)),d&#x3D;r+&quot;-options&quot;,l&#x3D;t.jQuery;h.forEach(function(t){var i,s&#x3D;t.getAttribute(r)||t.getAttribute(d);try{i&#x3D;s&amp;&amp;JSON.parse(s)}catch(a){return void(n&amp;&amp;n.error(&quot;Error parsing &quot;+r+&quot; on &quot;+t.className+&quot;: &quot;+a))}var u&#x3D;new e(t,i);l&amp;&amp;l.data(t,o,u)})})},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_1__,__WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_5__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(require(&quot;ev-emitter&quot;),require(&quot;get-size&quot;)):(t.Outlayer&#x3D;{},t.Outlayer.Item&#x3D;e(t.EvEmitter,t.getSize))}(window,function(t,e){&quot;use strict&quot;;function i(t){for(var e in t)return!1;return e&#x3D;null,!0}function n(t,e){t&amp;&amp;(this.element&#x3D;t,this.layout&#x3D;e,this.position&#x3D;{x:0,y:0},this._create())}function o(t){return t.replace(/([A-Z])/g,function(t){return&quot;-&quot;+t.toLowerCase()})}var s&#x3D;document.documentElement.style,r&#x3D;&quot;string&quot;&#x3D;&#x3D;typeof s.transition?&quot;transition&quot;:&quot;WebkitTransition&quot;,a&#x3D;&quot;string&quot;&#x3D;&#x3D;typeof s.transform?&quot;transform&quot;:&quot;WebkitTransform&quot;,u&#x3D;{WebkitTransition:&quot;webkitTransitionEnd&quot;,transition:&quot;transitionend&quot;}[r],h&#x3D;{transform:a,transition:r,transitionDuration:r+&quot;Duration&quot;,transitionProperty:r+&quot;Property&quot;,transitionDelay:r+&quot;Delay&quot;},d&#x3D;n.prototype&#x3D;Object.create(t.prototype);d.constructor&#x3D;n,d._create&#x3D;function(){this._transn&#x3D;{ingProperties:{},clean:{},onEnd:{}},this.css({position:&quot;absolute&quot;})},d.handleEvent&#x3D;function(t){var e&#x3D;&quot;on&quot;+t.type;this[e]&amp;&amp;this[e](t)},d.getSize&#x3D;function(){this.size&#x3D;e(this.element)},d.css&#x3D;function(t){var e&#x3D;this.element.style;for(var i in t){var n&#x3D;h[i]||i;e[n]&#x3D;t[i]}},d.getPosition&#x3D;function(){var t&#x3D;getComputedStyle(this.element),e&#x3D;this.layout._getOption(&quot;originLeft&quot;),i&#x3D;this.layout._getOption(&quot;originTop&quot;),n&#x3D;t[e?&quot;left&quot;:&quot;right&quot;],o&#x3D;t[i?&quot;top&quot;:&quot;bottom&quot;],s&#x3D;this.layout.size,r&#x3D;n.indexOf(&quot;%&quot;)!&#x3D;-1?parseFloat(n)/100*s.width:parseInt(n,10),a&#x3D;o.indexOf(&quot;%&quot;)!&#x3D;-1?parseFloat(o)/100*s.height:parseInt(o,10);r&#x3D;isNaN(r)?0:r,a&#x3D;isNaN(a)?0:a,r-&#x3D;e?s.paddingLeft:s.paddingRight,a-&#x3D;i?s.paddingTop:s.paddingBottom,this.position.x&#x3D;r,this.position.y&#x3D;a},d.layoutPosition&#x3D;function(){var t&#x3D;this.layout.size,e&#x3D;{},i&#x3D;this.layout._getOption(&quot;originLeft&quot;),n&#x3D;this.layout._getOption(&quot;originTop&quot;),o&#x3D;i?&quot;paddingLeft&quot;:&quot;paddingRight&quot;,s&#x3D;i?&quot;left&quot;:&quot;right&quot;,r&#x3D;i?&quot;right&quot;:&quot;left&quot;,a&#x3D;this.position.x+t[o];e[s]&#x3D;this.getXValue(a),e[r]&#x3D;&quot;&quot;;var u&#x3D;n?&quot;paddingTop&quot;:&quot;paddingBottom&quot;,h&#x3D;n?&quot;top&quot;:&quot;bottom&quot;,d&#x3D;n?&quot;bottom&quot;:&quot;top&quot;,l&#x3D;this.position.y+t[u];e[h]&#x3D;this.getYValue(l),e[d]&#x3D;&quot;&quot;,this.css(e),this.emitEvent(&quot;layout&quot;,[this])},d.getXValue&#x3D;function(t){var e&#x3D;this.layout._getOption(&quot;horizontal&quot;);return this.layout.options.percentPosition&amp;&amp;!e?t/this.layout.size.width*100+&quot;%&quot;:t+&quot;px&quot;},d.getYValue&#x3D;function(t){var e&#x3D;this.layout._getOption(&quot;horizontal&quot;);return this.layout.options.percentPosition&amp;&amp;e?t/this.layout.size.height*100+&quot;%&quot;:t+&quot;px&quot;},d._transitionTo&#x3D;function(t,e){this.getPosition();var i&#x3D;this.position.x,n&#x3D;this.position.y,o&#x3D;parseInt(t,10),s&#x3D;parseInt(e,10),r&#x3D;o&#x3D;&#x3D;&#x3D;this.position.x&amp;&amp;s&#x3D;&#x3D;&#x3D;this.position.y;if(this.setPosition(t,e),r&amp;&amp;!this.isTransitioning)return void this.layoutPosition();var a&#x3D;t-i,u&#x3D;e-n,h&#x3D;{};h.transform&#x3D;this.getTranslate(a,u),this.transition({to:h,onTransitionEnd:{transform:this.layoutPosition},isCleaning:!0})},d.getTranslate&#x3D;function(t,e){var i&#x3D;this.layout._getOption(&quot;originLeft&quot;),n&#x3D;this.layout._getOption(&quot;originTop&quot;);return t&#x3D;i?t:-t,e&#x3D;n?e:-e,&quot;translate3d(&quot;+t+&quot;px, &quot;+e+&quot;px, 0)&quot;},d.goTo&#x3D;function(t,e){this.setPosition(t,e),this.layoutPosition()},d.moveTo&#x3D;d._transitionTo,d.setPosition&#x3D;function(t,e){this.position.x&#x3D;parseInt(t,10),this.position.y&#x3D;parseInt(e,10)},d._nonTransition&#x3D;function(t){this.css(t.to),t.isCleaning&amp;&amp;this._removeStyles(t.to);for(var e in t.onTransitionEnd)t.onTransitionEnd[e].call(this)},d.transition&#x3D;function(t){if(!parseFloat(this.layout.options.transitionDuration))return void this._nonTransition(t);var e&#x3D;this._transn;for(var i in t.onTransitionEnd)e.onEnd[i]&#x3D;t.onTransitionEnd[i];for(i in t.to)e.ingProperties[i]&#x3D;!0,t.isCleaning&amp;&amp;(e.clean[i]&#x3D;!0);if(t.from){this.css(t.from);var n&#x3D;this.element.offsetHeight;n&#x3D;null}this.enableTransition(t.to),this.css(t.to),this.isTransitioning&#x3D;!0};var l&#x3D;&quot;opacity,&quot;+o(a);d.enableTransition&#x3D;function(){if(!this.isTransitioning){var t&#x3D;this.layout.options.transitionDuration;t&#x3D;&quot;number&quot;&#x3D;&#x3D;typeof t?t+&quot;ms&quot;:t,this.css({transitionProperty:l,transitionDuration:t,transitionDelay:this.staggerDelay||0}),this.element.addEventListener(u,this,!1)}},d.onwebkitTransitionEnd&#x3D;function(t){this.ontransitionend(t)},d.onotransitionend&#x3D;function(t){this.ontransitionend(t)};var f&#x3D;{&quot;-webkit-transform&quot;:&quot;transform&quot;};d.ontransitionend&#x3D;function(t){if(t.target&#x3D;&#x3D;&#x3D;this.element){var e&#x3D;this._transn,n&#x3D;f[t.propertyName]||t.propertyName;if(delete e.ingProperties[n],i(e.ingProperties)&amp;&amp;this.disableTransition(),n in e.clean&amp;&amp;(this.element.style[t.propertyName]&#x3D;&quot;&quot;,delete e.clean[n]),n in e.onEnd){var o&#x3D;e.onEnd[n];o.call(this),delete e.onEnd[n]}this.emitEvent(&quot;transitionEnd&quot;,[this])}},d.disableTransition&#x3D;function(){this.removeTransitionStyles(),this.element.removeEventListener(u,this,!1),this.isTransitioning&#x3D;!1},d._removeStyles&#x3D;function(t){var e&#x3D;{};for(var i in t)e[i]&#x3D;&quot;&quot;;this.css(e)};var m&#x3D;{transitionProperty:&quot;&quot;,transitionDuration:&quot;&quot;,transitionDelay:&quot;&quot;};return d.removeTransitionStyles&#x3D;function(){this.css(m)},d.stagger&#x3D;function(t){t&#x3D;isNaN(t)?0:t,this.staggerDelay&#x3D;t+&quot;ms&quot;},d.removeElem&#x3D;function(){this.element.parentNode.removeChild(this.element),this.css({display:&quot;&quot;}),this.emitEvent(&quot;remove&quot;,[this])},d.remove&#x3D;function(){return r&amp;&amp;parseFloat(this.layout.options.transitionDuration)?(this.once(&quot;transitionEnd&quot;,function(){this.removeElem()}),void this.hide()):void this.removeElem()},d.reveal&#x3D;function(){delete this.isHidden,this.css({display:&quot;&quot;});var t&#x3D;this.layout.options,e&#x3D;{},i&#x3D;this.getHideRevealTransitionEndProperty(&quot;visibleStyle&quot;);e[i]&#x3D;this.onRevealTransitionEnd,this.transition({from:t.hiddenStyle,to:t.visibleStyle,isCleaning:!0,onTransitionEnd:e})},d.onRevealTransitionEnd&#x3D;function(){this.isHidden||this.emitEvent(&quot;reveal&quot;)},d.getHideRevealTransitionEndProperty&#x3D;function(t){var e&#x3D;this.layout.options[t];if(e.opacity)return&quot;opacity&quot;;for(var i in e)return i},d.hide&#x3D;function(){this.isHidden&#x3D;!0,this.css({display:&quot;&quot;});var t&#x3D;this.layout.options,e&#x3D;{},i&#x3D;this.getHideRevealTransitionEndProperty(&quot;hiddenStyle&quot;);e[i]&#x3D;this.onHideTransitionEnd,this.transition({from:t.visibleStyle,to:t.hiddenStyle,isCleaning:!0,onTransitionEnd:e})},d.onHideTransitionEnd&#x3D;function(){this.isHidden&amp;&amp;(this.css({display:&quot;none&quot;}),this.emitEvent(&quot;hide&quot;))},d.destroy&#x3D;function(){this.css({position:&quot;&quot;,left:&quot;&quot;,right:&quot;&quot;,top:&quot;&quot;,bottom:&quot;&quot;,transition:&quot;&quot;,transform:&quot;&quot;})},n}),function(t,e){&quot;use strict&quot;; true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_1__,__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_4__,__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ &#x3D; (function(i,n,o,s){return e(t,i,n,o,s)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(t,require(&quot;ev-emitter&quot;),require(&quot;get-size&quot;),require(&quot;fizzy-ui-utils&quot;),require(&quot;./item&quot;)):t.Outlayer&#x3D;e(t,t.EvEmitter,t.getSize,t.fizzyUIUtils,t.Outlayer.Item)}(window,function(t,e,i,n,o){&quot;use strict&quot;;function s(t,e){var i&#x3D;n.getQueryElement(t);if(!i)return void(u&amp;&amp;u.error(&quot;Bad element for &quot;+this.constructor.namespace+&quot;: &quot;+(i||t)));this.element&#x3D;i,h&amp;&amp;(this.$element&#x3D;h(this.element)),this.options&#x3D;n.extend({},this.constructor.defaults),this.option(e);var o&#x3D;++l;this.element.outlayerGUID&#x3D;o,f[o]&#x3D;this,this._create();var s&#x3D;this._getOption(&quot;initLayout&quot;);s&amp;&amp;this.layout()}function r(t){function e(){t.apply(this,arguments)}return e.prototype&#x3D;Object.create(t.prototype),e.prototype.constructor&#x3D;e,e}function a(t){if(&quot;number&quot;&#x3D;&#x3D;typeof t)return t;var e&#x3D;t.match(/(^\d*\.?\d*)(\w*)/),i&#x3D;e&amp;&amp;e[1],n&#x3D;e&amp;&amp;e[2];if(!i.length)return 0;i&#x3D;parseFloat(i);var o&#x3D;c[n]||1;return i*o}var u&#x3D;t.console,h&#x3D;t.jQuery,d&#x3D;function(){},l&#x3D;0,f&#x3D;{};s.namespace&#x3D;&quot;outlayer&quot;,s.Item&#x3D;o,s.defaults&#x3D;{containerStyle:{position:&quot;relative&quot;},initLayout:!0,originLeft:!0,originTop:!0,resize:!0,resizeContainer:!0,transitionDuration:&quot;0.4s&quot;,hiddenStyle:{opacity:0,transform:&quot;scale(0.001)&quot;},visibleStyle:{opacity:1,transform:&quot;scale(1)&quot;}};var m&#x3D;s.prototype;n.extend(m,e.prototype),m.option&#x3D;function(t){n.extend(this.options,t)},m._getOption&#x3D;function(t){var e&#x3D;this.constructor.compatOptions[t];return e&amp;&amp;void 0!&#x3D;&#x3D;this.options[e]?this.options[e]:this.options[t]},s.compatOptions&#x3D;{initLayout:&quot;isInitLayout&quot;,horizontal:&quot;isHorizontal&quot;,layoutInstant:&quot;isLayoutInstant&quot;,originLeft:&quot;isOriginLeft&quot;,originTop:&quot;isOriginTop&quot;,resize:&quot;isResizeBound&quot;,resizeContainer:&quot;isResizingContainer&quot;},m._create&#x3D;function(){this.reloadItems(),this.stamps&#x3D;[],this.stamp(this.options.stamp),n.extend(this.element.style,this.options.containerStyle);var t&#x3D;this._getOption(&quot;resize&quot;);t&amp;&amp;this.bindResize()},m.reloadItems&#x3D;function(){this.items&#x3D;this._itemize(this.element.children)},m._itemize&#x3D;function(t){for(var e&#x3D;this._filterFindItemElements(t),i&#x3D;this.constructor.Item,n&#x3D;[],o&#x3D;0;o&lt;e.length;o++){var s&#x3D;e[o],r&#x3D;new i(s,this);n.push(r)}return n},m._filterFindItemElements&#x3D;function(t){return n.filterFindElements(t,this.options.itemSelector)},m.getItemElements&#x3D;function(){return this.items.map(function(t){return t.element})},m.layout&#x3D;function(){this._resetLayout(),this._manageStamps();var t&#x3D;this._getOption(&quot;layoutInstant&quot;),e&#x3D;void 0!&#x3D;&#x3D;t?t:!this._isLayoutInited;this.layoutItems(this.items,e),this._isLayoutInited&#x3D;!0},m._init&#x3D;m.layout,m._resetLayout&#x3D;function(){this.getSize()},m.getSize&#x3D;function(){this.size&#x3D;i(this.element)},m._getMeasurement&#x3D;function(t,e){var n,o&#x3D;this.options[t];o?(&quot;string&quot;&#x3D;&#x3D;typeof o?n&#x3D;this.element.querySelector(o):o instanceof HTMLElement&amp;&amp;(n&#x3D;o),this[t]&#x3D;n?i(n)[e]:o):this[t]&#x3D;0},m.layoutItems&#x3D;function(t,e){t&#x3D;this._getItemsForLayout(t),this._layoutItems(t,e),this._postLayout()},m._getItemsForLayout&#x3D;function(t){return t.filter(function(t){return!t.isIgnored})},m._layoutItems&#x3D;function(t,e){if(this._emitCompleteOnItems(&quot;layout&quot;,t),t&amp;&amp;t.length){var i&#x3D;[];t.forEach(function(t){var n&#x3D;this._getItemLayoutPosition(t);n.item&#x3D;t,n.isInstant&#x3D;e||t.isLayoutInstant,i.push(n)},this),this._processLayoutQueue(i)}},m._getItemLayoutPosition&#x3D;function(){return{x:0,y:0}},m._processLayoutQueue&#x3D;function(t){this.updateStagger(),t.forEach(function(t,e){this._positionItem(t.item,t.x,t.y,t.isInstant,e)},this)},m.updateStagger&#x3D;function(){var t&#x3D;this.options.stagger;return null&#x3D;&#x3D;&#x3D;t||void 0&#x3D;&#x3D;&#x3D;t?void(this.stagger&#x3D;0):(this.stagger&#x3D;a(t),this.stagger)},m._positionItem&#x3D;function(t,e,i,n,o){n?t.goTo(e,i):(t.stagger(o*this.stagger),t.moveTo(e,i))},m._postLayout&#x3D;function(){this.resizeContainer()},m.resizeContainer&#x3D;function(){var t&#x3D;this._getOption(&quot;resizeContainer&quot;);if(t){var e&#x3D;this._getContainerSize();e&amp;&amp;(this._setContainerMeasure(e.width,!0),this._setContainerMeasure(e.height,!1))}},m._getContainerSize&#x3D;d,m._setContainerMeasure&#x3D;function(t,e){if(void 0!&#x3D;&#x3D;t){var i&#x3D;this.size;i.isBorderBox&amp;&amp;(t+&#x3D;e?i.paddingLeft+i.paddingRight+i.borderLeftWidth+i.borderRightWidth:i.paddingBottom+i.paddingTop+i.borderTopWidth+i.borderBottomWidth),t&#x3D;Math.max(t,0),this.element.style[e?&quot;width&quot;:&quot;height&quot;]&#x3D;t+&quot;px&quot;}},m._emitCompleteOnItems&#x3D;function(t,e){function i(){o.dispatchEvent(t+&quot;Complete&quot;,null,[e])}function n(){r++,r&#x3D;&#x3D;s&amp;&amp;i()}var o&#x3D;this,s&#x3D;e.length;if(!e||!s)return void i();var r&#x3D;0;e.forEach(function(e){e.once(t,n)})},m.dispatchEvent&#x3D;function(t,e,i){var n&#x3D;e?[e].concat(i):i;if(this.emitEvent(t,n),h)if(this.$element&#x3D;this.$element||h(this.element),e){var o&#x3D;h.Event(e);o.type&#x3D;t,this.$element.trigger(o,i)}else this.$element.trigger(t,i)},m.ignore&#x3D;function(t){var e&#x3D;this.getItem(t);e&amp;&amp;(e.isIgnored&#x3D;!0)},m.unignore&#x3D;function(t){var e&#x3D;this.getItem(t);e&amp;&amp;delete e.isIgnored},m.stamp&#x3D;function(t){t&#x3D;this._find(t),t&amp;&amp;(this.stamps&#x3D;this.stamps.concat(t),t.forEach(this.ignore,this))},m.unstamp&#x3D;function(t){t&#x3D;this._find(t),t&amp;&amp;t.forEach(function(t){n.removeFrom(this.stamps,t),this.unignore(t)},this)},m._find&#x3D;function(t){if(t)return&quot;string&quot;&#x3D;&#x3D;typeof t&amp;&amp;(t&#x3D;this.element.querySelectorAll(t)),t&#x3D;n.makeArray(t)},m._manageStamps&#x3D;function(){this.stamps&amp;&amp;this.stamps.length&amp;&amp;(this._getBoundingRect(),this.stamps.forEach(this._manageStamp,this))},m._getBoundingRect&#x3D;function(){var t&#x3D;this.element.getBoundingClientRect(),e&#x3D;this.size;this._boundingRect&#x3D;{left:t.left+e.paddingLeft+e.borderLeftWidth,top:t.top+e.paddingTop+e.borderTopWidth,right:t.right-(e.paddingRight+e.borderRightWidth),bottom:t.bottom-(e.paddingBottom+e.borderBottomWidth)}},m._manageStamp&#x3D;d,m._getElementOffset&#x3D;function(t){var e&#x3D;t.getBoundingClientRect(),n&#x3D;this._boundingRect,o&#x3D;i(t),s&#x3D;{left:e.left-n.left-o.marginLeft,top:e.top-n.top-o.marginTop,right:n.right-e.right-o.marginRight,bottom:n.bottom-e.bottom-o.marginBottom};return s},m.handleEvent&#x3D;n.handleEvent,m.bindResize&#x3D;function(){t.addEventListener(&quot;resize&quot;,this),this.isResizeBound&#x3D;!0},m.unbindResize&#x3D;function(){t.removeEventListener(&quot;resize&quot;,this),this.isResizeBound&#x3D;!1},m.onresize&#x3D;function(){this.resize()},n.debounceMethod(s,&quot;onresize&quot;,100),m.resize&#x3D;function(){this.isResizeBound&amp;&amp;this.needsResizeLayout()&amp;&amp;this.layout()},m.needsResizeLayout&#x3D;function(){var t&#x3D;i(this.element),e&#x3D;this.size&amp;&amp;t;return e&amp;&amp;t.innerWidth!&#x3D;&#x3D;this.size.innerWidth},m.addItems&#x3D;function(t){var e&#x3D;this._itemize(t);return e.length&amp;&amp;(this.items&#x3D;this.items.concat(e)),e},m.appended&#x3D;function(t){var e&#x3D;this.addItems(t);e.length&amp;&amp;(this.layoutItems(e,!0),this.reveal(e))},m.prepended&#x3D;function(t){var e&#x3D;this._itemize(t);if(e.length){var i&#x3D;this.items.slice(0);this.items&#x3D;e.concat(i),this._resetLayout(),this._manageStamps(),this.layoutItems(e,!0),this.reveal(e),this.layoutItems(i)}},m.reveal&#x3D;function(t){if(this._emitCompleteOnItems(&quot;reveal&quot;,t),t&amp;&amp;t.length){var e&#x3D;this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.reveal()})}},m.hide&#x3D;function(t){if(this._emitCompleteOnItems(&quot;hide&quot;,t),t&amp;&amp;t.length){var e&#x3D;this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.hide()})}},m.revealItemElements&#x3D;function(t){var e&#x3D;this.getItems(t);this.reveal(e)},m.hideItemElements&#x3D;function(t){var e&#x3D;this.getItems(t);this.hide(e)},m.getItem&#x3D;function(t){for(var e&#x3D;0;e&lt;this.items.length;e++){var i&#x3D;this.items[e];if(i.element&#x3D;&#x3D;t)return i}},m.getItems&#x3D;function(t){t&#x3D;n.makeArray(t);var e&#x3D;[];return t.forEach(function(t){var i&#x3D;this.getItem(t);i&amp;&amp;e.push(i)},this),e},m.remove&#x3D;function(t){var e&#x3D;this.getItems(t);this._emitCompleteOnItems(&quot;remove&quot;,e),e&amp;&amp;e.length&amp;&amp;e.forEach(function(t){t.remove(),n.removeFrom(this.items,t)},this)},m.destroy&#x3D;function(){var t&#x3D;this.element.style;t.height&#x3D;&quot;&quot;,t.position&#x3D;&quot;&quot;,t.width&#x3D;&quot;&quot;,this.items.forEach(function(t){t.destroy()}),this.unbindResize();var e&#x3D;this.element.outlayerGUID;delete f[e],delete this.element.outlayerGUID,h&amp;&amp;h.removeData(this.element,this.constructor.namespace)},s.data&#x3D;function(t){t&#x3D;n.getQueryElement(t);var e&#x3D;t&amp;&amp;t.outlayerGUID;return e&amp;&amp;f[e]},s.create&#x3D;function(t,e){var i&#x3D;r(s);return i.defaults&#x3D;n.extend({},s.defaults),n.extend(i.defaults,e),i.compatOptions&#x3D;n.extend({},s.compatOptions),i.namespace&#x3D;t,i.data&#x3D;s.data,i.Item&#x3D;r(o),n.htmlInit(i,t),h&amp;&amp;h.bridget&amp;&amp;h.bridget(t,i),i};var c&#x3D;{ms:1,s:1e3};return s.Item&#x3D;o,s}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_6__], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_7__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(require(&quot;outlayer&quot;)):(t.Isotope&#x3D;t.Isotope||{},t.Isotope.Item&#x3D;e(t.Outlayer))}(window,function(t){&quot;use strict&quot;;function e(){t.Item.apply(this,arguments)}var i&#x3D;e.prototype&#x3D;Object.create(t.Item.prototype),n&#x3D;i._create;i._create&#x3D;function(){this.id&#x3D;this.layout.itemGUID++,n.call(this),this.sortData&#x3D;{}},i.updateSortData&#x3D;function(){if(!this.isIgnored){this.sortData.id&#x3D;this.id,this.sortData[&quot;original-order&quot;]&#x3D;this.id,this.sortData.random&#x3D;Math.random();var t&#x3D;this.layout.options.getSortData,e&#x3D;this.layout._sorters;for(var i in t){var n&#x3D;e[i];this.sortData[i]&#x3D;n(this.element,this)}}};var o&#x3D;i.destroy;return i.destroy&#x3D;function(){o.apply(this,arguments),this.css({display:&quot;&quot;})},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_6__], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_8__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(require(&quot;get-size&quot;),require(&quot;outlayer&quot;)):(t.Isotope&#x3D;t.Isotope||{},t.Isotope.LayoutMode&#x3D;e(t.getSize,t.Outlayer))}(window,function(t,e){&quot;use strict&quot;;function i(t){this.isotope&#x3D;t,t&amp;&amp;(this.options&#x3D;t.options[this.namespace],this.element&#x3D;t.element,this.items&#x3D;t.filteredItems,this.size&#x3D;t.size)}var n&#x3D;i.prototype,o&#x3D;[&quot;_resetLayout&quot;,&quot;_getItemLayoutPosition&quot;,&quot;_manageStamp&quot;,&quot;_getContainerSize&quot;,&quot;_getElementOffset&quot;,&quot;needsResizeLayout&quot;,&quot;_getOption&quot;];return o.forEach(function(t){n[t]&#x3D;function(){return e.prototype[t].apply(this.isotope,arguments)}}),n.needsVerticalResizeLayout&#x3D;function(){var e&#x3D;t(this.isotope.element),i&#x3D;this.isotope.size&amp;&amp;e;return i&amp;&amp;e.innerHeight!&#x3D;this.isotope.size.innerHeight},n._getMeasurement&#x3D;function(){this.isotope._getMeasurement.apply(this,arguments)},n.getColumnWidth&#x3D;function(){this.getSegmentSize(&quot;column&quot;,&quot;Width&quot;)},n.getRowHeight&#x3D;function(){this.getSegmentSize(&quot;row&quot;,&quot;Height&quot;)},n.getSegmentSize&#x3D;function(t,e){var i&#x3D;t+e,n&#x3D;&quot;outer&quot;+e;if(this._getMeasurement(i,n),!this[i]){var o&#x3D;this.getFirstItemSize();this[i]&#x3D;o&amp;&amp;o[n]||this.isotope.size[&quot;inner&quot;+e]}},n.getFirstItemSize&#x3D;function(){var e&#x3D;this.isotope.filteredItems[0];return e&amp;&amp;e.element&amp;&amp;t(e.element)},n.layout&#x3D;function(){this.isotope.layout.apply(this.isotope,arguments)},n.getSize&#x3D;function(){this.isotope.getSize(),this.size&#x3D;this.isotope.size},i.modes&#x3D;{},i.create&#x3D;function(t,e){function o(){i.apply(this,arguments)}return o.prototype&#x3D;Object.create(n),o.prototype.constructor&#x3D;o,e&amp;&amp;(o.options&#x3D;e),o.prototype.namespace&#x3D;t,i.modes[t]&#x3D;o,o},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_6__,__WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_9__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(require(&quot;outlayer&quot;),require(&quot;get-size&quot;)):t.Masonry&#x3D;e(t.Outlayer,t.getSize)}(window,function(t,e){var i&#x3D;t.create(&quot;masonry&quot;);return i.compatOptions.fitWidth&#x3D;&quot;isFitWidth&quot;,i.prototype._resetLayout&#x3D;function(){this.getSize(),this._getMeasurement(&quot;columnWidth&quot;,&quot;outerWidth&quot;),this._getMeasurement(&quot;gutter&quot;,&quot;outerWidth&quot;),this.measureColumns(),this.colYs&#x3D;[];for(var t&#x3D;0;t&lt;this.cols;t++)this.colYs.push(0);this.maxY&#x3D;0},i.prototype.measureColumns&#x3D;function(){if(this.getContainerWidth(),!this.columnWidth){var t&#x3D;this.items[0],i&#x3D;t&amp;&amp;t.element;this.columnWidth&#x3D;i&amp;&amp;e(i).outerWidth||this.containerWidth}var n&#x3D;this.columnWidth+&#x3D;this.gutter,o&#x3D;this.containerWidth+this.gutter,s&#x3D;o/n,r&#x3D;n-o%n,a&#x3D;r&amp;&amp;r&lt;1?&quot;round&quot;:&quot;floor&quot;;s&#x3D;Math[a](s),this.cols&#x3D;Math.max(s,1)},i.prototype.getContainerWidth&#x3D;function(){var t&#x3D;this._getOption(&quot;fitWidth&quot;),i&#x3D;t?this.element.parentNode:this.element,n&#x3D;e(i);this.containerWidth&#x3D;n&amp;&amp;n.innerWidth},i.prototype._getItemLayoutPosition&#x3D;function(t){t.getSize();var e&#x3D;t.size.outerWidth%this.columnWidth,i&#x3D;e&amp;&amp;e&lt;1?&quot;round&quot;:&quot;ceil&quot;,n&#x3D;Math[i](t.size.outerWidth/this.columnWidth);n&#x3D;Math.min(n,this.cols);for(var o&#x3D;this._getColGroup(n),s&#x3D;Math.min.apply(Math,o),r&#x3D;o.indexOf(s),a&#x3D;{x:this.columnWidth*r,y:s},u&#x3D;s+t.size.outerHeight,h&#x3D;this.cols+1-o.length,d&#x3D;0;d&lt;h;d++)this.colYs[r+d]&#x3D;u;return a},i.prototype._getColGroup&#x3D;function(t){if(t&lt;2)return this.colYs;for(var e&#x3D;[],i&#x3D;this.cols+1-t,n&#x3D;0;n&lt;i;n++){var o&#x3D;this.colYs.slice(n,n+t);e[n]&#x3D;Math.max.apply(Math,o)}return e},i.prototype._manageStamp&#x3D;function(t){var i&#x3D;e(t),n&#x3D;this._getElementOffset(t),o&#x3D;this._getOption(&quot;originLeft&quot;),s&#x3D;o?n.left:n.right,r&#x3D;s+i.outerWidth,a&#x3D;Math.floor(s/this.columnWidth);a&#x3D;Math.max(0,a);var u&#x3D;Math.floor(r/this.columnWidth);u-&#x3D;r%this.columnWidth?0:1,u&#x3D;Math.min(this.cols-1,u);for(var h&#x3D;this._getOption(&quot;originTop&quot;),d&#x3D;(h?n.top:n.bottom)+i.outerHeight,l&#x3D;a;l&lt;&#x3D;u;l++)this.colYs[l]&#x3D;Math.max(d,this.colYs[l])},i.prototype._getContainerSize&#x3D;function(){this.maxY&#x3D;Math.max.apply(Math,this.colYs);var t&#x3D;{height:this.maxY};return this._getOption(&quot;fitWidth&quot;)&amp;&amp;(t.width&#x3D;this._getContainerFitWidth()),t},i.prototype._getContainerFitWidth&#x3D;function(){for(var t&#x3D;0,e&#x3D;this.cols;--e&amp;&amp;0&#x3D;&#x3D;&#x3D;this.colYs[e];)t++;return(this.cols-t)*this.columnWidth-this.gutter},i.prototype.needsResizeLayout&#x3D;function(){var t&#x3D;this.containerWidth;return this.getContainerWidth(),t!&#x3D;this.containerWidth},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_8__,__WEBPACK_LOCAL_MODULE_9__], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_10__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(require(&quot;../layout-mode&quot;),require(&quot;masonry-layout&quot;)):e(t.Isotope.LayoutMode,t.Masonry)}(window,function(t,e){&quot;use strict&quot;;var i&#x3D;t.create(&quot;masonry&quot;),n&#x3D;i.prototype,o&#x3D;{_getElementOffset:!0,layout:!0,_getMeasurement:!0};for(var s in e.prototype)o[s]||(n[s]&#x3D;e.prototype[s]);var r&#x3D;n.measureColumns;n.measureColumns&#x3D;function(){this.items&#x3D;this.isotope.filteredItems,r.call(this)};var a&#x3D;n._getOption;return n._getOption&#x3D;function(t){return&quot;fitWidth&quot;&#x3D;&#x3D;t?void 0!&#x3D;&#x3D;this.options.isFitWidth?this.options.isFitWidth:this.options.fitWidth:a.apply(this.isotope,arguments)},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_11__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof exports?module.exports&#x3D;e(require(&quot;../layout-mode&quot;)):e(t.Isotope.LayoutMode)}(window,function(t){&quot;use strict&quot;;var e&#x3D;t.create(&quot;fitRows&quot;),i&#x3D;e.prototype;return i._resetLayout&#x3D;function(){this.x&#x3D;0,this.y&#x3D;0,this.maxY&#x3D;0,this._getMeasurement(&quot;gutter&quot;,&quot;outerWidth&quot;)},i._getItemLayoutPosition&#x3D;function(t){t.getSize();var e&#x3D;t.size.outerWidth+this.gutter,i&#x3D;this.isotope.size.innerWidth+this.gutter;0!&#x3D;&#x3D;this.x&amp;&amp;e+this.x&gt;i&amp;&amp;(this.x&#x3D;0,this.y&#x3D;this.maxY);var n&#x3D;{x:this.x,y:this.y};return this.maxY&#x3D;Math.max(this.maxY,this.y+t.size.outerHeight),this.x+&#x3D;e,n},i._getContainerSize&#x3D;function(){return{height:this.maxY}},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_LOCAL_MODULE_12__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(require(&quot;../layout-mode&quot;)):e(t.Isotope.LayoutMode)}(window,function(t){&quot;use strict&quot;;var e&#x3D;t.create(&quot;vertical&quot;,{horizontalAlignment:0}),i&#x3D;e.prototype;return i._resetLayout&#x3D;function(){this.y&#x3D;0},i._getItemLayoutPosition&#x3D;function(t){t.getSize();var e&#x3D;(this.isotope.size.innerWidth-t.size.outerWidth)*this.options.horizontalAlignment,i&#x3D;this.y;return this.y+&#x3D;t.size.outerHeight,{x:e,y:i}},i._getContainerSize&#x3D;function(){return{height:this.y}},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__WEBPACK_LOCAL_MODULE_6__,__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_3__,__WEBPACK_LOCAL_MODULE_4__,__WEBPACK_LOCAL_MODULE_7__,__WEBPACK_LOCAL_MODULE_8__,__WEBPACK_LOCAL_MODULE_10__,__WEBPACK_LOCAL_MODULE_11__,__WEBPACK_LOCAL_MODULE_12__], __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; function(i,n,o,s,r,a){return e(t,i,n,o,s,r,a)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__)):&quot;object&quot;&#x3D;&#x3D;typeof module&amp;&amp;module.exports?module.exports&#x3D;e(t,require(&quot;outlayer&quot;),require(&quot;get-size&quot;),require(&quot;desandro-matches-selector&quot;),require(&quot;fizzy-ui-utils&quot;),require(&quot;isotope/js/item&quot;),require(&quot;isotope/js/layout-mode&quot;),require(&quot;isotope/js/layout-modes/masonry&quot;),require(&quot;isotope/js/layout-modes/fit-rows&quot;),require(&quot;isotope/js/layout-modes/vertical&quot;)):t.Isotope&#x3D;e(t,t.Outlayer,t.getSize,t.matchesSelector,t.fizzyUIUtils,t.Isotope.Item,t.Isotope.LayoutMode)}(window,function(t,e,i,n,o,s,r){function a(t,e){return function(i,n){for(var o&#x3D;0;o&lt;t.length;o++){var s&#x3D;t[o],r&#x3D;i.sortData[s],a&#x3D;n.sortData[s];if(r&gt;a||r&lt;a){var u&#x3D;void 0!&#x3D;&#x3D;e[s]?e[s]:e,h&#x3D;u?1:-1;return(r&gt;a?1:-1)*h}}return 0}}var u&#x3D;t.jQuery,h&#x3D;String.prototype.trim?function(t){return t.trim()}:function(t){return t.replace(/^\s+|\s+$/g,&quot;&quot;)},d&#x3D;e.create(&quot;isotope&quot;,{layoutMode:&quot;masonry&quot;,isJQueryFiltering:!0,sortAscending:!0});d.Item&#x3D;s,d.LayoutMode&#x3D;r;var l&#x3D;d.prototype;l._create&#x3D;function(){this.itemGUID&#x3D;0,this._sorters&#x3D;{},this._getSorters(),e.prototype._create.call(this),this.modes&#x3D;{},this.filteredItems&#x3D;this.items,this.sortHistory&#x3D;[&quot;original-order&quot;];for(var t in r.modes)this._initLayoutMode(t)},l.reloadItems&#x3D;function(){this.itemGUID&#x3D;0,e.prototype.reloadItems.call(this)},l._itemize&#x3D;function(){for(var t&#x3D;e.prototype._itemize.apply(this,arguments),i&#x3D;0;i&lt;t.length;i++){var n&#x3D;t[i];n.id&#x3D;this.itemGUID++}return this._updateItemsSortData(t),t},l._initLayoutMode&#x3D;function(t){var e&#x3D;r.modes[t],i&#x3D;this.options[t]||{};this.options[t]&#x3D;e.options?o.extend(e.options,i):i,this.modes[t]&#x3D;new e(this)},l.layout&#x3D;function(){return!this._isLayoutInited&amp;&amp;this._getOption(&quot;initLayout&quot;)?void this.arrange():void this._layout()},l._layout&#x3D;function(){var t&#x3D;this._getIsInstant();this._resetLayout(),this._manageStamps(),this.layoutItems(this.filteredItems,t),this._isLayoutInited&#x3D;!0},l.arrange&#x3D;function(t){this.option(t),this._getIsInstant();var e&#x3D;this._filter(this.items);this.filteredItems&#x3D;e.matches,this._bindArrangeComplete(),this._isInstant?this._noTransition(this._hideReveal,[e]):this._hideReveal(e),this._sort(),this._layout()},l._init&#x3D;l.arrange,l._hideReveal&#x3D;function(t){this.reveal(t.needReveal),this.hide(t.needHide)},l._getIsInstant&#x3D;function(){var t&#x3D;this._getOption(&quot;layoutInstant&quot;),e&#x3D;void 0!&#x3D;&#x3D;t?t:!this._isLayoutInited;return this._isInstant&#x3D;e,e},l._bindArrangeComplete&#x3D;function(){function t(){e&amp;&amp;i&amp;&amp;n&amp;&amp;o.dispatchEvent(&quot;arrangeComplete&quot;,null,[o.filteredItems])}var e,i,n,o&#x3D;this;this.once(&quot;layoutComplete&quot;,function(){e&#x3D;!0,t()}),this.once(&quot;hideComplete&quot;,function(){i&#x3D;!0,t()}),this.once(&quot;revealComplete&quot;,function(){n&#x3D;!0,t()})},l._filter&#x3D;function(t){var e&#x3D;this.options.filter;e&#x3D;e||&quot;*&quot;;for(var i&#x3D;[],n&#x3D;[],o&#x3D;[],s&#x3D;this._getFilterTest(e),r&#x3D;0;r&lt;t.length;r++){var a&#x3D;t[r];if(!a.isIgnored){var u&#x3D;s(a);u&amp;&amp;i.push(a),u&amp;&amp;a.isHidden?n.push(a):u||a.isHidden||o.push(a)}}return{matches:i,needReveal:n,needHide:o}},l._getFilterTest&#x3D;function(t){return u&amp;&amp;this.options.isJQueryFiltering?function(e){return u(e.element).is(t)}:&quot;function&quot;&#x3D;&#x3D;typeof t?function(e){return t(e.element)}:function(e){return n(e.element,t)}},l.updateSortData&#x3D;function(t){var e;t?(t&#x3D;o.makeArray(t),e&#x3D;this.getItems(t)):e&#x3D;this.items,this._getSorters(),this._updateItemsSortData(e)},l._getSorters&#x3D;function(){var t&#x3D;this.options.getSortData;for(var e in t){var i&#x3D;t[e];this._sorters[e]&#x3D;f(i)}},l._updateItemsSortData&#x3D;function(t){for(var e&#x3D;t&amp;&amp;t.length,i&#x3D;0;e&amp;&amp;i&lt;e;i++){var n&#x3D;t[i];n.updateSortData()}};var f&#x3D;function(){function t(t){if(&quot;string&quot;!&#x3D;typeof t)return t;var i&#x3D;h(t).split(&quot; &quot;),n&#x3D;i[0],o&#x3D;n.match(/^\[(.+)\]$/),s&#x3D;o&amp;&amp;o[1],r&#x3D;e(s,n),a&#x3D;d.sortDataParsers[i[1]];
	    return t&#x3D;a?function(t){return t&amp;&amp;a(r(t))}:function(t){return t&amp;&amp;r(t)}}function e(t,e){return t?function(e){return e.getAttribute(t)}:function(t){var i&#x3D;t.querySelector(e);return i&amp;&amp;i.textContent}}return t}();d.sortDataParsers&#x3D;{parseInt:function(t){return parseInt(t,10)},parseFloat:function(t){return parseFloat(t)}},l._sort&#x3D;function(){if(this.options.sortBy){var t&#x3D;o.makeArray(this.options.sortBy);this._getIsSameSortBy(t)||(this.sortHistory&#x3D;t.concat(this.sortHistory));var e&#x3D;a(this.sortHistory,this.options.sortAscending);this.filteredItems.sort(e)}},l._getIsSameSortBy&#x3D;function(t){for(var e&#x3D;0;e&lt;t.length;e++)if(t[e]!&#x3D;this.sortHistory[e])return!1;return!0},l._mode&#x3D;function(){var t&#x3D;this.options.layoutMode,e&#x3D;this.modes[t];if(!e)throw new Error(&quot;No layout mode: &quot;+t);return e.options&#x3D;this.options[t],e},l._resetLayout&#x3D;function(){e.prototype._resetLayout.call(this),this._mode()._resetLayout()},l._getItemLayoutPosition&#x3D;function(t){return this._mode()._getItemLayoutPosition(t)},l._manageStamp&#x3D;function(t){this._mode()._manageStamp(t)},l._getContainerSize&#x3D;function(){return this._mode()._getContainerSize()},l.needsResizeLayout&#x3D;function(){return this._mode().needsResizeLayout()},l.appended&#x3D;function(t){var e&#x3D;this.addItems(t);if(e.length){var i&#x3D;this._filterRevealAdded(e);this.filteredItems&#x3D;this.filteredItems.concat(i)}},l.prepended&#x3D;function(t){var e&#x3D;this._itemize(t);if(e.length){this._resetLayout(),this._manageStamps();var i&#x3D;this._filterRevealAdded(e);this.layoutItems(this.filteredItems),this.filteredItems&#x3D;i.concat(this.filteredItems),this.items&#x3D;e.concat(this.items)}},l._filterRevealAdded&#x3D;function(t){var e&#x3D;this._filter(t);return this.hide(e.needHide),this.reveal(e.matches),this.layoutItems(e.matches,!0),e.matches},l.insert&#x3D;function(t){var e&#x3D;this.addItems(t);if(e.length){var i,n,o&#x3D;e.length;for(i&#x3D;0;i&lt;o;i++)n&#x3D;e[i],this.element.appendChild(n.element);var s&#x3D;this._filter(e).matches;for(i&#x3D;0;i&lt;o;i++)e[i].isLayoutInstant&#x3D;!0;for(this.arrange(),i&#x3D;0;i&lt;o;i++)delete e[i].isLayoutInstant;this.reveal(s)}};var m&#x3D;l.remove;return l.remove&#x3D;function(t){t&#x3D;o.makeArray(t);var e&#x3D;this.getItems(t);m.call(this,t);for(var i&#x3D;e&amp;&amp;e.length,n&#x3D;0;i&amp;&amp;n&lt;i;n++){var s&#x3D;e[n];o.removeFrom(this.filteredItems,s)}},l.shuffle&#x3D;function(){for(var t&#x3D;0;t&lt;this.items.length;t++){var e&#x3D;this.items[t];e.sortData.random&#x3D;Math.random()}this.options.sortBy&#x3D;&quot;random&quot;,this._sort(),this._layout()},l._noTransition&#x3D;function(t,e){var i&#x3D;this.options.transitionDuration;this.options.transitionDuration&#x3D;0;var n&#x3D;t.apply(this,e);return this.options.transitionDuration&#x3D;i,n},l.getFilteredItemElements&#x3D;function(){return this.filteredItems.map(function(t){return t.element})},d});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/* PaperPanel
	 *
	 * @type Object
	 * @description $.PaperPanel is the main object for the template&#x27;s app.
	 *              It&#x27;s used for implementing functions and options related
	 *              to the template. Keeping everything wrapped in an object
	 *              prevents conflict with other plugins and is a better
	 *              way to organize our code.
	 */

	__webpack_require__(28);

	$.PaperPanel &#x3D; {};

	/* --------------------
	 * - PaperPanel Options -
	 * --------------------
	 * Modify these options to suit your implementation
	 */
	$.PaperPanel.options &#x3D; {

	    animationSpeed: 500,
	    //Sidebar push menu toggle button selector
	    sidebarToggleSelector: &quot;[data-toggle&#x3D;&#x27;offcanvas&#x27;]&quot;,
	    //Activate sidebar push menu
	    sidebarPushMenu: true,
	    navbarMenuSlimscrollWidth: &quot;3px&quot;,
	    sidebarSlimScroll: true,
	    controlSidebarOptions: {
	        //Which button should trigger the open/close event
	        toggleBtnSelector: &quot;[data-toggle&#x3D;&#x27;control-sidebar&#x27;]&quot;,
	        //The sidebar selector
	        selector: &quot;.control-sidebar&quot;,
	        //Enable slide over content
	        slide: true
	    },

	    //The standard screen sizes that bootstrap uses.
	    //If you change these in the variables.less file, change
	    //them here too.
	    screenSizes: {
	        xs: 480,
	        sm: 768,
	        md: 1025,
	        lg: 1200
	    }
	};

	/* ------------------
	 * - Implementation -
	 * ------------------
	 * The next block of code implements PaperPanel&#x27;s
	 * functions and plugins as specified by the
	 * options above.
	 */
	$(function () {
	    &quot;use strict&quot;;

	    //Fix for IE page transitions
	    $(&quot;body&quot;).removeClass(&quot;hold-transition&quot;);

	    //Extend options if external options exist
	    if (typeof PaperPanelOptions !&#x3D;&#x3D; &quot;undefined&quot;) {
	        $.extend(true,
	            $.PaperPanel.options,
	            PaperPanelOptions);
	    }

	    //Easy access to options
	    var o &#x3D; $.PaperPanel.options;

	    //Set up the object
	    _init();

	    //Activate the layout maker
	    $.PaperPanel.layout.activate();

	    //Enable sidebar tree view controls
	    $.PaperPanel.tree(&#x27;.sidebar&#x27;);

	    //Enable control sidebar
	    if (o.enableControlSidebar) {
	        $.PaperPanel.controlSidebar.activate();
	    }

	    //Activate sidebar push menu
	    if (o.sidebarPushMenu) {
	        $.PaperPanel.pushMenu.activate(o.sidebarToggleSelector);
	    }
	    /*
	     * INITIALIZE BUTTON TOGGLE
	     * ------------------------
	     */

	    $(&#x27;.btn-group[data-toggle&#x3D;&quot;btn-toggle&quot;]&#x27;).each(function () {
	        var group &#x3D; $(this);
	        $(this).find(&quot;.btn&quot;).on(&#x27;click&#x27;, function (e) {
	            group.find(&quot;.btn.active&quot;).removeClass(&quot;active&quot;);
	            $(this).addClass(&quot;active&quot;);
	            e.preventDefault();
	        });

	    });
	});

	/* ----------------------------------
	 * - Initialize the PaperPanel Object -
	 * ----------------------------------
	 * All PaperPanel functions are implemented below.
	 */
	function _init() {
	    &#x27;use strict&#x27;;
	    /* Layout
	     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
	     * Fixes the layout height in case min-height fails.
	     *
	     * @type Object
	     * @usage $.PaperPanel.layout.activate()
	     *        $.PaperPanel.layout.fix()
	     *        $.PaperPanel.layout.fixSidebar()
	     */

	    var slimScroll &#x3D; $(&quot;.slimScroll&quot;);

	    if(slimScroll.length){
	        slimScroll.each(function () {
	            var $this &#x3D; $(this);
	            var attrData &#x3D;$this.data();
	            $this.slimscroll({
	                height: attrData.height ? attrData.height+&#x27;px&#x27; : ($(window).height()) + &quot;px&quot;,
	                color: attrData.color ? attrData.color : &quot;rgba(0,0,0,0.95)&quot;,
	                size:  attrData.size ? attrData.size +&#x27;px&#x27; : &quot;5px&quot;
	            });
	        });
	    }


	    $.PaperPanel.layout &#x3D; {
	        activate: function () {
	            var _this &#x3D; this;
	            _this.fix();
	            _this.fixSidebar();
	            $(window, &quot;.wrapper&quot;).resize(function () {
	                _this.fix();
	                _this.fixSidebar();
	            });
	        },
	        fix: function () {
	            //Get window height and the wrapper height
	            var neg &#x3D; $(&#x27;.main-header&#x27;).outerHeight() + $(&#x27;.main-footer&#x27;).outerHeight();
	            var window_height &#x3D; $(window).height();
	            var sidebar_height &#x3D; $(&quot;.sidebar&quot;).height();
	            //Set the min-height of the content and sidebar based on the
	            //the height of the document.
	            if ($(&quot;body&quot;).hasClass(&quot;fixed&quot;)) {
	                $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, window_height - $(&#x27;.main-footer&#x27;).outerHeight());
	            } else {
	                var postSetWidth;
	                if (window_height &gt;&#x3D; sidebar_height) {
	                    $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, window_height - neg);
	                    postSetWidth &#x3D; window_height - neg;
	                } else {
	                    $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, sidebar_height);
	                    postSetWidth &#x3D; sidebar_height;
	                }

	                //Fix for the control sidebar height
	                var controlSidebar &#x3D; $($.PaperPanel.options.controlSidebarOptions.selector);
	                if (typeof controlSidebar !&#x3D;&#x3D; &quot;undefined&quot;) {
	                    if (controlSidebar.height() &gt; postSetWidth)
	                        $(&quot;.content-wrapper, .right-side&quot;).css(&#x27;min-height&#x27;, controlSidebar.height());
	                }

	            }
	        },
	        fixSidebar: function () {
	            //Make sure the body tag has the .fixed class
	            if (!$(&quot;.main-sidebar&quot;).hasClass(&quot;fixed&quot;)) {
	                if (typeof $.fn.slimScroll !&#x3D; &#x27;undefined&#x27;) {
	                    $(&quot;.sidebar&quot;).slimScroll({destroy: true}).height(&quot;auto&quot;);

	                }
	                return;
	            } else if (typeof $.fn.slimScroll &#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; window.console) {
	                window.console.error(&quot;Error: the fixed layout requires the slimscroll plugin!&quot;);
	            }
	            //Enable slimscroll for fixed layout
	            if ($.PaperPanel.options.sidebarSlimScroll) {
	                if (typeof $.fn.slimScroll !&#x3D; &#x27;undefined&#x27;) {
	                    //Destroy if it exists
	                    $(&quot;.sidebar&quot;).slimScroll({destroy: true}).height(&quot;auto&quot;);
	                    //Add slimscroll

	                    $(&quot;.sidebar&quot;).slimscroll({
	                        height: ($(window).height()) + &quot;px&quot;,
	                        color: &quot;rgba(0,0,0,0.3)&quot;,
	                        size: &quot;5px&quot;
	                    });
	                }
	            }
	        }
	    };


	    /* PushMenu()
	     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
	     * Adds the push menu functionality to the sidebar.
	     *
	     * @type Function
	     * @usage: $.PaperPanel.pushMenu(&quot;[data-toggle&#x3D;&#x27;offcanvas&#x27;]&quot;)
	     */
	    $.PaperPanel.pushMenu &#x3D; {
	        activate: function (toggleBtn) {
	            //Get the screen sizes
	            var screenSizes &#x3D; $.PaperPanel.options.screenSizes;

	            //Enable sidebar toggle
	            $(document).on(&#x27;click&#x27;, toggleBtn, function (e) {
	                e.preventDefault();
	                e.stopPropagation();
	                //Enable sidebar push menu
	                if ($(window).width() &gt; (screenSizes.md - 1)) {
	                    if ($(&quot;body&quot;).hasClass(&#x27;sidebar-collapse&#x27;)) {
	                        $(&quot;body&quot;).removeClass(&#x27;sidebar-collapse&#x27;).trigger(&#x27;expanded.pushMenu&#x27;);
	                        if ($(&#x27;.nav-offcanvas-desktop&#x27;).length) {
	                            $(&quot;body&quot;).addClass(&#x27;sidebar-open&#x27;).trigger(&#x27;expanded.pushMenu&#x27;);
	                        }

	                    } else {
	                        $(&quot;body&quot;).addClass(&#x27;sidebar-collapse&#x27;).trigger(&#x27;collapsed.pushMenu&#x27;);
	                    }
	                }
	                //Handle sidebar push menu for small screens
	                else {
	                    if ($(&quot;body&quot;).hasClass(&#x27;sidebar-open&#x27;)) {
	                        $(&quot;body&quot;).removeClass(&#x27;sidebar-open&#x27;).removeClass(&#x27;sidebar-collapse&#x27;).trigger(&#x27;collapsed.pushMenu&#x27;);
	                    } else {
	                        $(&quot;body&quot;).addClass(&#x27;sidebar-open&#x27;).trigger(&#x27;expanded.pushMenu&#x27;);
	                    }
	                }
	            });

	            $(&quot;.content-wrapper&quot;).click(function () {
	                //Enable hide menu when clicking on the content-wrapper on small screens
	                if ($(window).width() &lt;&#x3D; (screenSizes.md - 1) &amp;&amp; $(&quot;body&quot;).hasClass(&quot;sidebar-open&quot;)) {
	                    $(&quot;body&quot;).removeClass(&#x27;sidebar-open&#x27;);
	                }
	            });


	        },
	        expandOnHover: function () {
	            var _this &#x3D; this;
	            var screenWidth &#x3D; $.PaperPanel.options.screenSizes.sm - 1;
	            //Expand sidebar on hover
	            $(&#x27;.main-sidebar&#x27;).hover(function () {
	                if ($(&#x27;body&#x27;).hasClass(&#x27;sidebar-mini&#x27;) &amp;&amp;
	                    $(&quot;body&quot;).hasClass(&#x27;sidebar-collapse&#x27;) &amp;&amp;
	                    $(window).width() &gt; screenWidth) {
	                    _this.expand();
	                }
	            }, function () {
	                if ($(&#x27;body&#x27;).hasClass(&#x27;sidebar-mini&#x27;) &amp;&amp;
	                    $(&#x27;body&#x27;).hasClass(&#x27;sidebar-expanded-on-hover&#x27;) &amp;&amp;
	                    $(window).width() &gt; screenWidth) {
	                    _this.collapse();
	                }
	            });
	        },
	        expand: function () {
	            $(&quot;body&quot;).removeClass(&#x27;sidebar-collapse&#x27;).addClass(&#x27;sidebar-expanded-on-hover&#x27;);
	        },
	        collapse: function () {
	            if ($(&#x27;body&#x27;).hasClass(&#x27;sidebar-expanded-on-hover&#x27;)) {
	                $(&#x27;body&#x27;).removeClass(&#x27;sidebar-expanded-on-hover&#x27;).addClass(&#x27;sidebar-collapse&#x27;);
	            }
	        }
	    };

	    /* Tree()
	     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
	     * Converts the sidebar into a multilevel
	     * tree view menu.
	     *
	     * @type Function
	     * @Usage: $.PaperPanel.tree(&#x27;.sidebar&#x27;)
	     */
	    $.PaperPanel.tree &#x3D; function (menu) {
	        var _this &#x3D; this;
	        var animationSpeed &#x3D; $.PaperPanel.options.animationSpeed;
	        $(document).on(&#x27;click&#x27;, menu + &#x27; li a&#x27;, function (e) {
	            //Get the clicked link and the next element
	            var $this &#x3D; $(this);
	            var checkElement &#x3D; $this.next();

	            //Check if the next element is a menu and is visible
	            if ((checkElement.is(&#x27;.treeview-menu&#x27;)) &amp;&amp; (checkElement.is(&#x27;:visible&#x27;)) &amp;&amp; (!$(&#x27;body&#x27;).hasClass(&#x27;sidebar-collapse&#x27;))) {
	                //Close the menu
	                checkElement.slideUp(animationSpeed, function () {
	                    checkElement.removeClass(&#x27;menu-open&#x27;);
	                    //Fix the layout in case the sidebar stretches over the height of the window
	                    //_this.layout.fix();
	                });
	                checkElement.parent(&quot;li&quot;).removeClass(&quot;active&quot;);
	            }
	            //If the menu is not visible
	            else if ((checkElement.is(&#x27;.treeview-menu&#x27;)) &amp;&amp; (!checkElement.is(&#x27;:visible&#x27;))) {
	                //Get the parent menu
	                var parent &#x3D; $this.parents(&#x27;ul&#x27;).first();
	                //Close all open menus within the parent
	                var ul &#x3D; parent.find(&#x27;ul:visible&#x27;).slideUp(animationSpeed);
	                //Remove the menu-open class from the parent
	                ul.removeClass(&#x27;menu-open&#x27;);
	                //Get the parent li
	                var parent_li &#x3D; $this.parent(&quot;li&quot;);

	                //Open the target menu and add the menu-open class
	                checkElement.slideDown(animationSpeed, function () {
	                    //Add the class active to the parent li
	                    checkElement.addClass(&#x27;menu-open&#x27;);
	                    parent.find(&#x27;li.active&#x27;).removeClass(&#x27;active&#x27;);
	                    parent_li.addClass(&#x27;active&#x27;);
	                    //Fix the layout in case the sidebar stretches over the height of the window
	                    _this.layout.fix();
	                });
	            }
	            //if this isn&#x27;t a link, prevent the page from being redirected
	            if (checkElement.is(&#x27;.treeview-menu&#x27;)) {
	                e.preventDefault();
	            }
	        });
	    };
	}

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
	 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
	 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
	 *
	 * Version: 1.3.8
	 *
	 */
	(function ($) {

	    $.fn.extend({
	        slimScroll: function (options) {

	            var defaults &#x3D; {

	                // width in pixels of the visible scroll area
	                width: &#x27;auto&#x27;,

	                // height in pixels of the visible scroll area
	                height: &#x27;250px&#x27;,

	                // width in pixels of the scrollbar and rail
	                size: &#x27;7px&#x27;,

	                // scrollbar color, accepts any hex/color value
	                color: &#x27;#000&#x27;,

	                // scrollbar position - left/right
	                position: &#x27;right&#x27;,

	                // distance in pixels between the side edge and the scrollbar
	                distance: &#x27;1px&#x27;,

	                // default scroll position on load - top / bottom / $(&#x27;selector&#x27;)
	                start: &#x27;top&#x27;,

	                // sets scrollbar opacity
	                opacity: .4,

	                // enables always-on mode for the scrollbar
	                alwaysVisible: false,

	                // check if we should hide the scrollbar when user is hovering over
	                disableFadeOut: false,

	                // sets visibility of the rail
	                railVisible: false,

	                // sets rail color
	                railColor: &#x27;#333&#x27;,

	                // sets rail opacity
	                railOpacity: .2,

	                // whether  we should use jQuery UI Draggable to enable bar dragging
	                railDraggable: true,

	                // defautlt CSS class of the slimscroll rail
	                railClass: &#x27;slimScrollRail&#x27;,

	                // defautlt CSS class of the slimscroll bar
	                barClass: &#x27;slimScrollBar&#x27;,

	                // defautlt CSS class of the slimscroll wrapper
	                wrapperClass: &#x27;slimScrollDiv&#x27;,

	                // check if mousewheel should scroll the window if we reach top/bottom
	                allowPageScroll: false,

	                // scroll amount applied to each mouse wheel step
	                wheelStep: 20,

	                // scroll amount applied when user is using gestures
	                touchScrollStep: 200,

	                // sets border radius
	                borderRadius: &#x27;7px&#x27;,

	                // sets border radius of the rail
	                railBorderRadius: &#x27;7px&#x27;
	            };

	            var o &#x3D; $.extend(defaults, options);

	            // do it for every element that matches selector
	            this.each(function () {

	                var isOverPanel, isOverBar, isDragg, queueHide, touchDif,
	                    barHeight, percentScroll, lastScroll,
	                    divS &#x3D; &#x27;&lt;div&gt;&lt;/div&gt;&#x27;,
	                    minBarHeight &#x3D; 30,
	                    releaseScroll &#x3D; false;

	                // used in event handlers and for better minification
	                var me &#x3D; $(this);

	                // ensure we are not binding it again
	                if (me.parent().hasClass(o.wrapperClass)) {
	                    // start from last bar position
	                    var offset &#x3D; me.scrollTop();

	                    // find bar and rail
	                    bar &#x3D; me.siblings(&#x27;.&#x27; + o.barClass);
	                    rail &#x3D; me.siblings(&#x27;.&#x27; + o.railClass);

	                    getBarHeight();

	                    // check if we should scroll existing instance
	                    if ($.isPlainObject(options)) {
	                        // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
	                        if (&#x27;height&#x27; in options &amp;&amp; options.height &#x3D;&#x3D; &#x27;auto&#x27;) {
	                            me.parent().css(&#x27;height&#x27;, &#x27;auto&#x27;);
	                            me.css(&#x27;height&#x27;, &#x27;auto&#x27;);
	                            var height &#x3D; me.parent().parent().height();
	                            me.parent().css(&#x27;height&#x27;, height);
	                            me.css(&#x27;height&#x27;, height);
	                        } else if (&#x27;height&#x27; in options) {
	                            var h &#x3D; options.height;
	                            me.parent().css(&#x27;height&#x27;, h);
	                            me.css(&#x27;height&#x27;, h);
	                        }

	                        if (&#x27;scrollTo&#x27; in options) {
	                            // jump to a static point
	                            offset &#x3D; parseInt(o.scrollTo);
	                        }
	                        else if (&#x27;scrollBy&#x27; in options) {
	                            // jump by value pixels
	                            offset +&#x3D; parseInt(o.scrollBy);
	                        }
	                        else if (&#x27;destroy&#x27; in options) {
	                            // remove slimscroll elements
	                            bar.remove();
	                            rail.remove();
	                            me.unwrap();
	                            return;
	                        }

	                        // scroll content by the given offset
	                        scrollContent(offset, false, true);
	                    }

	                    return;
	                }
	                else if ($.isPlainObject(options)) {
	                    if (&#x27;destroy&#x27; in options) {
	                        return;
	                    }
	                }

	                // optionally set height to the parent&#x27;s height
	                o.height &#x3D; (o.height &#x3D;&#x3D; &#x27;auto&#x27;) ? me.parent().height() : o.height;

	                // wrap content
	                var wrapper &#x3D; $(divS)
	                    .addClass(o.wrapperClass)
	                    .css({
	                        position: &#x27;relative&#x27;,
	                        overflow: &#x27;hidden&#x27;,
	                        width: o.width,
	                        height: o.height
	                    });

	                // update style for the div
	                me.css({
	                    overflow: &#x27;hidden&#x27;,
	                    width: o.width,
	                    height: o.height
	                });

	                // create scrollbar rail
	                var rail &#x3D; $(divS)
	                    .addClass(o.railClass)
	                    .css({
	                        width: o.size,
	                        height: &#x27;100%&#x27;,
	                        position: &#x27;absolute&#x27;,
	                        top: 0,
	                        display: (o.alwaysVisible &amp;&amp; o.railVisible) ? &#x27;block&#x27; : &#x27;none&#x27;,
	                        &#x27;border-radius&#x27;: o.railBorderRadius,
	                        background: o.railColor,
	                        opacity: o.railOpacity,
	                        zIndex: 90
	                    });

	                // create scrollbar
	                var bar &#x3D; $(divS)
	                    .addClass(o.barClass)
	                    .css({
	                        background: o.color,
	                        width: o.size,
	                        position: &#x27;absolute&#x27;,
	                        top: 0,
	                        opacity: o.opacity,
	                        display: o.alwaysVisible ? &#x27;block&#x27; : &#x27;none&#x27;,
	                        &#x27;border-radius&#x27;: o.borderRadius,
	                        BorderRadius: o.borderRadius,
	                        MozBorderRadius: o.borderRadius,
	                        WebkitBorderRadius: o.borderRadius,
	                        zIndex: 99
	                    });

	                // set position
	                var posCss &#x3D; (o.position &#x3D;&#x3D; &#x27;right&#x27;) ? {right: o.distance} : {left: o.distance};
	                rail.css(posCss);
	                bar.css(posCss);

	                // wrap it
	                me.wrap(wrapper);

	                // append to parent div
	                me.parent().append(bar);
	                me.parent().append(rail);

	                // make it draggable and no longer dependent on the jqueryUI
	                if (o.railDraggable) {
	                    bar.bind(&quot;mousedown&quot;, function (e) {
	                        var $doc &#x3D; $(document);
	                        isDragg &#x3D; true;
	                        t &#x3D; parseFloat(bar.css(&#x27;top&#x27;));
	                        pageY &#x3D; e.pageY;

	                        $doc.bind(&quot;mousemove.slimscroll&quot;, function (e) {
	                            currTop &#x3D; t + e.pageY - pageY;
	                            bar.css(&#x27;top&#x27;, currTop);
	                            scrollContent(0, bar.position().top, false);// scroll content
	                        });

	                        $doc.bind(&quot;mouseup.slimscroll&quot;, function (e) {
	                            isDragg &#x3D; false;
	                            hideBar();
	                            $doc.unbind(&#x27;.slimscroll&#x27;);
	                        });
	                        return false;
	                    }).bind(&quot;selectstart.slimscroll&quot;, function (e) {
	                        e.stopPropagation();
	                        e.preventDefault();
	                        return false;
	                    });
	                }

	                // on rail over
	                rail.hover(function () {
	                    showBar();
	                }, function () {
	                    hideBar();
	                });

	                // on bar over
	                bar.hover(function () {
	                    isOverBar &#x3D; true;
	                }, function () {
	                    isOverBar &#x3D; false;
	                });

	                // show on parent mouseover
	                me.hover(function () {
	                    isOverPanel &#x3D; true;
	                    showBar();
	                    hideBar();
	                }, function () {
	                    isOverPanel &#x3D; false;
	                    hideBar();
	                });

	                // support for mobile
	                me.bind(&#x27;touchstart&#x27;, function (e, b) {
	                    if (e.originalEvent.touches.length) {
	                        // record where touch started
	                        touchDif &#x3D; e.originalEvent.touches[0].pageY;
	                    }
	                });

	                me.bind(&#x27;touchmove&#x27;, function (e) {
	                    // prevent scrolling the page if necessary
	                    if (!releaseScroll) {
	                        e.originalEvent.preventDefault();
	                    }
	                    if (e.originalEvent.touches.length) {
	                        // see how far user swiped
	                        var diff &#x3D; (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
	                        // scroll content
	                        scrollContent(diff, true);
	                        touchDif &#x3D; e.originalEvent.touches[0].pageY;
	                    }
	                });

	                // set up initial height
	                getBarHeight();

	                // check start position
	                if (o.start &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;) {
	                    // scroll content to bottom
	                    bar.css({top: me.outerHeight() - bar.outerHeight()});
	                    scrollContent(0, true);
	                }
	                else if (o.start !&#x3D;&#x3D; &#x27;top&#x27;) {
	                    // assume jQuery selector
	                    scrollContent($(o.start).position().top, null, true);

	                    // make sure bar stays hidden
	                    if (!o.alwaysVisible) {
	                        bar.hide();
	                    }
	                }

	                // attach scroll events
	                attachWheel(this);

	                function _onWheel(e) {
	                    // use mouse wheel only when mouse is over
	                    if (!isOverPanel) {
	                        return;
	                    }

	                    var e &#x3D; e || window.event;

	                    var delta &#x3D; 0;
	                    if (e.wheelDelta) {
	                        delta &#x3D; -e.wheelDelta / 120;
	                    }
	                    if (e.detail) {
	                        delta &#x3D; e.detail / 3;
	                    }

	                    var target &#x3D; e.target || e.srcTarget || e.srcElement;
	                    if ($(target).closest(&#x27;.&#x27; + o.wrapperClass).is(me.parent())) {
	                        // scroll content
	                        scrollContent(delta, true);
	                    }

	                    // stop window scroll
	                    if (e.preventDefault &amp;&amp; !releaseScroll) {
	                        e.preventDefault();
	                    }
	                    if (!releaseScroll) {
	                        e.returnValue &#x3D; false;
	                    }
	                }

	                function scrollContent(y, isWheel, isJump) {
	                    releaseScroll &#x3D; false;
	                    var delta &#x3D; y;
	                    var maxTop &#x3D; me.outerHeight() - bar.outerHeight();

	                    if (isWheel) {
	                        // move bar with mouse wheel
	                        delta &#x3D; parseInt(bar.css(&#x27;top&#x27;)) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();

	                        // move bar, make sure it doesn&#x27;t go out
	                        delta &#x3D; Math.min(Math.max(delta, 0), maxTop);

	                        // if scrolling down, make sure a fractional change to the
	                        // scroll position isn&#x27;t rounded away when the scrollbar&#x27;s CSS is set
	                        // this flooring of delta would happened automatically when
	                        // bar.css is set below, but we floor here for clarity
	                        delta &#x3D; (y &gt; 0) ? Math.ceil(delta) : Math.floor(delta);

	                        // scroll the scrollbar
	                        bar.css({top: delta + &#x27;px&#x27;});
	                    }

	                    // calculate actual scroll amount
	                    percentScroll &#x3D; parseInt(bar.css(&#x27;top&#x27;)) / (me.outerHeight() - bar.outerHeight());
	                    delta &#x3D; percentScroll * (me[0].scrollHeight - me.outerHeight());

	                    if (isJump) {
	                        delta &#x3D; y;
	                        var offsetTop &#x3D; delta / me[0].scrollHeight * me.outerHeight();
	                        offsetTop &#x3D; Math.min(Math.max(offsetTop, 0), maxTop);
	                        bar.css({top: offsetTop + &#x27;px&#x27;});
	                    }

	                    // scroll content
	                    me.scrollTop(delta);

	                    // fire scrolling event
	                    me.trigger(&#x27;slimscrolling&#x27;, ~~delta);

	                    // ensure bar is visible
	                    showBar();

	                    // trigger hide when scroll is stopped
	                    hideBar();
	                }

	                function attachWheel(target) {
	                    if (window.addEventListener) {
	                        target.addEventListener(&#x27;DOMMouseScroll&#x27;, _onWheel, false);
	                        target.addEventListener(&#x27;mousewheel&#x27;, _onWheel, false);
	                    }
	                    else {
	                        document.attachEvent(&quot;onmousewheel&quot;, _onWheel)
	                    }
	                }

	                function getBarHeight() {
	                    // calculate scrollbar height and make sure it is not too small
	                    barHeight &#x3D; Math.max((me.outerHeight() / me[0].scrollHeight) * me.outerHeight(), minBarHeight);
	                    bar.css({height: barHeight + &#x27;px&#x27;});

	                    // hide scrollbar if content is not long enough
	                    var display &#x3D; barHeight &#x3D;&#x3D; me.outerHeight() ? &#x27;none&#x27; : &#x27;block&#x27;;
	                    bar.css({display: display});
	                }

	                function showBar() {
	                    // recalculate bar height
	                    getBarHeight();
	                    clearTimeout(queueHide);

	                    // when bar reached top or bottom
	                    if (percentScroll &#x3D;&#x3D; ~~percentScroll) {
	                        //release wheel
	                        releaseScroll &#x3D; o.allowPageScroll;

	                        // publish approporiate event
	                        if (lastScroll !&#x3D; percentScroll) {
	                            var msg &#x3D; (~~percentScroll &#x3D;&#x3D; 0) ? &#x27;top&#x27; : &#x27;bottom&#x27;;
	                            me.trigger(&#x27;slimscroll&#x27;, msg);
	                        }
	                    }
	                    else {
	                        releaseScroll &#x3D; false;
	                    }
	                    lastScroll &#x3D; percentScroll;

	                    // show only when required
	                    if (barHeight &gt;&#x3D; me.outerHeight()) {
	                        //allow window scroll
	                        releaseScroll &#x3D; true;
	                        return;
	                    }
	                    bar.stop(true, true).fadeIn(&#x27;fast&#x27;);
	                    if (o.railVisible) {
	                        rail.stop(true, true).fadeIn(&#x27;fast&#x27;);
	                    }
	                }

	                function hideBar() {
	                    // only hide when options allow it
	                    if (!o.alwaysVisible) {
	                        queueHide &#x3D; setTimeout(function () {
	                            if (!(o.disableFadeOut &amp;&amp; isOverPanel) &amp;&amp; !isOverBar &amp;&amp; !isDragg) {
	                                bar.fadeOut(&#x27;slow&#x27;);
	                                rail.fadeOut(&#x27;slow&#x27;);
	                            }
	                        }, 1000);
	                    }
	                }

	            });

	            // maintain chainability
	            return this;
	        }
	    });

	    $.fn.extend({
	        slimscroll: $.fn.slimScroll
	    });

	})(jQuery);


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30);

	jQuery(function ($) {
	    &quot;use strict&quot;;

	    var counter &#x3D; $(&#x27;.counter&#x27;);

	    counter.each(function () {
	        var $this &#x3D; $(this);
	        var eventDate &#x3D; $this.data(&#x27;date&#x27;);
	        var targetDate &#x3D; new Date(eventDate),
	            finished &#x3D; false,
	            availiableExamples &#x3D; {
	                set15daysFromNow: 15 * 24 * 60 * 60 * 1000,
	                set5minFromNow: 5 * 60 * 1000,
	                set1minFromNow: 1 * 60 * 1000
	            };

	        function callback(event) {
	            var $this &#x3D; $(this);
	            switch (event.type) {
	                case &quot;seconds&quot;:
	                case &quot;minutes&quot;:
	                case &quot;hours&quot;:
	                case &quot;days&quot;:
	                case &quot;weeks&quot;:
	                case &quot;daysLeft&quot;:
	                    $this.find(&#x27;div span.&#x27; + event.type).html(event.value);
	                    if (finished) {
	                        $this.fadeTo(0, 1);
	                        finished &#x3D; false;
	                    }

	                    break;
	                case &quot;finished&quot;:
	                    $this.fadeTo(&#x27;slow&#x27;, .5);
	                    finished &#x3D; true;
	                    break;
	            }
	        }

	        $this.countdown(targetDate.valueOf(), callback);

	    });
	});

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	/*
	 * jQuery The Final Countdown plugin v1.0.0 beta
	 * http://github.com/hilios/jquery.countdown
	 *
	 * Copyright (c) 2011 Edson Hilios
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * &quot;Software&quot;), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	(function($) {
	  
	  $.fn.countdown &#x3D; function(toDate, callback) {
	    var handlers &#x3D; [&#x27;seconds&#x27;, &#x27;minutes&#x27;, &#x27;hours&#x27;, &#x27;days&#x27;, &#x27;weeks&#x27;, &#x27;daysLeft&#x27;];
	    
	    function delegate(scope, method) {
	      return function() { return method.call(scope) }
	    }
	    
	    return this.each(function() {
	      // Convert
	      if(!(toDate instanceof Date)) {
	        if(String(toDate).match(/^[0-9]*$/)) {
	          toDate &#x3D; new Date(toDate);
	        } else if( toDate.match(/([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{2,4})\s([0-9]{1,2})\:([0-9]{2})\:([0-9]{2})/) ||
	            toDate.match(/([0-9]{2,4})\/([0-9]{1,2})\/([0-9]{1,2})\s([0-9]{1,2})\:([0-9]{2})\:([0-9]{2})/)
	            ) {
	          toDate &#x3D; new Date(toDate);
	        } else if(toDate.match(/([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{2,4})/) || 
	                  toDate.match(/([0-9]{2,4})\/([0-9]{1,2})\/([0-9]{1,2})/)
	                  ) {
	          toDate &#x3D; new Date(toDate)
	        } else {
	          throw new Error(&quot;Doesn&#x27;t seen to be a valid date object or string&quot;)
	        }
	      }
	      
	      var $this &#x3D; $(this),
	          values &#x3D; {},
	          lasting &#x3D; {},
	          interval &#x3D; $this.data(&#x27;countdownInterval&#x27;),
	          currentDate &#x3D; new Date(),
	          secondsLeft &#x3D; Math.floor((toDate.valueOf() - currentDate.valueOf()) / 1000);
	      
	      function triggerEvents() {
	        secondsLeft--;
	        if(secondsLeft &lt; 0) {
	          secondsLeft &#x3D; 0;
	        }
	        lasting &#x3D; {
	          seconds : secondsLeft % 60,
	          minutes : Math.floor(secondsLeft / 60) % 60,
	          hours   : Math.floor(secondsLeft / 60 / 60) % 24,
	          days    : Math.floor(secondsLeft / 60 / 60 / 24),
	          weeks   : Math.floor(secondsLeft / 60 / 60 / 24 / 7),
	          daysLeft: Math.floor(secondsLeft / 60 / 60 / 24) % 7
	        }
	        for(var i&#x3D;0; i&lt;handlers.length; i++) {
	          var eventName &#x3D; handlers[i];
	          if(values[eventName] !&#x3D; lasting[eventName]) {
	            values[eventName] &#x3D; lasting[eventName];
	            dispatchEvent(eventName);
	          }
	        }
	        if(secondsLeft &#x3D;&#x3D; 0) { 
	          stop();
	          dispatchEvent(&#x27;finished&#x27;);
	        }
	      }
	      triggerEvents();
	      
	      function dispatchEvent(eventName) {
	        var event &#x3D; $.Event(eventName);
	        event.date  &#x3D; new Date(new Date().valueOf() + secondsLeft);
	        event.value &#x3D; values[eventName] || &quot;0&quot;;
	        event.toDate &#x3D; toDate;
	        event.lasting &#x3D; lasting;
	        switch(eventName) {
	          case &quot;seconds&quot;:
	          case &quot;minutes&quot;:
	          case &quot;hours&quot;:
	            event.value &#x3D; event.value &lt; 10 ? &#x27;0&#x27;+event.value.toString() : event.value.toString();
	            break;
	          default:
	            if(event.value) {
	              event.value &#x3D; event.value.toString();
	            }
	            break;
	        }
	        callback.call($this, event);
	      }
	      
	      $this.bind(&#x27;remove&#x27;, function() {
	        stop(); // If the selector is removed clear the interval for memory sake!
	        dispatchEvent(&#x27;removed&#x27;);
	      });
	      
	      function stop() {
	        clearInterval(interval);
	      }

	      function start() {
	        $this.data(&#x27;countdownInterval&#x27;, setInterval(delegate($this, triggerEvents), 1000));
	        interval &#x3D; $this.data(&#x27;countdownInterval&#x27;);
	      }
	      
	      if(interval) stop();
	      start();
	    });
	  }
	  // Wrap the remove method to trigger an event when called
	  var removeEvent &#x3D; new $.Event(&#x27;remove&#x27;),
	      removeFunction &#x3D; $.fn.remove;
	  $.fn.remove &#x3D; function() {
	    $(this).trigger(removeEvent);
	    return removeFunction.apply(this, arguments);
	  }
	})(jQuery);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30);

	jQuery(function ($) {
	    &quot;use strict&quot;;

	    // Initialize Counters
	    $(&#x27;.sc-counter&#x27;).each(function () {
	        $(this).data(&#x27;value&#x27;, $(this).text()).text(0);
	    });

	    counterStart();

	    // Check If Counter In Viewport
	    $(window).on(&#x27;load resize scroll&#x27;, function () {
	        counterStart();
	    });

	    function counterStart() {
	        $(&#x27;.sc-counter&#x27;).each(function () {

	            /* Counter Elements */
	            var counter &#x3D; $(this);

	            /* Counter Variables */
	            var counter_value &#x3D; counter.data(&#x27;value&#x27;);

	            var counter_animated &#x3D; counter.hasClass(&#x27;counter-animated&#x27;);

	            /* Animate If In Viewport */
	            if (isElementInViewport(counter) &amp;&amp; !counter_animated) {

	                counter.addClass(&#x27;counter-animated&#x27;);
	                $({startVal: 0}).animate({startVal: counter_value},
	                    {
	                        duration: 3000,
	                        easing: &#x27;swing&#x27;,
	                        step: function () {
	                            counter.text(getNumberWithCommas(Math.ceil(this.startVal)));
	                        }
	                    }
	                );

	            }
	        });
	    }

	});


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(33);
	jQuery(function ($) {
	    &quot;use strict&quot;;
	    var Charts &#x3D; {
	        _HYPHY_REGEX: /-([a-z])/g,
	        _cleanAttr: function (t) {
	            delete t.chart, delete t.datasets, delete t.datasetsOptions, delete t.labels, delete t.options
	        },
	         doughnut: function (element) {
	            var attrData &#x3D; $.extend({}, $(element).data()),
	                data &#x3D; attrData.dataset ? eval(attrData.dataset) : {},
	                dataOptions &#x3D; attrData.datasetOptions ? eval(&quot;(&quot; + attrData.datasetOptions + &quot;)&quot;) : {},
	                labels &#x3D; attrData.labels ? eval(attrData.labels) : {},
	                options &#x3D; attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {};

	            Charts._cleanAttr(attrData);
	            var datasets &#x3D; $.extend({
	                    data: data,
	                    borderWidth: 2,
	                    hoverBorderColor: &quot;transparent&quot;
	                }, dataOptions),
	                options &#x3D; $.extend({
	                    cutoutPercentage: 80,
	                    legend: {
	                        display: !1
	                    },
	                    animation: {
	                        animateRotate: !1,
	                        duration: 0
	                    }
	                }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;doughnut&quot;,
	                data: {
	                    datasets: [datasets],
	                    labels: labels
	                },
	                options: options
	            })
	        },
	        &quot;spark-line&quot;: function (element) {
	            var attrData &#x3D; $.extend({}, $(element).data()),
	                data &#x3D; attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions &#x3D; attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels &#x3D; attrData.labels ? eval(attrData.labels) : {},
	                options &#x3D; attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                data &#x3D; {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: &quot;rgba(255,255,255,.3)&quot;,
	                            borderColor: &quot;#fff&quot;,
	                            pointBorderColor: &quot;#fff&quot;,
	                            lineTension: .25,
	                            pointRadius: 0
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options &#x3D; $.extend({
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    xAxes: [{
	                        display: !1
	                    }],
	                    yAxes: [{
	                        display: !1
	                    }]
	                },
	                tooltips: {
	                    enabled: !1
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;bar&quot;,
	                data: data,
	                options: options
	            })
	        },
	         line: function (element) {
	            var attrData &#x3D; $.extend({}, $(element).data()),
	                data &#x3D; attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions &#x3D; attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels &#x3D; attrData.labels ? eval(attrData.labels) : {},
	                options &#x3D; attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark &#x3D; !!attrData.dark,
	                data &#x3D; {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: isDark ? &quot;rgba(28,168,221,.03)&quot; : &quot;rgba(66,165,245,.2)&quot;,
	                            borderColor: &quot;#42a5f5&quot;,
	                            pointBorderColor: &quot;#fff&quot;,
	                            lineTension: .25,
	                            pointRadius: 0,
	                            pointHoverRadius: 0,
	                            pointHitRadius: 20
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options &#x3D; $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            beginAtZero: !1,
	                            fixedStepSize: 1e3,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14,
	                    callbacks: {
	                        title: function () {
	                            return &quot;&quot;
	                        },
	                        labelColor: function () {
	                            return {
	                                backgroundColor: &quot;#42a5f5&quot;,
	                                borderColor: &quot;#42a5f5&quot;
	                            }
	                        }
	                    }
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;line&quot;,
	                data: data,
	                options: options
	            })
	        },
	         bar: function (element) {
	            var attrData &#x3D; $.extend({}, $(element).data()),
	                data &#x3D; attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions &#x3D; attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels &#x3D; attrData.labels ? eval(attrData.labels) : {},
	                options &#x3D; attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark &#x3D; !!attrData.dark,
	                data &#x3D; {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? &quot;#42a5f5&quot; : &quot;#1bc98e&quot;,
	                            borderColor: &quot;transparent&quot;
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options &#x3D; $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;bar&quot;,
	                data: data,
	                options: options
	            })
	        },
	         pie: function (element) {
	            var attrData &#x3D; $.extend({}, $(element).data()),
	                data &#x3D; attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions &#x3D; attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels &#x3D; attrData.labels ? eval(attrData.labels) : {},
	                options &#x3D; attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark &#x3D; !!attrData.dark,
	                data &#x3D; {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? &quot;#42a5f5&quot; : &quot;#1bc98e&quot;,
	                            borderColor: &quot;transparent&quot;
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options &#x3D; $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;pie&quot;,
	                data: data,
	                options: options
	            })
	        },
	         radar: function (element) {
	            var attrData &#x3D; $.extend({}, $(element).data()),
	                data &#x3D; attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions &#x3D; attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels &#x3D; attrData.labels ? eval(attrData.labels) : {},
	                options &#x3D; attrData.options ? eval(&quot;(&quot; + attrData.options + &quot;)&quot;) : {},
	                isDark &#x3D; !!attrData.dark,
	                data &#x3D; {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? &quot;#42a5f5&quot; : &quot;#1bc98e&quot;,
	                            borderColor: &quot;transparent&quot;
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options &#x3D; $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            zeroLineColor: isDark ? &quot;rgba(255,255,255,.05)&quot; : &quot;rgba(0,0,0,.05)&quot;,
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? &quot;#a2a2a2&quot; : &quot;rgba(0,0,0,.4)&quot;,
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext(&quot;2d&quot;), {
	                type: &quot;radar&quot;,
	                data: data,
	                options: options
	            })
	        }
	    };

	    $(&quot;[data-chart]&quot;).each(function () {
	        $(this).is(&quot;:visible&quot;)
	        &amp;&amp; !$(this).hasClass(&quot;js-chart-drawn&quot;)
	        &amp;&amp; (Charts[$(this).attr(&quot;data-chart&quot;)](this), $(this).addClass(&quot;js-chart-drawn&quot;))
	    })

	});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @namespace Chart
	 */
	var Chart &#x3D; __webpack_require__(34)();

	Chart.helpers &#x3D; __webpack_require__(36);

	// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
	__webpack_require__(41)(Chart);

	Chart.defaults &#x3D; __webpack_require__(35);
	Chart.Element &#x3D; __webpack_require__(47);
	Chart.elements &#x3D; __webpack_require__(48);
	Chart.Interaction &#x3D; __webpack_require__(53);
	Chart.layouts &#x3D; __webpack_require__(54);
	Chart.platform &#x3D; __webpack_require__(55);
	Chart.plugins &#x3D; __webpack_require__(58);
	Chart.Ticks &#x3D; __webpack_require__(59);

	__webpack_require__(60)(Chart);
	__webpack_require__(61)(Chart);
	__webpack_require__(62)(Chart);
	__webpack_require__(63)(Chart);
	__webpack_require__(64)(Chart);
	__webpack_require__(65)(Chart);

	__webpack_require__(66)(Chart);
	__webpack_require__(67)(Chart);
	__webpack_require__(68)(Chart);
	__webpack_require__(69)(Chart);
	__webpack_require__(70)(Chart);
	__webpack_require__(71)(Chart);

	// Controllers must be loaded after elements
	// See Chart.core.datasetController.dataElementType
	__webpack_require__(197)(Chart);
	__webpack_require__(198)(Chart);
	__webpack_require__(199)(Chart);
	__webpack_require__(200)(Chart);
	__webpack_require__(201)(Chart);
	__webpack_require__(202)(Chart);
	__webpack_require__(203)(Chart);

	__webpack_require__(204)(Chart);
	__webpack_require__(205)(Chart);
	__webpack_require__(206)(Chart);
	__webpack_require__(207)(Chart);
	__webpack_require__(208)(Chart);
	__webpack_require__(209)(Chart);
	__webpack_require__(210)(Chart);

	// Loading built-it plugins
	var plugins &#x3D; __webpack_require__(211);
	for (var k in plugins) {
		if (plugins.hasOwnProperty(k)) {
			Chart.plugins.register(plugins[k]);
		}
	}

	Chart.platform.initialize();

	module.exports &#x3D; Chart;
	if (typeof window !&#x3D;&#x3D; &#x27;undefined&#x27;) {
		window.Chart &#x3D; Chart;
	}

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, not available anymore
	 * @namespace Chart.Legend
	 * @deprecated since version 2.1.5
	 * @todo remove at version 3
	 * @private
	 */
	Chart.Legend &#x3D; plugins.legend._element;

	/**
	 * Provided for backward compatibility, not available anymore
	 * @namespace Chart.Title
	 * @deprecated since version 2.1.5
	 * @todo remove at version 3
	 * @private
	 */
	Chart.Title &#x3D; plugins.title._element;

	/**
	 * Provided for backward compatibility, use Chart.plugins instead
	 * @namespace Chart.pluginService
	 * @deprecated since version 2.1.5
	 * @todo remove at version 3
	 * @private
	 */
	Chart.pluginService &#x3D; Chart.plugins;

	/**
	 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
	 * effect, instead simply create/register plugins via plain JavaScript objects.
	 * @interface Chart.PluginBase
	 * @deprecated since version 2.5.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.PluginBase &#x3D; Chart.Element.extend({});

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas instead.
	 * @namespace Chart.canvasHelpers
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.canvasHelpers &#x3D; Chart.helpers.canvas;

	/**
	 * Provided for backward compatibility, use Chart.layouts instead.
	 * @namespace Chart.layoutService
	 * @deprecated since version 2.8.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.layoutService &#x3D; Chart.layouts;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);

	defaults._set(&#x27;global&#x27;, {
		responsive: true,
		responsiveAnimationDuration: 0,
		maintainAspectRatio: true,
		events: [&#x27;mousemove&#x27;, &#x27;mouseout&#x27;, &#x27;click&#x27;, &#x27;touchstart&#x27;, &#x27;touchmove&#x27;],
		hover: {
			onHover: null,
			mode: &#x27;nearest&#x27;,
			intersect: true,
			animationDuration: 400
		},
		onClick: null,
		defaultColor: &#x27;rgba(0,0,0,0.1)&#x27;,
		defaultFontColor: &#x27;#666&#x27;,
		defaultFontFamily: &quot;&#x27;Helvetica Neue&#x27;, &#x27;Helvetica&#x27;, &#x27;Arial&#x27;, sans-serif&quot;,
		defaultFontSize: 12,
		defaultFontStyle: &#x27;normal&#x27;,
		showLines: true,

		// Element defaults defined in element extensions
		elements: {},

		// Layout options such as padding
		layout: {
			padding: {
				top: 0,
				right: 0,
				bottom: 0,
				left: 0
			}
		}
	});

	module.exports &#x3D; function() {

		// Occupy the global variable of Chart, and create a simple base class
		var Chart &#x3D; function(item, config) {
			this.construct(item, config);
			return this;
		};

		Chart.Chart &#x3D; Chart;

		return Chart;
	};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);

	module.exports &#x3D; {
		/**
		 * @private
		 */
		_set: function(scope, values) {
			return helpers.merge(this[scope] || (this[scope] &#x3D; {}), values);
		}
	};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; __webpack_require__(37);
	module.exports.easing &#x3D; __webpack_require__(38);
	module.exports.canvas &#x3D; __webpack_require__(39);
	module.exports.options &#x3D; __webpack_require__(40);


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	/**
	 * @namespace Chart.helpers
	 */
	var helpers &#x3D; {
		/**
		 * An empty function that can be used, for example, for optional callback.
		 */
		noop: function() {},

		/**
		 * Returns a unique id, sequentially generated from a global variable.
		 * @returns {Number}
		 * @function
		 */
		uid: (function() {
			var id &#x3D; 0;
			return function() {
				return id++;
			};
		}()),

		/**
		 * Returns true if &#x60;value&#x60; is neither null nor undefined, else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @since 2.7.0
		 */
		isNullOrUndef: function(value) {
			return value &#x3D;&#x3D;&#x3D; null || typeof value &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;;
		},

		/**
		 * Returns true if &#x60;value&#x60; is an array, else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @function
		 */
		isArray: Array.isArray ? Array.isArray : function(value) {
			return Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &#x27;[object Array]&#x27;;
		},

		/**
		 * Returns true if &#x60;value&#x60; is an object (excluding null), else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @since 2.7.0
		 */
		isObject: function(value) {
			return value !&#x3D;&#x3D; null &amp;&amp; Object.prototype.toString.call(value) &#x3D;&#x3D;&#x3D; &#x27;[object Object]&#x27;;
		},

		/**
		 * Returns &#x60;value&#x60; if defined, else returns &#x60;defaultValue&#x60;.
		 * @param {*} value - The value to return if defined.
		 * @param {*} defaultValue - The value to return if &#x60;value&#x60; is undefined.
		 * @returns {*}
		 */
		valueOrDefault: function(value, defaultValue) {
			return typeof value &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; ? defaultValue : value;
		},

		/**
		 * Returns value at the given &#x60;index&#x60; in array if defined, else returns &#x60;defaultValue&#x60;.
		 * @param {Array} value - The array to lookup for value at &#x60;index&#x60;.
		 * @param {Number} index - The index in &#x60;value&#x60; to lookup for value.
		 * @param {*} defaultValue - The value to return if &#x60;value[index]&#x60; is undefined.
		 * @returns {*}
		 */
		valueAtIndexOrDefault: function(value, index, defaultValue) {
			return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
		},

		/**
		 * Calls &#x60;fn&#x60; with the given &#x60;args&#x60; in the scope defined by &#x60;thisArg&#x60; and returns the
		 * value returned by &#x60;fn&#x60;. If &#x60;fn&#x60; is not a function, this method returns undefined.
		 * @param {Function} fn - The function to call.
		 * @param {Array|undefined|null} args - The arguments with which &#x60;fn&#x60; should be called.
		 * @param {Object} [thisArg] - The value of &#x60;this&#x60; provided for the call to &#x60;fn&#x60;.
		 * @returns {*}
		 */
		callback: function(fn, args, thisArg) {
			if (fn &amp;&amp; typeof fn.call &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
				return fn.apply(thisArg, args);
			}
		},

		/**
		 * Note(SB) for performance sake, this method should only be used when loopable type
		 * is unknown or in none intensive code (not called often and small loopable). Else
		 * it&#x27;s preferable to use a regular for() loop and save extra function calls.
		 * @param {Object|Array} loopable - The object or array to be iterated.
		 * @param {Function} fn - The function to call for each item.
		 * @param {Object} [thisArg] - The value of &#x60;this&#x60; provided for the call to &#x60;fn&#x60;.
		 * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
		 */
		each: function(loopable, fn, thisArg, reverse) {
			var i, len, keys;
			if (helpers.isArray(loopable)) {
				len &#x3D; loopable.length;
				if (reverse) {
					for (i &#x3D; len - 1; i &gt;&#x3D; 0; i--) {
						fn.call(thisArg, loopable[i], i);
					}
				} else {
					for (i &#x3D; 0; i &lt; len; i++) {
						fn.call(thisArg, loopable[i], i);
					}
				}
			} else if (helpers.isObject(loopable)) {
				keys &#x3D; Object.keys(loopable);
				len &#x3D; keys.length;
				for (i &#x3D; 0; i &lt; len; i++) {
					fn.call(thisArg, loopable[keys[i]], keys[i]);
				}
			}
		},

		/**
		 * Returns true if the &#x60;a0&#x60; and &#x60;a1&#x60; arrays have the same content, else returns false.
		 * @see http://stackoverflow.com/a/14853974
		 * @param {Array} a0 - The array to compare
		 * @param {Array} a1 - The array to compare
		 * @returns {Boolean}
		 */
		arrayEquals: function(a0, a1) {
			var i, ilen, v0, v1;

			if (!a0 || !a1 || a0.length !&#x3D;&#x3D; a1.length) {
				return false;
			}

			for (i &#x3D; 0, ilen &#x3D; a0.length; i &lt; ilen; ++i) {
				v0 &#x3D; a0[i];
				v1 &#x3D; a1[i];

				if (v0 instanceof Array &amp;&amp; v1 instanceof Array) {
					if (!helpers.arrayEquals(v0, v1)) {
						return false;
					}
				} else if (v0 !&#x3D;&#x3D; v1) {
					// NOTE: two different object instances will never be equal: {x:20} !&#x3D; {x:20}
					return false;
				}
			}

			return true;
		},

		/**
		 * Returns a deep copy of &#x60;source&#x60; without keeping references on objects and arrays.
		 * @param {*} source - The value to clone.
		 * @returns {*}
		 */
		clone: function(source) {
			if (helpers.isArray(source)) {
				return source.map(helpers.clone);
			}

			if (helpers.isObject(source)) {
				var target &#x3D; {};
				var keys &#x3D; Object.keys(source);
				var klen &#x3D; keys.length;
				var k &#x3D; 0;

				for (; k &lt; klen; ++k) {
					target[keys[k]] &#x3D; helpers.clone(source[keys[k]]);
				}

				return target;
			}

			return source;
		},

		/**
		 * The default merger when Chart.helpers.merge is called without merger option.
		 * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
		 * @private
		 */
		_merger: function(key, target, source, options) {
			var tval &#x3D; target[key];
			var sval &#x3D; source[key];

			if (helpers.isObject(tval) &amp;&amp; helpers.isObject(sval)) {
				helpers.merge(tval, sval, options);
			} else {
				target[key] &#x3D; helpers.clone(sval);
			}
		},

		/**
		 * Merges source[key] in target[key] only if target[key] is undefined.
		 * @private
		 */
		_mergerIf: function(key, target, source) {
			var tval &#x3D; target[key];
			var sval &#x3D; source[key];

			if (helpers.isObject(tval) &amp;&amp; helpers.isObject(sval)) {
				helpers.mergeIf(tval, sval);
			} else if (!target.hasOwnProperty(key)) {
				target[key] &#x3D; helpers.clone(sval);
			}
		},

		/**
		 * Recursively deep copies &#x60;source&#x60; properties into &#x60;target&#x60; with the given &#x60;options&#x60;.
		 * IMPORTANT: &#x60;target&#x60; is not cloned and will be updated with &#x60;source&#x60; properties.
		 * @param {Object} target - The target object in which all sources are merged into.
		 * @param {Object|Array(Object)} source - Object(s) to merge into &#x60;target&#x60;.
		 * @param {Object} [options] - Merging options:
		 * @param {Function} [options.merger] - The merge method (key, target, source, options)
		 * @returns {Object} The &#x60;target&#x60; object.
		 */
		merge: function(target, source, options) {
			var sources &#x3D; helpers.isArray(source) ? source : [source];
			var ilen &#x3D; sources.length;
			var merge, i, keys, klen, k;

			if (!helpers.isObject(target)) {
				return target;
			}

			options &#x3D; options || {};
			merge &#x3D; options.merger || helpers._merger;

			for (i &#x3D; 0; i &lt; ilen; ++i) {
				source &#x3D; sources[i];
				if (!helpers.isObject(source)) {
					continue;
				}

				keys &#x3D; Object.keys(source);
				for (k &#x3D; 0, klen &#x3D; keys.length; k &lt; klen; ++k) {
					merge(keys[k], target, source, options);
				}
			}

			return target;
		},

		/**
		 * Recursively deep copies &#x60;source&#x60; properties into &#x60;target&#x60; *only* if not defined in target.
		 * IMPORTANT: &#x60;target&#x60; is not cloned and will be updated with &#x60;source&#x60; properties.
		 * @param {Object} target - The target object in which all sources are merged into.
		 * @param {Object|Array(Object)} source - Object(s) to merge into &#x60;target&#x60;.
		 * @returns {Object} The &#x60;target&#x60; object.
		 */
		mergeIf: function(target, source) {
			return helpers.merge(target, source, {merger: helpers._mergerIf});
		},

		/**
		 * Applies the contents of two or more objects together into the first object.
		 * @param {Object} target - The target object in which all objects are merged into.
		 * @param {Object} arg1 - Object containing additional properties to merge in target.
		 * @param {Object} argN - Additional objects containing properties to merge in target.
		 * @returns {Object} The &#x60;target&#x60; object.
		 */
		extend: function(target) {
			var setFn &#x3D; function(value, key) {
				target[key] &#x3D; value;
			};
			for (var i &#x3D; 1, ilen &#x3D; arguments.length; i &lt; ilen; ++i) {
				helpers.each(arguments[i], setFn);
			}
			return target;
		},

		/**
		 * Basic javascript inheritance based on the model created in Backbone.js
		 */
		inherits: function(extensions) {
			var me &#x3D; this;
			var ChartElement &#x3D; (extensions &amp;&amp; extensions.hasOwnProperty(&#x27;constructor&#x27;)) ? extensions.constructor : function() {
				return me.apply(this, arguments);
			};

			var Surrogate &#x3D; function() {
				this.constructor &#x3D; ChartElement;
			};

			Surrogate.prototype &#x3D; me.prototype;
			ChartElement.prototype &#x3D; new Surrogate();
			ChartElement.extend &#x3D; helpers.inherits;

			if (extensions) {
				helpers.extend(ChartElement.prototype, extensions);
			}

			ChartElement.__super__ &#x3D; me.prototype;
			return ChartElement;
		}
	};

	module.exports &#x3D; helpers;

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.callback instead.
	 * @function Chart.helpers.callCallback
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.callCallback &#x3D; helpers.callback;

	/**
	 * Provided for backward compatibility, use Array.prototype.indexOf instead.
	 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
	 * @function Chart.helpers.indexOf
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.indexOf &#x3D; function(array, item, fromIndex) {
		return Array.prototype.indexOf.call(array, item, fromIndex);
	};

	/**
	 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
	 * @function Chart.helpers.getValueOrDefault
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.getValueOrDefault &#x3D; helpers.valueOrDefault;

	/**
	 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
	 * @function Chart.helpers.getValueAtIndexOrDefault
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.getValueAtIndexOrDefault &#x3D; helpers.valueAtIndexOrDefault;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(37);

	/**
	 * Easing functions adapted from Robert Penner&#x27;s easing equations.
	 * @namespace Chart.helpers.easingEffects
	 * @see http://www.robertpenner.com/easing/
	 */
	var effects &#x3D; {
		linear: function(t) {
			return t;
		},

		easeInQuad: function(t) {
			return t * t;
		},

		easeOutQuad: function(t) {
			return -t * (t - 2);
		},

		easeInOutQuad: function(t) {
			if ((t /&#x3D; 0.5) &lt; 1) {
				return 0.5 * t * t;
			}
			return -0.5 * ((--t) * (t - 2) - 1);
		},

		easeInCubic: function(t) {
			return t * t * t;
		},

		easeOutCubic: function(t) {
			return (t &#x3D; t - 1) * t * t + 1;
		},

		easeInOutCubic: function(t) {
			if ((t /&#x3D; 0.5) &lt; 1) {
				return 0.5 * t * t * t;
			}
			return 0.5 * ((t -&#x3D; 2) * t * t + 2);
		},

		easeInQuart: function(t) {
			return t * t * t * t;
		},

		easeOutQuart: function(t) {
			return -((t &#x3D; t - 1) * t * t * t - 1);
		},

		easeInOutQuart: function(t) {
			if ((t /&#x3D; 0.5) &lt; 1) {
				return 0.5 * t * t * t * t;
			}
			return -0.5 * ((t -&#x3D; 2) * t * t * t - 2);
		},

		easeInQuint: function(t) {
			return t * t * t * t * t;
		},

		easeOutQuint: function(t) {
			return (t &#x3D; t - 1) * t * t * t * t + 1;
		},

		easeInOutQuint: function(t) {
			if ((t /&#x3D; 0.5) &lt; 1) {
				return 0.5 * t * t * t * t * t;
			}
			return 0.5 * ((t -&#x3D; 2) * t * t * t * t + 2);
		},

		easeInSine: function(t) {
			return -Math.cos(t * (Math.PI / 2)) + 1;
		},

		easeOutSine: function(t) {
			return Math.sin(t * (Math.PI / 2));
		},

		easeInOutSine: function(t) {
			return -0.5 * (Math.cos(Math.PI * t) - 1);
		},

		easeInExpo: function(t) {
			return (t &#x3D;&#x3D;&#x3D; 0) ? 0 : Math.pow(2, 10 * (t - 1));
		},

		easeOutExpo: function(t) {
			return (t &#x3D;&#x3D;&#x3D; 1) ? 1 : -Math.pow(2, -10 * t) + 1;
		},

		easeInOutExpo: function(t) {
			if (t &#x3D;&#x3D;&#x3D; 0) {
				return 0;
			}
			if (t &#x3D;&#x3D;&#x3D; 1) {
				return 1;
			}
			if ((t /&#x3D; 0.5) &lt; 1) {
				return 0.5 * Math.pow(2, 10 * (t - 1));
			}
			return 0.5 * (-Math.pow(2, -10 * --t) + 2);
		},

		easeInCirc: function(t) {
			if (t &gt;&#x3D; 1) {
				return t;
			}
			return -(Math.sqrt(1 - t * t) - 1);
		},

		easeOutCirc: function(t) {
			return Math.sqrt(1 - (t &#x3D; t - 1) * t);
		},

		easeInOutCirc: function(t) {
			if ((t /&#x3D; 0.5) &lt; 1) {
				return -0.5 * (Math.sqrt(1 - t * t) - 1);
			}
			return 0.5 * (Math.sqrt(1 - (t -&#x3D; 2) * t) + 1);
		},

		easeInElastic: function(t) {
			var s &#x3D; 1.70158;
			var p &#x3D; 0;
			var a &#x3D; 1;
			if (t &#x3D;&#x3D;&#x3D; 0) {
				return 0;
			}
			if (t &#x3D;&#x3D;&#x3D; 1) {
				return 1;
			}
			if (!p) {
				p &#x3D; 0.3;
			}
			if (a &lt; 1) {
				a &#x3D; 1;
				s &#x3D; p / 4;
			} else {
				s &#x3D; p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return -(a * Math.pow(2, 10 * (t -&#x3D; 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
		},

		easeOutElastic: function(t) {
			var s &#x3D; 1.70158;
			var p &#x3D; 0;
			var a &#x3D; 1;
			if (t &#x3D;&#x3D;&#x3D; 0) {
				return 0;
			}
			if (t &#x3D;&#x3D;&#x3D; 1) {
				return 1;
			}
			if (!p) {
				p &#x3D; 0.3;
			}
			if (a &lt; 1) {
				a &#x3D; 1;
				s &#x3D; p / 4;
			} else {
				s &#x3D; p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
		},

		easeInOutElastic: function(t) {
			var s &#x3D; 1.70158;
			var p &#x3D; 0;
			var a &#x3D; 1;
			if (t &#x3D;&#x3D;&#x3D; 0) {
				return 0;
			}
			if ((t /&#x3D; 0.5) &#x3D;&#x3D;&#x3D; 2) {
				return 1;
			}
			if (!p) {
				p &#x3D; 0.45;
			}
			if (a &lt; 1) {
				a &#x3D; 1;
				s &#x3D; p / 4;
			} else {
				s &#x3D; p / (2 * Math.PI) * Math.asin(1 / a);
			}
			if (t &lt; 1) {
				return -0.5 * (a * Math.pow(2, 10 * (t -&#x3D; 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (t -&#x3D; 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
		},
		easeInBack: function(t) {
			var s &#x3D; 1.70158;
			return t * t * ((s + 1) * t - s);
		},

		easeOutBack: function(t) {
			var s &#x3D; 1.70158;
			return (t &#x3D; t - 1) * t * ((s + 1) * t + s) + 1;
		},

		easeInOutBack: function(t) {
			var s &#x3D; 1.70158;
			if ((t /&#x3D; 0.5) &lt; 1) {
				return 0.5 * (t * t * (((s *&#x3D; (1.525)) + 1) * t - s));
			}
			return 0.5 * ((t -&#x3D; 2) * t * (((s *&#x3D; (1.525)) + 1) * t + s) + 2);
		},

		easeInBounce: function(t) {
			return 1 - effects.easeOutBounce(1 - t);
		},

		easeOutBounce: function(t) {
			if (t &lt; (1 / 2.75)) {
				return 7.5625 * t * t;
			}
			if (t &lt; (2 / 2.75)) {
				return 7.5625 * (t -&#x3D; (1.5 / 2.75)) * t + 0.75;
			}
			if (t &lt; (2.5 / 2.75)) {
				return 7.5625 * (t -&#x3D; (2.25 / 2.75)) * t + 0.9375;
			}
			return 7.5625 * (t -&#x3D; (2.625 / 2.75)) * t + 0.984375;
		},

		easeInOutBounce: function(t) {
			if (t &lt; 0.5) {
				return effects.easeInBounce(t * 2) * 0.5;
			}
			return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
		}
	};

	module.exports &#x3D; {
		effects: effects
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
	 * @function Chart.helpers.easingEffects
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.easingEffects &#x3D; effects;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(37);

	/**
	 * @namespace Chart.helpers.canvas
	 */
	var exports &#x3D; module.exports &#x3D; {
		/**
		 * Clears the entire canvas associated to the given &#x60;chart&#x60;.
		 * @param {Chart} chart - The chart for which to clear the canvas.
		 */
		clear: function(chart) {
			chart.ctx.clearRect(0, 0, chart.width, chart.height);
		},

		/**
		 * Creates a &quot;path&quot; for a rectangle with rounded corners at position (x, y) with a
		 * given size (width, height) and the same &#x60;radius&#x60; for all corners.
		 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
		 * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
		 * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
		 * @param {Number} width - The rectangle&#x27;s width.
		 * @param {Number} height - The rectangle&#x27;s height.
		 * @param {Number} radius - The rounded amount (in pixels) for the four corners.
		 * @todo handle &#x60;radius&#x60; as top-left, top-right, bottom-right, bottom-left array/object?
		 */
		roundedRect: function(ctx, x, y, width, height, radius) {
			if (radius) {
				var rx &#x3D; Math.min(radius, width / 2);
				var ry &#x3D; Math.min(radius, height / 2);

				ctx.moveTo(x + rx, y);
				ctx.lineTo(x + width - rx, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
				ctx.lineTo(x + width, y + height - ry);
				ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
				ctx.lineTo(x + rx, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
				ctx.lineTo(x, y + ry);
				ctx.quadraticCurveTo(x, y, x + rx, y);
			} else {
				ctx.rect(x, y, width, height);
			}
		},

		drawPoint: function(ctx, style, radius, x, y) {
			var type, edgeLength, xOffset, yOffset, height, size;

			if (style &amp;&amp; typeof style &#x3D;&#x3D;&#x3D; &#x27;object&#x27;) {
				type &#x3D; style.toString();
				if (type &#x3D;&#x3D;&#x3D; &#x27;[object HTMLImageElement]&#x27; || type &#x3D;&#x3D;&#x3D; &#x27;[object HTMLCanvasElement]&#x27;) {
					ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
					return;
				}
			}

			if (isNaN(radius) || radius &lt;&#x3D; 0) {
				return;
			}

			switch (style) {
			// Default includes circle
			default:
				ctx.beginPath();
				ctx.arc(x, y, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;triangle&#x27;:
				ctx.beginPath();
				edgeLength &#x3D; 3 * radius / Math.sqrt(3);
				height &#x3D; edgeLength * Math.sqrt(3) / 2;
				ctx.moveTo(x - edgeLength / 2, y + height / 3);
				ctx.lineTo(x + edgeLength / 2, y + height / 3);
				ctx.lineTo(x, y - 2 * height / 3);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;rect&#x27;:
				size &#x3D; 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
				ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
				break;
			case &#x27;rectRounded&#x27;:
				var offset &#x3D; radius / Math.SQRT2;
				var leftX &#x3D; x - offset;
				var topY &#x3D; y - offset;
				var sideSize &#x3D; Math.SQRT2 * radius;
				ctx.beginPath();
				this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;rectRot&#x27;:
				size &#x3D; 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.moveTo(x - size, y);
				ctx.lineTo(x, y + size);
				ctx.lineTo(x + size, y);
				ctx.lineTo(x, y - size);
				ctx.closePath();
				ctx.fill();
				break;
			case &#x27;cross&#x27;:
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case &#x27;crossRot&#x27;:
				ctx.beginPath();
				xOffset &#x3D; Math.cos(Math.PI / 4) * radius;
				yOffset &#x3D; Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case &#x27;star&#x27;:
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				xOffset &#x3D; Math.cos(Math.PI / 4) * radius;
				yOffset &#x3D; Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case &#x27;line&#x27;:
				ctx.beginPath();
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case &#x27;dash&#x27;:
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			}

			ctx.stroke();
		},

		clipArea: function(ctx, area) {
			ctx.save();
			ctx.beginPath();
			ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
			ctx.clip();
		},

		unclipArea: function(ctx) {
			ctx.restore();
		},

		lineTo: function(ctx, previous, target, flip) {
			if (target.steppedLine) {
				if ((target.steppedLine &#x3D;&#x3D;&#x3D; &#x27;after&#x27; &amp;&amp; !flip) || (target.steppedLine !&#x3D;&#x3D; &#x27;after&#x27; &amp;&amp; flip)) {
					ctx.lineTo(previous.x, target.y);
				} else {
					ctx.lineTo(target.x, previous.y);
				}
				ctx.lineTo(target.x, target.y);
				return;
			}

			if (!target.tension) {
				ctx.lineTo(target.x, target.y);
				return;
			}

			ctx.bezierCurveTo(
				flip ? previous.controlPointPreviousX : previous.controlPointNextX,
				flip ? previous.controlPointPreviousY : previous.controlPointNextY,
				flip ? target.controlPointNextX : target.controlPointPreviousX,
				flip ? target.controlPointNextY : target.controlPointPreviousY,
				target.x,
				target.y);
		}
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
	 * @namespace Chart.helpers.clear
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.clear &#x3D; exports.clear;

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
	 * @namespace Chart.helpers.drawRoundedRectangle
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.drawRoundedRectangle &#x3D; function(ctx) {
		ctx.beginPath();
		exports.roundedRect.apply(exports, arguments);
		ctx.closePath();
	};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(37);

	/**
	 * @alias Chart.helpers.options
	 * @namespace
	 */
	module.exports &#x3D; {
		/**
		 * Converts the given line height &#x60;value&#x60; in pixels for a specific font &#x60;size&#x60;.
		 * @param {Number|String} value - The lineHeight to parse (eg. 1.6, &#x27;14px&#x27;, &#x27;75%&#x27;, &#x27;1.6em&#x27;).
		 * @param {Number} size - The font size (in pixels) used to resolve relative &#x60;value&#x60;.
		 * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
		 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
		 * @since 2.7.0
		 */
		toLineHeight: function(value, size) {
			var matches &#x3D; (&#x27;&#x27; + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
			if (!matches || matches[1] &#x3D;&#x3D;&#x3D; &#x27;normal&#x27;) {
				return size * 1.2;
			}

			value &#x3D; +matches[2];

			switch (matches[3]) {
			case &#x27;px&#x27;:
				return value;
			case &#x27;%&#x27;:
				value /&#x3D; 100;
				break;
			default:
				break;
			}

			return size * value;
		},

		/**
		 * Converts the given value into a padding object with pre-computed width/height.
		 * @param {Number|Object} value - If a number, set the value to all TRBL component,
		 *  else, if and object, use defined properties and sets undefined ones to 0.
		 * @returns {Object} The padding values (top, right, bottom, left, width, height)
		 * @since 2.7.0
		 */
		toPadding: function(value) {
			var t, r, b, l;

			if (helpers.isObject(value)) {
				t &#x3D; +value.top || 0;
				r &#x3D; +value.right || 0;
				b &#x3D; +value.bottom || 0;
				l &#x3D; +value.left || 0;
			} else {
				t &#x3D; r &#x3D; b &#x3D; l &#x3D; +value || 0;
			}

			return {
				top: t,
				right: r,
				bottom: b,
				left: l,
				height: t + b,
				width: l + r
			};
		},

		/**
		 * Evaluates the given &#x60;inputs&#x60; sequentially and returns the first defined value.
		 * @param {Array[]} inputs - An array of values, falling back to the last value.
		 * @param {Object} [context] - If defined and the current value is a function, the value
		 * is called with &#x60;context&#x60; as first argument and the result becomes the new input.
		 * @param {Number} [index] - If defined and the current value is an array, the value
		 * at &#x60;index&#x60; become the new input.
		 * @since 2.7.0
		 */
		resolve: function(inputs, context, index) {
			var i, ilen, value;

			for (i &#x3D; 0, ilen &#x3D; inputs.length; i &lt; ilen; ++i) {
				value &#x3D; inputs[i];
				if (value &#x3D;&#x3D;&#x3D; undefined) {
					continue;
				}
				if (context !&#x3D;&#x3D; undefined &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
					value &#x3D; value(context);
				}
				if (index !&#x3D;&#x3D; undefined &amp;&amp; helpers.isArray(value)) {
					value &#x3D; value[index];
				}
				if (value !&#x3D;&#x3D; undefined) {
					return value;
				}
			}
		}
	};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	/* global document: false */
	&#x27;use strict&#x27;;

	var color &#x3D; __webpack_require__(42);
	var defaults &#x3D; __webpack_require__(35);
	var helpers &#x3D; __webpack_require__(36);

	module.exports &#x3D; function(Chart) {

		// -- Basic js utility methods

		helpers.configMerge &#x3D; function(/* objects ... */) {
			return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
				merger: function(key, target, source, options) {
					var tval &#x3D; target[key] || {};
					var sval &#x3D; source[key];

					if (key &#x3D;&#x3D;&#x3D; &#x27;scales&#x27;) {
						// scale config merging is complex. Add our own function here for that
						target[key] &#x3D; helpers.scaleMerge(tval, sval);
					} else if (key &#x3D;&#x3D;&#x3D; &#x27;scale&#x27;) {
						// used in polar area &amp; radar charts since there is only one scale
						target[key] &#x3D; helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
					} else {
						helpers._merger(key, target, source, options);
					}
				}
			});
		};

		helpers.scaleMerge &#x3D; function(/* objects ... */) {
			return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
				merger: function(key, target, source, options) {
					if (key &#x3D;&#x3D;&#x3D; &#x27;xAxes&#x27; || key &#x3D;&#x3D;&#x3D; &#x27;yAxes&#x27;) {
						var slen &#x3D; source[key].length;
						var i, type, scale;

						if (!target[key]) {
							target[key] &#x3D; [];
						}

						for (i &#x3D; 0; i &lt; slen; ++i) {
							scale &#x3D; source[key][i];
							type &#x3D; helpers.valueOrDefault(scale.type, key &#x3D;&#x3D;&#x3D; &#x27;xAxes&#x27; ? &#x27;category&#x27; : &#x27;linear&#x27;);

							if (i &gt;&#x3D; target[key].length) {
								target[key].push({});
							}

							if (!target[key][i].type || (scale.type &amp;&amp; scale.type !&#x3D;&#x3D; target[key][i].type)) {
								// new/untyped scale or type changed: let&#x27;s apply the new defaults
								// then merge source scale to correctly overwrite the defaults.
								helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
							} else {
								// scales type are the same
								helpers.merge(target[key][i], scale);
							}
						}
					} else {
						helpers._merger(key, target, source, options);
					}
				}
			});
		};

		helpers.where &#x3D; function(collection, filterCallback) {
			if (helpers.isArray(collection) &amp;&amp; Array.prototype.filter) {
				return collection.filter(filterCallback);
			}
			var filtered &#x3D; [];

			helpers.each(collection, function(item) {
				if (filterCallback(item)) {
					filtered.push(item);
				}
			});

			return filtered;
		};
		helpers.findIndex &#x3D; Array.prototype.findIndex ?
			function(array, callback, scope) {
				return array.findIndex(callback, scope);
			} :
			function(array, callback, scope) {
				scope &#x3D; scope &#x3D;&#x3D;&#x3D; undefined ? array : scope;
				for (var i &#x3D; 0, ilen &#x3D; array.length; i &lt; ilen; ++i) {
					if (callback.call(scope, array[i], i, array)) {
						return i;
					}
				}
				return -1;
			};
		helpers.findNextWhere &#x3D; function(arrayToSearch, filterCallback, startIndex) {
			// Default to start of the array
			if (helpers.isNullOrUndef(startIndex)) {
				startIndex &#x3D; -1;
			}
			for (var i &#x3D; startIndex + 1; i &lt; arrayToSearch.length; i++) {
				var currentItem &#x3D; arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};
		helpers.findPreviousWhere &#x3D; function(arrayToSearch, filterCallback, startIndex) {
			// Default to end of the array
			if (helpers.isNullOrUndef(startIndex)) {
				startIndex &#x3D; arrayToSearch.length;
			}
			for (var i &#x3D; startIndex - 1; i &gt;&#x3D; 0; i--) {
				var currentItem &#x3D; arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};

		// -- Math methods
		helpers.isNumber &#x3D; function(n) {
			return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
		};
		helpers.almostEquals &#x3D; function(x, y, epsilon) {
			return Math.abs(x - y) &lt; epsilon;
		};
		helpers.almostWhole &#x3D; function(x, epsilon) {
			var rounded &#x3D; Math.round(x);
			return (((rounded - epsilon) &lt; x) &amp;&amp; ((rounded + epsilon) &gt; x));
		};
		helpers.max &#x3D; function(array) {
			return array.reduce(function(max, value) {
				if (!isNaN(value)) {
					return Math.max(max, value);
				}
				return max;
			}, Number.NEGATIVE_INFINITY);
		};
		helpers.min &#x3D; function(array) {
			return array.reduce(function(min, value) {
				if (!isNaN(value)) {
					return Math.min(min, value);
				}
				return min;
			}, Number.POSITIVE_INFINITY);
		};
		helpers.sign &#x3D; Math.sign ?
			function(x) {
				return Math.sign(x);
			} :
			function(x) {
				x &#x3D; +x; // convert to a number
				if (x &#x3D;&#x3D;&#x3D; 0 || isNaN(x)) {
					return x;
				}
				return x &gt; 0 ? 1 : -1;
			};
		helpers.log10 &#x3D; Math.log10 ?
			function(x) {
				return Math.log10(x);
			} :
			function(x) {
				var exponent &#x3D; Math.log(x) * Math.LOG10E; // Math.LOG10E &#x3D; 1 / Math.LN10.
				// Check for whole powers of 10,
				// which due to floating point rounding error should be corrected.
				var powerOf10 &#x3D; Math.round(exponent);
				var isPowerOf10 &#x3D; x &#x3D;&#x3D;&#x3D; Math.pow(10, powerOf10);

				return isPowerOf10 ? powerOf10 : exponent;
			};
		helpers.toRadians &#x3D; function(degrees) {
			return degrees * (Math.PI / 180);
		};
		helpers.toDegrees &#x3D; function(radians) {
			return radians * (180 / Math.PI);
		};
		// Gets the angle from vertical upright to the point about a centre.
		helpers.getAngleFromPoint &#x3D; function(centrePoint, anglePoint) {
			var distanceFromXCenter &#x3D; anglePoint.x - centrePoint.x;
			var distanceFromYCenter &#x3D; anglePoint.y - centrePoint.y;
			var radialDistanceFromCenter &#x3D; Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

			var angle &#x3D; Math.atan2(distanceFromYCenter, distanceFromXCenter);

			if (angle &lt; (-0.5 * Math.PI)) {
				angle +&#x3D; 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
			}

			return {
				angle: angle,
				distance: radialDistanceFromCenter
			};
		};
		helpers.distanceBetweenPoints &#x3D; function(pt1, pt2) {
			return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
		};
		helpers.aliasPixel &#x3D; function(pixelWidth) {
			return (pixelWidth % 2 &#x3D;&#x3D;&#x3D; 0) ? 0 : 0.5;
		};
		helpers.splineCurve &#x3D; function(firstPoint, middlePoint, afterPoint, t) {
			// Props to Rob Spencer at scaled innovation for his post on splining between points
			// http://scaledinnovation.com/analytics/splines/aboutSplines.html

			// This function must also respect &quot;skipped&quot; points

			var previous &#x3D; firstPoint.skip ? middlePoint : firstPoint;
			var current &#x3D; middlePoint;
			var next &#x3D; afterPoint.skip ? middlePoint : afterPoint;

			var d01 &#x3D; Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
			var d12 &#x3D; Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

			var s01 &#x3D; d01 / (d01 + d12);
			var s12 &#x3D; d12 / (d01 + d12);

			// If all points are the same, s01 &amp; s02 will be inf
			s01 &#x3D; isNaN(s01) ? 0 : s01;
			s12 &#x3D; isNaN(s12) ? 0 : s12;

			var fa &#x3D; t * s01; // scaling factor for triangle Ta
			var fb &#x3D; t * s12;

			return {
				previous: {
					x: current.x - fa * (next.x - previous.x),
					y: current.y - fa * (next.y - previous.y)
				},
				next: {
					x: current.x + fb * (next.x - previous.x),
					y: current.y + fb * (next.y - previous.y)
				}
			};
		};
		helpers.EPSILON &#x3D; Number.EPSILON || 1e-14;
		helpers.splineCurveMonotone &#x3D; function(points) {
			// This function calculates Bézier control points in a similar way than |splineCurve|,
			// but preserves monotonicity of the provided data and ensures no local extremums are added
			// between the dataset discrete points due to the interpolation.
			// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

			var pointsWithTangents &#x3D; (points || []).map(function(point) {
				return {
					model: point._model,
					deltaK: 0,
					mK: 0
				};
			});

			// Calculate slopes (deltaK) and initialize tangents (mK)
			var pointsLen &#x3D; pointsWithTangents.length;
			var i, pointBefore, pointCurrent, pointAfter;
			for (i &#x3D; 0; i &lt; pointsLen; ++i) {
				pointCurrent &#x3D; pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}

				pointBefore &#x3D; i &gt; 0 ? pointsWithTangents[i - 1] : null;
				pointAfter &#x3D; i &lt; pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointAfter &amp;&amp; !pointAfter.model.skip) {
					var slopeDeltaX &#x3D; (pointAfter.model.x - pointCurrent.model.x);

					// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
					pointCurrent.deltaK &#x3D; slopeDeltaX !&#x3D;&#x3D; 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
				}

				if (!pointBefore || pointBefore.model.skip) {
					pointCurrent.mK &#x3D; pointCurrent.deltaK;
				} else if (!pointAfter || pointAfter.model.skip) {
					pointCurrent.mK &#x3D; pointBefore.deltaK;
				} else if (this.sign(pointBefore.deltaK) !&#x3D;&#x3D; this.sign(pointCurrent.deltaK)) {
					pointCurrent.mK &#x3D; 0;
				} else {
					pointCurrent.mK &#x3D; (pointBefore.deltaK + pointCurrent.deltaK) / 2;
				}
			}

			// Adjust tangents to ensure monotonic properties
			var alphaK, betaK, tauK, squaredMagnitude;
			for (i &#x3D; 0; i &lt; pointsLen - 1; ++i) {
				pointCurrent &#x3D; pointsWithTangents[i];
				pointAfter &#x3D; pointsWithTangents[i + 1];
				if (pointCurrent.model.skip || pointAfter.model.skip) {
					continue;
				}

				if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
					pointCurrent.mK &#x3D; pointAfter.mK &#x3D; 0;
					continue;
				}

				alphaK &#x3D; pointCurrent.mK / pointCurrent.deltaK;
				betaK &#x3D; pointAfter.mK / pointCurrent.deltaK;
				squaredMagnitude &#x3D; Math.pow(alphaK, 2) + Math.pow(betaK, 2);
				if (squaredMagnitude &lt;&#x3D; 9) {
					continue;
				}

				tauK &#x3D; 3 / Math.sqrt(squaredMagnitude);
				pointCurrent.mK &#x3D; alphaK * tauK * pointCurrent.deltaK;
				pointAfter.mK &#x3D; betaK * tauK * pointCurrent.deltaK;
			}

			// Compute control points
			var deltaX;
			for (i &#x3D; 0; i &lt; pointsLen; ++i) {
				pointCurrent &#x3D; pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}

				pointBefore &#x3D; i &gt; 0 ? pointsWithTangents[i - 1] : null;
				pointAfter &#x3D; i &lt; pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointBefore &amp;&amp; !pointBefore.model.skip) {
					deltaX &#x3D; (pointCurrent.model.x - pointBefore.model.x) / 3;
					pointCurrent.model.controlPointPreviousX &#x3D; pointCurrent.model.x - deltaX;
					pointCurrent.model.controlPointPreviousY &#x3D; pointCurrent.model.y - deltaX * pointCurrent.mK;
				}
				if (pointAfter &amp;&amp; !pointAfter.model.skip) {
					deltaX &#x3D; (pointAfter.model.x - pointCurrent.model.x) / 3;
					pointCurrent.model.controlPointNextX &#x3D; pointCurrent.model.x + deltaX;
					pointCurrent.model.controlPointNextY &#x3D; pointCurrent.model.y + deltaX * pointCurrent.mK;
				}
			}
		};
		helpers.nextItem &#x3D; function(collection, index, loop) {
			if (loop) {
				return index &gt;&#x3D; collection.length - 1 ? collection[0] : collection[index + 1];
			}
			return index &gt;&#x3D; collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
		};
		helpers.previousItem &#x3D; function(collection, index, loop) {
			if (loop) {
				return index &lt;&#x3D; 0 ? collection[collection.length - 1] : collection[index - 1];
			}
			return index &lt;&#x3D; 0 ? collection[0] : collection[index - 1];
		};
		// Implementation of the nice number algorithm used in determining where axis labels will go
		helpers.niceNum &#x3D; function(range, round) {
			var exponent &#x3D; Math.floor(helpers.log10(range));
			var fraction &#x3D; range / Math.pow(10, exponent);
			var niceFraction;

			if (round) {
				if (fraction &lt; 1.5) {
					niceFraction &#x3D; 1;
				} else if (fraction &lt; 3) {
					niceFraction &#x3D; 2;
				} else if (fraction &lt; 7) {
					niceFraction &#x3D; 5;
				} else {
					niceFraction &#x3D; 10;
				}
			} else if (fraction &lt;&#x3D; 1.0) {
				niceFraction &#x3D; 1;
			} else if (fraction &lt;&#x3D; 2) {
				niceFraction &#x3D; 2;
			} else if (fraction &lt;&#x3D; 5) {
				niceFraction &#x3D; 5;
			} else {
				niceFraction &#x3D; 10;
			}

			return niceFraction * Math.pow(10, exponent);
		};
		// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		helpers.requestAnimFrame &#x3D; (function() {
			if (typeof window &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
				return function(callback) {
					callback();
				};
			}
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					return window.setTimeout(callback, 1000 / 60);
				};
		}());
		// -- DOM methods
		helpers.getRelativePosition &#x3D; function(evt, chart) {
			var mouseX, mouseY;
			var e &#x3D; evt.originalEvent || evt;
			var canvas &#x3D; evt.currentTarget || evt.srcElement;
			var boundingRect &#x3D; canvas.getBoundingClientRect();

			var touches &#x3D; e.touches;
			if (touches &amp;&amp; touches.length &gt; 0) {
				mouseX &#x3D; touches[0].clientX;
				mouseY &#x3D; touches[0].clientY;

			} else {
				mouseX &#x3D; e.clientX;
				mouseY &#x3D; e.clientY;
			}

			// Scale mouse coordinates into canvas coordinates
			// by following the pattern laid out by &#x27;jerryj&#x27; in the comments of
			// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
			var paddingLeft &#x3D; parseFloat(helpers.getStyle(canvas, &#x27;padding-left&#x27;));
			var paddingTop &#x3D; parseFloat(helpers.getStyle(canvas, &#x27;padding-top&#x27;));
			var paddingRight &#x3D; parseFloat(helpers.getStyle(canvas, &#x27;padding-right&#x27;));
			var paddingBottom &#x3D; parseFloat(helpers.getStyle(canvas, &#x27;padding-bottom&#x27;));
			var width &#x3D; boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
			var height &#x3D; boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

			// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
			// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
			mouseX &#x3D; Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
			mouseY &#x3D; Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

			return {
				x: mouseX,
				y: mouseY
			};

		};

		// Private helper function to convert max-width/max-height values that may be percentages into a number
		function parseMaxStyle(styleValue, node, parentProperty) {
			var valueInPixels;
			if (typeof styleValue &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
				valueInPixels &#x3D; parseInt(styleValue, 10);

				if (styleValue.indexOf(&#x27;%&#x27;) !&#x3D;&#x3D; -1) {
					// percentage * size in dimension
					valueInPixels &#x3D; valueInPixels / 100 * node.parentNode[parentProperty];
				}
			} else {
				valueInPixels &#x3D; styleValue;
			}

			return valueInPixels;
		}

		/**
		 * Returns if the given value contains an effective constraint.
		 * @private
		 */
		function isConstrainedValue(value) {
			return value !&#x3D;&#x3D; undefined &amp;&amp; value !&#x3D;&#x3D; null &amp;&amp; value !&#x3D;&#x3D; &#x27;none&#x27;;
		}

		// Private helper to get a constraint dimension
		// @param domNode : the node to check the constraint on
		// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
		// @param percentageProperty : property of parent to use when calculating width as a percentage
		// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
		function getConstraintDimension(domNode, maxStyle, percentageProperty) {
			var view &#x3D; document.defaultView;
			var parentNode &#x3D; domNode.parentNode;
			var constrainedNode &#x3D; view.getComputedStyle(domNode)[maxStyle];
			var constrainedContainer &#x3D; view.getComputedStyle(parentNode)[maxStyle];
			var hasCNode &#x3D; isConstrainedValue(constrainedNode);
			var hasCContainer &#x3D; isConstrainedValue(constrainedContainer);
			var infinity &#x3D; Number.POSITIVE_INFINITY;

			if (hasCNode || hasCContainer) {
				return Math.min(
					hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
					hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
			}

			return &#x27;none&#x27;;
		}
		// returns Number or undefined if no constraint
		helpers.getConstraintWidth &#x3D; function(domNode) {
			return getConstraintDimension(domNode, &#x27;max-width&#x27;, &#x27;clientWidth&#x27;);
		};
		// returns Number or undefined if no constraint
		helpers.getConstraintHeight &#x3D; function(domNode) {
			return getConstraintDimension(domNode, &#x27;max-height&#x27;, &#x27;clientHeight&#x27;);
		};
		helpers.getMaximumWidth &#x3D; function(domNode) {
			var container &#x3D; domNode.parentNode;
			if (!container) {
				return domNode.clientWidth;
			}

			var paddingLeft &#x3D; parseInt(helpers.getStyle(container, &#x27;padding-left&#x27;), 10);
			var paddingRight &#x3D; parseInt(helpers.getStyle(container, &#x27;padding-right&#x27;), 10);
			var w &#x3D; container.clientWidth - paddingLeft - paddingRight;
			var cw &#x3D; helpers.getConstraintWidth(domNode);
			return isNaN(cw) ? w : Math.min(w, cw);
		};
		helpers.getMaximumHeight &#x3D; function(domNode) {
			var container &#x3D; domNode.parentNode;
			if (!container) {
				return domNode.clientHeight;
			}

			var paddingTop &#x3D; parseInt(helpers.getStyle(container, &#x27;padding-top&#x27;), 10);
			var paddingBottom &#x3D; parseInt(helpers.getStyle(container, &#x27;padding-bottom&#x27;), 10);
			var h &#x3D; container.clientHeight - paddingTop - paddingBottom;
			var ch &#x3D; helpers.getConstraintHeight(domNode);
			return isNaN(ch) ? h : Math.min(h, ch);
		};
		helpers.getStyle &#x3D; function(el, property) {
			return el.currentStyle ?
				el.currentStyle[property] :
				document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
		};
		helpers.retinaScale &#x3D; function(chart, forceRatio) {
			var pixelRatio &#x3D; chart.currentDevicePixelRatio &#x3D; forceRatio || window.devicePixelRatio || 1;
			if (pixelRatio &#x3D;&#x3D;&#x3D; 1) {
				return;
			}

			var canvas &#x3D; chart.canvas;
			var height &#x3D; chart.height;
			var width &#x3D; chart.width;

			canvas.height &#x3D; height * pixelRatio;
			canvas.width &#x3D; width * pixelRatio;
			chart.ctx.scale(pixelRatio, pixelRatio);

			// If no style has been set on the canvas, the render size is used as display size,
			// making the chart visually bigger, so let&#x27;s enforce it to the &quot;correct&quot; values.
			// See https://github.com/chartjs/Chart.js/issues/3575
			if (!canvas.style.height &amp;&amp; !canvas.style.width) {
				canvas.style.height &#x3D; height + &#x27;px&#x27;;
				canvas.style.width &#x3D; width + &#x27;px&#x27;;
			}
		};
		// -- Canvas methods
		helpers.fontString &#x3D; function(pixelSize, fontStyle, fontFamily) {
			return fontStyle + &#x27; &#x27; + pixelSize + &#x27;px &#x27; + fontFamily;
		};
		helpers.longestText &#x3D; function(ctx, font, arrayOfThings, cache) {
			cache &#x3D; cache || {};
			var data &#x3D; cache.data &#x3D; cache.data || {};
			var gc &#x3D; cache.garbageCollect &#x3D; cache.garbageCollect || [];

			if (cache.font !&#x3D;&#x3D; font) {
				data &#x3D; cache.data &#x3D; {};
				gc &#x3D; cache.garbageCollect &#x3D; [];
				cache.font &#x3D; font;
			}

			ctx.font &#x3D; font;
			var longest &#x3D; 0;
			helpers.each(arrayOfThings, function(thing) {
				// Undefined strings and arrays should not be measured
				if (thing !&#x3D;&#x3D; undefined &amp;&amp; thing !&#x3D;&#x3D; null &amp;&amp; helpers.isArray(thing) !&#x3D;&#x3D; true) {
					longest &#x3D; helpers.measureText(ctx, data, gc, longest, thing);
				} else if (helpers.isArray(thing)) {
					// if it is an array lets measure each element
					// to do maybe simplify this function a bit so we can do this more recursively?
					helpers.each(thing, function(nestedThing) {
						// Undefined strings and arrays should not be measured
						if (nestedThing !&#x3D;&#x3D; undefined &amp;&amp; nestedThing !&#x3D;&#x3D; null &amp;&amp; !helpers.isArray(nestedThing)) {
							longest &#x3D; helpers.measureText(ctx, data, gc, longest, nestedThing);
						}
					});
				}
			});

			var gcLen &#x3D; gc.length / 2;
			if (gcLen &gt; arrayOfThings.length) {
				for (var i &#x3D; 0; i &lt; gcLen; i++) {
					delete data[gc[i]];
				}
				gc.splice(0, gcLen);
			}
			return longest;
		};
		helpers.measureText &#x3D; function(ctx, data, gc, longest, string) {
			var textWidth &#x3D; data[string];
			if (!textWidth) {
				textWidth &#x3D; data[string] &#x3D; ctx.measureText(string).width;
				gc.push(string);
			}
			if (textWidth &gt; longest) {
				longest &#x3D; textWidth;
			}
			return longest;
		};
		helpers.numberOfLabelLines &#x3D; function(arrayOfThings) {
			var numberOfLines &#x3D; 1;
			helpers.each(arrayOfThings, function(thing) {
				if (helpers.isArray(thing)) {
					if (thing.length &gt; numberOfLines) {
						numberOfLines &#x3D; thing.length;
					}
				}
			});
			return numberOfLines;
		};

		helpers.color &#x3D; !color ?
			function(value) {
				console.error(&#x27;Color.js not found!&#x27;);
				return value;
			} :
			function(value) {
				/* global CanvasGradient */
				if (value instanceof CanvasGradient) {
					value &#x3D; defaults.global.defaultColor;
				}

				return color(value);
			};

		helpers.getHoverColor &#x3D; function(colorValue) {
			/* global CanvasPattern */
			return (colorValue instanceof CanvasPattern) ?
				colorValue :
				helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
		};
	};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/* MIT license */
	var convert &#x3D; __webpack_require__(43);
	var string &#x3D; __webpack_require__(45);

	var Color &#x3D; function (obj) {
		if (obj instanceof Color) {
			return obj;
		}
		if (!(this instanceof Color)) {
			return new Color(obj);
		}

		this.valid &#x3D; false;
		this.values &#x3D; {
			rgb: [0, 0, 0],
			hsl: [0, 0, 0],
			hsv: [0, 0, 0],
			hwb: [0, 0, 0],
			cmyk: [0, 0, 0, 0],
			alpha: 1
		};

		// parse Color() argument
		var vals;
		if (typeof obj &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
			vals &#x3D; string.getRgba(obj);
			if (vals) {
				this.setValues(&#x27;rgb&#x27;, vals);
			} else if (vals &#x3D; string.getHsla(obj)) {
				this.setValues(&#x27;hsl&#x27;, vals);
			} else if (vals &#x3D; string.getHwb(obj)) {
				this.setValues(&#x27;hwb&#x27;, vals);
			}
		} else if (typeof obj &#x3D;&#x3D;&#x3D; &#x27;object&#x27;) {
			vals &#x3D; obj;
			if (vals.r !&#x3D;&#x3D; undefined || vals.red !&#x3D;&#x3D; undefined) {
				this.setValues(&#x27;rgb&#x27;, vals);
			} else if (vals.l !&#x3D;&#x3D; undefined || vals.lightness !&#x3D;&#x3D; undefined) {
				this.setValues(&#x27;hsl&#x27;, vals);
			} else if (vals.v !&#x3D;&#x3D; undefined || vals.value !&#x3D;&#x3D; undefined) {
				this.setValues(&#x27;hsv&#x27;, vals);
			} else if (vals.w !&#x3D;&#x3D; undefined || vals.whiteness !&#x3D;&#x3D; undefined) {
				this.setValues(&#x27;hwb&#x27;, vals);
			} else if (vals.c !&#x3D;&#x3D; undefined || vals.cyan !&#x3D;&#x3D; undefined) {
				this.setValues(&#x27;cmyk&#x27;, vals);
			}
		}
	};

	Color.prototype &#x3D; {
		isValid: function () {
			return this.valid;
		},
		rgb: function () {
			return this.setSpace(&#x27;rgb&#x27;, arguments);
		},
		hsl: function () {
			return this.setSpace(&#x27;hsl&#x27;, arguments);
		},
		hsv: function () {
			return this.setSpace(&#x27;hsv&#x27;, arguments);
		},
		hwb: function () {
			return this.setSpace(&#x27;hwb&#x27;, arguments);
		},
		cmyk: function () {
			return this.setSpace(&#x27;cmyk&#x27;, arguments);
		},

		rgbArray: function () {
			return this.values.rgb;
		},
		hslArray: function () {
			return this.values.hsl;
		},
		hsvArray: function () {
			return this.values.hsv;
		},
		hwbArray: function () {
			var values &#x3D; this.values;
			if (values.alpha !&#x3D;&#x3D; 1) {
				return values.hwb.concat([values.alpha]);
			}
			return values.hwb;
		},
		cmykArray: function () {
			return this.values.cmyk;
		},
		rgbaArray: function () {
			var values &#x3D; this.values;
			return values.rgb.concat([values.alpha]);
		},
		hslaArray: function () {
			var values &#x3D; this.values;
			return values.hsl.concat([values.alpha]);
		},
		alpha: function (val) {
			if (val &#x3D;&#x3D;&#x3D; undefined) {
				return this.values.alpha;
			}
			this.setValues(&#x27;alpha&#x27;, val);
			return this;
		},

		red: function (val) {
			return this.setChannel(&#x27;rgb&#x27;, 0, val);
		},
		green: function (val) {
			return this.setChannel(&#x27;rgb&#x27;, 1, val);
		},
		blue: function (val) {
			return this.setChannel(&#x27;rgb&#x27;, 2, val);
		},
		hue: function (val) {
			if (val) {
				val %&#x3D; 360;
				val &#x3D; val &lt; 0 ? 360 + val : val;
			}
			return this.setChannel(&#x27;hsl&#x27;, 0, val);
		},
		saturation: function (val) {
			return this.setChannel(&#x27;hsl&#x27;, 1, val);
		},
		lightness: function (val) {
			return this.setChannel(&#x27;hsl&#x27;, 2, val);
		},
		saturationv: function (val) {
			return this.setChannel(&#x27;hsv&#x27;, 1, val);
		},
		whiteness: function (val) {
			return this.setChannel(&#x27;hwb&#x27;, 1, val);
		},
		blackness: function (val) {
			return this.setChannel(&#x27;hwb&#x27;, 2, val);
		},
		value: function (val) {
			return this.setChannel(&#x27;hsv&#x27;, 2, val);
		},
		cyan: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 0, val);
		},
		magenta: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 1, val);
		},
		yellow: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 2, val);
		},
		black: function (val) {
			return this.setChannel(&#x27;cmyk&#x27;, 3, val);
		},

		hexString: function () {
			return string.hexString(this.values.rgb);
		},
		rgbString: function () {
			return string.rgbString(this.values.rgb, this.values.alpha);
		},
		rgbaString: function () {
			return string.rgbaString(this.values.rgb, this.values.alpha);
		},
		percentString: function () {
			return string.percentString(this.values.rgb, this.values.alpha);
		},
		hslString: function () {
			return string.hslString(this.values.hsl, this.values.alpha);
		},
		hslaString: function () {
			return string.hslaString(this.values.hsl, this.values.alpha);
		},
		hwbString: function () {
			return string.hwbString(this.values.hwb, this.values.alpha);
		},
		keyword: function () {
			return string.keyword(this.values.rgb, this.values.alpha);
		},

		rgbNumber: function () {
			var rgb &#x3D; this.values.rgb;
			return (rgb[0] &lt;&lt; 16) | (rgb[1] &lt;&lt; 8) | rgb[2];
		},

		luminosity: function () {
			// http://www.w3.org/TR/WCAG20/#relativeluminancedef
			var rgb &#x3D; this.values.rgb;
			var lum &#x3D; [];
			for (var i &#x3D; 0; i &lt; rgb.length; i++) {
				var chan &#x3D; rgb[i] / 255;
				lum[i] &#x3D; (chan &lt;&#x3D; 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
			}
			return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
		},

		contrast: function (color2) {
			// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
			var lum1 &#x3D; this.luminosity();
			var lum2 &#x3D; color2.luminosity();
			if (lum1 &gt; lum2) {
				return (lum1 + 0.05) / (lum2 + 0.05);
			}
			return (lum2 + 0.05) / (lum1 + 0.05);
		},

		level: function (color2) {
			var contrastRatio &#x3D; this.contrast(color2);
			if (contrastRatio &gt;&#x3D; 7.1) {
				return &#x27;AAA&#x27;;
			}

			return (contrastRatio &gt;&#x3D; 4.5) ? &#x27;AA&#x27; : &#x27;&#x27;;
		},

		dark: function () {
			// YIQ equation from http://24ways.org/2010/calculating-color-contrast
			var rgb &#x3D; this.values.rgb;
			var yiq &#x3D; (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
			return yiq &lt; 128;
		},

		light: function () {
			return !this.dark();
		},

		negate: function () {
			var rgb &#x3D; [];
			for (var i &#x3D; 0; i &lt; 3; i++) {
				rgb[i] &#x3D; 255 - this.values.rgb[i];
			}
			this.setValues(&#x27;rgb&#x27;, rgb);
			return this;
		},

		lighten: function (ratio) {
			var hsl &#x3D; this.values.hsl;
			hsl[2] +&#x3D; hsl[2] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		darken: function (ratio) {
			var hsl &#x3D; this.values.hsl;
			hsl[2] -&#x3D; hsl[2] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		saturate: function (ratio) {
			var hsl &#x3D; this.values.hsl;
			hsl[1] +&#x3D; hsl[1] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		desaturate: function (ratio) {
			var hsl &#x3D; this.values.hsl;
			hsl[1] -&#x3D; hsl[1] * ratio;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		whiten: function (ratio) {
			var hwb &#x3D; this.values.hwb;
			hwb[1] +&#x3D; hwb[1] * ratio;
			this.setValues(&#x27;hwb&#x27;, hwb);
			return this;
		},

		blacken: function (ratio) {
			var hwb &#x3D; this.values.hwb;
			hwb[2] +&#x3D; hwb[2] * ratio;
			this.setValues(&#x27;hwb&#x27;, hwb);
			return this;
		},

		greyscale: function () {
			var rgb &#x3D; this.values.rgb;
			// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
			var val &#x3D; rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
			this.setValues(&#x27;rgb&#x27;, [val, val, val]);
			return this;
		},

		clearer: function (ratio) {
			var alpha &#x3D; this.values.alpha;
			this.setValues(&#x27;alpha&#x27;, alpha - (alpha * ratio));
			return this;
		},

		opaquer: function (ratio) {
			var alpha &#x3D; this.values.alpha;
			this.setValues(&#x27;alpha&#x27;, alpha + (alpha * ratio));
			return this;
		},

		rotate: function (degrees) {
			var hsl &#x3D; this.values.hsl;
			var hue &#x3D; (hsl[0] + degrees) % 360;
			hsl[0] &#x3D; hue &lt; 0 ? 360 + hue : hue;
			this.setValues(&#x27;hsl&#x27;, hsl);
			return this;
		},

		/**
		 * Ported from sass implementation in C
		 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		 */
		mix: function (mixinColor, weight) {
			var color1 &#x3D; this;
			var color2 &#x3D; mixinColor;
			var p &#x3D; weight &#x3D;&#x3D;&#x3D; undefined ? 0.5 : weight;

			var w &#x3D; 2 * p - 1;
			var a &#x3D; color1.alpha() - color2.alpha();

			var w1 &#x3D; (((w * a &#x3D;&#x3D;&#x3D; -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			var w2 &#x3D; 1 - w1;

			return this
				.rgb(
					w1 * color1.red() + w2 * color2.red(),
					w1 * color1.green() + w2 * color2.green(),
					w1 * color1.blue() + w2 * color2.blue()
				)
				.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
		},

		toJSON: function () {
			return this.rgb();
		},

		clone: function () {
			// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
			// making the final build way to big to embed in Chart.js. So let&#x27;s do it manually,
			// assuming that values to clone are 1 dimension arrays containing only numbers,
			// except &#x27;alpha&#x27; which is a number.
			var result &#x3D; new Color();
			var source &#x3D; this.values;
			var target &#x3D; result.values;
			var value, type;

			for (var prop in source) {
				if (source.hasOwnProperty(prop)) {
					value &#x3D; source[prop];
					type &#x3D; ({}).toString.call(value);
					if (type &#x3D;&#x3D;&#x3D; &#x27;[object Array]&#x27;) {
						target[prop] &#x3D; value.slice(0);
					} else if (type &#x3D;&#x3D;&#x3D; &#x27;[object Number]&#x27;) {
						target[prop] &#x3D; value;
					} else {
						console.error(&#x27;unexpected color value:&#x27;, value);
					}
				}
			}

			return result;
		}
	};

	Color.prototype.spaces &#x3D; {
		rgb: [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;],
		hsl: [&#x27;hue&#x27;, &#x27;saturation&#x27;, &#x27;lightness&#x27;],
		hsv: [&#x27;hue&#x27;, &#x27;saturation&#x27;, &#x27;value&#x27;],
		hwb: [&#x27;hue&#x27;, &#x27;whiteness&#x27;, &#x27;blackness&#x27;],
		cmyk: [&#x27;cyan&#x27;, &#x27;magenta&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]
	};

	Color.prototype.maxes &#x3D; {
		rgb: [255, 255, 255],
		hsl: [360, 100, 100],
		hsv: [360, 100, 100],
		hwb: [360, 100, 100],
		cmyk: [100, 100, 100, 100]
	};

	Color.prototype.getValues &#x3D; function (space) {
		var values &#x3D; this.values;
		var vals &#x3D; {};

		for (var i &#x3D; 0; i &lt; space.length; i++) {
			vals[space.charAt(i)] &#x3D; values[space][i];
		}

		if (values.alpha !&#x3D;&#x3D; 1) {
			vals.a &#x3D; values.alpha;
		}

		// {r: 255, g: 255, b: 255, a: 0.4}
		return vals;
	};

	Color.prototype.setValues &#x3D; function (space, vals) {
		var values &#x3D; this.values;
		var spaces &#x3D; this.spaces;
		var maxes &#x3D; this.maxes;
		var alpha &#x3D; 1;
		var i;

		this.valid &#x3D; true;

		if (space &#x3D;&#x3D;&#x3D; &#x27;alpha&#x27;) {
			alpha &#x3D; vals;
		} else if (vals.length) {
			// [10, 10, 10]
			values[space] &#x3D; vals.slice(0, space.length);
			alpha &#x3D; vals[space.length];
		} else if (vals[space.charAt(0)] !&#x3D;&#x3D; undefined) {
			// {r: 10, g: 10, b: 10}
			for (i &#x3D; 0; i &lt; space.length; i++) {
				values[space][i] &#x3D; vals[space.charAt(i)];
			}

			alpha &#x3D; vals.a;
		} else if (vals[spaces[space][0]] !&#x3D;&#x3D; undefined) {
			// {red: 10, green: 10, blue: 10}
			var chans &#x3D; spaces[space];

			for (i &#x3D; 0; i &lt; space.length; i++) {
				values[space][i] &#x3D; vals[chans[i]];
			}

			alpha &#x3D; vals.alpha;
		}

		values.alpha &#x3D; Math.max(0, Math.min(1, (alpha &#x3D;&#x3D;&#x3D; undefined ? values.alpha : alpha)));

		if (space &#x3D;&#x3D;&#x3D; &#x27;alpha&#x27;) {
			return false;
		}

		var capped;

		// cap values of the space prior converting all values
		for (i &#x3D; 0; i &lt; space.length; i++) {
			capped &#x3D; Math.max(0, Math.min(maxes[space][i], values[space][i]));
			values[space][i] &#x3D; Math.round(capped);
		}

		// convert to all the other color spaces
		for (var sname in spaces) {
			if (sname !&#x3D;&#x3D; space) {
				values[sname] &#x3D; convert[space][sname](values[space]);
			}
		}

		return true;
	};

	Color.prototype.setSpace &#x3D; function (space, args) {
		var vals &#x3D; args[0];

		if (vals &#x3D;&#x3D;&#x3D; undefined) {
			// color.rgb()
			return this.getValues(space);
		}

		// color.rgb(10, 10, 10)
		if (typeof vals &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
			vals &#x3D; Array.prototype.slice.call(args);
		}

		this.setValues(space, vals);
		return this;
	};

	Color.prototype.setChannel &#x3D; function (space, index, val) {
		var svalues &#x3D; this.values[space];
		if (val &#x3D;&#x3D;&#x3D; undefined) {
			// color.red()
			return svalues[index];
		} else if (val &#x3D;&#x3D;&#x3D; svalues[index]) {
			// color.red(color.red())
			return this;
		}

		// color.red(100)
		svalues[index] &#x3D; val;
		this.setValues(space, svalues);

		return this;
	};

	if (typeof window !&#x3D;&#x3D; &#x27;undefined&#x27;) {
		window.Color &#x3D; Color;
	}

	module.exports &#x3D; Color;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	var conversions &#x3D; __webpack_require__(44);

	var convert &#x3D; function() {
	   return new Converter();
	}

	for (var func in conversions) {
	  // export Raw versions
	  convert[func + &quot;Raw&quot;] &#x3D;  (function(func) {
	    // accept array or plain args
	    return function(arg) {
	      if (typeof arg &#x3D;&#x3D; &quot;number&quot;)
	        arg &#x3D; Array.prototype.slice.call(arguments);
	      return conversions[func](arg);
	    }
	  })(func);

	  var pair &#x3D; /(\w+)2(\w+)/.exec(func),
	      from &#x3D; pair[1],
	      to &#x3D; pair[2];

	  // export rgb2hsl and [&quot;rgb&quot;][&quot;hsl&quot;]
	  convert[from] &#x3D; convert[from] || {};

	  convert[from][to] &#x3D; convert[func] &#x3D; (function(func) { 
	    return function(arg) {
	      if (typeof arg &#x3D;&#x3D; &quot;number&quot;)
	        arg &#x3D; Array.prototype.slice.call(arguments);
	      
	      var val &#x3D; conversions[func](arg);
	      if (typeof val &#x3D;&#x3D; &quot;string&quot; || val &#x3D;&#x3D;&#x3D; undefined)
	        return val; // keyword

	      for (var i &#x3D; 0; i &lt; val.length; i++)
	        val[i] &#x3D; Math.round(val[i]);
	      return val;
	    }
	  })(func);
	}


	/* Converter does lazy conversion and caching */
	var Converter &#x3D; function() {
	   this.convs &#x3D; {};
	};

	/* Either get the values for a space or
	  set the values for a space, depending on args */
	Converter.prototype.routeSpace &#x3D; function(space, args) {
	   var values &#x3D; args[0];
	   if (values &#x3D;&#x3D;&#x3D; undefined) {
	      // color.rgb()
	      return this.getValues(space);
	   }
	   // color.rgb(10, 10, 10)
	   if (typeof values &#x3D;&#x3D; &quot;number&quot;) {
	      values &#x3D; Array.prototype.slice.call(args);        
	   }

	   return this.setValues(space, values);
	};
	  
	/* Set the values for a space, invalidating cache */
	Converter.prototype.setValues &#x3D; function(space, values) {
	   this.space &#x3D; space;
	   this.convs &#x3D; {};
	   this.convs[space] &#x3D; values;
	   return this;
	};

	/* Get the values for a space. If there&#x27;s already
	  a conversion for the space, fetch it, otherwise
	  compute it */
	Converter.prototype.getValues &#x3D; function(space) {
	   var vals &#x3D; this.convs[space];
	   if (!vals) {
	      var fspace &#x3D; this.space,
	          from &#x3D; this.convs[fspace];
	      vals &#x3D; convert[fspace][space](from);

	      this.convs[space] &#x3D; vals;
	   }
	  return vals;
	};

	[&quot;rgb&quot;, &quot;hsl&quot;, &quot;hsv&quot;, &quot;cmyk&quot;, &quot;keyword&quot;].forEach(function(space) {
	   Converter.prototype[space] &#x3D; function(vals) {
	      return this.routeSpace(space, arguments);
	   }
	});

	module.exports &#x3D; convert;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	/* MIT license */

	module.exports &#x3D; {
	  rgb2hsl: rgb2hsl,
	  rgb2hsv: rgb2hsv,
	  rgb2hwb: rgb2hwb,
	  rgb2cmyk: rgb2cmyk,
	  rgb2keyword: rgb2keyword,
	  rgb2xyz: rgb2xyz,
	  rgb2lab: rgb2lab,
	  rgb2lch: rgb2lch,

	  hsl2rgb: hsl2rgb,
	  hsl2hsv: hsl2hsv,
	  hsl2hwb: hsl2hwb,
	  hsl2cmyk: hsl2cmyk,
	  hsl2keyword: hsl2keyword,

	  hsv2rgb: hsv2rgb,
	  hsv2hsl: hsv2hsl,
	  hsv2hwb: hsv2hwb,
	  hsv2cmyk: hsv2cmyk,
	  hsv2keyword: hsv2keyword,

	  hwb2rgb: hwb2rgb,
	  hwb2hsl: hwb2hsl,
	  hwb2hsv: hwb2hsv,
	  hwb2cmyk: hwb2cmyk,
	  hwb2keyword: hwb2keyword,

	  cmyk2rgb: cmyk2rgb,
	  cmyk2hsl: cmyk2hsl,
	  cmyk2hsv: cmyk2hsv,
	  cmyk2hwb: cmyk2hwb,
	  cmyk2keyword: cmyk2keyword,

	  keyword2rgb: keyword2rgb,
	  keyword2hsl: keyword2hsl,
	  keyword2hsv: keyword2hsv,
	  keyword2hwb: keyword2hwb,
	  keyword2cmyk: keyword2cmyk,
	  keyword2lab: keyword2lab,
	  keyword2xyz: keyword2xyz,

	  xyz2rgb: xyz2rgb,
	  xyz2lab: xyz2lab,
	  xyz2lch: xyz2lch,

	  lab2xyz: lab2xyz,
	  lab2rgb: lab2rgb,
	  lab2lch: lab2lch,

	  lch2lab: lch2lab,
	  lch2xyz: lch2xyz,
	  lch2rgb: lch2rgb
	}


	function rgb2hsl(rgb) {
	  var r &#x3D; rgb[0]/255,
	      g &#x3D; rgb[1]/255,
	      b &#x3D; rgb[2]/255,
	      min &#x3D; Math.min(r, g, b),
	      max &#x3D; Math.max(r, g, b),
	      delta &#x3D; max - min,
	      h, s, l;

	  if (max &#x3D;&#x3D; min)
	    h &#x3D; 0;
	  else if (r &#x3D;&#x3D; max)
	    h &#x3D; (g - b) / delta;
	  else if (g &#x3D;&#x3D; max)
	    h &#x3D; 2 + (b - r) / delta;
	  else if (b &#x3D;&#x3D; max)
	    h &#x3D; 4 + (r - g)/ delta;

	  h &#x3D; Math.min(h * 60, 360);

	  if (h &lt; 0)
	    h +&#x3D; 360;

	  l &#x3D; (min + max) / 2;

	  if (max &#x3D;&#x3D; min)
	    s &#x3D; 0;
	  else if (l &lt;&#x3D; 0.5)
	    s &#x3D; delta / (max + min);
	  else
	    s &#x3D; delta / (2 - max - min);

	  return [h, s * 100, l * 100];
	}

	function rgb2hsv(rgb) {
	  var r &#x3D; rgb[0],
	      g &#x3D; rgb[1],
	      b &#x3D; rgb[2],
	      min &#x3D; Math.min(r, g, b),
	      max &#x3D; Math.max(r, g, b),
	      delta &#x3D; max - min,
	      h, s, v;

	  if (max &#x3D;&#x3D; 0)
	    s &#x3D; 0;
	  else
	    s &#x3D; (delta/max * 1000)/10;

	  if (max &#x3D;&#x3D; min)
	    h &#x3D; 0;
	  else if (r &#x3D;&#x3D; max)
	    h &#x3D; (g - b) / delta;
	  else if (g &#x3D;&#x3D; max)
	    h &#x3D; 2 + (b - r) / delta;
	  else if (b &#x3D;&#x3D; max)
	    h &#x3D; 4 + (r - g) / delta;

	  h &#x3D; Math.min(h * 60, 360);

	  if (h &lt; 0)
	    h +&#x3D; 360;

	  v &#x3D; ((max / 255) * 1000) / 10;

	  return [h, s, v];
	}

	function rgb2hwb(rgb) {
	  var r &#x3D; rgb[0],
	      g &#x3D; rgb[1],
	      b &#x3D; rgb[2],
	      h &#x3D; rgb2hsl(rgb)[0],
	      w &#x3D; 1/255 * Math.min(r, Math.min(g, b)),
	      b &#x3D; 1 - 1/255 * Math.max(r, Math.max(g, b));

	  return [h, w * 100, b * 100];
	}

	function rgb2cmyk(rgb) {
	  var r &#x3D; rgb[0] / 255,
	      g &#x3D; rgb[1] / 255,
	      b &#x3D; rgb[2] / 255,
	      c, m, y, k;

	  k &#x3D; Math.min(1 - r, 1 - g, 1 - b);
	  c &#x3D; (1 - r - k) / (1 - k) || 0;
	  m &#x3D; (1 - g - k) / (1 - k) || 0;
	  y &#x3D; (1 - b - k) / (1 - k) || 0;
	  return [c * 100, m * 100, y * 100, k * 100];
	}

	function rgb2keyword(rgb) {
	  return reverseKeywords[JSON.stringify(rgb)];
	}

	function rgb2xyz(rgb) {
	  var r &#x3D; rgb[0] / 255,
	      g &#x3D; rgb[1] / 255,
	      b &#x3D; rgb[2] / 255;

	  // assume sRGB
	  r &#x3D; r &gt; 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	  g &#x3D; g &gt; 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	  b &#x3D; b &gt; 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	  var x &#x3D; (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	  var y &#x3D; (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	  var z &#x3D; (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	  return [x * 100, y *100, z * 100];
	}

	function rgb2lab(rgb) {
	  var xyz &#x3D; rgb2xyz(rgb),
	        x &#x3D; xyz[0],
	        y &#x3D; xyz[1],
	        z &#x3D; xyz[2],
	        l, a, b;

	  x /&#x3D; 95.047;
	  y /&#x3D; 100;
	  z /&#x3D; 108.883;

	  x &#x3D; x &gt; 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y &#x3D; y &gt; 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z &#x3D; z &gt; 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l &#x3D; (116 * y) - 16;
	  a &#x3D; 500 * (x - y);
	  b &#x3D; 200 * (y - z);

	  return [l, a, b];
	}

	function rgb2lch(args) {
	  return lab2lch(rgb2lab(args));
	}

	function hsl2rgb(hsl) {
	  var h &#x3D; hsl[0] / 360,
	      s &#x3D; hsl[1] / 100,
	      l &#x3D; hsl[2] / 100,
	      t1, t2, t3, rgb, val;

	  if (s &#x3D;&#x3D; 0) {
	    val &#x3D; l * 255;
	    return [val, val, val];
	  }

	  if (l &lt; 0.5)
	    t2 &#x3D; l * (1 + s);
	  else
	    t2 &#x3D; l + s - l * s;
	  t1 &#x3D; 2 * l - t2;

	  rgb &#x3D; [0, 0, 0];
	  for (var i &#x3D; 0; i &lt; 3; i++) {
	    t3 &#x3D; h + 1 / 3 * - (i - 1);
	    t3 &lt; 0 &amp;&amp; t3++;
	    t3 &gt; 1 &amp;&amp; t3--;

	    if (6 * t3 &lt; 1)
	      val &#x3D; t1 + (t2 - t1) * 6 * t3;
	    else if (2 * t3 &lt; 1)
	      val &#x3D; t2;
	    else if (3 * t3 &lt; 2)
	      val &#x3D; t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	    else
	      val &#x3D; t1;

	    rgb[i] &#x3D; val * 255;
	  }

	  return rgb;
	}

	function hsl2hsv(hsl) {
	  var h &#x3D; hsl[0],
	      s &#x3D; hsl[1] / 100,
	      l &#x3D; hsl[2] / 100,
	      sv, v;

	  if(l &#x3D;&#x3D;&#x3D; 0) {
	      // no need to do calc on black
	      // also avoids divide by 0 error
	      return [0, 0, 0];
	  }

	  l *&#x3D; 2;
	  s *&#x3D; (l &lt;&#x3D; 1) ? l : 2 - l;
	  v &#x3D; (l + s) / 2;
	  sv &#x3D; (2 * s) / (l + s);
	  return [h, sv * 100, v * 100];
	}

	function hsl2hwb(args) {
	  return rgb2hwb(hsl2rgb(args));
	}

	function hsl2cmyk(args) {
	  return rgb2cmyk(hsl2rgb(args));
	}

	function hsl2keyword(args) {
	  return rgb2keyword(hsl2rgb(args));
	}


	function hsv2rgb(hsv) {
	  var h &#x3D; hsv[0] / 60,
	      s &#x3D; hsv[1] / 100,
	      v &#x3D; hsv[2] / 100,
	      hi &#x3D; Math.floor(h) % 6;

	  var f &#x3D; h - Math.floor(h),
	      p &#x3D; 255 * v * (1 - s),
	      q &#x3D; 255 * v * (1 - (s * f)),
	      t &#x3D; 255 * v * (1 - (s * (1 - f))),
	      v &#x3D; 255 * v;

	  switch(hi) {
	    case 0:
	      return [v, t, p];
	    case 1:
	      return [q, v, p];
	    case 2:
	      return [p, v, t];
	    case 3:
	      return [p, q, v];
	    case 4:
	      return [t, p, v];
	    case 5:
	      return [v, p, q];
	  }
	}

	function hsv2hsl(hsv) {
	  var h &#x3D; hsv[0],
	      s &#x3D; hsv[1] / 100,
	      v &#x3D; hsv[2] / 100,
	      sl, l;

	  l &#x3D; (2 - s) * v;
	  sl &#x3D; s * v;
	  sl /&#x3D; (l &lt;&#x3D; 1) ? l : 2 - l;
	  sl &#x3D; sl || 0;
	  l /&#x3D; 2;
	  return [h, sl * 100, l * 100];
	}

	function hsv2hwb(args) {
	  return rgb2hwb(hsv2rgb(args))
	}

	function hsv2cmyk(args) {
	  return rgb2cmyk(hsv2rgb(args));
	}

	function hsv2keyword(args) {
	  return rgb2keyword(hsv2rgb(args));
	}

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	function hwb2rgb(hwb) {
	  var h &#x3D; hwb[0] / 360,
	      wh &#x3D; hwb[1] / 100,
	      bl &#x3D; hwb[2] / 100,
	      ratio &#x3D; wh + bl,
	      i, v, f, n;

	  // wh + bl cant be &gt; 1
	  if (ratio &gt; 1) {
	    wh /&#x3D; ratio;
	    bl /&#x3D; ratio;
	  }

	  i &#x3D; Math.floor(6 * h);
	  v &#x3D; 1 - bl;
	  f &#x3D; 6 * h - i;
	  if ((i &amp; 0x01) !&#x3D; 0) {
	    f &#x3D; 1 - f;
	  }
	  n &#x3D; wh + f * (v - wh);  // linear interpolation

	  switch (i) {
	    default:
	    case 6:
	    case 0: r &#x3D; v; g &#x3D; n; b &#x3D; wh; break;
	    case 1: r &#x3D; n; g &#x3D; v; b &#x3D; wh; break;
	    case 2: r &#x3D; wh; g &#x3D; v; b &#x3D; n; break;
	    case 3: r &#x3D; wh; g &#x3D; n; b &#x3D; v; break;
	    case 4: r &#x3D; n; g &#x3D; wh; b &#x3D; v; break;
	    case 5: r &#x3D; v; g &#x3D; wh; b &#x3D; n; break;
	  }

	  return [r * 255, g * 255, b * 255];
	}

	function hwb2hsl(args) {
	  return rgb2hsl(hwb2rgb(args));
	}

	function hwb2hsv(args) {
	  return rgb2hsv(hwb2rgb(args));
	}

	function hwb2cmyk(args) {
	  return rgb2cmyk(hwb2rgb(args));
	}

	function hwb2keyword(args) {
	  return rgb2keyword(hwb2rgb(args));
	}

	function cmyk2rgb(cmyk) {
	  var c &#x3D; cmyk[0] / 100,
	      m &#x3D; cmyk[1] / 100,
	      y &#x3D; cmyk[2] / 100,
	      k &#x3D; cmyk[3] / 100,
	      r, g, b;

	  r &#x3D; 1 - Math.min(1, c * (1 - k) + k);
	  g &#x3D; 1 - Math.min(1, m * (1 - k) + k);
	  b &#x3D; 1 - Math.min(1, y * (1 - k) + k);
	  return [r * 255, g * 255, b * 255];
	}

	function cmyk2hsl(args) {
	  return rgb2hsl(cmyk2rgb(args));
	}

	function cmyk2hsv(args) {
	  return rgb2hsv(cmyk2rgb(args));
	}

	function cmyk2hwb(args) {
	  return rgb2hwb(cmyk2rgb(args));
	}

	function cmyk2keyword(args) {
	  return rgb2keyword(cmyk2rgb(args));
	}


	function xyz2rgb(xyz) {
	  var x &#x3D; xyz[0] / 100,
	      y &#x3D; xyz[1] / 100,
	      z &#x3D; xyz[2] / 100,
	      r, g, b;

	  r &#x3D; (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	  g &#x3D; (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	  b &#x3D; (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	  // assume sRGB
	  r &#x3D; r &gt; 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
	    : r &#x3D; (r * 12.92);

	  g &#x3D; g &gt; 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
	    : g &#x3D; (g * 12.92);

	  b &#x3D; b &gt; 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
	    : b &#x3D; (b * 12.92);

	  r &#x3D; Math.min(Math.max(0, r), 1);
	  g &#x3D; Math.min(Math.max(0, g), 1);
	  b &#x3D; Math.min(Math.max(0, b), 1);

	  return [r * 255, g * 255, b * 255];
	}

	function xyz2lab(xyz) {
	  var x &#x3D; xyz[0],
	      y &#x3D; xyz[1],
	      z &#x3D; xyz[2],
	      l, a, b;

	  x /&#x3D; 95.047;
	  y /&#x3D; 100;
	  z /&#x3D; 108.883;

	  x &#x3D; x &gt; 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y &#x3D; y &gt; 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z &#x3D; z &gt; 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l &#x3D; (116 * y) - 16;
	  a &#x3D; 500 * (x - y);
	  b &#x3D; 200 * (y - z);

	  return [l, a, b];
	}

	function xyz2lch(args) {
	  return lab2lch(xyz2lab(args));
	}

	function lab2xyz(lab) {
	  var l &#x3D; lab[0],
	      a &#x3D; lab[1],
	      b &#x3D; lab[2],
	      x, y, z, y2;

	  if (l &lt;&#x3D; 8) {
	    y &#x3D; (l * 100) / 903.3;
	    y2 &#x3D; (7.787 * (y / 100)) + (16 / 116);
	  } else {
	    y &#x3D; 100 * Math.pow((l + 16) / 116, 3);
	    y2 &#x3D; Math.pow(y / 100, 1/3);
	  }

	  x &#x3D; x / 95.047 &lt;&#x3D; 0.008856 ? x &#x3D; (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

	  z &#x3D; z / 108.883 &lt;&#x3D; 0.008859 ? z &#x3D; (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

	  return [x, y, z];
	}

	function lab2lch(lab) {
	  var l &#x3D; lab[0],
	      a &#x3D; lab[1],
	      b &#x3D; lab[2],
	      hr, h, c;

	  hr &#x3D; Math.atan2(b, a);
	  h &#x3D; hr * 360 / 2 / Math.PI;
	  if (h &lt; 0) {
	    h +&#x3D; 360;
	  }
	  c &#x3D; Math.sqrt(a * a + b * b);
	  return [l, c, h];
	}

	function lab2rgb(args) {
	  return xyz2rgb(lab2xyz(args));
	}

	function lch2lab(lch) {
	  var l &#x3D; lch[0],
	      c &#x3D; lch[1],
	      h &#x3D; lch[2],
	      a, b, hr;

	  hr &#x3D; h / 360 * 2 * Math.PI;
	  a &#x3D; c * Math.cos(hr);
	  b &#x3D; c * Math.sin(hr);
	  return [l, a, b];
	}

	function lch2xyz(args) {
	  return lab2xyz(lch2lab(args));
	}

	function lch2rgb(args) {
	  return lab2rgb(lch2lab(args));
	}

	function keyword2rgb(keyword) {
	  return cssKeywords[keyword];
	}

	function keyword2hsl(args) {
	  return rgb2hsl(keyword2rgb(args));
	}

	function keyword2hsv(args) {
	  return rgb2hsv(keyword2rgb(args));
	}

	function keyword2hwb(args) {
	  return rgb2hwb(keyword2rgb(args));
	}

	function keyword2cmyk(args) {
	  return rgb2cmyk(keyword2rgb(args));
	}

	function keyword2lab(args) {
	  return rgb2lab(keyword2rgb(args));
	}

	function keyword2xyz(args) {
	  return rgb2xyz(keyword2rgb(args));
	}

	var cssKeywords &#x3D; {
	  aliceblue:  [240,248,255],
	  antiquewhite: [250,235,215],
	  aqua: [0,255,255],
	  aquamarine: [127,255,212],
	  azure:  [240,255,255],
	  beige:  [245,245,220],
	  bisque: [255,228,196],
	  black:  [0,0,0],
	  blanchedalmond: [255,235,205],
	  blue: [0,0,255],
	  blueviolet: [138,43,226],
	  brown:  [165,42,42],
	  burlywood:  [222,184,135],
	  cadetblue:  [95,158,160],
	  chartreuse: [127,255,0],
	  chocolate:  [210,105,30],
	  coral:  [255,127,80],
	  cornflowerblue: [100,149,237],
	  cornsilk: [255,248,220],
	  crimson:  [220,20,60],
	  cyan: [0,255,255],
	  darkblue: [0,0,139],
	  darkcyan: [0,139,139],
	  darkgoldenrod:  [184,134,11],
	  darkgray: [169,169,169],
	  darkgreen:  [0,100,0],
	  darkgrey: [169,169,169],
	  darkkhaki:  [189,183,107],
	  darkmagenta:  [139,0,139],
	  darkolivegreen: [85,107,47],
	  darkorange: [255,140,0],
	  darkorchid: [153,50,204],
	  darkred:  [139,0,0],
	  darksalmon: [233,150,122],
	  darkseagreen: [143,188,143],
	  darkslateblue:  [72,61,139],
	  darkslategray:  [47,79,79],
	  darkslategrey:  [47,79,79],
	  darkturquoise:  [0,206,209],
	  darkviolet: [148,0,211],
	  deeppink: [255,20,147],
	  deepskyblue:  [0,191,255],
	  dimgray:  [105,105,105],
	  dimgrey:  [105,105,105],
	  dodgerblue: [30,144,255],
	  firebrick:  [178,34,34],
	  floralwhite:  [255,250,240],
	  forestgreen:  [34,139,34],
	  fuchsia:  [255,0,255],
	  gainsboro:  [220,220,220],
	  ghostwhite: [248,248,255],
	  gold: [255,215,0],
	  goldenrod:  [218,165,32],
	  gray: [128,128,128],
	  green:  [0,128,0],
	  greenyellow:  [173,255,47],
	  grey: [128,128,128],
	  honeydew: [240,255,240],
	  hotpink:  [255,105,180],
	  indianred:  [205,92,92],
	  indigo: [75,0,130],
	  ivory:  [255,255,240],
	  khaki:  [240,230,140],
	  lavender: [230,230,250],
	  lavenderblush:  [255,240,245],
	  lawngreen:  [124,252,0],
	  lemonchiffon: [255,250,205],
	  lightblue:  [173,216,230],
	  lightcoral: [240,128,128],
	  lightcyan:  [224,255,255],
	  lightgoldenrodyellow: [250,250,210],
	  lightgray:  [211,211,211],
	  lightgreen: [144,238,144],
	  lightgrey:  [211,211,211],
	  lightpink:  [255,182,193],
	  lightsalmon:  [255,160,122],
	  lightseagreen:  [32,178,170],
	  lightskyblue: [135,206,250],
	  lightslategray: [119,136,153],
	  lightslategrey: [119,136,153],
	  lightsteelblue: [176,196,222],
	  lightyellow:  [255,255,224],
	  lime: [0,255,0],
	  limegreen:  [50,205,50],
	  linen:  [250,240,230],
	  magenta:  [255,0,255],
	  maroon: [128,0,0],
	  mediumaquamarine: [102,205,170],
	  mediumblue: [0,0,205],
	  mediumorchid: [186,85,211],
	  mediumpurple: [147,112,219],
	  mediumseagreen: [60,179,113],
	  mediumslateblue:  [123,104,238],
	  mediumspringgreen:  [0,250,154],
	  mediumturquoise:  [72,209,204],
	  mediumvioletred:  [199,21,133],
	  midnightblue: [25,25,112],
	  mintcream:  [245,255,250],
	  mistyrose:  [255,228,225],
	  moccasin: [255,228,181],
	  navajowhite:  [255,222,173],
	  navy: [0,0,128],
	  oldlace:  [253,245,230],
	  olive:  [128,128,0],
	  olivedrab:  [107,142,35],
	  orange: [255,165,0],
	  orangered:  [255,69,0],
	  orchid: [218,112,214],
	  palegoldenrod:  [238,232,170],
	  palegreen:  [152,251,152],
	  paleturquoise:  [175,238,238],
	  palevioletred:  [219,112,147],
	  papayawhip: [255,239,213],
	  peachpuff:  [255,218,185],
	  peru: [205,133,63],
	  pink: [255,192,203],
	  plum: [221,160,221],
	  powderblue: [176,224,230],
	  purple: [128,0,128],
	  rebeccapurple: [102, 51, 153],
	  red:  [255,0,0],
	  rosybrown:  [188,143,143],
	  royalblue:  [65,105,225],
	  saddlebrown:  [139,69,19],
	  salmon: [250,128,114],
	  sandybrown: [244,164,96],
	  seagreen: [46,139,87],
	  seashell: [255,245,238],
	  sienna: [160,82,45],
	  silver: [192,192,192],
	  skyblue:  [135,206,235],
	  slateblue:  [106,90,205],
	  slategray:  [112,128,144],
	  slategrey:  [112,128,144],
	  snow: [255,250,250],
	  springgreen:  [0,255,127],
	  steelblue:  [70,130,180],
	  tan:  [210,180,140],
	  teal: [0,128,128],
	  thistle:  [216,191,216],
	  tomato: [255,99,71],
	  turquoise:  [64,224,208],
	  violet: [238,130,238],
	  wheat:  [245,222,179],
	  white:  [255,255,255],
	  whitesmoke: [245,245,245],
	  yellow: [255,255,0],
	  yellowgreen:  [154,205,50]
	};

	var reverseKeywords &#x3D; {};
	for (var key in cssKeywords) {
	  reverseKeywords[JSON.stringify(cssKeywords[key])] &#x3D; key;
	}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/* MIT license */
	var colorNames &#x3D; __webpack_require__(46);

	module.exports &#x3D; {
	   getRgba: getRgba,
	   getHsla: getHsla,
	   getRgb: getRgb,
	   getHsl: getHsl,
	   getHwb: getHwb,
	   getAlpha: getAlpha,

	   hexString: hexString,
	   rgbString: rgbString,
	   rgbaString: rgbaString,
	   percentString: percentString,
	   percentaString: percentaString,
	   hslString: hslString,
	   hslaString: hslaString,
	   hwbString: hwbString,
	   keyword: keyword
	}

	function getRgba(string) {
	   if (!string) {
	      return;
	   }
	   var abbr &#x3D;  /^#([a-fA-F0-9]{3})$/i,
	       hex &#x3D;  /^#([a-fA-F0-9]{6})$/i,
	       rgba &#x3D; /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
	       per &#x3D; /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
	       keyword &#x3D; /(\w+)/;

	   var rgb &#x3D; [0, 0, 0],
	       a &#x3D; 1,
	       match &#x3D; string.match(abbr);
	   if (match) {
	      match &#x3D; match[1];
	      for (var i &#x3D; 0; i &lt; rgb.length; i++) {
	         rgb[i] &#x3D; parseInt(match[i] + match[i], 16);
	      }
	   }
	   else if (match &#x3D; string.match(hex)) {
	      match &#x3D; match[1];
	      for (var i &#x3D; 0; i &lt; rgb.length; i++) {
	         rgb[i] &#x3D; parseInt(match.slice(i * 2, i * 2 + 2), 16);
	      }
	   }
	   else if (match &#x3D; string.match(rgba)) {
	      for (var i &#x3D; 0; i &lt; rgb.length; i++) {
	         rgb[i] &#x3D; parseInt(match[i + 1]);
	      }
	      a &#x3D; parseFloat(match[4]);
	   }
	   else if (match &#x3D; string.match(per)) {
	      for (var i &#x3D; 0; i &lt; rgb.length; i++) {
	         rgb[i] &#x3D; Math.round(parseFloat(match[i + 1]) * 2.55);
	      }
	      a &#x3D; parseFloat(match[4]);
	   }
	   else if (match &#x3D; string.match(keyword)) {
	      if (match[1] &#x3D;&#x3D; &quot;transparent&quot;) {
	         return [0, 0, 0, 0];
	      }
	      rgb &#x3D; colorNames[match[1]];
	      if (!rgb) {
	         return;
	      }
	   }

	   for (var i &#x3D; 0; i &lt; rgb.length; i++) {
	      rgb[i] &#x3D; scale(rgb[i], 0, 255);
	   }
	   if (!a &amp;&amp; a !&#x3D; 0) {
	      a &#x3D; 1;
	   }
	   else {
	      a &#x3D; scale(a, 0, 1);
	   }
	   rgb[3] &#x3D; a;
	   return rgb;
	}

	function getHsla(string) {
	   if (!string) {
	      return;
	   }
	   var hsl &#x3D; /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match &#x3D; string.match(hsl);
	   if (match) {
	      var alpha &#x3D; parseFloat(match[4]);
	      var h &#x3D; scale(parseInt(match[1]), 0, 360),
	          s &#x3D; scale(parseFloat(match[2]), 0, 100),
	          l &#x3D; scale(parseFloat(match[3]), 0, 100),
	          a &#x3D; scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, s, l, a];
	   }
	}

	function getHwb(string) {
	   if (!string) {
	      return;
	   }
	   var hwb &#x3D; /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match &#x3D; string.match(hwb);
	   if (match) {
	    var alpha &#x3D; parseFloat(match[4]);
	      var h &#x3D; scale(parseInt(match[1]), 0, 360),
	          w &#x3D; scale(parseFloat(match[2]), 0, 100),
	          b &#x3D; scale(parseFloat(match[3]), 0, 100),
	          a &#x3D; scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, w, b, a];
	   }
	}

	function getRgb(string) {
	   var rgba &#x3D; getRgba(string);
	   return rgba &amp;&amp; rgba.slice(0, 3);
	}

	function getHsl(string) {
	  var hsla &#x3D; getHsla(string);
	  return hsla &amp;&amp; hsla.slice(0, 3);
	}

	function getAlpha(string) {
	   var vals &#x3D; getRgba(string);
	   if (vals) {
	      return vals[3];
	   }
	   else if (vals &#x3D; getHsla(string)) {
	      return vals[3];
	   }
	   else if (vals &#x3D; getHwb(string)) {
	      return vals[3];
	   }
	}

	// generators
	function hexString(rgb) {
	   return &quot;#&quot; + hexDouble(rgb[0]) + hexDouble(rgb[1])
	              + hexDouble(rgb[2]);
	}

	function rgbString(rgba, alpha) {
	   if (alpha &lt; 1 || (rgba[3] &amp;&amp; rgba[3] &lt; 1)) {
	      return rgbaString(rgba, alpha);
	   }
	   return &quot;rgb(&quot; + rgba[0] + &quot;, &quot; + rgba[1] + &quot;, &quot; + rgba[2] + &quot;)&quot;;
	}

	function rgbaString(rgba, alpha) {
	   if (alpha &#x3D;&#x3D;&#x3D; undefined) {
	      alpha &#x3D; (rgba[3] !&#x3D;&#x3D; undefined ? rgba[3] : 1);
	   }
	   return &quot;rgba(&quot; + rgba[0] + &quot;, &quot; + rgba[1] + &quot;, &quot; + rgba[2]
	           + &quot;, &quot; + alpha + &quot;)&quot;;
	}

	function percentString(rgba, alpha) {
	   if (alpha &lt; 1 || (rgba[3] &amp;&amp; rgba[3] &lt; 1)) {
	      return percentaString(rgba, alpha);
	   }
	   var r &#x3D; Math.round(rgba[0]/255 * 100),
	       g &#x3D; Math.round(rgba[1]/255 * 100),
	       b &#x3D; Math.round(rgba[2]/255 * 100);

	   return &quot;rgb(&quot; + r + &quot;%, &quot; + g + &quot;%, &quot; + b + &quot;%)&quot;;
	}

	function percentaString(rgba, alpha) {
	   var r &#x3D; Math.round(rgba[0]/255 * 100),
	       g &#x3D; Math.round(rgba[1]/255 * 100),
	       b &#x3D; Math.round(rgba[2]/255 * 100);
	   return &quot;rgba(&quot; + r + &quot;%, &quot; + g + &quot;%, &quot; + b + &quot;%, &quot; + (alpha || rgba[3] || 1) + &quot;)&quot;;
	}

	function hslString(hsla, alpha) {
	   if (alpha &lt; 1 || (hsla[3] &amp;&amp; hsla[3] &lt; 1)) {
	      return hslaString(hsla, alpha);
	   }
	   return &quot;hsl(&quot; + hsla[0] + &quot;, &quot; + hsla[1] + &quot;%, &quot; + hsla[2] + &quot;%)&quot;;
	}

	function hslaString(hsla, alpha) {
	   if (alpha &#x3D;&#x3D;&#x3D; undefined) {
	      alpha &#x3D; (hsla[3] !&#x3D;&#x3D; undefined ? hsla[3] : 1);
	   }
	   return &quot;hsla(&quot; + hsla[0] + &quot;, &quot; + hsla[1] + &quot;%, &quot; + hsla[2] + &quot;%, &quot;
	           + alpha + &quot;)&quot;;
	}

	// hwb is a bit different than rgb(a) &amp; hsl(a) since there is no alpha specific syntax
	// (hwb have alpha optional &amp; 1 is default value)
	function hwbString(hwb, alpha) {
	   if (alpha &#x3D;&#x3D;&#x3D; undefined) {
	      alpha &#x3D; (hwb[3] !&#x3D;&#x3D; undefined ? hwb[3] : 1);
	   }
	   return &quot;hwb(&quot; + hwb[0] + &quot;, &quot; + hwb[1] + &quot;%, &quot; + hwb[2] + &quot;%&quot;
	           + (alpha !&#x3D;&#x3D; undefined &amp;&amp; alpha !&#x3D;&#x3D; 1 ? &quot;, &quot; + alpha : &quot;&quot;) + &quot;)&quot;;
	}

	function keyword(rgb) {
	  return reverseNames[rgb.slice(0, 3)];
	}

	// helpers
	function scale(num, min, max) {
	   return Math.min(Math.max(min, num), max);
	}

	function hexDouble(num) {
	  var str &#x3D; num.toString(16).toUpperCase();
	  return (str.length &lt; 2) ? &quot;0&quot; + str : str;
	}


	//create a list of reverse color names
	var reverseNames &#x3D; {};
	for (var name in colorNames) {
	   reverseNames[colorNames[name]] &#x3D; name;
	}


/***/ }),
/* 46 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;

	module.exports &#x3D; {
		&quot;aliceblue&quot;: [240, 248, 255],
		&quot;antiquewhite&quot;: [250, 235, 215],
		&quot;aqua&quot;: [0, 255, 255],
		&quot;aquamarine&quot;: [127, 255, 212],
		&quot;azure&quot;: [240, 255, 255],
		&quot;beige&quot;: [245, 245, 220],
		&quot;bisque&quot;: [255, 228, 196],
		&quot;black&quot;: [0, 0, 0],
		&quot;blanchedalmond&quot;: [255, 235, 205],
		&quot;blue&quot;: [0, 0, 255],
		&quot;blueviolet&quot;: [138, 43, 226],
		&quot;brown&quot;: [165, 42, 42],
		&quot;burlywood&quot;: [222, 184, 135],
		&quot;cadetblue&quot;: [95, 158, 160],
		&quot;chartreuse&quot;: [127, 255, 0],
		&quot;chocolate&quot;: [210, 105, 30],
		&quot;coral&quot;: [255, 127, 80],
		&quot;cornflowerblue&quot;: [100, 149, 237],
		&quot;cornsilk&quot;: [255, 248, 220],
		&quot;crimson&quot;: [220, 20, 60],
		&quot;cyan&quot;: [0, 255, 255],
		&quot;darkblue&quot;: [0, 0, 139],
		&quot;darkcyan&quot;: [0, 139, 139],
		&quot;darkgoldenrod&quot;: [184, 134, 11],
		&quot;darkgray&quot;: [169, 169, 169],
		&quot;darkgreen&quot;: [0, 100, 0],
		&quot;darkgrey&quot;: [169, 169, 169],
		&quot;darkkhaki&quot;: [189, 183, 107],
		&quot;darkmagenta&quot;: [139, 0, 139],
		&quot;darkolivegreen&quot;: [85, 107, 47],
		&quot;darkorange&quot;: [255, 140, 0],
		&quot;darkorchid&quot;: [153, 50, 204],
		&quot;darkred&quot;: [139, 0, 0],
		&quot;darksalmon&quot;: [233, 150, 122],
		&quot;darkseagreen&quot;: [143, 188, 143],
		&quot;darkslateblue&quot;: [72, 61, 139],
		&quot;darkslategray&quot;: [47, 79, 79],
		&quot;darkslategrey&quot;: [47, 79, 79],
		&quot;darkturquoise&quot;: [0, 206, 209],
		&quot;darkviolet&quot;: [148, 0, 211],
		&quot;deeppink&quot;: [255, 20, 147],
		&quot;deepskyblue&quot;: [0, 191, 255],
		&quot;dimgray&quot;: [105, 105, 105],
		&quot;dimgrey&quot;: [105, 105, 105],
		&quot;dodgerblue&quot;: [30, 144, 255],
		&quot;firebrick&quot;: [178, 34, 34],
		&quot;floralwhite&quot;: [255, 250, 240],
		&quot;forestgreen&quot;: [34, 139, 34],
		&quot;fuchsia&quot;: [255, 0, 255],
		&quot;gainsboro&quot;: [220, 220, 220],
		&quot;ghostwhite&quot;: [248, 248, 255],
		&quot;gold&quot;: [255, 215, 0],
		&quot;goldenrod&quot;: [218, 165, 32],
		&quot;gray&quot;: [128, 128, 128],
		&quot;green&quot;: [0, 128, 0],
		&quot;greenyellow&quot;: [173, 255, 47],
		&quot;grey&quot;: [128, 128, 128],
		&quot;honeydew&quot;: [240, 255, 240],
		&quot;hotpink&quot;: [255, 105, 180],
		&quot;indianred&quot;: [205, 92, 92],
		&quot;indigo&quot;: [75, 0, 130],
		&quot;ivory&quot;: [255, 255, 240],
		&quot;khaki&quot;: [240, 230, 140],
		&quot;lavender&quot;: [230, 230, 250],
		&quot;lavenderblush&quot;: [255, 240, 245],
		&quot;lawngreen&quot;: [124, 252, 0],
		&quot;lemonchiffon&quot;: [255, 250, 205],
		&quot;lightblue&quot;: [173, 216, 230],
		&quot;lightcoral&quot;: [240, 128, 128],
		&quot;lightcyan&quot;: [224, 255, 255],
		&quot;lightgoldenrodyellow&quot;: [250, 250, 210],
		&quot;lightgray&quot;: [211, 211, 211],
		&quot;lightgreen&quot;: [144, 238, 144],
		&quot;lightgrey&quot;: [211, 211, 211],
		&quot;lightpink&quot;: [255, 182, 193],
		&quot;lightsalmon&quot;: [255, 160, 122],
		&quot;lightseagreen&quot;: [32, 178, 170],
		&quot;lightskyblue&quot;: [135, 206, 250],
		&quot;lightslategray&quot;: [119, 136, 153],
		&quot;lightslategrey&quot;: [119, 136, 153],
		&quot;lightsteelblue&quot;: [176, 196, 222],
		&quot;lightyellow&quot;: [255, 255, 224],
		&quot;lime&quot;: [0, 255, 0],
		&quot;limegreen&quot;: [50, 205, 50],
		&quot;linen&quot;: [250, 240, 230],
		&quot;magenta&quot;: [255, 0, 255],
		&quot;maroon&quot;: [128, 0, 0],
		&quot;mediumaquamarine&quot;: [102, 205, 170],
		&quot;mediumblue&quot;: [0, 0, 205],
		&quot;mediumorchid&quot;: [186, 85, 211],
		&quot;mediumpurple&quot;: [147, 112, 219],
		&quot;mediumseagreen&quot;: [60, 179, 113],
		&quot;mediumslateblue&quot;: [123, 104, 238],
		&quot;mediumspringgreen&quot;: [0, 250, 154],
		&quot;mediumturquoise&quot;: [72, 209, 204],
		&quot;mediumvioletred&quot;: [199, 21, 133],
		&quot;midnightblue&quot;: [25, 25, 112],
		&quot;mintcream&quot;: [245, 255, 250],
		&quot;mistyrose&quot;: [255, 228, 225],
		&quot;moccasin&quot;: [255, 228, 181],
		&quot;navajowhite&quot;: [255, 222, 173],
		&quot;navy&quot;: [0, 0, 128],
		&quot;oldlace&quot;: [253, 245, 230],
		&quot;olive&quot;: [128, 128, 0],
		&quot;olivedrab&quot;: [107, 142, 35],
		&quot;orange&quot;: [255, 165, 0],
		&quot;orangered&quot;: [255, 69, 0],
		&quot;orchid&quot;: [218, 112, 214],
		&quot;palegoldenrod&quot;: [238, 232, 170],
		&quot;palegreen&quot;: [152, 251, 152],
		&quot;paleturquoise&quot;: [175, 238, 238],
		&quot;palevioletred&quot;: [219, 112, 147],
		&quot;papayawhip&quot;: [255, 239, 213],
		&quot;peachpuff&quot;: [255, 218, 185],
		&quot;peru&quot;: [205, 133, 63],
		&quot;pink&quot;: [255, 192, 203],
		&quot;plum&quot;: [221, 160, 221],
		&quot;powderblue&quot;: [176, 224, 230],
		&quot;purple&quot;: [128, 0, 128],
		&quot;rebeccapurple&quot;: [102, 51, 153],
		&quot;red&quot;: [255, 0, 0],
		&quot;rosybrown&quot;: [188, 143, 143],
		&quot;royalblue&quot;: [65, 105, 225],
		&quot;saddlebrown&quot;: [139, 69, 19],
		&quot;salmon&quot;: [250, 128, 114],
		&quot;sandybrown&quot;: [244, 164, 96],
		&quot;seagreen&quot;: [46, 139, 87],
		&quot;seashell&quot;: [255, 245, 238],
		&quot;sienna&quot;: [160, 82, 45],
		&quot;silver&quot;: [192, 192, 192],
		&quot;skyblue&quot;: [135, 206, 235],
		&quot;slateblue&quot;: [106, 90, 205],
		&quot;slategray&quot;: [112, 128, 144],
		&quot;slategrey&quot;: [112, 128, 144],
		&quot;snow&quot;: [255, 250, 250],
		&quot;springgreen&quot;: [0, 255, 127],
		&quot;steelblue&quot;: [70, 130, 180],
		&quot;tan&quot;: [210, 180, 140],
		&quot;teal&quot;: [0, 128, 128],
		&quot;thistle&quot;: [216, 191, 216],
		&quot;tomato&quot;: [255, 99, 71],
		&quot;turquoise&quot;: [64, 224, 208],
		&quot;violet&quot;: [238, 130, 238],
		&quot;wheat&quot;: [245, 222, 179],
		&quot;white&quot;: [255, 255, 255],
		&quot;whitesmoke&quot;: [245, 245, 245],
		&quot;yellow&quot;: [255, 255, 0],
		&quot;yellowgreen&quot;: [154, 205, 50]
	};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var color &#x3D; __webpack_require__(42);
	var helpers &#x3D; __webpack_require__(36);

	function interpolate(start, view, model, ease) {
		var keys &#x3D; Object.keys(model);
		var i, ilen, key, actual, origin, target, type, c0, c1;

		for (i &#x3D; 0, ilen &#x3D; keys.length; i &lt; ilen; ++i) {
			key &#x3D; keys[i];

			target &#x3D; model[key];

			// if a value is added to the model after pivot() has been called, the view
			// doesn&#x27;t contain it, so let&#x27;s initialize the view to the target value.
			if (!view.hasOwnProperty(key)) {
				view[key] &#x3D; target;
			}

			actual &#x3D; view[key];

			if (actual &#x3D;&#x3D;&#x3D; target || key[0] &#x3D;&#x3D;&#x3D; &#x27;_&#x27;) {
				continue;
			}

			if (!start.hasOwnProperty(key)) {
				start[key] &#x3D; actual;
			}

			origin &#x3D; start[key];

			type &#x3D; typeof target;

			if (type &#x3D;&#x3D;&#x3D; typeof origin) {
				if (type &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
					c0 &#x3D; color(origin);
					if (c0.valid) {
						c1 &#x3D; color(target);
						if (c1.valid) {
							view[key] &#x3D; c1.mix(c0, ease).rgbString();
							continue;
						}
					}
				} else if (type &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; isFinite(origin) &amp;&amp; isFinite(target)) {
					view[key] &#x3D; origin + (target - origin) * ease;
					continue;
				}
			}

			view[key] &#x3D; target;
		}
	}

	var Element &#x3D; function(configuration) {
		helpers.extend(this, configuration);
		this.initialize.apply(this, arguments);
	};

	helpers.extend(Element.prototype, {

		initialize: function() {
			this.hidden &#x3D; false;
		},

		pivot: function() {
			var me &#x3D; this;
			if (!me._view) {
				me._view &#x3D; helpers.clone(me._model);
			}
			me._start &#x3D; {};
			return me;
		},

		transition: function(ease) {
			var me &#x3D; this;
			var model &#x3D; me._model;
			var start &#x3D; me._start;
			var view &#x3D; me._view;

			// No animation -&gt; No Transition
			if (!model || ease &#x3D;&#x3D;&#x3D; 1) {
				me._view &#x3D; model;
				me._start &#x3D; null;
				return me;
			}

			if (!view) {
				view &#x3D; me._view &#x3D; {};
			}

			if (!start) {
				start &#x3D; me._start &#x3D; {};
			}

			interpolate(start, view, model, ease);

			return me;
		},

		tooltipPosition: function() {
			return {
				x: this._model.x,
				y: this._model.y
			};
		},

		hasValue: function() {
			return helpers.isNumber(this._model.x) &amp;&amp; helpers.isNumber(this._model.y);
		}
	});

	Element.extend &#x3D; helpers.inherits;

	module.exports &#x3D; Element;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; {};
	module.exports.Arc &#x3D; __webpack_require__(49);
	module.exports.Line &#x3D; __webpack_require__(50);
	module.exports.Point &#x3D; __webpack_require__(51);
	module.exports.Rectangle &#x3D; __webpack_require__(52);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		elements: {
			arc: {
				backgroundColor: defaults.global.defaultColor,
				borderColor: &#x27;#fff&#x27;,
				borderWidth: 2
			}
		}
	});

	module.exports &#x3D; Element.extend({
		inLabelRange: function(mouseX) {
			var vm &#x3D; this._view;

			if (vm) {
				return (Math.pow(mouseX - vm.x, 2) &lt; Math.pow(vm.radius + vm.hoverRadius, 2));
			}
			return false;
		},

		inRange: function(chartX, chartY) {
			var vm &#x3D; this._view;

			if (vm) {
				var pointRelativePosition &#x3D; helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
				var	angle &#x3D; pointRelativePosition.angle;
				var distance &#x3D; pointRelativePosition.distance;

				// Sanitise angle range
				var startAngle &#x3D; vm.startAngle;
				var endAngle &#x3D; vm.endAngle;
				while (endAngle &lt; startAngle) {
					endAngle +&#x3D; 2.0 * Math.PI;
				}
				while (angle &gt; endAngle) {
					angle -&#x3D; 2.0 * Math.PI;
				}
				while (angle &lt; startAngle) {
					angle +&#x3D; 2.0 * Math.PI;
				}

				// Check if within the range of the open/close angle
				var betweenAngles &#x3D; (angle &gt;&#x3D; startAngle &amp;&amp; angle &lt;&#x3D; endAngle);
				var withinRadius &#x3D; (distance &gt;&#x3D; vm.innerRadius &amp;&amp; distance &lt;&#x3D; vm.outerRadius);

				return (betweenAngles &amp;&amp; withinRadius);
			}
			return false;
		},

		getCenterPoint: function() {
			var vm &#x3D; this._view;
			var halfAngle &#x3D; (vm.startAngle + vm.endAngle) / 2;
			var halfRadius &#x3D; (vm.innerRadius + vm.outerRadius) / 2;
			return {
				x: vm.x + Math.cos(halfAngle) * halfRadius,
				y: vm.y + Math.sin(halfAngle) * halfRadius
			};
		},

		getArea: function() {
			var vm &#x3D; this._view;
			return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
		},

		tooltipPosition: function() {
			var vm &#x3D; this._view;
			var centreAngle &#x3D; vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
			var rangeFromCentre &#x3D; (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

			return {
				x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
				y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
			};
		},

		draw: function() {
			var ctx &#x3D; this._chart.ctx;
			var vm &#x3D; this._view;
			var sA &#x3D; vm.startAngle;
			var eA &#x3D; vm.endAngle;

			ctx.beginPath();

			ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
			ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

			ctx.closePath();
			ctx.strokeStyle &#x3D; vm.borderColor;
			ctx.lineWidth &#x3D; vm.borderWidth;

			ctx.fillStyle &#x3D; vm.backgroundColor;

			ctx.fill();
			ctx.lineJoin &#x3D; &#x27;bevel&#x27;;

			if (vm.borderWidth) {
				ctx.stroke();
			}
		}
	});


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);

	var globalDefaults &#x3D; defaults.global;

	defaults._set(&#x27;global&#x27;, {
		elements: {
			line: {
				tension: 0.4,
				backgroundColor: globalDefaults.defaultColor,
				borderWidth: 3,
				borderColor: globalDefaults.defaultColor,
				borderCapStyle: &#x27;butt&#x27;,
				borderDash: [],
				borderDashOffset: 0.0,
				borderJoinStyle: &#x27;miter&#x27;,
				capBezierPoints: true,
				fill: true, // do we fill in the area between the line and its base axis
			}
		}
	});

	module.exports &#x3D; Element.extend({
		draw: function() {
			var me &#x3D; this;
			var vm &#x3D; me._view;
			var ctx &#x3D; me._chart.ctx;
			var spanGaps &#x3D; vm.spanGaps;
			var points &#x3D; me._children.slice(); // clone array
			var globalOptionLineElements &#x3D; globalDefaults.elements.line;
			var lastDrawnIndex &#x3D; -1;
			var index, current, previous, currentVM;

			// If we are looping, adding the first point again
			if (me._loop &amp;&amp; points.length) {
				points.push(points[0]);
			}

			ctx.save();

			// Stroke Line Options
			ctx.lineCap &#x3D; vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

			// IE 9 and 10 do not support line dash
			if (ctx.setLineDash) {
				ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
			}

			ctx.lineDashOffset &#x3D; vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
			ctx.lineJoin &#x3D; vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
			ctx.lineWidth &#x3D; vm.borderWidth || globalOptionLineElements.borderWidth;
			ctx.strokeStyle &#x3D; vm.borderColor || globalDefaults.defaultColor;

			// Stroke Line
			ctx.beginPath();
			lastDrawnIndex &#x3D; -1;

			for (index &#x3D; 0; index &lt; points.length; ++index) {
				current &#x3D; points[index];
				previous &#x3D; helpers.previousItem(points, index);
				currentVM &#x3D; current._view;

				// First point moves to it&#x27;s starting position no matter what
				if (index &#x3D;&#x3D;&#x3D; 0) {
					if (!currentVM.skip) {
						ctx.moveTo(currentVM.x, currentVM.y);
						lastDrawnIndex &#x3D; index;
					}
				} else {
					previous &#x3D; lastDrawnIndex &#x3D;&#x3D;&#x3D; -1 ? previous : points[lastDrawnIndex];

					if (!currentVM.skip) {
						if ((lastDrawnIndex !&#x3D;&#x3D; (index - 1) &amp;&amp; !spanGaps) || lastDrawnIndex &#x3D;&#x3D;&#x3D; -1) {
							// There was a gap and this is the first point after the gap
							ctx.moveTo(currentVM.x, currentVM.y);
						} else {
							// Line to next point
							helpers.canvas.lineTo(ctx, previous._view, current._view);
						}
						lastDrawnIndex &#x3D; index;
					}
				}
			}

			ctx.stroke();
			ctx.restore();
		}
	});


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);

	var defaultColor &#x3D; defaults.global.defaultColor;

	defaults._set(&#x27;global&#x27;, {
		elements: {
			point: {
				radius: 3,
				pointStyle: &#x27;circle&#x27;,
				backgroundColor: defaultColor,
				borderColor: defaultColor,
				borderWidth: 1,
				// Hover
				hitRadius: 1,
				hoverRadius: 4,
				hoverBorderWidth: 1
			}
		}
	});

	function xRange(mouseX) {
		var vm &#x3D; this._view;
		return vm ? (Math.abs(mouseX - vm.x) &lt; vm.radius + vm.hitRadius) : false;
	}

	function yRange(mouseY) {
		var vm &#x3D; this._view;
		return vm ? (Math.abs(mouseY - vm.y) &lt; vm.radius + vm.hitRadius) : false;
	}

	module.exports &#x3D; Element.extend({
		inRange: function(mouseX, mouseY) {
			var vm &#x3D; this._view;
			return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) &lt; Math.pow(vm.hitRadius + vm.radius, 2)) : false;
		},

		inLabelRange: xRange,
		inXRange: xRange,
		inYRange: yRange,

		getCenterPoint: function() {
			var vm &#x3D; this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		},

		getArea: function() {
			return Math.PI * Math.pow(this._view.radius, 2);
		},

		tooltipPosition: function() {
			var vm &#x3D; this._view;
			return {
				x: vm.x,
				y: vm.y,
				padding: vm.radius + vm.borderWidth
			};
		},

		draw: function(chartArea) {
			var vm &#x3D; this._view;
			var model &#x3D; this._model;
			var ctx &#x3D; this._chart.ctx;
			var pointStyle &#x3D; vm.pointStyle;
			var radius &#x3D; vm.radius;
			var x &#x3D; vm.x;
			var y &#x3D; vm.y;
			var color &#x3D; helpers.color;
			var errMargin &#x3D; 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
			var ratio &#x3D; 0;

			if (vm.skip) {
				return;
			}

			ctx.strokeStyle &#x3D; vm.borderColor || defaultColor;
			ctx.lineWidth &#x3D; helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
			ctx.fillStyle &#x3D; vm.backgroundColor || defaultColor;

			// Cliping for Points.
			// going out from inner charArea?
			if ((chartArea !&#x3D;&#x3D; undefined) &amp;&amp; ((model.x &lt; chartArea.left) || (chartArea.right * errMargin &lt; model.x) || (model.y &lt; chartArea.top) || (chartArea.bottom * errMargin &lt; model.y))) {
				// Point fade out
				if (model.x &lt; chartArea.left) {
					ratio &#x3D; (x - model.x) / (chartArea.left - model.x);
				} else if (chartArea.right * errMargin &lt; model.x) {
					ratio &#x3D; (model.x - x) / (model.x - chartArea.right);
				} else if (model.y &lt; chartArea.top) {
					ratio &#x3D; (y - model.y) / (chartArea.top - model.y);
				} else if (chartArea.bottom * errMargin &lt; model.y) {
					ratio &#x3D; (model.y - y) / (model.y - chartArea.bottom);
				}
				ratio &#x3D; Math.round(ratio * 100) / 100;
				ctx.strokeStyle &#x3D; color(ctx.strokeStyle).alpha(ratio).rgbString();
				ctx.fillStyle &#x3D; color(ctx.fillStyle).alpha(ratio).rgbString();
			}

			helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
		}
	});


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);

	defaults._set(&#x27;global&#x27;, {
		elements: {
			rectangle: {
				backgroundColor: defaults.global.defaultColor,
				borderColor: defaults.global.defaultColor,
				borderSkipped: &#x27;bottom&#x27;,
				borderWidth: 0
			}
		}
	});

	function isVertical(bar) {
		return bar._view.width !&#x3D;&#x3D; undefined;
	}

	/**
	 * Helper function to get the bounds of the bar regardless of the orientation
	 * @param bar {Chart.Element.Rectangle} the bar
	 * @return {Bounds} bounds of the bar
	 * @private
	 */
	function getBarBounds(bar) {
		var vm &#x3D; bar._view;
		var x1, x2, y1, y2;

		if (isVertical(bar)) {
			// vertical
			var halfWidth &#x3D; vm.width / 2;
			x1 &#x3D; vm.x - halfWidth;
			x2 &#x3D; vm.x + halfWidth;
			y1 &#x3D; Math.min(vm.y, vm.base);
			y2 &#x3D; Math.max(vm.y, vm.base);
		} else {
			// horizontal bar
			var halfHeight &#x3D; vm.height / 2;
			x1 &#x3D; Math.min(vm.x, vm.base);
			x2 &#x3D; Math.max(vm.x, vm.base);
			y1 &#x3D; vm.y - halfHeight;
			y2 &#x3D; vm.y + halfHeight;
		}

		return {
			left: x1,
			top: y1,
			right: x2,
			bottom: y2
		};
	}

	module.exports &#x3D; Element.extend({
		draw: function() {
			var ctx &#x3D; this._chart.ctx;
			var vm &#x3D; this._view;
			var left, right, top, bottom, signX, signY, borderSkipped;
			var borderWidth &#x3D; vm.borderWidth;

			if (!vm.horizontal) {
				// bar
				left &#x3D; vm.x - vm.width / 2;
				right &#x3D; vm.x + vm.width / 2;
				top &#x3D; vm.y;
				bottom &#x3D; vm.base;
				signX &#x3D; 1;
				signY &#x3D; bottom &gt; top ? 1 : -1;
				borderSkipped &#x3D; vm.borderSkipped || &#x27;bottom&#x27;;
			} else {
				// horizontal bar
				left &#x3D; vm.base;
				right &#x3D; vm.x;
				top &#x3D; vm.y - vm.height / 2;
				bottom &#x3D; vm.y + vm.height / 2;
				signX &#x3D; right &gt; left ? 1 : -1;
				signY &#x3D; 1;
				borderSkipped &#x3D; vm.borderSkipped || &#x27;left&#x27;;
			}

			// Canvas doesn&#x27;t allow us to stroke inside the width so we can
			// adjust the sizes to fit if we&#x27;re setting a stroke on the line
			if (borderWidth) {
				// borderWidth shold be less than bar width and bar height.
				var barSize &#x3D; Math.min(Math.abs(left - right), Math.abs(top - bottom));
				borderWidth &#x3D; borderWidth &gt; barSize ? barSize : borderWidth;
				var halfStroke &#x3D; borderWidth / 2;
				// Adjust borderWidth when bar top position is near vm.base(zero).
				var borderLeft &#x3D; left + (borderSkipped !&#x3D;&#x3D; &#x27;left&#x27; ? halfStroke * signX : 0);
				var borderRight &#x3D; right + (borderSkipped !&#x3D;&#x3D; &#x27;right&#x27; ? -halfStroke * signX : 0);
				var borderTop &#x3D; top + (borderSkipped !&#x3D;&#x3D; &#x27;top&#x27; ? halfStroke * signY : 0);
				var borderBottom &#x3D; bottom + (borderSkipped !&#x3D;&#x3D; &#x27;bottom&#x27; ? -halfStroke * signY : 0);
				// not become a vertical line?
				if (borderLeft !&#x3D;&#x3D; borderRight) {
					top &#x3D; borderTop;
					bottom &#x3D; borderBottom;
				}
				// not become a horizontal line?
				if (borderTop !&#x3D;&#x3D; borderBottom) {
					left &#x3D; borderLeft;
					right &#x3D; borderRight;
				}
			}

			ctx.beginPath();
			ctx.fillStyle &#x3D; vm.backgroundColor;
			ctx.strokeStyle &#x3D; vm.borderColor;
			ctx.lineWidth &#x3D; borderWidth;

			// Corner points, from bottom-left to bottom-right clockwise
			// | 1 2 |
			// | 0 3 |
			var corners &#x3D; [
				[left, bottom],
				[left, top],
				[right, top],
				[right, bottom]
			];

			// Find first (starting) corner with fallback to &#x27;bottom&#x27;
			var borders &#x3D; [&#x27;bottom&#x27;, &#x27;left&#x27;, &#x27;top&#x27;, &#x27;right&#x27;];
			var startCorner &#x3D; borders.indexOf(borderSkipped, 0);
			if (startCorner &#x3D;&#x3D;&#x3D; -1) {
				startCorner &#x3D; 0;
			}

			function cornerAt(index) {
				return corners[(startCorner + index) % 4];
			}

			// Draw rectangle from &#x27;startCorner&#x27;
			var corner &#x3D; cornerAt(0);
			ctx.moveTo(corner[0], corner[1]);

			for (var i &#x3D; 1; i &lt; 4; i++) {
				corner &#x3D; cornerAt(i);
				ctx.lineTo(corner[0], corner[1]);
			}

			ctx.fill();
			if (borderWidth) {
				ctx.stroke();
			}
		},

		height: function() {
			var vm &#x3D; this._view;
			return vm.base - vm.y;
		},

		inRange: function(mouseX, mouseY) {
			var inRange &#x3D; false;

			if (this._view) {
				var bounds &#x3D; getBarBounds(this);
				inRange &#x3D; mouseX &gt;&#x3D; bounds.left &amp;&amp; mouseX &lt;&#x3D; bounds.right &amp;&amp; mouseY &gt;&#x3D; bounds.top &amp;&amp; mouseY &lt;&#x3D; bounds.bottom;
			}

			return inRange;
		},

		inLabelRange: function(mouseX, mouseY) {
			var me &#x3D; this;
			if (!me._view) {
				return false;
			}

			var inRange &#x3D; false;
			var bounds &#x3D; getBarBounds(me);

			if (isVertical(me)) {
				inRange &#x3D; mouseX &gt;&#x3D; bounds.left &amp;&amp; mouseX &lt;&#x3D; bounds.right;
			} else {
				inRange &#x3D; mouseY &gt;&#x3D; bounds.top &amp;&amp; mouseY &lt;&#x3D; bounds.bottom;
			}

			return inRange;
		},

		inXRange: function(mouseX) {
			var bounds &#x3D; getBarBounds(this);
			return mouseX &gt;&#x3D; bounds.left &amp;&amp; mouseX &lt;&#x3D; bounds.right;
		},

		inYRange: function(mouseY) {
			var bounds &#x3D; getBarBounds(this);
			return mouseY &gt;&#x3D; bounds.top &amp;&amp; mouseY &lt;&#x3D; bounds.bottom;
		},

		getCenterPoint: function() {
			var vm &#x3D; this._view;
			var x, y;
			if (isVertical(this)) {
				x &#x3D; vm.x;
				y &#x3D; (vm.y + vm.base) / 2;
			} else {
				x &#x3D; (vm.x + vm.base) / 2;
				y &#x3D; vm.y;
			}

			return {x: x, y: y};
		},

		getArea: function() {
			var vm &#x3D; this._view;
			return vm.width * Math.abs(vm.y - vm.base);
		},

		tooltipPosition: function() {
			var vm &#x3D; this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		}
	});


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);

	/**
	 * Helper function to get relative position for an event
	 * @param {Event|IEvent} event - The event to get the position for
	 * @param {Chart} chart - The chart
	 * @returns {Point} the event position
	 */
	function getRelativePosition(e, chart) {
		if (e.native) {
			return {
				x: e.x,
				y: e.y
			};
		}

		return helpers.getRelativePosition(e, chart);
	}

	/**
	 * Helper function to traverse all of the visible elements in the chart
	 * @param chart {chart} the chart
	 * @param handler {Function} the callback to execute for each visible item
	 */
	function parseVisibleItems(chart, handler) {
		var datasets &#x3D; chart.data.datasets;
		var meta, i, j, ilen, jlen;

		for (i &#x3D; 0, ilen &#x3D; datasets.length; i &lt; ilen; ++i) {
			if (!chart.isDatasetVisible(i)) {
				continue;
			}

			meta &#x3D; chart.getDatasetMeta(i);
			for (j &#x3D; 0, jlen &#x3D; meta.data.length; j &lt; jlen; ++j) {
				var element &#x3D; meta.data[j];
				if (!element._view.skip) {
					handler(element);
				}
			}
		}
	}

	/**
	 * Helper function to get the items that intersect the event position
	 * @param items {ChartElement[]} elements to filter
	 * @param position {Point} the point to be nearest to
	 * @return {ChartElement[]} the nearest items
	 */
	function getIntersectItems(chart, position) {
		var elements &#x3D; [];

		parseVisibleItems(chart, function(element) {
			if (element.inRange(position.x, position.y)) {
				elements.push(element);
			}
		});

		return elements;
	}

	/**
	 * Helper function to get the items nearest to the event position considering all visible items in teh chart
	 * @param chart {Chart} the chart to look at elements from
	 * @param position {Point} the point to be nearest to
	 * @param intersect {Boolean} if true, only consider items that intersect the position
	 * @param distanceMetric {Function} function to provide the distance between points
	 * @return {ChartElement[]} the nearest items
	 */
	function getNearestItems(chart, position, intersect, distanceMetric) {
		var minDistance &#x3D; Number.POSITIVE_INFINITY;
		var nearestItems &#x3D; [];

		parseVisibleItems(chart, function(element) {
			if (intersect &amp;&amp; !element.inRange(position.x, position.y)) {
				return;
			}

			var center &#x3D; element.getCenterPoint();
			var distance &#x3D; distanceMetric(position, center);

			if (distance &lt; minDistance) {
				nearestItems &#x3D; [element];
				minDistance &#x3D; distance;
			} else if (distance &#x3D;&#x3D;&#x3D; minDistance) {
				// Can have multiple items at the same distance in which case we sort by size
				nearestItems.push(element);
			}
		});

		return nearestItems;
	}

	/**
	 * Get a distance metric function for two points based on the
	 * axis mode setting
	 * @param {String} axis the axis mode. x|y|xy
	 */
	function getDistanceMetricForAxis(axis) {
		var useX &#x3D; axis.indexOf(&#x27;x&#x27;) !&#x3D;&#x3D; -1;
		var useY &#x3D; axis.indexOf(&#x27;y&#x27;) !&#x3D;&#x3D; -1;

		return function(pt1, pt2) {
			var deltaX &#x3D; useX ? Math.abs(pt1.x - pt2.x) : 0;
			var deltaY &#x3D; useY ? Math.abs(pt1.y - pt2.y) : 0;
			return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
		};
	}

	function indexMode(chart, e, options) {
		var position &#x3D; getRelativePosition(e, chart);
		// Default axis for index mode is &#x27;x&#x27; to match old behaviour
		options.axis &#x3D; options.axis || &#x27;x&#x27;;
		var distanceMetric &#x3D; getDistanceMetricForAxis(options.axis);
		var items &#x3D; options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
		var elements &#x3D; [];

		if (!items.length) {
			return [];
		}

		chart.data.datasets.forEach(function(dataset, datasetIndex) {
			if (chart.isDatasetVisible(datasetIndex)) {
				var meta &#x3D; chart.getDatasetMeta(datasetIndex);
				var element &#x3D; meta.data[items[0]._index];

				// don&#x27;t count items that are skipped (null data)
				if (element &amp;&amp; !element._view.skip) {
					elements.push(element);
				}
			}
		});

		return elements;
	}

	/**
	 * @interface IInteractionOptions
	 */
	/**
	 * If true, only consider items that intersect the point
	 * @name IInterfaceOptions#boolean
	 * @type Boolean
	 */

	/**
	 * Contains interaction related functions
	 * @namespace Chart.Interaction
	 */
	module.exports &#x3D; {
		// Helper function for different modes
		modes: {
			single: function(chart, e) {
				var position &#x3D; getRelativePosition(e, chart);
				var elements &#x3D; [];

				parseVisibleItems(chart, function(element) {
					if (element.inRange(position.x, position.y)) {
						elements.push(element);
						return elements;
					}
				});

				return elements.slice(0, 1);
			},

			/**
			 * @function Chart.Interaction.modes.label
			 * @deprecated since version 2.4.0
			 * @todo remove at version 3
			 * @private
			 */
			label: indexMode,

			/**
			 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
			 * @function Chart.Interaction.modes.index
			 * @since v2.4.0
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			index: indexMode,

			/**
			 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect is false, we find the nearest item and return the items in that dataset
			 * @function Chart.Interaction.modes.dataset
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			dataset: function(chart, e, options) {
				var position &#x3D; getRelativePosition(e, chart);
				options.axis &#x3D; options.axis || &#x27;xy&#x27;;
				var distanceMetric &#x3D; getDistanceMetricForAxis(options.axis);
				var items &#x3D; options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

				if (items.length &gt; 0) {
					items &#x3D; chart.getDatasetMeta(items[0]._datasetIndex).data;
				}

				return items;
			},

			/**
			 * @function Chart.Interaction.modes.x-axis
			 * @deprecated since version 2.4.0. Use index mode and intersect &#x3D;&#x3D; true
			 * @todo remove at version 3
			 * @private
			 */
			&#x27;x-axis&#x27;: function(chart, e) {
				return indexMode(chart, e, {intersect: false});
			},

			/**
			 * Point mode returns all elements that hit test based on the event position
			 * of the event
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			point: function(chart, e) {
				var position &#x3D; getRelativePosition(e, chart);
				return getIntersectItems(chart, position);
			},

			/**
			 * nearest mode returns the element closest to the point
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			nearest: function(chart, e, options) {
				var position &#x3D; getRelativePosition(e, chart);
				options.axis &#x3D; options.axis || &#x27;xy&#x27;;
				var distanceMetric &#x3D; getDistanceMetricForAxis(options.axis);
				var nearestItems &#x3D; getNearestItems(chart, position, options.intersect, distanceMetric);

				// We have multiple items at the same distance from the event. Now sort by smallest
				if (nearestItems.length &gt; 1) {
					nearestItems.sort(function(a, b) {
						var sizeA &#x3D; a.getArea();
						var sizeB &#x3D; b.getArea();
						var ret &#x3D; sizeA - sizeB;

						if (ret &#x3D;&#x3D;&#x3D; 0) {
							// if equal sort by dataset index
							ret &#x3D; a._datasetIndex - b._datasetIndex;
						}

						return ret;
					});
				}

				// Return only 1 item
				return nearestItems.slice(0, 1);
			},

			/**
			 * x mode returns the elements that hit-test at the current x coordinate
			 * @function Chart.Interaction.modes.x
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			x: function(chart, e, options) {
				var position &#x3D; getRelativePosition(e, chart);
				var items &#x3D; [];
				var intersectsItem &#x3D; false;

				parseVisibleItems(chart, function(element) {
					if (element.inXRange(position.x)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem &#x3D; true;
					}
				});

				// If we want to trigger on an intersect and we don&#x27;t have any items
				// that intersect the position, return nothing
				if (options.intersect &amp;&amp; !intersectsItem) {
					items &#x3D; [];
				}
				return items;
			},

			/**
			 * y mode returns the elements that hit-test at the current y coordinate
			 * @function Chart.Interaction.modes.y
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			y: function(chart, e, options) {
				var position &#x3D; getRelativePosition(e, chart);
				var items &#x3D; [];
				var intersectsItem &#x3D; false;

				parseVisibleItems(chart, function(element) {
					if (element.inYRange(position.y)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem &#x3D; true;
					}
				});

				// If we want to trigger on an intersect and we don&#x27;t have any items
				// that intersect the position, return nothing
				if (options.intersect &amp;&amp; !intersectsItem) {
					items &#x3D; [];
				}
				return items;
			}
		}
	};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);

	function filterByPosition(array, position) {
		return helpers.where(array, function(v) {
			return v.position &#x3D;&#x3D;&#x3D; position;
		});
	}

	function sortByWeight(array, reverse) {
		array.forEach(function(v, i) {
			v._tmpIndex_ &#x3D; i;
			return v;
		});
		array.sort(function(a, b) {
			var v0 &#x3D; reverse ? b : a;
			var v1 &#x3D; reverse ? a : b;
			return v0.weight &#x3D;&#x3D;&#x3D; v1.weight ?
				v0._tmpIndex_ - v1._tmpIndex_ :
				v0.weight - v1.weight;
		});
		array.forEach(function(v) {
			delete v._tmpIndex_;
		});
	}

	/**
	 * @interface ILayoutItem
	 * @prop {String} position - The position of the item in the chart layout. Possible values are
	 * &#x27;left&#x27;, &#x27;top&#x27;, &#x27;right&#x27;, &#x27;bottom&#x27;, and &#x27;chartArea&#x27;
	 * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
	 * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
	 * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
	 * @prop {Function} update - Takes two parameters: width and height. Returns size of item
	 * @prop {Function} getPadding -  Returns an object with padding on the edges
	 * @prop {Number} width - Width of item. Must be valid after update()
	 * @prop {Number} height - Height of item. Must be valid after update()
	 * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
	 */

	// The layout service is very self explanatory.  It&#x27;s responsible for the layout within a chart.
	// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
	// It is this service&#x27;s responsibility of carrying out that layout.
	module.exports &#x3D; {
		defaults: {},

		/**
		 * Register a box to a chart.
		 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
		 * @param {Chart} chart - the chart to use
		 * @param {ILayoutItem} item - the item to add to be layed out
		 */
		addBox: function(chart, item) {
			if (!chart.boxes) {
				chart.boxes &#x3D; [];
			}

			// initialize item with default values
			item.fullWidth &#x3D; item.fullWidth || false;
			item.position &#x3D; item.position || &#x27;top&#x27;;
			item.weight &#x3D; item.weight || 0;

			chart.boxes.push(item);
		},

		/**
		 * Remove a layoutItem from a chart
		 * @param {Chart} chart - the chart to remove the box from
		 * @param {Object} layoutItem - the item to remove from the layout
		 */
		removeBox: function(chart, layoutItem) {
			var index &#x3D; chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
			if (index !&#x3D;&#x3D; -1) {
				chart.boxes.splice(index, 1);
			}
		},

		/**
		 * Sets (or updates) options on the given &#x60;item&#x60;.
		 * @param {Chart} chart - the chart in which the item lives (or will be added to)
		 * @param {Object} item - the item to configure with the given options
		 * @param {Object} options - the new item options.
		 */
		configure: function(chart, item, options) {
			var props &#x3D; [&#x27;fullWidth&#x27;, &#x27;position&#x27;, &#x27;weight&#x27;];
			var ilen &#x3D; props.length;
			var i &#x3D; 0;
			var prop;

			for (; i &lt; ilen; ++i) {
				prop &#x3D; props[i];
				if (options.hasOwnProperty(prop)) {
					item[prop] &#x3D; options[prop];
				}
			}
		},

		/**
		 * Fits boxes of the given chart into the given size by having each box measure itself
		 * then running a fitting algorithm
		 * @param {Chart} chart - the chart
		 * @param {Number} width - the width to fit into
		 * @param {Number} height - the height to fit into
		 */
		update: function(chart, width, height) {
			if (!chart) {
				return;
			}

			var layoutOptions &#x3D; chart.options.layout || {};
			var padding &#x3D; helpers.options.toPadding(layoutOptions.padding);
			var leftPadding &#x3D; padding.left;
			var rightPadding &#x3D; padding.right;
			var topPadding &#x3D; padding.top;
			var bottomPadding &#x3D; padding.bottom;

			var leftBoxes &#x3D; filterByPosition(chart.boxes, &#x27;left&#x27;);
			var rightBoxes &#x3D; filterByPosition(chart.boxes, &#x27;right&#x27;);
			var topBoxes &#x3D; filterByPosition(chart.boxes, &#x27;top&#x27;);
			var bottomBoxes &#x3D; filterByPosition(chart.boxes, &#x27;bottom&#x27;);
			var chartAreaBoxes &#x3D; filterByPosition(chart.boxes, &#x27;chartArea&#x27;);

			// Sort boxes by weight. A higher weight is further away from the chart area
			sortByWeight(leftBoxes, true);
			sortByWeight(rightBoxes, false);
			sortByWeight(topBoxes, true);
			sortByWeight(bottomBoxes, false);

			// Essentially we now have any number of boxes on each of the 4 sides.
			// Our canvas looks like the following.
			// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
			// B1 is the bottom axis
			// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
			// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
			// an error will be thrown.
			//
			// |----------------------------------------------------|
			// |                  T1 (Full Width)                   |
			// |----------------------------------------------------|
			// |    |    |                 T2                  |    |
			// |    |----|-------------------------------------|----|
			// |    |    | C1 |                           | C2 |    |
			// |    |    |----|                           |----|    |
			// |    |    |                                     |    |
			// | L1 | L2 |           ChartArea (C0)            | R1 |
			// |    |    |                                     |    |
			// |    |    |----|                           |----|    |
			// |    |    | C3 |                           | C4 |    |
			// |    |----|-------------------------------------|----|
			// |    |    |                 B1                  |    |
			// |----------------------------------------------------|
			// |                  B2 (Full Width)                   |
			// |----------------------------------------------------|
			//
			// What we do to find the best sizing, we do the following
			// 1. Determine the minimum size of the chart area.
			// 2. Split the remaining width equally between each vertical axis
			// 3. Split the remaining height equally between each horizontal axis
			// 4. Give each layout the maximum size it can be. The layout will return it&#x27;s minimum size
			// 5. Adjust the sizes of each axis based on it&#x27;s minimum reported size.
			// 6. Refit each axis
			// 7. Position each axis in the final location
			// 8. Tell the chart the final location of the chart area
			// 9. Tell any axes that overlay the chart area the positions of the chart area

			// Step 1
			var chartWidth &#x3D; width - leftPadding - rightPadding;
			var chartHeight &#x3D; height - topPadding - bottomPadding;
			var chartAreaWidth &#x3D; chartWidth / 2; // min 50%
			var chartAreaHeight &#x3D; chartHeight / 2; // min 50%

			// Step 2
			var verticalBoxWidth &#x3D; (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

			// Step 3
			var horizontalBoxHeight &#x3D; (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

			// Step 4
			var maxChartAreaWidth &#x3D; chartWidth;
			var maxChartAreaHeight &#x3D; chartHeight;
			var minBoxSizes &#x3D; [];

			function getMinimumBoxSize(box) {
				var minSize;
				var isHorizontal &#x3D; box.isHorizontal();

				if (isHorizontal) {
					minSize &#x3D; box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
					maxChartAreaHeight -&#x3D; minSize.height;
				} else {
					minSize &#x3D; box.update(verticalBoxWidth, maxChartAreaHeight);
					maxChartAreaWidth -&#x3D; minSize.width;
				}

				minBoxSizes.push({
					horizontal: isHorizontal,
					minSize: minSize,
					box: box,
				});
			}

			helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

			// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
			var maxHorizontalLeftPadding &#x3D; 0;
			var maxHorizontalRightPadding &#x3D; 0;
			var maxVerticalTopPadding &#x3D; 0;
			var maxVerticalBottomPadding &#x3D; 0;

			helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
				if (horizontalBox.getPadding) {
					var boxPadding &#x3D; horizontalBox.getPadding();
					maxHorizontalLeftPadding &#x3D; Math.max(maxHorizontalLeftPadding, boxPadding.left);
					maxHorizontalRightPadding &#x3D; Math.max(maxHorizontalRightPadding, boxPadding.right);
				}
			});

			helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
				if (verticalBox.getPadding) {
					var boxPadding &#x3D; verticalBox.getPadding();
					maxVerticalTopPadding &#x3D; Math.max(maxVerticalTopPadding, boxPadding.top);
					maxVerticalBottomPadding &#x3D; Math.max(maxVerticalBottomPadding, boxPadding.bottom);
				}
			});

			// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
			// be if the axes are drawn at their minimum sizes.
			// Steps 5 &amp; 6
			var totalLeftBoxesWidth &#x3D; leftPadding;
			var totalRightBoxesWidth &#x3D; rightPadding;
			var totalTopBoxesHeight &#x3D; topPadding;
			var totalBottomBoxesHeight &#x3D; bottomPadding;

			// Function to fit a box
			function fitBox(box) {
				var minBoxSize &#x3D; helpers.findNextWhere(minBoxSizes, function(minBox) {
					return minBox.box &#x3D;&#x3D;&#x3D; box;
				});

				if (minBoxSize) {
					if (box.isHorizontal()) {
						var scaleMargin &#x3D; {
							left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
							right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
							top: 0,
							bottom: 0
						};

						// Don&#x27;t use min size here because of label rotation. When the labels are rotated, their rotation highly depends
						// on the margin. Sometimes they need to increase in size slightly
						box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
					} else {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight);
					}
				}
			}

			// Update, and calculate the left and right margins for the horizontal boxes
			helpers.each(leftBoxes.concat(rightBoxes), fitBox);

			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth +&#x3D; box.width;
			});

			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth +&#x3D; box.width;
			});

			// Set the Left and Right margins for the horizontal boxes
			helpers.each(topBoxes.concat(bottomBoxes), fitBox);

			// Figure out how much margin is on the top and bottom of the vertical boxes
			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight +&#x3D; box.height;
			});

			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight +&#x3D; box.height;
			});

			function finalFitVerticalBox(box) {
				var minBoxSize &#x3D; helpers.findNextWhere(minBoxSizes, function(minSize) {
					return minSize.box &#x3D;&#x3D;&#x3D; box;
				});

				var scaleMargin &#x3D; {
					left: 0,
					right: 0,
					top: totalTopBoxesHeight,
					bottom: totalBottomBoxesHeight
				};

				if (minBoxSize) {
					box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
				}
			}

			// Let the left layout know the final margin
			helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

			// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
			totalLeftBoxesWidth &#x3D; leftPadding;
			totalRightBoxesWidth &#x3D; rightPadding;
			totalTopBoxesHeight &#x3D; topPadding;
			totalBottomBoxesHeight &#x3D; bottomPadding;

			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth +&#x3D; box.width;
			});

			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth +&#x3D; box.width;
			});

			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight +&#x3D; box.height;
			});
			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight +&#x3D; box.height;
			});

			// We may be adding some padding to account for rotated x axis labels
			var leftPaddingAddition &#x3D; Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
			totalLeftBoxesWidth +&#x3D; leftPaddingAddition;
			totalRightBoxesWidth +&#x3D; Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

			var topPaddingAddition &#x3D; Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
			totalTopBoxesHeight +&#x3D; topPaddingAddition;
			totalBottomBoxesHeight +&#x3D; Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

			// Figure out if our chart area changed. This would occur if the dataset layout label rotation
			// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
			// without calling &#x60;fit&#x60; again
			var newMaxChartAreaHeight &#x3D; height - totalTopBoxesHeight - totalBottomBoxesHeight;
			var newMaxChartAreaWidth &#x3D; width - totalLeftBoxesWidth - totalRightBoxesWidth;

			if (newMaxChartAreaWidth !&#x3D;&#x3D; maxChartAreaWidth || newMaxChartAreaHeight !&#x3D;&#x3D; maxChartAreaHeight) {
				helpers.each(leftBoxes, function(box) {
					box.height &#x3D; newMaxChartAreaHeight;
				});

				helpers.each(rightBoxes, function(box) {
					box.height &#x3D; newMaxChartAreaHeight;
				});

				helpers.each(topBoxes, function(box) {
					if (!box.fullWidth) {
						box.width &#x3D; newMaxChartAreaWidth;
					}
				});

				helpers.each(bottomBoxes, function(box) {
					if (!box.fullWidth) {
						box.width &#x3D; newMaxChartAreaWidth;
					}
				});

				maxChartAreaHeight &#x3D; newMaxChartAreaHeight;
				maxChartAreaWidth &#x3D; newMaxChartAreaWidth;
			}

			// Step 7 - Position the boxes
			var left &#x3D; leftPadding + leftPaddingAddition;
			var top &#x3D; topPadding + topPaddingAddition;

			function placeBox(box) {
				if (box.isHorizontal()) {
					box.left &#x3D; box.fullWidth ? leftPadding : totalLeftBoxesWidth;
					box.right &#x3D; box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
					box.top &#x3D; top;
					box.bottom &#x3D; top + box.height;

					// Move to next point
					top &#x3D; box.bottom;

				} else {

					box.left &#x3D; left;
					box.right &#x3D; left + box.width;
					box.top &#x3D; totalTopBoxesHeight;
					box.bottom &#x3D; totalTopBoxesHeight + maxChartAreaHeight;

					// Move to next point
					left &#x3D; box.right;
				}
			}

			helpers.each(leftBoxes.concat(topBoxes), placeBox);

			// Account for chart width and height
			left +&#x3D; maxChartAreaWidth;
			top +&#x3D; maxChartAreaHeight;

			helpers.each(rightBoxes, placeBox);
			helpers.each(bottomBoxes, placeBox);

			// Step 8
			chart.chartArea &#x3D; {
				left: totalLeftBoxesWidth,
				top: totalTopBoxesHeight,
				right: totalLeftBoxesWidth + maxChartAreaWidth,
				bottom: totalTopBoxesHeight + maxChartAreaHeight
			};

			// Step 9
			helpers.each(chartAreaBoxes, function(box) {
				box.left &#x3D; chart.chartArea.left;
				box.top &#x3D; chart.chartArea.top;
				box.right &#x3D; chart.chartArea.right;
				box.bottom &#x3D; chart.chartArea.bottom;

				box.update(maxChartAreaWidth, maxChartAreaHeight);
			});
		}
	};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);
	var basic &#x3D; __webpack_require__(56);
	var dom &#x3D; __webpack_require__(57);

	// @TODO Make possible to select another platform at build time.
	var implementation &#x3D; dom._enabled ? dom : basic;

	/**
	 * @namespace Chart.platform
	 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
	 * @since 2.4.0
	 */
	module.exports &#x3D; helpers.extend({
		/**
		 * @since 2.7.0
		 */
		initialize: function() {},

		/**
		 * Called at chart construction time, returns a context2d instance implementing
		 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
		 * @param {*} item - The native item from which to acquire context (platform specific)
		 * @param {Object} options - The chart options
		 * @returns {CanvasRenderingContext2D} context2d instance
		 */
		acquireContext: function() {},

		/**
		 * Called at chart destruction time, releases any resources associated to the context
		 * previously returned by the acquireContext() method.
		 * @param {CanvasRenderingContext2D} context - The context2d instance
		 * @returns {Boolean} true if the method succeeded, else false
		 */
		releaseContext: function() {},

		/**
		 * Registers the specified listener on the given chart.
		 * @param {Chart} chart - Chart from which to listen for event
		 * @param {String} type - The ({@link IEvent}) type to listen for
		 * @param {Function} listener - Receives a notification (an object that implements
		 * the {@link IEvent} interface) when an event of the specified type occurs.
		 */
		addEventListener: function() {},

		/**
		 * Removes the specified listener previously registered with addEventListener.
		 * @param {Chart} chart -Chart from which to remove the listener
		 * @param {String} type - The ({@link IEvent}) type to remove
		 * @param {Function} listener - The listener function to remove from the event target.
		 */
		removeEventListener: function() {}

	}, implementation);

	/**
	 * @interface IPlatform
	 * Allows abstracting platform dependencies away from the chart
	 * @borrows Chart.platform.acquireContext as acquireContext
	 * @borrows Chart.platform.releaseContext as releaseContext
	 * @borrows Chart.platform.addEventListener as addEventListener
	 * @borrows Chart.platform.removeEventListener as removeEventListener
	 */

	/**
	 * @interface IEvent
	 * @prop {String} type - The event type name, possible values are:
	 * &#x27;contextmenu&#x27;, &#x27;mouseenter&#x27;, &#x27;mousedown&#x27;, &#x27;mousemove&#x27;, &#x27;mouseup&#x27;, &#x27;mouseout&#x27;,
	 * &#x27;click&#x27;, &#x27;dblclick&#x27;, &#x27;keydown&#x27;, &#x27;keypress&#x27;, &#x27;keyup&#x27; and &#x27;resize&#x27;
	 * @prop {*} native - The original native event (null for emulated events, e.g. &#x27;resize&#x27;)
	 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
	 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
	 */


/***/ }),
/* 56 */
/***/ (function(module, exports) {

	/**
	 * Platform fallback implementation (minimal).
	 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
	 */

	module.exports &#x3D; {
		acquireContext: function(item) {
			if (item &amp;&amp; item.canvas) {
				// Support for any object associated to a canvas (including a context2d)
				item &#x3D; item.canvas;
			}

			return item &amp;&amp; item.getContext(&#x27;2d&#x27;) || null;
		}
	};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Chart.Platform implementation for targeting a web browser
	 */

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);

	var EXPANDO_KEY &#x3D; &#x27;$chartjs&#x27;;
	var CSS_PREFIX &#x3D; &#x27;chartjs-&#x27;;
	var CSS_RENDER_MONITOR &#x3D; CSS_PREFIX + &#x27;render-monitor&#x27;;
	var CSS_RENDER_ANIMATION &#x3D; CSS_PREFIX + &#x27;render-animation&#x27;;
	var ANIMATION_START_EVENTS &#x3D; [&#x27;animationstart&#x27;, &#x27;webkitAnimationStart&#x27;];

	/**
	 * DOM event types -&gt; Chart.js event types.
	 * Note: only events with different types are mapped.
	 * @see https://developer.mozilla.org/en-US/docs/Web/Events
	 */
	var EVENT_TYPES &#x3D; {
		touchstart: &#x27;mousedown&#x27;,
		touchmove: &#x27;mousemove&#x27;,
		touchend: &#x27;mouseup&#x27;,
		pointerenter: &#x27;mouseenter&#x27;,
		pointerdown: &#x27;mousedown&#x27;,
		pointermove: &#x27;mousemove&#x27;,
		pointerup: &#x27;mouseup&#x27;,
		pointerleave: &#x27;mouseout&#x27;,
		pointerout: &#x27;mouseout&#x27;
	};

	/**
	 * The &quot;used&quot; size is the final value of a dimension property after all calculations have
	 * been performed. This method uses the computed style of &#x60;element&#x60; but returns undefined
	 * if the computed style is not expressed in pixels. That can happen in some cases where
	 * &#x60;element&#x60; has a size relative to its parent and this last one is not yet displayed,
	 * for example because of &#x60;display: none&#x60; on a parent node.
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
	 * @returns {Number} Size in pixels or undefined if unknown.
	 */
	function readUsedSize(element, property) {
		var value &#x3D; helpers.getStyle(element, property);
		var matches &#x3D; value &amp;&amp; value.match(/^(\d+)(\.\d+)?px$/);
		return matches ? Number(matches[1]) : undefined;
	}

	/**
	 * Initializes the canvas style and render size without modifying the canvas display size,
	 * since responsiveness is handled by the controller.resize() method. The config is used
	 * to determine the aspect ratio to apply in case no explicit height has been specified.
	 */
	function initCanvas(canvas, config) {
		var style &#x3D; canvas.style;

		// NOTE(SB) canvas.getAttribute(&#x27;width&#x27;) !&#x3D;&#x3D; canvas.width: in the first case it
		// returns null or &#x27;&#x27; if no explicit value has been set to the canvas attribute.
		var renderHeight &#x3D; canvas.getAttribute(&#x27;height&#x27;);
		var renderWidth &#x3D; canvas.getAttribute(&#x27;width&#x27;);

		// Chart.js modifies some canvas values that we want to restore on destroy
		canvas[EXPANDO_KEY] &#x3D; {
			initial: {
				height: renderHeight,
				width: renderWidth,
				style: {
					display: style.display,
					height: style.height,
					width: style.width
				}
			}
		};

		// Force canvas to display as block to avoid extra space caused by inline
		// elements, which would interfere with the responsive resize process.
		// https://github.com/chartjs/Chart.js/issues/2538
		style.display &#x3D; style.display || &#x27;block&#x27;;

		if (renderWidth &#x3D;&#x3D;&#x3D; null || renderWidth &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
			var displayWidth &#x3D; readUsedSize(canvas, &#x27;width&#x27;);
			if (displayWidth !&#x3D;&#x3D; undefined) {
				canvas.width &#x3D; displayWidth;
			}
		}

		if (renderHeight &#x3D;&#x3D;&#x3D; null || renderHeight &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
			if (canvas.style.height &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
				// If no explicit render height and style height, let&#x27;s apply the aspect ratio,
				// which one can be specified by the user but also by charts as default option
				// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
				canvas.height &#x3D; canvas.width / (config.options.aspectRatio || 2);
			} else {
				var displayHeight &#x3D; readUsedSize(canvas, &#x27;height&#x27;);
				if (displayWidth !&#x3D;&#x3D; undefined) {
					canvas.height &#x3D; displayHeight;
				}
			}
		}

		return canvas;
	}

	/**
	 * Detects support for options object argument in addEventListener.
	 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
	 * @private
	 */
	var supportsEventListenerOptions &#x3D; (function() {
		var supports &#x3D; false;
		try {
			var options &#x3D; Object.defineProperty({}, &#x27;passive&#x27;, {
				get: function() {
					supports &#x3D; true;
				}
			});
			window.addEventListener(&#x27;e&#x27;, null, options);
		} catch (e) {
			// continue regardless of error
		}
		return supports;
	}());

	// Default passive to true as expected by Chrome for &#x27;touchstart&#x27; and &#x27;touchend&#x27; events.
	// https://github.com/chartjs/Chart.js/issues/4287
	var eventListenerOptions &#x3D; supportsEventListenerOptions ? {passive: true} : false;

	function addEventListener(node, type, listener) {
		node.addEventListener(type, listener, eventListenerOptions);
	}

	function removeEventListener(node, type, listener) {
		node.removeEventListener(type, listener, eventListenerOptions);
	}

	function createEvent(type, chart, x, y, nativeEvent) {
		return {
			type: type,
			chart: chart,
			native: nativeEvent || null,
			x: x !&#x3D;&#x3D; undefined ? x : null,
			y: y !&#x3D;&#x3D; undefined ? y : null,
		};
	}

	function fromNativeEvent(event, chart) {
		var type &#x3D; EVENT_TYPES[event.type] || event.type;
		var pos &#x3D; helpers.getRelativePosition(event, chart);
		return createEvent(type, chart, pos.x, pos.y, event);
	}

	function throttled(fn, thisArg) {
		var ticking &#x3D; false;
		var args &#x3D; [];

		return function() {
			args &#x3D; Array.prototype.slice.call(arguments);
			thisArg &#x3D; thisArg || this;

			if (!ticking) {
				ticking &#x3D; true;
				helpers.requestAnimFrame.call(window, function() {
					ticking &#x3D; false;
					fn.apply(thisArg, args);
				});
			}
		};
	}

	// Implementation based on https://github.com/marcj/css-element-queries
	function createResizer(handler) {
		var resizer &#x3D; document.createElement(&#x27;div&#x27;);
		var cls &#x3D; CSS_PREFIX + &#x27;size-monitor&#x27;;
		var maxSize &#x3D; 1000000;
		var style &#x3D;
			&#x27;position:absolute;&#x27; +
			&#x27;left:0;&#x27; +
			&#x27;top:0;&#x27; +
			&#x27;right:0;&#x27; +
			&#x27;bottom:0;&#x27; +
			&#x27;overflow:hidden;&#x27; +
			&#x27;pointer-events:none;&#x27; +
			&#x27;visibility:hidden;&#x27; +
			&#x27;z-index:-1;&#x27;;

		resizer.style.cssText &#x3D; style;
		resizer.className &#x3D; cls;
		resizer.innerHTML &#x3D;
			&#x27;&lt;div class&#x3D;&quot;&#x27; + cls + &#x27;-expand&quot; style&#x3D;&quot;&#x27; + style + &#x27;&quot;&gt;&#x27; +
				&#x27;&lt;div style&#x3D;&quot;&#x27; +
					&#x27;position:absolute;&#x27; +
					&#x27;width:&#x27; + maxSize + &#x27;px;&#x27; +
					&#x27;height:&#x27; + maxSize + &#x27;px;&#x27; +
					&#x27;left:0;&#x27; +
					&#x27;top:0&quot;&gt;&#x27; +
				&#x27;&lt;/div&gt;&#x27; +
			&#x27;&lt;/div&gt;&#x27; +
			&#x27;&lt;div class&#x3D;&quot;&#x27; + cls + &#x27;-shrink&quot; style&#x3D;&quot;&#x27; + style + &#x27;&quot;&gt;&#x27; +
				&#x27;&lt;div style&#x3D;&quot;&#x27; +
					&#x27;position:absolute;&#x27; +
					&#x27;width:200%;&#x27; +
					&#x27;height:200%;&#x27; +
					&#x27;left:0; &#x27; +
					&#x27;top:0&quot;&gt;&#x27; +
				&#x27;&lt;/div&gt;&#x27; +
			&#x27;&lt;/div&gt;&#x27;;

		var expand &#x3D; resizer.childNodes[0];
		var shrink &#x3D; resizer.childNodes[1];

		resizer._reset &#x3D; function() {
			expand.scrollLeft &#x3D; maxSize;
			expand.scrollTop &#x3D; maxSize;
			shrink.scrollLeft &#x3D; maxSize;
			shrink.scrollTop &#x3D; maxSize;
		};
		var onScroll &#x3D; function() {
			resizer._reset();
			handler();
		};

		addEventListener(expand, &#x27;scroll&#x27;, onScroll.bind(expand, &#x27;expand&#x27;));
		addEventListener(shrink, &#x27;scroll&#x27;, onScroll.bind(shrink, &#x27;shrink&#x27;));

		return resizer;
	}

	// https://davidwalsh.name/detect-node-insertion
	function watchForRender(node, handler) {
		var expando &#x3D; node[EXPANDO_KEY] || (node[EXPANDO_KEY] &#x3D; {});
		var proxy &#x3D; expando.renderProxy &#x3D; function(e) {
			if (e.animationName &#x3D;&#x3D;&#x3D; CSS_RENDER_ANIMATION) {
				handler();
			}
		};

		helpers.each(ANIMATION_START_EVENTS, function(type) {
			addEventListener(node, type, proxy);
		});

		// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
		// is removed then added back immediately (same animation frame?). Accessing the
		// &#x60;offsetParent&#x60; property will force a reflow and re-evaluate the CSS animation.
		// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
		// https://github.com/chartjs/Chart.js/issues/4737
		expando.reflow &#x3D; !!node.offsetParent;

		node.classList.add(CSS_RENDER_MONITOR);
	}

	function unwatchForRender(node) {
		var expando &#x3D; node[EXPANDO_KEY] || {};
		var proxy &#x3D; expando.renderProxy;

		if (proxy) {
			helpers.each(ANIMATION_START_EVENTS, function(type) {
				removeEventListener(node, type, proxy);
			});

			delete expando.renderProxy;
		}

		node.classList.remove(CSS_RENDER_MONITOR);
	}

	function addResizeListener(node, listener, chart) {
		var expando &#x3D; node[EXPANDO_KEY] || (node[EXPANDO_KEY] &#x3D; {});

		// Let&#x27;s keep track of this added resizer and thus avoid DOM query when removing it.
		var resizer &#x3D; expando.resizer &#x3D; createResizer(throttled(function() {
			if (expando.resizer) {
				return listener(createEvent(&#x27;resize&#x27;, chart));
			}
		}));

		// The resizer needs to be attached to the node parent, so we first need to be
		// sure that &#x60;node&#x60; is attached to the DOM before injecting the resizer element.
		watchForRender(node, function() {
			if (expando.resizer) {
				var container &#x3D; node.parentNode;
				if (container &amp;&amp; container !&#x3D;&#x3D; resizer.parentNode) {
					container.insertBefore(resizer, container.firstChild);
				}

				// The container size might have changed, let&#x27;s reset the resizer state.
				resizer._reset();
			}
		});
	}

	function removeResizeListener(node) {
		var expando &#x3D; node[EXPANDO_KEY] || {};
		var resizer &#x3D; expando.resizer;

		delete expando.resizer;
		unwatchForRender(node);

		if (resizer &amp;&amp; resizer.parentNode) {
			resizer.parentNode.removeChild(resizer);
		}
	}

	function injectCSS(platform, css) {
		// http://stackoverflow.com/q/3922139
		var style &#x3D; platform._style || document.createElement(&#x27;style&#x27;);
		if (!platform._style) {
			platform._style &#x3D; style;
			css &#x3D; &#x27;/* Chart.js */\n&#x27; + css;
			style.setAttribute(&#x27;type&#x27;, &#x27;text/css&#x27;);
			document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(style);
		}

		style.appendChild(document.createTextNode(css));
	}

	module.exports &#x3D; {
		/**
		 * This property holds whether this platform is enabled for the current environment.
		 * Currently used by platform.js to select the proper implementation.
		 * @private
		 */
		_enabled: typeof window !&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; typeof document !&#x3D;&#x3D; &#x27;undefined&#x27;,

		initialize: function() {
			var keyframes &#x3D; &#x27;from{opacity:0.99}to{opacity:1}&#x27;;

			injectCSS(this,
				// DOM rendering detection
				// https://davidwalsh.name/detect-node-insertion
				&#x27;@-webkit-keyframes &#x27; + CSS_RENDER_ANIMATION + &#x27;{&#x27; + keyframes + &#x27;}&#x27; +
				&#x27;@keyframes &#x27; + CSS_RENDER_ANIMATION + &#x27;{&#x27; + keyframes + &#x27;}&#x27; +
				&#x27;.&#x27; + CSS_RENDER_MONITOR + &#x27;{&#x27; +
					&#x27;-webkit-animation:&#x27; + CSS_RENDER_ANIMATION + &#x27; 0.001s;&#x27; +
					&#x27;animation:&#x27; + CSS_RENDER_ANIMATION + &#x27; 0.001s;&#x27; +
				&#x27;}&#x27;
			);
		},

		acquireContext: function(item, config) {
			if (typeof item &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
				item &#x3D; document.getElementById(item);
			} else if (item.length) {
				// Support for array based queries (such as jQuery)
				item &#x3D; item[0];
			}

			if (item &amp;&amp; item.canvas) {
				// Support for any object associated to a canvas (including a context2d)
				item &#x3D; item.canvas;
			}

			// To prevent canvas fingerprinting, some add-ons undefine the getContext
			// method, for example: https://github.com/kkapsner/CanvasBlocker
			// https://github.com/chartjs/Chart.js/issues/2807
			var context &#x3D; item &amp;&amp; item.getContext &amp;&amp; item.getContext(&#x27;2d&#x27;);

			// &#x60;instanceof HTMLCanvasElement/CanvasRenderingContext2D&#x60; fails when the item is
			// inside an iframe or when running in a protected environment. We could guess the
			// types from their toString() value but let&#x27;s keep things flexible and assume it&#x27;s
			// a sufficient condition if the item has a context2D which has item as &#x60;canvas&#x60;.
			// https://github.com/chartjs/Chart.js/issues/3887
			// https://github.com/chartjs/Chart.js/issues/4102
			// https://github.com/chartjs/Chart.js/issues/4152
			if (context &amp;&amp; context.canvas &#x3D;&#x3D;&#x3D; item) {
				initCanvas(item, config);
				return context;
			}

			return null;
		},

		releaseContext: function(context) {
			var canvas &#x3D; context.canvas;
			if (!canvas[EXPANDO_KEY]) {
				return;
			}

			var initial &#x3D; canvas[EXPANDO_KEY].initial;
			[&#x27;height&#x27;, &#x27;width&#x27;].forEach(function(prop) {
				var value &#x3D; initial[prop];
				if (helpers.isNullOrUndef(value)) {
					canvas.removeAttribute(prop);
				} else {
					canvas.setAttribute(prop, value);
				}
			});

			helpers.each(initial.style || {}, function(value, key) {
				canvas.style[key] &#x3D; value;
			});

			// The canvas render size might have been changed (and thus the state stack discarded),
			// we can&#x27;t use save() and restore() to restore the initial state. So make sure that at
			// least the canvas context is reset to the default state by setting the canvas width.
			// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
			canvas.width &#x3D; canvas.width;

			delete canvas[EXPANDO_KEY];
		},

		addEventListener: function(chart, type, listener) {
			var canvas &#x3D; chart.canvas;
			if (type &#x3D;&#x3D;&#x3D; &#x27;resize&#x27;) {
				// Note: the resize event is not supported on all browsers.
				addResizeListener(canvas, listener, chart);
				return;
			}

			var expando &#x3D; listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] &#x3D; {});
			var proxies &#x3D; expando.proxies || (expando.proxies &#x3D; {});
			var proxy &#x3D; proxies[chart.id + &#x27;_&#x27; + type] &#x3D; function(event) {
				listener(fromNativeEvent(event, chart));
			};

			addEventListener(canvas, type, proxy);
		},

		removeEventListener: function(chart, type, listener) {
			var canvas &#x3D; chart.canvas;
			if (type &#x3D;&#x3D;&#x3D; &#x27;resize&#x27;) {
				// Note: the resize event is not supported on all browsers.
				removeResizeListener(canvas, listener);
				return;
			}

			var expando &#x3D; listener[EXPANDO_KEY] || {};
			var proxies &#x3D; expando.proxies || {};
			var proxy &#x3D; proxies[chart.id + &#x27;_&#x27; + type];
			if (!proxy) {
				return;
			}

			removeEventListener(canvas, type, proxy);
		}
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use EventTarget.addEventListener instead.
	 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
	 * @function Chart.helpers.addEvent
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.addEvent &#x3D; addEventListener;

	/**
	 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
	 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
	 * @function Chart.helpers.removeEvent
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.removeEvent &#x3D; removeEventListener;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		plugins: {}
	});

	/**
	 * The plugin service singleton
	 * @namespace Chart.plugins
	 * @since 2.1.0
	 */
	module.exports &#x3D; {
		/**
		 * Globally registered plugins.
		 * @private
		 */
		_plugins: [],

		/**
		 * This identifier is used to invalidate the descriptors cache attached to each chart
		 * when a global plugin is registered or unregistered. In this case, the cache ID is
		 * incremented and descriptors are regenerated during following API calls.
		 * @private
		 */
		_cacheId: 0,

		/**
		 * Registers the given plugin(s) if not already registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		register: function(plugins) {
			var p &#x3D; this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				if (p.indexOf(plugin) &#x3D;&#x3D;&#x3D; -1) {
					p.push(plugin);
				}
			});

			this._cacheId++;
		},

		/**
		 * Unregisters the given plugin(s) only if registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		unregister: function(plugins) {
			var p &#x3D; this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				var idx &#x3D; p.indexOf(plugin);
				if (idx !&#x3D;&#x3D; -1) {
					p.splice(idx, 1);
				}
			});

			this._cacheId++;
		},

		/**
		 * Remove all registered plugins.
		 * @since 2.1.5
		 */
		clear: function() {
			this._plugins &#x3D; [];
			this._cacheId++;
		},

		/**
		 * Returns the number of registered plugins?
		 * @returns {Number}
		 * @since 2.1.5
		 */
		count: function() {
			return this._plugins.length;
		},

		/**
		 * Returns all registered plugin instances.
		 * @returns {Array} array of plugin objects.
		 * @since 2.1.5
		 */
		getAll: function() {
			return this._plugins;
		},

		/**
		 * Calls enabled plugins for &#x60;chart&#x60; on the specified hook and with the given args.
		 * This method immediately returns as soon as a plugin explicitly returns false. The
		 * returned value can be used, for instance, to interrupt the current action.
		 * @param {Object} chart - The chart instance for which plugins should be called.
		 * @param {String} hook - The name of the plugin method to call (e.g. &#x27;beforeUpdate&#x27;).
		 * @param {Array} [args] - Extra arguments to apply to the hook call.
		 * @returns {Boolean} false if any of the plugins return false, else returns true.
		 */
		notify: function(chart, hook, args) {
			var descriptors &#x3D; this.descriptors(chart);
			var ilen &#x3D; descriptors.length;
			var i, descriptor, plugin, params, method;

			for (i &#x3D; 0; i &lt; ilen; ++i) {
				descriptor &#x3D; descriptors[i];
				plugin &#x3D; descriptor.plugin;
				method &#x3D; plugin[hook];
				if (typeof method &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
					params &#x3D; [chart].concat(args || []);
					params.push(descriptor.options);
					if (method.apply(plugin, params) &#x3D;&#x3D;&#x3D; false) {
						return false;
					}
				}
			}

			return true;
		},

		/**
		 * Returns descriptors of enabled plugins for the given chart.
		 * @returns {Array} [{ plugin, options }]
		 * @private
		 */
		descriptors: function(chart) {
			var cache &#x3D; chart.$plugins || (chart.$plugins &#x3D; {});
			if (cache.id &#x3D;&#x3D;&#x3D; this._cacheId) {
				return cache.descriptors;
			}

			var plugins &#x3D; [];
			var descriptors &#x3D; [];
			var config &#x3D; (chart &amp;&amp; chart.config) || {};
			var options &#x3D; (config.options &amp;&amp; config.options.plugins) || {};

			this._plugins.concat(config.plugins || []).forEach(function(plugin) {
				var idx &#x3D; plugins.indexOf(plugin);
				if (idx !&#x3D;&#x3D; -1) {
					return;
				}

				var id &#x3D; plugin.id;
				var opts &#x3D; options[id];
				if (opts &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				if (opts &#x3D;&#x3D;&#x3D; true) {
					opts &#x3D; helpers.clone(defaults.global.plugins[id]);
				}

				plugins.push(plugin);
				descriptors.push({
					plugin: plugin,
					options: opts || {}
				});
			});

			cache.descriptors &#x3D; descriptors;
			cache.id &#x3D; this._cacheId;
			return descriptors;
		},

		/**
		 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
		 * but in some cases, this reference can be changed by the user when updating options.
		 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
		 * @private
		 */
		_invalidate: function(chart) {
			delete chart.$plugins;
		}
	};

	/**
	 * Plugin extension hooks.
	 * @interface IPlugin
	 * @since 2.1.0
	 */
	/**
	 * @method IPlugin#beforeInit
	 * @desc Called before initializing &#x60;chart&#x60;.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#afterInit
	 * @desc Called after &#x60;chart&#x60; has been initialized and before the first update.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeUpdate
	 * @desc Called before updating &#x60;chart&#x60;. If any plugin returns &#x60;false&#x60;, the update
	 * is cancelled (and thus subsequent render(s)) until another &#x60;update&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart update.
	 */
	/**
	 * @method IPlugin#afterUpdate
	 * @desc Called after &#x60;chart&#x60; has been updated and before rendering. Note that this
	 * hook will not be called if the chart update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetsUpdate
	 * @desc Called before updating the &#x60;chart&#x60; datasets. If any plugin returns &#x60;false&#x60;,
	 * the datasets update is cancelled until another &#x60;update&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} false to cancel the datasets update.
	 * @since version 2.1.5
	*/
	/**
	 * @method IPlugin#afterDatasetsUpdate
	 * @desc Called after the &#x60;chart&#x60; datasets have been updated. Note that this hook
	 * will not be called if the datasets update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @since version 2.1.5
	 */
	/**
	 * @method IPlugin#beforeDatasetUpdate
	 * @desc Called before updating the &#x60;chart&#x60; dataset at the given &#x60;args.index&#x60;. If any plugin
	 * returns &#x60;false&#x60;, the datasets update is cancelled until another &#x60;update&#x60; is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetUpdate
	 * @desc Called after the &#x60;chart&#x60; datasets at the given &#x60;args.index&#x60; has been updated. Note
	 * that this hook will not be called if the datasets update has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeLayout
	 * @desc Called before laying out &#x60;chart&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the layout update is cancelled until another &#x60;update&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart layout.
	 */
	/**
	 * @method IPlugin#afterLayout
	 * @desc Called after the &#x60;chart&#x60; has been layed out. Note that this hook will not
	 * be called if the layout update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeRender
	 * @desc Called before rendering &#x60;chart&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the rendering is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart rendering.
	 */
	/**
	 * @method IPlugin#afterRender
	 * @desc Called after the &#x60;chart&#x60; has been fully rendered (and animation completed). Note
	 * that this hook will not be called if the rendering has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDraw
	 * @desc Called before drawing &#x60;chart&#x60; at every animation frame specified by the given
	 * easing value. If any plugin returns &#x60;false&#x60;, the frame drawing is cancelled until
	 * another &#x60;render&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart drawing.
	 */
	/**
	 * @method IPlugin#afterDraw
	 * @desc Called after the &#x60;chart&#x60; has been drawn for the specific easing value. Note
	 * that this hook will not be called if the drawing has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetsDraw
	 * @desc Called before drawing the &#x60;chart&#x60; datasets. If any plugin returns &#x60;false&#x60;,
	 * the datasets drawing is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetsDraw
	 * @desc Called after the &#x60;chart&#x60; datasets have been drawn. Note that this hook
	 * will not be called if the datasets drawing has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetDraw
	 * @desc Called before drawing the &#x60;chart&#x60; dataset at the given &#x60;args.index&#x60; (datasets
	 * are drawn in the reverse order). If any plugin returns &#x60;false&#x60;, the datasets drawing
	 * is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetDraw
	 * @desc Called after the &#x60;chart&#x60; datasets at the given &#x60;args.index&#x60; have been drawn
	 * (datasets are drawn in the reverse order). Note that this hook will not be called
	 * if the datasets drawing has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Number} args.index - The dataset index.
	 * @param {Object} args.meta - The dataset metadata.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeTooltipDraw
	 * @desc Called before drawing the &#x60;tooltip&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the tooltip drawing is cancelled until another &#x60;render&#x60; is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.tooltip - The tooltip.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} &#x60;false&#x60; to cancel the chart tooltip drawing.
	 */
	/**
	 * @method IPlugin#afterTooltipDraw
	 * @desc Called after drawing the &#x60;tooltip&#x60;. Note that this hook will not
	 * be called if the tooltip drawing has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.tooltip - The tooltip.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeEvent
	 * @desc Called before processing the specified &#x60;event&#x60;. If any plugin returns &#x60;false&#x60;,
	 * the event will be discarded.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {IEvent} event - The event object.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#afterEvent
	 * @desc Called after the &#x60;event&#x60; has been consumed. Note that this hook
	 * will not be called if the &#x60;event&#x60; has been previously discarded.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {IEvent} event - The event object.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#resize
	 * @desc Called after the chart as been resized.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} size - The new canvas display size (eq. canvas.style width &amp; height).
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#destroy
	 * @desc Called after the chart as been destroyed.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);

	/**
	 * Namespace to hold static tick generation functions
	 * @namespace Chart.Ticks
	 */
	module.exports &#x3D; {
		/**
		 * Namespace to hold formatters for different types of ticks
		 * @namespace Chart.Ticks.formatters
		 */
		formatters: {
			/**
			 * Formatter for value labels
			 * @method Chart.Ticks.formatters.values
			 * @param value the value to display
			 * @return {String|Array} the label to display
			 */
			values: function(value) {
				return helpers.isArray(value) ? value : &#x27;&#x27; + value;
			},

			/**
			 * Formatter for linear numeric ticks
			 * @method Chart.Ticks.formatters.linear
			 * @param tickValue {Number} the value to be formatted
			 * @param index {Number} the position of the tickValue parameter in the ticks array
			 * @param ticks {Array&lt;Number&gt;} the list of ticks being converted
			 * @return {String} string representation of the tickValue parameter
			 */
			linear: function(tickValue, index, ticks) {
				// If we have lots of ticks, don&#x27;t use the ones
				var delta &#x3D; ticks.length &gt; 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

				// If we have a number like 2.5 as the delta, figure out how many decimal places we need
				if (Math.abs(delta) &gt; 1) {
					if (tickValue !&#x3D;&#x3D; Math.floor(tickValue)) {
						// not an integer
						delta &#x3D; tickValue - Math.floor(tickValue);
					}
				}

				var logDelta &#x3D; helpers.log10(Math.abs(delta));
				var tickString &#x3D; &#x27;&#x27;;

				if (tickValue !&#x3D;&#x3D; 0) {
					var numDecimal &#x3D; -1 * Math.floor(logDelta);
					numDecimal &#x3D; Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
					tickString &#x3D; tickValue.toFixed(numDecimal);
				} else {
					tickString &#x3D; &#x27;0&#x27;; // never show decimal places for 0
				}

				return tickString;
			},

			logarithmic: function(tickValue, index, ticks) {
				var remain &#x3D; tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));

				if (tickValue &#x3D;&#x3D;&#x3D; 0) {
					return &#x27;0&#x27;;
				} else if (remain &#x3D;&#x3D;&#x3D; 1 || remain &#x3D;&#x3D;&#x3D; 2 || remain &#x3D;&#x3D;&#x3D; 5 || index &#x3D;&#x3D;&#x3D; 0 || index &#x3D;&#x3D;&#x3D; ticks.length - 1) {
					return tickValue.toExponential();
				}
				return &#x27;&#x27;;
			}
		}
	};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		animation: {
			duration: 1000,
			easing: &#x27;easeOutQuart&#x27;,
			onProgress: helpers.noop,
			onComplete: helpers.noop
		}
	});

	module.exports &#x3D; function(Chart) {

		Chart.Animation &#x3D; Element.extend({
			chart: null, // the animation associated chart instance
			currentStep: 0, // the current animation step
			numSteps: 60, // default number of steps
			easing: &#x27;&#x27;, // the easing to use for this animation
			render: null, // render function used by the animation service

			onAnimationProgress: null, // user specified callback to fire on each step of the animation
			onAnimationComplete: null, // user specified callback to fire when the animation finishes
		});

		Chart.animationService &#x3D; {
			frameDuration: 17,
			animations: [],
			dropFrames: 0,
			request: null,

			/**
			 * @param {Chart} chart - The chart to animate.
			 * @param {Chart.Animation} animation - The animation that we will animate.
			 * @param {Number} duration - The animation duration in ms.
			 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
			 */
			addAnimation: function(chart, animation, duration, lazy) {
				var animations &#x3D; this.animations;
				var i, ilen;

				animation.chart &#x3D; chart;

				if (!lazy) {
					chart.animating &#x3D; true;
				}

				for (i &#x3D; 0, ilen &#x3D; animations.length; i &lt; ilen; ++i) {
					if (animations[i].chart &#x3D;&#x3D;&#x3D; chart) {
						animations[i] &#x3D; animation;
						return;
					}
				}

				animations.push(animation);

				// If there are no animations queued, manually kickstart a digest, for lack of a better word
				if (animations.length &#x3D;&#x3D;&#x3D; 1) {
					this.requestAnimationFrame();
				}
			},

			cancelAnimation: function(chart) {
				var index &#x3D; helpers.findIndex(this.animations, function(animation) {
					return animation.chart &#x3D;&#x3D;&#x3D; chart;
				});

				if (index !&#x3D;&#x3D; -1) {
					this.animations.splice(index, 1);
					chart.animating &#x3D; false;
				}
			},

			requestAnimationFrame: function() {
				var me &#x3D; this;
				if (me.request &#x3D;&#x3D;&#x3D; null) {
					// Skip animation frame requests until the active one is executed.
					// This can happen when processing mouse events, e.g. &#x27;mousemove&#x27;
					// and &#x27;mouseout&#x27; events will trigger multiple renders.
					me.request &#x3D; helpers.requestAnimFrame.call(window, function() {
						me.request &#x3D; null;
						me.startDigest();
					});
				}
			},

			/**
			 * @private
			 */
			startDigest: function() {
				var me &#x3D; this;
				var startTime &#x3D; Date.now();
				var framesToDrop &#x3D; 0;

				if (me.dropFrames &gt; 1) {
					framesToDrop &#x3D; Math.floor(me.dropFrames);
					me.dropFrames &#x3D; me.dropFrames % 1;
				}

				me.advance(1 + framesToDrop);

				var endTime &#x3D; Date.now();

				me.dropFrames +&#x3D; (endTime - startTime) / me.frameDuration;

				// Do we have more stuff to animate?
				if (me.animations.length &gt; 0) {
					me.requestAnimationFrame();
				}
			},

			/**
			 * @private
			 */
			advance: function(count) {
				var animations &#x3D; this.animations;
				var animation, chart;
				var i &#x3D; 0;

				while (i &lt; animations.length) {
					animation &#x3D; animations[i];
					chart &#x3D; animation.chart;

					animation.currentStep &#x3D; (animation.currentStep || 0) + count;
					animation.currentStep &#x3D; Math.min(animation.currentStep, animation.numSteps);

					helpers.callback(animation.render, [chart, animation], chart);
					helpers.callback(animation.onAnimationProgress, [animation], chart);

					if (animation.currentStep &gt;&#x3D; animation.numSteps) {
						helpers.callback(animation.onAnimationComplete, [animation], chart);
						chart.animating &#x3D; false;
						animations.splice(i, 1);
					} else {
						++i;
					}
				}
			}
		};

		/**
		 * Provided for backward compatibility, use Chart.Animation instead
		 * @prop Chart.Animation#animationObject
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(Chart.Animation.prototype, &#x27;animationObject&#x27;, {
			get: function() {
				return this;
			}
		});

		/**
		 * Provided for backward compatibility, use Chart.Animation#chart instead
		 * @prop Chart.Animation#chartInstance
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(Chart.Animation.prototype, &#x27;chartInstance&#x27;, {
			get: function() {
				return this.chart;
			},
			set: function(value) {
				this.chart &#x3D; value;
			}
		});

	};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var helpers &#x3D; __webpack_require__(36);
	var Interaction &#x3D; __webpack_require__(53);
	var layouts &#x3D; __webpack_require__(54);
	var platform &#x3D; __webpack_require__(55);
	var plugins &#x3D; __webpack_require__(58);

	module.exports &#x3D; function(Chart) {

		// Create a dictionary of chart types, to allow for extension of existing types
		Chart.types &#x3D; {};

		// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
		// Destroy method on the chart will remove the instance of the chart from this reference.
		Chart.instances &#x3D; {};

		// Controllers available for dataset visualization eg. bar, line, slice, etc.
		Chart.controllers &#x3D; {};

		/**
		 * Initializes the given config with global and chart default values.
		 */
		function initConfig(config) {
			config &#x3D; config || {};

			// Do NOT use configMerge() for the data object because this method merges arrays
			// and so would change references to labels and datasets, preventing data updates.
			var data &#x3D; config.data &#x3D; config.data || {};
			data.datasets &#x3D; data.datasets || [];
			data.labels &#x3D; data.labels || [];

			config.options &#x3D; helpers.configMerge(
				defaults.global,
				defaults[config.type],
				config.options || {});

			return config;
		}

		/**
		 * Updates the config of the chart
		 * @param chart {Chart} chart to update the options for
		 */
		function updateConfig(chart) {
			var newOptions &#x3D; chart.options;

			helpers.each(chart.scales, function(scale) {
				layouts.removeBox(chart, scale);
			});

			newOptions &#x3D; helpers.configMerge(
				Chart.defaults.global,
				Chart.defaults[chart.config.type],
				newOptions);

			chart.options &#x3D; chart.config.options &#x3D; newOptions;
			chart.ensureScalesHaveIDs();
			chart.buildOrUpdateScales();
			// Tooltip
			chart.tooltip._options &#x3D; newOptions.tooltips;
			chart.tooltip.initialize();
		}

		function positionIsHorizontal(position) {
			return position &#x3D;&#x3D;&#x3D; &#x27;top&#x27; || position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;;
		}

		helpers.extend(Chart.prototype, /** @lends Chart */ {
			/**
			 * @private
			 */
			construct: function(item, config) {
				var me &#x3D; this;

				config &#x3D; initConfig(config);

				var context &#x3D; platform.acquireContext(item, config);
				var canvas &#x3D; context &amp;&amp; context.canvas;
				var height &#x3D; canvas &amp;&amp; canvas.height;
				var width &#x3D; canvas &amp;&amp; canvas.width;

				me.id &#x3D; helpers.uid();
				me.ctx &#x3D; context;
				me.canvas &#x3D; canvas;
				me.config &#x3D; config;
				me.width &#x3D; width;
				me.height &#x3D; height;
				me.aspectRatio &#x3D; height ? width / height : null;
				me.options &#x3D; config.options;
				me._bufferedRender &#x3D; false;

				/**
				 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
				 * the &quot;instance&quot; still need to be defined since it might be called from plugins.
				 * @prop Chart#chart
				 * @deprecated since version 2.6.0
				 * @todo remove at version 3
				 * @private
				 */
				me.chart &#x3D; me;
				me.controller &#x3D; me; // chart.chart.controller #inception

				// Add the chart instance to the global namespace
				Chart.instances[me.id] &#x3D; me;

				// Define alias to the config data: &#x60;chart.data &#x3D;&#x3D;&#x3D; chart.config.data&#x60;
				Object.defineProperty(me, &#x27;data&#x27;, {
					get: function() {
						return me.config.data;
					},
					set: function(value) {
						me.config.data &#x3D; value;
					}
				});

				if (!context || !canvas) {
					// The given item is not a compatible context2d element, let&#x27;s return before finalizing
					// the chart initialization but after setting basic chart / controller properties that
					// can help to figure out that the chart is not valid (e.g chart.canvas !&#x3D;&#x3D; null);
					// https://github.com/chartjs/Chart.js/issues/2807
					console.error(&quot;Failed to create chart: can&#x27;t acquire context from the given item&quot;);
					return;
				}

				me.initialize();
				me.update();
			},

			/**
			 * @private
			 */
			initialize: function() {
				var me &#x3D; this;

				// Before init plugin notification
				plugins.notify(me, &#x27;beforeInit&#x27;);

				helpers.retinaScale(me, me.options.devicePixelRatio);

				me.bindEvents();

				if (me.options.responsive) {
					// Initial resize before chart draws (must be silent to preserve initial animations).
					me.resize(true);
				}

				// Make sure scales have IDs and are built before we build any controllers.
				me.ensureScalesHaveIDs();
				me.buildOrUpdateScales();
				me.initToolTip();

				// After init plugin notification
				plugins.notify(me, &#x27;afterInit&#x27;);

				return me;
			},

			clear: function() {
				helpers.canvas.clear(this);
				return this;
			},

			stop: function() {
				// Stops any current animation loop occurring
				Chart.animationService.cancelAnimation(this);
				return this;
			},

			resize: function(silent) {
				var me &#x3D; this;
				var options &#x3D; me.options;
				var canvas &#x3D; me.canvas;
				var aspectRatio &#x3D; (options.maintainAspectRatio &amp;&amp; me.aspectRatio) || null;

				// the canvas render width and height will be casted to integers so make sure that
				// the canvas display style uses the same integer values to avoid blurring effect.

				// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased
				var newWidth &#x3D; Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
				var newHeight &#x3D; Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

				if (me.width &#x3D;&#x3D;&#x3D; newWidth &amp;&amp; me.height &#x3D;&#x3D;&#x3D; newHeight) {
					return;
				}

				canvas.width &#x3D; me.width &#x3D; newWidth;
				canvas.height &#x3D; me.height &#x3D; newHeight;
				canvas.style.width &#x3D; newWidth + &#x27;px&#x27;;
				canvas.style.height &#x3D; newHeight + &#x27;px&#x27;;

				helpers.retinaScale(me, options.devicePixelRatio);

				if (!silent) {
					// Notify any plugins about the resize
					var newSize &#x3D; {width: newWidth, height: newHeight};
					plugins.notify(me, &#x27;resize&#x27;, [newSize]);

					// Notify of resize
					if (me.options.onResize) {
						me.options.onResize(me, newSize);
					}

					me.stop();
					me.update(me.options.responsiveAnimationDuration);
				}
			},

			ensureScalesHaveIDs: function() {
				var options &#x3D; this.options;
				var scalesOptions &#x3D; options.scales || {};
				var scaleOptions &#x3D; options.scale;

				helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
					xAxisOptions.id &#x3D; xAxisOptions.id || (&#x27;x-axis-&#x27; + index);
				});

				helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
					yAxisOptions.id &#x3D; yAxisOptions.id || (&#x27;y-axis-&#x27; + index);
				});

				if (scaleOptions) {
					scaleOptions.id &#x3D; scaleOptions.id || &#x27;scale&#x27;;
				}
			},

			/**
			 * Builds a map of scale ID to scale object for future lookup.
			 */
			buildOrUpdateScales: function() {
				var me &#x3D; this;
				var options &#x3D; me.options;
				var scales &#x3D; me.scales || {};
				var items &#x3D; [];
				var updated &#x3D; Object.keys(scales).reduce(function(obj, id) {
					obj[id] &#x3D; false;
					return obj;
				}, {});

				if (options.scales) {
					items &#x3D; items.concat(
						(options.scales.xAxes || []).map(function(xAxisOptions) {
							return {options: xAxisOptions, dtype: &#x27;category&#x27;, dposition: &#x27;bottom&#x27;};
						}),
						(options.scales.yAxes || []).map(function(yAxisOptions) {
							return {options: yAxisOptions, dtype: &#x27;linear&#x27;, dposition: &#x27;left&#x27;};
						})
					);
				}

				if (options.scale) {
					items.push({
						options: options.scale,
						dtype: &#x27;radialLinear&#x27;,
						isDefault: true,
						dposition: &#x27;chartArea&#x27;
					});
				}

				helpers.each(items, function(item) {
					var scaleOptions &#x3D; item.options;
					var id &#x3D; scaleOptions.id;
					var scaleType &#x3D; helpers.valueOrDefault(scaleOptions.type, item.dtype);

					if (positionIsHorizontal(scaleOptions.position) !&#x3D;&#x3D; positionIsHorizontal(item.dposition)) {
						scaleOptions.position &#x3D; item.dposition;
					}

					updated[id] &#x3D; true;
					var scale &#x3D; null;
					if (id in scales &amp;&amp; scales[id].type &#x3D;&#x3D;&#x3D; scaleType) {
						scale &#x3D; scales[id];
						scale.options &#x3D; scaleOptions;
						scale.ctx &#x3D; me.ctx;
						scale.chart &#x3D; me;
					} else {
						var scaleClass &#x3D; Chart.scaleService.getScaleConstructor(scaleType);
						if (!scaleClass) {
							return;
						}
						scale &#x3D; new scaleClass({
							id: id,
							type: scaleType,
							options: scaleOptions,
							ctx: me.ctx,
							chart: me
						});
						scales[scale.id] &#x3D; scale;
					}

					scale.mergeTicksOptions();

					// TODO(SB): I think we should be able to remove this custom case (options.scale)
					// and consider it as a regular scale part of the &quot;scales&quot;&quot; map only! This would
					// make the logic easier and remove some useless? custom code.
					if (item.isDefault) {
						me.scale &#x3D; scale;
					}
				});
				// clear up discarded scales
				helpers.each(updated, function(hasUpdated, id) {
					if (!hasUpdated) {
						delete scales[id];
					}
				});

				me.scales &#x3D; scales;

				Chart.scaleService.addScalesToLayout(this);
			},

			buildOrUpdateControllers: function() {
				var me &#x3D; this;
				var types &#x3D; [];
				var newControllers &#x3D; [];

				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					var meta &#x3D; me.getDatasetMeta(datasetIndex);
					var type &#x3D; dataset.type || me.config.type;

					if (meta.type &amp;&amp; meta.type !&#x3D;&#x3D; type) {
						me.destroyDatasetMeta(datasetIndex);
						meta &#x3D; me.getDatasetMeta(datasetIndex);
					}
					meta.type &#x3D; type;

					types.push(meta.type);

					if (meta.controller) {
						meta.controller.updateIndex(datasetIndex);
						meta.controller.linkScales();
					} else {
						var ControllerClass &#x3D; Chart.controllers[meta.type];
						if (ControllerClass &#x3D;&#x3D;&#x3D; undefined) {
							throw new Error(&#x27;&quot;&#x27; + meta.type + &#x27;&quot; is not a chart type.&#x27;);
						}

						meta.controller &#x3D; new ControllerClass(me, datasetIndex);
						newControllers.push(meta.controller);
					}
				}, me);

				return newControllers;
			},

			/**
			 * Reset the elements of all datasets
			 * @private
			 */
			resetElements: function() {
				var me &#x3D; this;
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.reset();
				}, me);
			},

			/**
			* Resets the chart back to it&#x27;s state before the initial animation
			*/
			reset: function() {
				this.resetElements();
				this.tooltip.initialize();
			},

			update: function(config) {
				var me &#x3D; this;

				if (!config || typeof config !&#x3D;&#x3D; &#x27;object&#x27;) {
					// backwards compatibility
					config &#x3D; {
						duration: config,
						lazy: arguments[1]
					};
				}

				updateConfig(me);

				// plugins options references might have change, let&#x27;s invalidate the cache
				// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
				plugins._invalidate(me);

				if (plugins.notify(me, &#x27;beforeUpdate&#x27;) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				// In case the entire data object changed
				me.tooltip._data &#x3D; me.data;

				// Make sure dataset controllers are updated and new controllers are reset
				var newControllers &#x3D; me.buildOrUpdateControllers();

				// Make sure all dataset controllers have correct meta data counts
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
				}, me);

				me.updateLayout();

				// Can only reset the new controllers after the scales have been updated
				if (me.options.animation &amp;&amp; me.options.animation.duration) {
					helpers.each(newControllers, function(controller) {
						controller.reset();
					});
				}

				me.updateDatasets();

				// Need to reset tooltip in case it is displayed with elements that are removed
				// after update.
				me.tooltip.initialize();

				// Last active contains items that were previously in the tooltip.
				// When we reset the tooltip, we need to clear it
				me.lastActive &#x3D; [];

				// Do this before render so that any plugins that need final scale updates can use it
				plugins.notify(me, &#x27;afterUpdate&#x27;);

				if (me._bufferedRender) {
					me._bufferedRequest &#x3D; {
						duration: config.duration,
						easing: config.easing,
						lazy: config.lazy
					};
				} else {
					me.render(config);
				}
			},

			/**
			 * Updates the chart layout unless a plugin returns &#x60;false&#x60; to the &#x60;beforeLayout&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterLayout&#x60;.
			 * @private
			 */
			updateLayout: function() {
				var me &#x3D; this;

				if (plugins.notify(me, &#x27;beforeLayout&#x27;) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				layouts.update(this, this.width, this.height);

				/**
				 * Provided for backward compatibility, use &#x60;afterLayout&#x60; instead.
				 * @method IPlugin#afterScaleUpdate
				 * @deprecated since version 2.5.0
				 * @todo remove at version 3
				 * @private
				 */
				plugins.notify(me, &#x27;afterScaleUpdate&#x27;);
				plugins.notify(me, &#x27;afterLayout&#x27;);
			},

			/**
			 * Updates all datasets unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetsUpdate&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetsUpdate&#x60;.
			 * @private
			 */
			updateDatasets: function() {
				var me &#x3D; this;

				if (plugins.notify(me, &#x27;beforeDatasetsUpdate&#x27;) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				for (var i &#x3D; 0, ilen &#x3D; me.data.datasets.length; i &lt; ilen; ++i) {
					me.updateDataset(i);
				}

				plugins.notify(me, &#x27;afterDatasetsUpdate&#x27;);
			},

			/**
			 * Updates dataset at index unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetUpdate&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetUpdate&#x60;.
			 * @private
			 */
			updateDataset: function(index) {
				var me &#x3D; this;
				var meta &#x3D; me.getDatasetMeta(index);
				var args &#x3D; {
					meta: meta,
					index: index
				};

				if (plugins.notify(me, &#x27;beforeDatasetUpdate&#x27;, [args]) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				meta.controller.update();

				plugins.notify(me, &#x27;afterDatasetUpdate&#x27;, [args]);
			},

			render: function(config) {
				var me &#x3D; this;

				if (!config || typeof config !&#x3D;&#x3D; &#x27;object&#x27;) {
					// backwards compatibility
					config &#x3D; {
						duration: config,
						lazy: arguments[1]
					};
				}

				var duration &#x3D; config.duration;
				var lazy &#x3D; config.lazy;

				if (plugins.notify(me, &#x27;beforeRender&#x27;) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				var animationOptions &#x3D; me.options.animation;
				var onComplete &#x3D; function(animation) {
					plugins.notify(me, &#x27;afterRender&#x27;);
					helpers.callback(animationOptions &amp;&amp; animationOptions.onComplete, [animation], me);
				};

				if (animationOptions &amp;&amp; ((typeof duration !&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; duration !&#x3D;&#x3D; 0) || (typeof duration &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; animationOptions.duration !&#x3D;&#x3D; 0))) {
					var animation &#x3D; new Chart.Animation({
						numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
						easing: config.easing || animationOptions.easing,

						render: function(chart, animationObject) {
							var easingFunction &#x3D; helpers.easing.effects[animationObject.easing];
							var currentStep &#x3D; animationObject.currentStep;
							var stepDecimal &#x3D; currentStep / animationObject.numSteps;

							chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
						},

						onAnimationProgress: animationOptions.onProgress,
						onAnimationComplete: onComplete
					});

					Chart.animationService.addAnimation(me, animation, duration, lazy);
				} else {
					me.draw();

					// See https://github.com/chartjs/Chart.js/issues/3781
					onComplete(new Chart.Animation({numSteps: 0, chart: me}));
				}

				return me;
			},

			draw: function(easingValue) {
				var me &#x3D; this;

				me.clear();

				if (helpers.isNullOrUndef(easingValue)) {
					easingValue &#x3D; 1;
				}

				me.transition(easingValue);

				if (plugins.notify(me, &#x27;beforeDraw&#x27;, [easingValue]) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				// Draw all the scales
				helpers.each(me.boxes, function(box) {
					box.draw(me.chartArea);
				}, me);

				if (me.scale) {
					me.scale.draw();
				}

				me.drawDatasets(easingValue);
				me._drawTooltip(easingValue);

				plugins.notify(me, &#x27;afterDraw&#x27;, [easingValue]);
			},

			/**
			 * @private
			 */
			transition: function(easingValue) {
				var me &#x3D; this;

				for (var i &#x3D; 0, ilen &#x3D; (me.data.datasets || []).length; i &lt; ilen; ++i) {
					if (me.isDatasetVisible(i)) {
						me.getDatasetMeta(i).controller.transition(easingValue);
					}
				}

				me.tooltip.transition(easingValue);
			},

			/**
			 * Draws all datasets unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetsDraw&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetsDraw&#x60;.
			 * @private
			 */
			drawDatasets: function(easingValue) {
				var me &#x3D; this;

				if (plugins.notify(me, &#x27;beforeDatasetsDraw&#x27;, [easingValue]) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				// Draw datasets reversed to support proper line stacking
				for (var i &#x3D; (me.data.datasets || []).length - 1; i &gt;&#x3D; 0; --i) {
					if (me.isDatasetVisible(i)) {
						me.drawDataset(i, easingValue);
					}
				}

				plugins.notify(me, &#x27;afterDatasetsDraw&#x27;, [easingValue]);
			},

			/**
			 * Draws dataset at index unless a plugin returns &#x60;false&#x60; to the &#x60;beforeDatasetDraw&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterDatasetDraw&#x60;.
			 * @private
			 */
			drawDataset: function(index, easingValue) {
				var me &#x3D; this;
				var meta &#x3D; me.getDatasetMeta(index);
				var args &#x3D; {
					meta: meta,
					index: index,
					easingValue: easingValue
				};

				if (plugins.notify(me, &#x27;beforeDatasetDraw&#x27;, [args]) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				meta.controller.draw(easingValue);

				plugins.notify(me, &#x27;afterDatasetDraw&#x27;, [args]);
			},

			/**
			 * Draws tooltip unless a plugin returns &#x60;false&#x60; to the &#x60;beforeTooltipDraw&#x60;
			 * hook, in which case, plugins will not be called on &#x60;afterTooltipDraw&#x60;.
			 * @private
			 */
			_drawTooltip: function(easingValue) {
				var me &#x3D; this;
				var tooltip &#x3D; me.tooltip;
				var args &#x3D; {
					tooltip: tooltip,
					easingValue: easingValue
				};

				if (plugins.notify(me, &#x27;beforeTooltipDraw&#x27;, [args]) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				tooltip.draw();

				plugins.notify(me, &#x27;afterTooltipDraw&#x27;, [args]);
			},

			// Get the single element that was clicked on
			// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
			getElementAtEvent: function(e) {
				return Interaction.modes.single(this, e);
			},

			getElementsAtEvent: function(e) {
				return Interaction.modes.label(this, e, {intersect: true});
			},

			getElementsAtXAxis: function(e) {
				return Interaction.modes[&#x27;x-axis&#x27;](this, e, {intersect: true});
			},

			getElementsAtEventForMode: function(e, mode, options) {
				var method &#x3D; Interaction.modes[mode];
				if (typeof method &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
					return method(this, e, options);
				}

				return [];
			},

			getDatasetAtEvent: function(e) {
				return Interaction.modes.dataset(this, e, {intersect: true});
			},

			getDatasetMeta: function(datasetIndex) {
				var me &#x3D; this;
				var dataset &#x3D; me.data.datasets[datasetIndex];
				if (!dataset._meta) {
					dataset._meta &#x3D; {};
				}

				var meta &#x3D; dataset._meta[me.id];
				if (!meta) {
					meta &#x3D; dataset._meta[me.id] &#x3D; {
						type: null,
						data: [],
						dataset: null,
						controller: null,
						hidden: null,			// See isDatasetVisible() comment
						xAxisID: null,
						yAxisID: null
					};
				}

				return meta;
			},

			getVisibleDatasetCount: function() {
				var count &#x3D; 0;
				for (var i &#x3D; 0, ilen &#x3D; this.data.datasets.length; i &lt; ilen; ++i) {
					if (this.isDatasetVisible(i)) {
						count++;
					}
				}
				return count;
			},

			isDatasetVisible: function(datasetIndex) {
				var meta &#x3D; this.getDatasetMeta(datasetIndex);

				// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
				// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
				return typeof meta.hidden &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27; ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
			},

			generateLegend: function() {
				return this.options.legendCallback(this);
			},

			/**
			 * @private
			 */
			destroyDatasetMeta: function(datasetIndex) {
				var id &#x3D; this.id;
				var dataset &#x3D; this.data.datasets[datasetIndex];
				var meta &#x3D; dataset._meta &amp;&amp; dataset._meta[id];

				if (meta) {
					meta.controller.destroy();
					delete dataset._meta[id];
				}
			},

			destroy: function() {
				var me &#x3D; this;
				var canvas &#x3D; me.canvas;
				var i, ilen;

				me.stop();

				// dataset controllers need to cleanup associated data
				for (i &#x3D; 0, ilen &#x3D; me.data.datasets.length; i &lt; ilen; ++i) {
					me.destroyDatasetMeta(i);
				}

				if (canvas) {
					me.unbindEvents();
					helpers.canvas.clear(me);
					platform.releaseContext(me.ctx);
					me.canvas &#x3D; null;
					me.ctx &#x3D; null;
				}

				plugins.notify(me, &#x27;destroy&#x27;);

				delete Chart.instances[me.id];
			},

			toBase64Image: function() {
				return this.canvas.toDataURL.apply(this.canvas, arguments);
			},

			initToolTip: function() {
				var me &#x3D; this;
				me.tooltip &#x3D; new Chart.Tooltip({
					_chart: me,
					_chartInstance: me, // deprecated, backward compatibility
					_data: me.data,
					_options: me.options.tooltips
				}, me);
			},

			/**
			 * @private
			 */
			bindEvents: function() {
				var me &#x3D; this;
				var listeners &#x3D; me._listeners &#x3D; {};
				var listener &#x3D; function() {
					me.eventHandler.apply(me, arguments);
				};

				helpers.each(me.options.events, function(type) {
					platform.addEventListener(me, type, listener);
					listeners[type] &#x3D; listener;
				});

				// Elements used to detect size change should not be injected for non responsive charts.
				// See https://github.com/chartjs/Chart.js/issues/2210
				if (me.options.responsive) {
					listener &#x3D; function() {
						me.resize();
					};

					platform.addEventListener(me, &#x27;resize&#x27;, listener);
					listeners.resize &#x3D; listener;
				}
			},

			/**
			 * @private
			 */
			unbindEvents: function() {
				var me &#x3D; this;
				var listeners &#x3D; me._listeners;
				if (!listeners) {
					return;
				}

				delete me._listeners;
				helpers.each(listeners, function(listener, type) {
					platform.removeEventListener(me, type, listener);
				});
			},

			updateHoverStyle: function(elements, mode, enabled) {
				var method &#x3D; enabled ? &#x27;setHoverStyle&#x27; : &#x27;removeHoverStyle&#x27;;
				var element, i, ilen;

				for (i &#x3D; 0, ilen &#x3D; elements.length; i &lt; ilen; ++i) {
					element &#x3D; elements[i];
					if (element) {
						this.getDatasetMeta(element._datasetIndex).controller[method](element);
					}
				}
			},

			/**
			 * @private
			 */
			eventHandler: function(e) {
				var me &#x3D; this;
				var tooltip &#x3D; me.tooltip;

				if (plugins.notify(me, &#x27;beforeEvent&#x27;, [e]) &#x3D;&#x3D;&#x3D; false) {
					return;
				}

				// Buffer any update calls so that renders do not occur
				me._bufferedRender &#x3D; true;
				me._bufferedRequest &#x3D; null;

				var changed &#x3D; me.handleEvent(e);
				// for smooth tooltip animations issue #4989
				// the tooltip should be the source of change
				// Animation check workaround:
				// tooltip._start will be null when tooltip isn&#x27;t animating
				if (tooltip) {
					changed &#x3D; tooltip._start
						? tooltip.handleEvent(e)
						: changed | tooltip.handleEvent(e);
				}

				plugins.notify(me, &#x27;afterEvent&#x27;, [e]);

				var bufferedRequest &#x3D; me._bufferedRequest;
				if (bufferedRequest) {
					// If we have an update that was triggered, we need to do a normal render
					me.render(bufferedRequest);
				} else if (changed &amp;&amp; !me.animating) {
					// If entering, leaving, or changing elements, animate the change via pivot
					me.stop();

					// We only need to render at this point. Updating will cause scales to be
					// recomputed generating flicker &amp; using more memory than necessary.
					me.render(me.options.hover.animationDuration, true);
				}

				me._bufferedRender &#x3D; false;
				me._bufferedRequest &#x3D; null;

				return me;
			},

			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event the event to handle
			 * @return {Boolean} true if the chart needs to re-render
			 */
			handleEvent: function(e) {
				var me &#x3D; this;
				var options &#x3D; me.options || {};
				var hoverOptions &#x3D; options.hover;
				var changed &#x3D; false;

				me.lastActive &#x3D; me.lastActive || [];

				// Find Active Elements for hover and tooltips
				if (e.type &#x3D;&#x3D;&#x3D; &#x27;mouseout&#x27;) {
					me.active &#x3D; [];
				} else {
					me.active &#x3D; me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
				}

				// Invoke onHover hook
				// Need to call with native event here to not break backwards compatibility
				helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

				if (e.type &#x3D;&#x3D;&#x3D; &#x27;mouseup&#x27; || e.type &#x3D;&#x3D;&#x3D; &#x27;click&#x27;) {
					if (options.onClick) {
						// Use e.native here for backwards compatibility
						options.onClick.call(me, e.native, me.active);
					}
				}

				// Remove styling for last active (even if it may still be active)
				if (me.lastActive.length) {
					me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
				}

				// Built in hover styling
				if (me.active.length &amp;&amp; hoverOptions.mode) {
					me.updateHoverStyle(me.active, hoverOptions.mode, true);
				}

				changed &#x3D; !helpers.arrayEquals(me.active, me.lastActive);

				// Remember Last Actives
				me.lastActive &#x3D; me.active;

				return changed;
			}
		});

		/**
		 * Provided for backward compatibility, use Chart instead.
		 * @class Chart.Controller
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.Controller &#x3D; Chart;
	};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);

	module.exports &#x3D; function(Chart) {

		var arrayEvents &#x3D; [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;splice&#x27;, &#x27;unshift&#x27;];

		/**
		 * Hooks the array methods that add or remove values (&#x27;push&#x27;, pop&#x27;, &#x27;shift&#x27;, &#x27;splice&#x27;,
		 * &#x27;unshift&#x27;) and notify the listener AFTER the array has been altered. Listeners are
		 * called on the &#x27;onData*&#x27; callbacks (e.g. onDataPush, etc.) with same arguments.
		 */
		function listenArrayEvents(array, listener) {
			if (array._chartjs) {
				array._chartjs.listeners.push(listener);
				return;
			}

			Object.defineProperty(array, &#x27;_chartjs&#x27;, {
				configurable: true,
				enumerable: false,
				value: {
					listeners: [listener]
				}
			});

			arrayEvents.forEach(function(key) {
				var method &#x3D; &#x27;onData&#x27; + key.charAt(0).toUpperCase() + key.slice(1);
				var base &#x3D; array[key];

				Object.defineProperty(array, key, {
					configurable: true,
					enumerable: false,
					value: function() {
						var args &#x3D; Array.prototype.slice.call(arguments);
						var res &#x3D; base.apply(this, args);

						helpers.each(array._chartjs.listeners, function(object) {
							if (typeof object[method] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
								object[method].apply(object, args);
							}
						});

						return res;
					}
				});
			});
		}

		/**
		 * Removes the given array event listener and cleanup extra attached properties (such as
		 * the _chartjs stub and overridden methods) if array doesn&#x27;t have any more listeners.
		 */
		function unlistenArrayEvents(array, listener) {
			var stub &#x3D; array._chartjs;
			if (!stub) {
				return;
			}

			var listeners &#x3D; stub.listeners;
			var index &#x3D; listeners.indexOf(listener);
			if (index !&#x3D;&#x3D; -1) {
				listeners.splice(index, 1);
			}

			if (listeners.length &gt; 0) {
				return;
			}

			arrayEvents.forEach(function(key) {
				delete array[key];
			});

			delete array._chartjs;
		}

		// Base class for all dataset controllers (line, bar, etc)
		Chart.DatasetController &#x3D; function(chart, datasetIndex) {
			this.initialize(chart, datasetIndex);
		};

		helpers.extend(Chart.DatasetController.prototype, {

			/**
			 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
			 * @type {Chart.core.element}
			 */
			datasetElementType: null,

			/**
			 * Element type used to generate a meta data (e.g. Chart.element.Point).
			 * @type {Chart.core.element}
			 */
			dataElementType: null,

			initialize: function(chart, datasetIndex) {
				var me &#x3D; this;
				me.chart &#x3D; chart;
				me.index &#x3D; datasetIndex;
				me.linkScales();
				me.addElements();
			},

			updateIndex: function(datasetIndex) {
				this.index &#x3D; datasetIndex;
			},

			linkScales: function() {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var dataset &#x3D; me.getDataset();

				if (meta.xAxisID &#x3D;&#x3D;&#x3D; null || !(meta.xAxisID in me.chart.scales)) {
					meta.xAxisID &#x3D; dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
				}
				if (meta.yAxisID &#x3D;&#x3D;&#x3D; null || !(meta.yAxisID in me.chart.scales)) {
					meta.yAxisID &#x3D; dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
				}
			},

			getDataset: function() {
				return this.chart.data.datasets[this.index];
			},

			getMeta: function() {
				return this.chart.getDatasetMeta(this.index);
			},

			getScaleForId: function(scaleID) {
				return this.chart.scales[scaleID];
			},

			reset: function() {
				this.update(true);
			},

			/**
			 * @private
			 */
			destroy: function() {
				if (this._data) {
					unlistenArrayEvents(this._data, this);
				}
			},

			createMetaDataset: function() {
				var me &#x3D; this;
				var type &#x3D; me.datasetElementType;
				return type &amp;&amp; new type({
					_chart: me.chart,
					_datasetIndex: me.index
				});
			},

			createMetaData: function(index) {
				var me &#x3D; this;
				var type &#x3D; me.dataElementType;
				return type &amp;&amp; new type({
					_chart: me.chart,
					_datasetIndex: me.index,
					_index: index
				});
			},

			addElements: function() {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var data &#x3D; me.getDataset().data || [];
				var metaData &#x3D; meta.data;
				var i, ilen;

				for (i &#x3D; 0, ilen &#x3D; data.length; i &lt; ilen; ++i) {
					metaData[i] &#x3D; metaData[i] || me.createMetaData(i);
				}

				meta.dataset &#x3D; meta.dataset || me.createMetaDataset();
			},

			addElementAndReset: function(index) {
				var element &#x3D; this.createMetaData(index);
				this.getMeta().data.splice(index, 0, element);
				this.updateElement(element, index, true);
			},

			buildOrUpdateElements: function() {
				var me &#x3D; this;
				var dataset &#x3D; me.getDataset();
				var data &#x3D; dataset.data || (dataset.data &#x3D; []);

				// In order to correctly handle data addition/deletion animation (an thus simulate
				// real-time charts), we need to monitor these data modifications and synchronize
				// the internal meta data accordingly.
				if (me._data !&#x3D;&#x3D; data) {
					if (me._data) {
						// This case happens when the user replaced the data array instance.
						unlistenArrayEvents(me._data, me);
					}

					listenArrayEvents(data, me);
					me._data &#x3D; data;
				}

				// Re-sync meta data in case the user replaced the data array or if we missed
				// any updates and so make sure that we handle number of datapoints changing.
				me.resyncElements();
			},

			update: helpers.noop,

			transition: function(easingValue) {
				var meta &#x3D; this.getMeta();
				var elements &#x3D; meta.data || [];
				var ilen &#x3D; elements.length;
				var i &#x3D; 0;

				for (; i &lt; ilen; ++i) {
					elements[i].transition(easingValue);
				}

				if (meta.dataset) {
					meta.dataset.transition(easingValue);
				}
			},

			draw: function() {
				var meta &#x3D; this.getMeta();
				var elements &#x3D; meta.data || [];
				var ilen &#x3D; elements.length;
				var i &#x3D; 0;

				if (meta.dataset) {
					meta.dataset.draw();
				}

				for (; i &lt; ilen; ++i) {
					elements[i].draw();
				}
			},

			removeHoverStyle: function(element, elementOpts) {
				var dataset &#x3D; this.chart.data.datasets[element._datasetIndex];
				var index &#x3D; element._index;
				var custom &#x3D; element.custom || {};
				var valueOrDefault &#x3D; helpers.valueAtIndexOrDefault;
				var model &#x3D; element._model;

				model.backgroundColor &#x3D; custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
				model.borderColor &#x3D; custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
				model.borderWidth &#x3D; custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
			},

			setHoverStyle: function(element) {
				var dataset &#x3D; this.chart.data.datasets[element._datasetIndex];
				var index &#x3D; element._index;
				var custom &#x3D; element.custom || {};
				var valueOrDefault &#x3D; helpers.valueAtIndexOrDefault;
				var getHoverColor &#x3D; helpers.getHoverColor;
				var model &#x3D; element._model;

				model.backgroundColor &#x3D; custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
				model.borderColor &#x3D; custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
				model.borderWidth &#x3D; custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},

			/**
			 * @private
			 */
			resyncElements: function() {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var data &#x3D; me.getDataset().data;
				var numMeta &#x3D; meta.data.length;
				var numData &#x3D; data.length;

				if (numData &lt; numMeta) {
					meta.data.splice(numData, numMeta - numData);
				} else if (numData &gt; numMeta) {
					me.insertElements(numMeta, numData - numMeta);
				}
			},

			/**
			 * @private
			 */
			insertElements: function(start, count) {
				for (var i &#x3D; 0; i &lt; count; ++i) {
					this.addElementAndReset(start + i);
				}
			},

			/**
			 * @private
			 */
			onDataPush: function() {
				this.insertElements(this.getDataset().data.length - 1, arguments.length);
			},

			/**
			 * @private
			 */
			onDataPop: function() {
				this.getMeta().data.pop();
			},

			/**
			 * @private
			 */
			onDataShift: function() {
				this.getMeta().data.shift();
			},

			/**
			 * @private
			 */
			onDataSplice: function(start, count) {
				this.getMeta().data.splice(start, count);
				this.insertElements(start, arguments.length - 2);
			},

			/**
			 * @private
			 */
			onDataUnshift: function() {
				this.insertElements(0, arguments.length);
			}
		});

		Chart.DatasetController.extend &#x3D; helpers.inherits;
	};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var helpers &#x3D; __webpack_require__(36);
	var layouts &#x3D; __webpack_require__(54);

	module.exports &#x3D; function(Chart) {

		Chart.scaleService &#x3D; {
			// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
			// use the new chart options to grab the correct scale
			constructors: {},
			// Use a registration function so that we can move to an ES6 map when we no longer need to support
			// old browsers

			// Scale config defaults
			defaults: {},
			registerScaleType: function(type, scaleConstructor, scaleDefaults) {
				this.constructors[type] &#x3D; scaleConstructor;
				this.defaults[type] &#x3D; helpers.clone(scaleDefaults);
			},
			getScaleConstructor: function(type) {
				return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
			},
			getScaleDefaults: function(type) {
				// Return the scale defaults merged with the global settings so that we always use the latest ones
				return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
			},
			updateScaleDefaults: function(type, additions) {
				var me &#x3D; this;
				if (me.defaults.hasOwnProperty(type)) {
					me.defaults[type] &#x3D; helpers.extend(me.defaults[type], additions);
				}
			},
			addScalesToLayout: function(chart) {
				// Adds each scale to the chart.boxes array to be sized accordingly
				helpers.each(chart.scales, function(scale) {
					// Set ILayoutItem parameters for backwards compatibility
					scale.fullWidth &#x3D; scale.options.fullWidth;
					scale.position &#x3D; scale.options.position;
					scale.weight &#x3D; scale.options.weight;
					layouts.addBox(chart, scale);
				});
			}
		};
	};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);
	var Ticks &#x3D; __webpack_require__(59);

	defaults._set(&#x27;scale&#x27;, {
		display: true,
		position: &#x27;left&#x27;,
		offset: false,

		// grid line settings
		gridLines: {
			display: true,
			color: &#x27;rgba(0, 0, 0, 0.1)&#x27;,
			lineWidth: 1,
			drawBorder: true,
			drawOnChartArea: true,
			drawTicks: true,
			tickMarkLength: 10,
			zeroLineWidth: 1,
			zeroLineColor: &#x27;rgba(0,0,0,0.25)&#x27;,
			zeroLineBorderDash: [],
			zeroLineBorderDashOffset: 0.0,
			offsetGridLines: false,
			borderDash: [],
			borderDashOffset: 0.0
		},

		// scale label
		scaleLabel: {
			// display property
			display: false,

			// actual label
			labelString: &#x27;&#x27;,

			// line height
			lineHeight: 1.2,

			// top/bottom padding
			padding: {
				top: 4,
				bottom: 4
			}
		},

		// label settings
		ticks: {
			beginAtZero: false,
			minRotation: 0,
			maxRotation: 50,
			mirror: false,
			padding: 0,
			reverse: false,
			display: true,
			autoSkip: true,
			autoSkipPadding: 0,
			labelOffset: 0,
			// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
			callback: Ticks.formatters.values,
			minor: {},
			major: {}
		}
	});

	function labelsFromTicks(ticks) {
		var labels &#x3D; [];
		var i, ilen;

		for (i &#x3D; 0, ilen &#x3D; ticks.length; i &lt; ilen; ++i) {
			labels.push(ticks[i].label);
		}

		return labels;
	}

	function getLineValue(scale, index, offsetGridLines) {
		var lineValue &#x3D; scale.getPixelForTick(index);

		if (offsetGridLines) {
			if (index &#x3D;&#x3D;&#x3D; 0) {
				lineValue -&#x3D; (scale.getPixelForTick(1) - lineValue) / 2;
			} else {
				lineValue -&#x3D; (lineValue - scale.getPixelForTick(index - 1)) / 2;
			}
		}
		return lineValue;
	}

	module.exports &#x3D; function(Chart) {

		function computeTextSize(context, tick, font) {
			return helpers.isArray(tick) ?
				helpers.longestText(context, font, tick) :
				context.measureText(tick).width;
		}

		function parseFontOptions(options) {
			var valueOrDefault &#x3D; helpers.valueOrDefault;
			var globalDefaults &#x3D; defaults.global;
			var size &#x3D; valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
			var style &#x3D; valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
			var family &#x3D; valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

			return {
				size: size,
				style: style,
				family: family,
				font: helpers.fontString(size, style, family)
			};
		}

		function parseLineHeight(options) {
			return helpers.options.toLineHeight(
				helpers.valueOrDefault(options.lineHeight, 1.2),
				helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
		}

		Chart.Scale &#x3D; Element.extend({
			/**
			 * Get the padding needed for the scale
			 * @method getPadding
			 * @private
			 * @returns {Padding} the necessary padding
			 */
			getPadding: function() {
				var me &#x3D; this;
				return {
					left: me.paddingLeft || 0,
					top: me.paddingTop || 0,
					right: me.paddingRight || 0,
					bottom: me.paddingBottom || 0
				};
			},

			/**
			 * Returns the scale tick objects ({label, major})
			 * @since 2.7
			 */
			getTicks: function() {
				return this._ticks;
			},

			// These methods are ordered by lifecyle. Utilities then follow.
			// Any function defined here is inherited by all scale types.
			// Any function can be extended by the scale type

			mergeTicksOptions: function() {
				var ticks &#x3D; this.options.ticks;
				if (ticks.minor &#x3D;&#x3D;&#x3D; false) {
					ticks.minor &#x3D; {
						display: false
					};
				}
				if (ticks.major &#x3D;&#x3D;&#x3D; false) {
					ticks.major &#x3D; {
						display: false
					};
				}
				for (var key in ticks) {
					if (key !&#x3D;&#x3D; &#x27;major&#x27; &amp;&amp; key !&#x3D;&#x3D; &#x27;minor&#x27;) {
						if (typeof ticks.minor[key] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
							ticks.minor[key] &#x3D; ticks[key];
						}
						if (typeof ticks.major[key] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
							ticks.major[key] &#x3D; ticks[key];
						}
					}
				}
			},
			beforeUpdate: function() {
				helpers.callback(this.options.beforeUpdate, [this]);
			},
			update: function(maxWidth, maxHeight, margins) {
				var me &#x3D; this;
				var i, ilen, labels, label, ticks, tick;

				// Update Lifecycle - Probably don&#x27;t want to ever extend or overwrite this function ;)
				me.beforeUpdate();

				// Absorb the master measurements
				me.maxWidth &#x3D; maxWidth;
				me.maxHeight &#x3D; maxHeight;
				me.margins &#x3D; helpers.extend({
					left: 0,
					right: 0,
					top: 0,
					bottom: 0
				}, margins);
				me.longestTextCache &#x3D; me.longestTextCache || {};

				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();

				// Data min/max
				me.beforeDataLimits();
				me.determineDataLimits();
				me.afterDataLimits();

				// Ticks - &#x60;this.ticks&#x60; is now DEPRECATED!
				// Internal ticks are now stored as objects in the PRIVATE &#x60;this._ticks&#x60; member
				// and must not be accessed directly from outside this class. &#x60;this.ticks&#x60; being
				// around for long time and not marked as private, we can&#x27;t change its structure
				// without unexpected breaking changes. If you need to access the scale ticks,
				// use scale.getTicks() instead.

				me.beforeBuildTicks();

				// New implementations should return an array of objects but for BACKWARD COMPAT,
				// we still support no return (&#x60;this.ticks&#x60; internally set by calling this method).
				ticks &#x3D; me.buildTicks() || [];

				me.afterBuildTicks();

				me.beforeTickToLabelConversion();

				// New implementations should return the formatted tick labels but for BACKWARD
				// COMPAT, we still support no return (&#x60;this.ticks&#x60; internally changed by calling
				// this method and supposed to contain only string values).
				labels &#x3D; me.convertTicksToLabels(ticks) || me.ticks;

				me.afterTickToLabelConversion();

				me.ticks &#x3D; labels;   // BACKWARD COMPATIBILITY

				// IMPORTANT: from this point, we consider that &#x60;this.ticks&#x60; will NEVER change!

				// BACKWARD COMPAT: synchronize &#x60;_ticks&#x60; with labels (so potentially &#x60;this.ticks&#x60;)
				for (i &#x3D; 0, ilen &#x3D; labels.length; i &lt; ilen; ++i) {
					label &#x3D; labels[i];
					tick &#x3D; ticks[i];
					if (!tick) {
						ticks.push(tick &#x3D; {
							label: label,
							major: false
						});
					} else {
						tick.label &#x3D; label;
					}
				}

				me._ticks &#x3D; ticks;

				// Tick Rotation
				me.beforeCalculateTickRotation();
				me.calculateTickRotation();
				me.afterCalculateTickRotation();
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();

				return me.minSize;

			},
			afterUpdate: function() {
				helpers.callback(this.options.afterUpdate, [this]);
			},

			//

			beforeSetDimensions: function() {
				helpers.callback(this.options.beforeSetDimensions, [this]);
			},
			setDimensions: function() {
				var me &#x3D; this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width &#x3D; me.maxWidth;
					me.left &#x3D; 0;
					me.right &#x3D; me.width;
				} else {
					me.height &#x3D; me.maxHeight;

					// Reset position before calculating rotation
					me.top &#x3D; 0;
					me.bottom &#x3D; me.height;
				}

				// Reset padding
				me.paddingLeft &#x3D; 0;
				me.paddingTop &#x3D; 0;
				me.paddingRight &#x3D; 0;
				me.paddingBottom &#x3D; 0;
			},
			afterSetDimensions: function() {
				helpers.callback(this.options.afterSetDimensions, [this]);
			},

			// Data limits
			beforeDataLimits: function() {
				helpers.callback(this.options.beforeDataLimits, [this]);
			},
			determineDataLimits: helpers.noop,
			afterDataLimits: function() {
				helpers.callback(this.options.afterDataLimits, [this]);
			},

			//
			beforeBuildTicks: function() {
				helpers.callback(this.options.beforeBuildTicks, [this]);
			},
			buildTicks: helpers.noop,
			afterBuildTicks: function() {
				helpers.callback(this.options.afterBuildTicks, [this]);
			},

			beforeTickToLabelConversion: function() {
				helpers.callback(this.options.beforeTickToLabelConversion, [this]);
			},
			convertTicksToLabels: function() {
				var me &#x3D; this;
				// Convert ticks to strings
				var tickOpts &#x3D; me.options.ticks;
				me.ticks &#x3D; me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
			},
			afterTickToLabelConversion: function() {
				helpers.callback(this.options.afterTickToLabelConversion, [this]);
			},

			//

			beforeCalculateTickRotation: function() {
				helpers.callback(this.options.beforeCalculateTickRotation, [this]);
			},
			calculateTickRotation: function() {
				var me &#x3D; this;
				var context &#x3D; me.ctx;
				var tickOpts &#x3D; me.options.ticks;
				var labels &#x3D; labelsFromTicks(me._ticks);

				// Get the width of each grid by calculating the difference
				// between x offsets between 0 and 1.
				var tickFont &#x3D; parseFontOptions(tickOpts);
				context.font &#x3D; tickFont.font;

				var labelRotation &#x3D; tickOpts.minRotation || 0;

				if (labels.length &amp;&amp; me.options.display &amp;&amp; me.isHorizontal()) {
					var originalLabelWidth &#x3D; helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
					var labelWidth &#x3D; originalLabelWidth;
					var cosRotation, sinRotation;

					// Allow 3 pixels x2 padding either side for label readability
					var tickWidth &#x3D; me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

					// Max label rotation can be set or default to 90 - also act as a loop counter
					while (labelWidth &gt; tickWidth &amp;&amp; labelRotation &lt; tickOpts.maxRotation) {
						var angleRadians &#x3D; helpers.toRadians(labelRotation);
						cosRotation &#x3D; Math.cos(angleRadians);
						sinRotation &#x3D; Math.sin(angleRadians);

						if (sinRotation * originalLabelWidth &gt; me.maxHeight) {
							// go back one step
							labelRotation--;
							break;
						}

						labelRotation++;
						labelWidth &#x3D; cosRotation * originalLabelWidth;
					}
				}

				me.labelRotation &#x3D; labelRotation;
			},
			afterCalculateTickRotation: function() {
				helpers.callback(this.options.afterCalculateTickRotation, [this]);
			},

			//

			beforeFit: function() {
				helpers.callback(this.options.beforeFit, [this]);
			},
			fit: function() {
				var me &#x3D; this;
				// Reset
				var minSize &#x3D; me.minSize &#x3D; {
					width: 0,
					height: 0
				};

				var labels &#x3D; labelsFromTicks(me._ticks);

				var opts &#x3D; me.options;
				var tickOpts &#x3D; opts.ticks;
				var scaleLabelOpts &#x3D; opts.scaleLabel;
				var gridLineOpts &#x3D; opts.gridLines;
				var display &#x3D; opts.display;
				var isHorizontal &#x3D; me.isHorizontal();

				var tickFont &#x3D; parseFontOptions(tickOpts);
				var tickMarkLength &#x3D; opts.gridLines.tickMarkLength;

				// Width
				if (isHorizontal) {
					// subtract the margins to line up with the chartArea if we are a full width scale
					minSize.width &#x3D; me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
				} else {
					minSize.width &#x3D; display &amp;&amp; gridLineOpts.drawTicks ? tickMarkLength : 0;
				}

				// height
				if (isHorizontal) {
					minSize.height &#x3D; display &amp;&amp; gridLineOpts.drawTicks ? tickMarkLength : 0;
				} else {
					minSize.height &#x3D; me.maxHeight; // fill all the height
				}

				// Are we showing a title for the scale?
				if (scaleLabelOpts.display &amp;&amp; display) {
					var scaleLabelLineHeight &#x3D; parseLineHeight(scaleLabelOpts);
					var scaleLabelPadding &#x3D; helpers.options.toPadding(scaleLabelOpts.padding);
					var deltaHeight &#x3D; scaleLabelLineHeight + scaleLabelPadding.height;

					if (isHorizontal) {
						minSize.height +&#x3D; deltaHeight;
					} else {
						minSize.width +&#x3D; deltaHeight;
					}
				}

				// Don&#x27;t bother fitting the ticks if we are not showing them
				if (tickOpts.display &amp;&amp; display) {
					var largestTextWidth &#x3D; helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
					var tallestLabelHeightInLines &#x3D; helpers.numberOfLabelLines(labels);
					var lineSpace &#x3D; tickFont.size * 0.5;
					var tickPadding &#x3D; me.options.ticks.padding;

					if (isHorizontal) {
						// A horizontal axis is more constrained by the height.
						me.longestLabelWidth &#x3D; largestTextWidth;

						var angleRadians &#x3D; helpers.toRadians(me.labelRotation);
						var cosRotation &#x3D; Math.cos(angleRadians);
						var sinRotation &#x3D; Math.sin(angleRadians);

						// TODO - improve this calculation
						var labelHeight &#x3D; (sinRotation * largestTextWidth)
							+ (tickFont.size * tallestLabelHeightInLines)
							+ (lineSpace * (tallestLabelHeightInLines - 1))
							+ lineSpace; // padding

						minSize.height &#x3D; Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

						me.ctx.font &#x3D; tickFont.font;
						var firstLabelWidth &#x3D; computeTextSize(me.ctx, labels[0], tickFont.font);
						var lastLabelWidth &#x3D; computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

						// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
						// which means that the right padding is dominated by the font height
						if (me.labelRotation !&#x3D;&#x3D; 0) {
							me.paddingLeft &#x3D; opts.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
							me.paddingRight &#x3D; opts.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
						} else {
							me.paddingLeft &#x3D; firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
							me.paddingRight &#x3D; lastLabelWidth / 2 + 3;
						}
					} else {
						// A vertical axis is more constrained by the width. Labels are the
						// dominant factor here, so get that length first and account for padding
						if (tickOpts.mirror) {
							largestTextWidth &#x3D; 0;
						} else {
							// use lineSpace for consistency with horizontal axis
							// tickPadding is not implemented for horizontal
							largestTextWidth +&#x3D; tickPadding + lineSpace;
						}

						minSize.width &#x3D; Math.min(me.maxWidth, minSize.width + largestTextWidth);

						me.paddingTop &#x3D; tickFont.size / 2;
						me.paddingBottom &#x3D; tickFont.size / 2;
					}
				}

				me.handleMargins();

				me.width &#x3D; minSize.width;
				me.height &#x3D; minSize.height;
			},

			/**
			 * Handle margins and padding interactions
			 * @private
			 */
			handleMargins: function() {
				var me &#x3D; this;
				if (me.margins) {
					me.paddingLeft &#x3D; Math.max(me.paddingLeft - me.margins.left, 0);
					me.paddingTop &#x3D; Math.max(me.paddingTop - me.margins.top, 0);
					me.paddingRight &#x3D; Math.max(me.paddingRight - me.margins.right, 0);
					me.paddingBottom &#x3D; Math.max(me.paddingBottom - me.margins.bottom, 0);
				}
			},

			afterFit: function() {
				helpers.callback(this.options.afterFit, [this]);
			},

			// Shared Methods
			isHorizontal: function() {
				return this.options.position &#x3D;&#x3D;&#x3D; &#x27;top&#x27; || this.options.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;;
			},
			isFullWidth: function() {
				return (this.options.fullWidth);
			},

			// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
			getRightValue: function(rawValue) {
				// Null and undefined values first
				if (helpers.isNullOrUndef(rawValue)) {
					return NaN;
				}
				// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
				if (typeof rawValue &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; !isFinite(rawValue)) {
					return NaN;
				}
				// If it is in fact an object, dive in one more level
				if (rawValue) {
					if (this.isHorizontal()) {
						if (rawValue.x !&#x3D;&#x3D; undefined) {
							return this.getRightValue(rawValue.x);
						}
					} else if (rawValue.y !&#x3D;&#x3D; undefined) {
						return this.getRightValue(rawValue.y);
					}
				}

				// Value is good, return it
				return rawValue;
			},

			/**
			 * Used to get the value to display in the tooltip for the data at the given index
			 * @param index
			 * @param datasetIndex
			 */
			getLabelForIndex: helpers.noop,

			/**
			 * Returns the location of the given data point. Value can either be an index or a numerical value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param value
			 * @param index
			 * @param datasetIndex
			 */
			getPixelForValue: helpers.noop,

			/**
			 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param pixel
			 */
			getValueForPixel: helpers.noop,

			/**
			 * Returns the location of the tick at the given index
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForTick: function(index) {
				var me &#x3D; this;
				var offset &#x3D; me.options.offset;
				if (me.isHorizontal()) {
					var innerWidth &#x3D; me.width - (me.paddingLeft + me.paddingRight);
					var tickWidth &#x3D; innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
					var pixel &#x3D; (tickWidth * index) + me.paddingLeft;

					if (offset) {
						pixel +&#x3D; tickWidth / 2;
					}

					var finalVal &#x3D; me.left + Math.round(pixel);
					finalVal +&#x3D; me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				var innerHeight &#x3D; me.height - (me.paddingTop + me.paddingBottom);
				return me.top + (index * (innerHeight / (me._ticks.length - 1)));
			},

			/**
			 * Utility for getting the pixel location of a percentage of scale
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForDecimal: function(decimal) {
				var me &#x3D; this;
				if (me.isHorizontal()) {
					var innerWidth &#x3D; me.width - (me.paddingLeft + me.paddingRight);
					var valueOffset &#x3D; (innerWidth * decimal) + me.paddingLeft;

					var finalVal &#x3D; me.left + Math.round(valueOffset);
					finalVal +&#x3D; me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				return me.top + (decimal * me.height);
			},

			/**
			 * Returns the pixel for the minimum chart value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getBasePixel: function() {
				return this.getPixelForValue(this.getBaseValue());
			},

			getBaseValue: function() {
				var me &#x3D; this;
				var min &#x3D; me.min;
				var max &#x3D; me.max;

				return me.beginAtZero ? 0 :
					min &lt; 0 &amp;&amp; max &lt; 0 ? max :
					min &gt; 0 &amp;&amp; max &gt; 0 ? min :
					0;
			},

			/**
			 * Returns a subset of ticks to be plotted to avoid overlapping labels.
			 * @private
			 */
			_autoSkip: function(ticks) {
				var skipRatio;
				var me &#x3D; this;
				var isHorizontal &#x3D; me.isHorizontal();
				var optionTicks &#x3D; me.options.ticks.minor;
				var tickCount &#x3D; ticks.length;
				var labelRotationRadians &#x3D; helpers.toRadians(me.labelRotation);
				var cosRotation &#x3D; Math.cos(labelRotationRadians);
				var longestRotatedLabel &#x3D; me.longestLabelWidth * cosRotation;
				var result &#x3D; [];
				var i, tick, shouldSkip;

				// figure out the maximum number of gridlines to show
				var maxTicks;
				if (optionTicks.maxTicksLimit) {
					maxTicks &#x3D; optionTicks.maxTicksLimit;
				}

				if (isHorizontal) {
					skipRatio &#x3D; false;

					if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount &gt; (me.width - (me.paddingLeft + me.paddingRight))) {
						skipRatio &#x3D; 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
					}

					// if they defined a max number of optionTicks,
					// increase skipRatio until that number is met
					if (maxTicks &amp;&amp; tickCount &gt; maxTicks) {
						skipRatio &#x3D; Math.max(skipRatio, Math.floor(tickCount / maxTicks));
					}
				}

				for (i &#x3D; 0; i &lt; tickCount; i++) {
					tick &#x3D; ticks[i];

					// Since we always show the last tick,we need may need to hide the last shown one before
					shouldSkip &#x3D; (skipRatio &gt; 1 &amp;&amp; i % skipRatio &gt; 0) || (i % skipRatio &#x3D;&#x3D;&#x3D; 0 &amp;&amp; i + skipRatio &gt;&#x3D; tickCount);
					if (shouldSkip &amp;&amp; i !&#x3D;&#x3D; tickCount - 1) {
						// leave tick in place but make sure it&#x27;s not displayed (#4635)
						delete tick.label;
					}
					result.push(tick);
				}
				return result;
			},

			// Actually draw the scale on the canvas
			// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
			draw: function(chartArea) {
				var me &#x3D; this;
				var options &#x3D; me.options;
				if (!options.display) {
					return;
				}

				var context &#x3D; me.ctx;
				var globalDefaults &#x3D; defaults.global;
				var optionTicks &#x3D; options.ticks.minor;
				var optionMajorTicks &#x3D; options.ticks.major || optionTicks;
				var gridLines &#x3D; options.gridLines;
				var scaleLabel &#x3D; options.scaleLabel;

				var isRotated &#x3D; me.labelRotation !&#x3D;&#x3D; 0;
				var isHorizontal &#x3D; me.isHorizontal();

				var ticks &#x3D; optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
				var tickFontColor &#x3D; helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
				var tickFont &#x3D; parseFontOptions(optionTicks);
				var majorTickFontColor &#x3D; helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
				var majorTickFont &#x3D; parseFontOptions(optionMajorTicks);

				var tl &#x3D; gridLines.drawTicks ? gridLines.tickMarkLength : 0;

				var scaleLabelFontColor &#x3D; helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
				var scaleLabelFont &#x3D; parseFontOptions(scaleLabel);
				var scaleLabelPadding &#x3D; helpers.options.toPadding(scaleLabel.padding);
				var labelRotationRadians &#x3D; helpers.toRadians(me.labelRotation);

				var itemsToDraw &#x3D; [];

				var axisWidth &#x3D; me.options.gridLines.lineWidth;
				var xTickStart &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;right&#x27; ? me.right : me.right - axisWidth - tl;
				var xTickEnd &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;right&#x27; ? me.right + tl : me.right;
				var yTickStart &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; ? me.top + axisWidth : me.bottom - tl - axisWidth;
				var yTickEnd &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27; ? me.top + axisWidth + tl : me.bottom + axisWidth;

				helpers.each(ticks, function(tick, index) {
					// autoskipper skipped this tick (#4635)
					if (helpers.isNullOrUndef(tick.label)) {
						return;
					}

					var label &#x3D; tick.label;
					var lineWidth, lineColor, borderDash, borderDashOffset;
					if (index &#x3D;&#x3D;&#x3D; me.zeroLineIndex &amp;&amp; options.offset &#x3D;&#x3D;&#x3D; gridLines.offsetGridLines) {
						// Draw the first index specially
						lineWidth &#x3D; gridLines.zeroLineWidth;
						lineColor &#x3D; gridLines.zeroLineColor;
						borderDash &#x3D; gridLines.zeroLineBorderDash;
						borderDashOffset &#x3D; gridLines.zeroLineBorderDashOffset;
					} else {
						lineWidth &#x3D; helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
						lineColor &#x3D; helpers.valueAtIndexOrDefault(gridLines.color, index);
						borderDash &#x3D; helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
						borderDashOffset &#x3D; helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
					}

					// Common properties
					var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
					var textAlign &#x3D; &#x27;middle&#x27;;
					var textBaseline &#x3D; &#x27;middle&#x27;;
					var tickPadding &#x3D; optionTicks.padding;

					if (isHorizontal) {
						var labelYOffset &#x3D; tl + tickPadding;

						if (options.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;) {
							// bottom
							textBaseline &#x3D; !isRotated ? &#x27;top&#x27; : &#x27;middle&#x27;;
							textAlign &#x3D; !isRotated ? &#x27;center&#x27; : &#x27;right&#x27;;
							labelY &#x3D; me.top + labelYOffset;
						} else {
							// top
							textBaseline &#x3D; !isRotated ? &#x27;bottom&#x27; : &#x27;middle&#x27;;
							textAlign &#x3D; !isRotated ? &#x27;center&#x27; : &#x27;left&#x27;;
							labelY &#x3D; me.bottom - labelYOffset;
						}

						var xLineValue &#x3D; getLineValue(me, index, gridLines.offsetGridLines &amp;&amp; ticks.length &gt; 1);
						if (xLineValue &lt; me.left) {
							lineColor &#x3D; &#x27;rgba(0,0,0,0)&#x27;;
						}
						xLineValue +&#x3D; helpers.aliasPixel(lineWidth);

						labelX &#x3D; me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

						tx1 &#x3D; tx2 &#x3D; x1 &#x3D; x2 &#x3D; xLineValue;
						ty1 &#x3D; yTickStart;
						ty2 &#x3D; yTickEnd;
						y1 &#x3D; chartArea.top;
						y2 &#x3D; chartArea.bottom + axisWidth;
					} else {
						var isLeft &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;left&#x27;;
						var labelXOffset;

						if (optionTicks.mirror) {
							textAlign &#x3D; isLeft ? &#x27;left&#x27; : &#x27;right&#x27;;
							labelXOffset &#x3D; tickPadding;
						} else {
							textAlign &#x3D; isLeft ? &#x27;right&#x27; : &#x27;left&#x27;;
							labelXOffset &#x3D; tl + tickPadding;
						}

						labelX &#x3D; isLeft ? me.right - labelXOffset : me.left + labelXOffset;

						var yLineValue &#x3D; getLineValue(me, index, gridLines.offsetGridLines &amp;&amp; ticks.length &gt; 1);
						if (yLineValue &lt; me.top) {
							lineColor &#x3D; &#x27;rgba(0,0,0,0)&#x27;;
						}
						yLineValue +&#x3D; helpers.aliasPixel(lineWidth);

						labelY &#x3D; me.getPixelForTick(index) + optionTicks.labelOffset;

						tx1 &#x3D; xTickStart;
						tx2 &#x3D; xTickEnd;
						x1 &#x3D; chartArea.left;
						x2 &#x3D; chartArea.right + axisWidth;
						ty1 &#x3D; ty2 &#x3D; y1 &#x3D; y2 &#x3D; yLineValue;
					}

					itemsToDraw.push({
						tx1: tx1,
						ty1: ty1,
						tx2: tx2,
						ty2: ty2,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
						labelX: labelX,
						labelY: labelY,
						glWidth: lineWidth,
						glColor: lineColor,
						glBorderDash: borderDash,
						glBorderDashOffset: borderDashOffset,
						rotation: -1 * labelRotationRadians,
						label: label,
						major: tick.major,
						textBaseline: textBaseline,
						textAlign: textAlign
					});
				});

				// Draw all of the tick labels, tick marks, and grid lines at the correct places
				helpers.each(itemsToDraw, function(itemToDraw) {
					if (gridLines.display) {
						context.save();
						context.lineWidth &#x3D; itemToDraw.glWidth;
						context.strokeStyle &#x3D; itemToDraw.glColor;
						if (context.setLineDash) {
							context.setLineDash(itemToDraw.glBorderDash);
							context.lineDashOffset &#x3D; itemToDraw.glBorderDashOffset;
						}

						context.beginPath();

						if (gridLines.drawTicks) {
							context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
							context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
						}

						if (gridLines.drawOnChartArea) {
							context.moveTo(itemToDraw.x1, itemToDraw.y1);
							context.lineTo(itemToDraw.x2, itemToDraw.y2);
						}

						context.stroke();
						context.restore();
					}

					if (optionTicks.display) {
						// Make sure we draw text in the correct color and font
						context.save();
						context.translate(itemToDraw.labelX, itemToDraw.labelY);
						context.rotate(itemToDraw.rotation);
						context.font &#x3D; itemToDraw.major ? majorTickFont.font : tickFont.font;
						context.fillStyle &#x3D; itemToDraw.major ? majorTickFontColor : tickFontColor;
						context.textBaseline &#x3D; itemToDraw.textBaseline;
						context.textAlign &#x3D; itemToDraw.textAlign;

						var label &#x3D; itemToDraw.label;
						if (helpers.isArray(label)) {
							var lineCount &#x3D; label.length;
							var lineHeight &#x3D; tickFont.size * 1.5;
							var y &#x3D; me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;

							for (var i &#x3D; 0; i &lt; lineCount; ++i) {
								// We just make sure the multiline element is a string here..
								context.fillText(&#x27;&#x27; + label[i], 0, y);
								// apply same lineSpacing as calculated @ L#320
								y +&#x3D; lineHeight;
							}
						} else {
							context.fillText(label, 0, 0);
						}
						context.restore();
					}
				});

				if (scaleLabel.display) {
					// Draw the scale label
					var scaleLabelX;
					var scaleLabelY;
					var rotation &#x3D; 0;
					var halfLineHeight &#x3D; parseLineHeight(scaleLabel) / 2;

					if (isHorizontal) {
						scaleLabelX &#x3D; me.left + ((me.right - me.left) / 2); // midpoint of the width
						scaleLabelY &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;
							? me.bottom - halfLineHeight - scaleLabelPadding.bottom
							: me.top + halfLineHeight + scaleLabelPadding.top;
					} else {
						var isLeft &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;left&#x27;;
						scaleLabelX &#x3D; isLeft
							? me.left + halfLineHeight + scaleLabelPadding.top
							: me.right - halfLineHeight - scaleLabelPadding.top;
						scaleLabelY &#x3D; me.top + ((me.bottom - me.top) / 2);
						rotation &#x3D; isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
					}

					context.save();
					context.translate(scaleLabelX, scaleLabelY);
					context.rotate(rotation);
					context.textAlign &#x3D; &#x27;center&#x27;;
					context.textBaseline &#x3D; &#x27;middle&#x27;;
					context.fillStyle &#x3D; scaleLabelFontColor; // render in correct colour
					context.font &#x3D; scaleLabelFont.font;
					context.fillText(scaleLabel.labelString, 0, 0);
					context.restore();
				}

				if (gridLines.drawBorder) {
					// Draw the line at the edge of the axis
					context.lineWidth &#x3D; helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
					context.strokeStyle &#x3D; helpers.valueAtIndexOrDefault(gridLines.color, 0);
					var x1 &#x3D; me.left;
					var x2 &#x3D; me.right + axisWidth;
					var y1 &#x3D; me.top;
					var y2 &#x3D; me.bottom + axisWidth;

					var aliasPixel &#x3D; helpers.aliasPixel(context.lineWidth);
					if (isHorizontal) {
						y1 &#x3D; y2 &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;top&#x27; ? me.bottom : me.top;
						y1 +&#x3D; aliasPixel;
						y2 +&#x3D; aliasPixel;
					} else {
						x1 &#x3D; x2 &#x3D; options.position &#x3D;&#x3D;&#x3D; &#x27;left&#x27; ? me.right : me.left;
						x1 +&#x3D; aliasPixel;
						x2 +&#x3D; aliasPixel;
					}

					context.beginPath();
					context.moveTo(x1, y1);
					context.lineTo(x2, y2);
					context.stroke();
				}
			}
		});
	};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		tooltips: {
			enabled: true,
			custom: null,
			mode: &#x27;nearest&#x27;,
			position: &#x27;average&#x27;,
			intersect: true,
			backgroundColor: &#x27;rgba(0,0,0,0.8)&#x27;,
			titleFontStyle: &#x27;bold&#x27;,
			titleSpacing: 2,
			titleMarginBottom: 6,
			titleFontColor: &#x27;#fff&#x27;,
			titleAlign: &#x27;left&#x27;,
			bodySpacing: 2,
			bodyFontColor: &#x27;#fff&#x27;,
			bodyAlign: &#x27;left&#x27;,
			footerFontStyle: &#x27;bold&#x27;,
			footerSpacing: 2,
			footerMarginTop: 6,
			footerFontColor: &#x27;#fff&#x27;,
			footerAlign: &#x27;left&#x27;,
			yPadding: 6,
			xPadding: 6,
			caretPadding: 2,
			caretSize: 5,
			cornerRadius: 6,
			multiKeyBackground: &#x27;#fff&#x27;,
			displayColors: true,
			borderColor: &#x27;rgba(0,0,0,0)&#x27;,
			borderWidth: 0,
			callbacks: {
				// Args are: (tooltipItems, data)
				beforeTitle: helpers.noop,
				title: function(tooltipItems, data) {
					// Pick first xLabel for now
					var title &#x3D; &#x27;&#x27;;
					var labels &#x3D; data.labels;
					var labelCount &#x3D; labels ? labels.length : 0;

					if (tooltipItems.length &gt; 0) {
						var item &#x3D; tooltipItems[0];

						if (item.xLabel) {
							title &#x3D; item.xLabel;
						} else if (labelCount &gt; 0 &amp;&amp; item.index &lt; labelCount) {
							title &#x3D; labels[item.index];
						}
					}

					return title;
				},
				afterTitle: helpers.noop,

				// Args are: (tooltipItems, data)
				beforeBody: helpers.noop,

				// Args are: (tooltipItem, data)
				beforeLabel: helpers.noop,
				label: function(tooltipItem, data) {
					var label &#x3D; data.datasets[tooltipItem.datasetIndex].label || &#x27;&#x27;;

					if (label) {
						label +&#x3D; &#x27;: &#x27;;
					}
					label +&#x3D; tooltipItem.yLabel;
					return label;
				},
				labelColor: function(tooltipItem, chart) {
					var meta &#x3D; chart.getDatasetMeta(tooltipItem.datasetIndex);
					var activeElement &#x3D; meta.data[tooltipItem.index];
					var view &#x3D; activeElement._view;
					return {
						borderColor: view.borderColor,
						backgroundColor: view.backgroundColor
					};
				},
				labelTextColor: function() {
					return this._options.bodyFontColor;
				},
				afterLabel: helpers.noop,

				// Args are: (tooltipItems, data)
				afterBody: helpers.noop,

				// Args are: (tooltipItems, data)
				beforeFooter: helpers.noop,
				footer: helpers.noop,
				afterFooter: helpers.noop
			}
		}
	});

	module.exports &#x3D; function(Chart) {

		/**
	 	 * Helper method to merge the opacity into a color
	 	 */
		function mergeOpacity(colorString, opacity) {
			var color &#x3D; helpers.color(colorString);
			return color.alpha(opacity * color.alpha()).rgbaString();
		}

		// Helper to push or concat based on if the 2nd parameter is an array or not
		function pushOrConcat(base, toPush) {
			if (toPush) {
				if (helpers.isArray(toPush)) {
					// base &#x3D; base.concat(toPush);
					Array.prototype.push.apply(base, toPush);
				} else {
					base.push(toPush);
				}
			}

			return base;
		}

		// Private helper to create a tooltip item model
		// @param element : the chart element (point, arc, bar) to create the tooltip item for
		// @return : new tooltip item
		function createTooltipItem(element) {
			var xScale &#x3D; element._xScale;
			var yScale &#x3D; element._yScale || element._scale; // handle radar || polarArea charts
			var index &#x3D; element._index;
			var datasetIndex &#x3D; element._datasetIndex;

			return {
				xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : &#x27;&#x27;,
				yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : &#x27;&#x27;,
				index: index,
				datasetIndex: datasetIndex,
				x: element._model.x,
				y: element._model.y
			};
		}

		/**
		 * Helper to get the reset model for the tooltip
		 * @param tooltipOpts {Object} the tooltip options
		 */
		function getBaseModel(tooltipOpts) {
			var globalDefaults &#x3D; defaults.global;
			var valueOrDefault &#x3D; helpers.valueOrDefault;

			return {
				// Positioning
				xPadding: tooltipOpts.xPadding,
				yPadding: tooltipOpts.yPadding,
				xAlign: tooltipOpts.xAlign,
				yAlign: tooltipOpts.yAlign,

				// Body
				bodyFontColor: tooltipOpts.bodyFontColor,
				_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
				_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
				_bodyAlign: tooltipOpts.bodyAlign,
				bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
				bodySpacing: tooltipOpts.bodySpacing,

				// Title
				titleFontColor: tooltipOpts.titleFontColor,
				_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
				_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
				titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
				_titleAlign: tooltipOpts.titleAlign,
				titleSpacing: tooltipOpts.titleSpacing,
				titleMarginBottom: tooltipOpts.titleMarginBottom,

				// Footer
				footerFontColor: tooltipOpts.footerFontColor,
				_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
				_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
				footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
				_footerAlign: tooltipOpts.footerAlign,
				footerSpacing: tooltipOpts.footerSpacing,
				footerMarginTop: tooltipOpts.footerMarginTop,

				// Appearance
				caretSize: tooltipOpts.caretSize,
				cornerRadius: tooltipOpts.cornerRadius,
				backgroundColor: tooltipOpts.backgroundColor,
				opacity: 0,
				legendColorBackground: tooltipOpts.multiKeyBackground,
				displayColors: tooltipOpts.displayColors,
				borderColor: tooltipOpts.borderColor,
				borderWidth: tooltipOpts.borderWidth
			};
		}

		/**
		 * Get the size of the tooltip
		 */
		function getTooltipSize(tooltip, model) {
			var ctx &#x3D; tooltip._chart.ctx;

			var height &#x3D; model.yPadding * 2; // Tooltip Padding
			var width &#x3D; 0;

			// Count of all lines in the body
			var body &#x3D; model.body;
			var combinedBodyLength &#x3D; body.reduce(function(count, bodyItem) {
				return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
			}, 0);
			combinedBodyLength +&#x3D; model.beforeBody.length + model.afterBody.length;

			var titleLineCount &#x3D; model.title.length;
			var footerLineCount &#x3D; model.footer.length;
			var titleFontSize &#x3D; model.titleFontSize;
			var bodyFontSize &#x3D; model.bodyFontSize;
			var footerFontSize &#x3D; model.footerFontSize;

			height +&#x3D; titleLineCount * titleFontSize; // Title Lines
			height +&#x3D; titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
			height +&#x3D; titleLineCount ? model.titleMarginBottom : 0; // Title&#x27;s bottom Margin
			height +&#x3D; combinedBodyLength * bodyFontSize; // Body Lines
			height +&#x3D; combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
			height +&#x3D; footerLineCount ? model.footerMarginTop : 0; // Footer Margin
			height +&#x3D; footerLineCount * (footerFontSize); // Footer Lines
			height +&#x3D; footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

			// Title width
			var widthPadding &#x3D; 0;
			var maxLineWidth &#x3D; function(line) {
				width &#x3D; Math.max(width, ctx.measureText(line).width + widthPadding);
			};

			ctx.font &#x3D; helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
			helpers.each(model.title, maxLineWidth);

			// Body width
			ctx.font &#x3D; helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
			helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

			// Body lines may include some extra width due to the color box
			widthPadding &#x3D; model.displayColors ? (bodyFontSize + 2) : 0;
			helpers.each(body, function(bodyItem) {
				helpers.each(bodyItem.before, maxLineWidth);
				helpers.each(bodyItem.lines, maxLineWidth);
				helpers.each(bodyItem.after, maxLineWidth);
			});

			// Reset back to 0
			widthPadding &#x3D; 0;

			// Footer width
			ctx.font &#x3D; helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
			helpers.each(model.footer, maxLineWidth);

			// Add padding
			width +&#x3D; 2 * model.xPadding;

			return {
				width: width,
				height: height
			};
		}

		/**
		 * Helper to get the alignment of a tooltip given the size
		 */
		function determineAlignment(tooltip, size) {
			var model &#x3D; tooltip._model;
			var chart &#x3D; tooltip._chart;
			var chartArea &#x3D; tooltip._chart.chartArea;
			var xAlign &#x3D; &#x27;center&#x27;;
			var yAlign &#x3D; &#x27;center&#x27;;

			if (model.y &lt; size.height) {
				yAlign &#x3D; &#x27;top&#x27;;
			} else if (model.y &gt; (chart.height - size.height)) {
				yAlign &#x3D; &#x27;bottom&#x27;;
			}

			var lf, rf; // functions to determine left, right alignment
			var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
			var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
			var midX &#x3D; (chartArea.left + chartArea.right) / 2;
			var midY &#x3D; (chartArea.top + chartArea.bottom) / 2;

			if (yAlign &#x3D;&#x3D;&#x3D; &#x27;center&#x27;) {
				lf &#x3D; function(x) {
					return x &lt;&#x3D; midX;
				};
				rf &#x3D; function(x) {
					return x &gt; midX;
				};
			} else {
				lf &#x3D; function(x) {
					return x &lt;&#x3D; (size.width / 2);
				};
				rf &#x3D; function(x) {
					return x &gt;&#x3D; (chart.width - (size.width / 2));
				};
			}

			olf &#x3D; function(x) {
				return x + size.width + model.caretSize + model.caretPadding &gt; chart.width;
			};
			orf &#x3D; function(x) {
				return x - size.width - model.caretSize - model.caretPadding &lt; 0;
			};
			yf &#x3D; function(y) {
				return y &lt;&#x3D; midY ? &#x27;top&#x27; : &#x27;bottom&#x27;;
			};

			if (lf(model.x)) {
				xAlign &#x3D; &#x27;left&#x27;;

				// Is tooltip too wide and goes over the right side of the chart.?
				if (olf(model.x)) {
					xAlign &#x3D; &#x27;center&#x27;;
					yAlign &#x3D; yf(model.y);
				}
			} else if (rf(model.x)) {
				xAlign &#x3D; &#x27;right&#x27;;

				// Is tooltip too wide and goes outside left edge of canvas?
				if (orf(model.x)) {
					xAlign &#x3D; &#x27;center&#x27;;
					yAlign &#x3D; yf(model.y);
				}
			}

			var opts &#x3D; tooltip._options;
			return {
				xAlign: opts.xAlign ? opts.xAlign : xAlign,
				yAlign: opts.yAlign ? opts.yAlign : yAlign
			};
		}

		/**
		 * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
		 */
		function getBackgroundPoint(vm, size, alignment, chart) {
			// Background Position
			var x &#x3D; vm.x;
			var y &#x3D; vm.y;

			var caretSize &#x3D; vm.caretSize;
			var caretPadding &#x3D; vm.caretPadding;
			var cornerRadius &#x3D; vm.cornerRadius;
			var xAlign &#x3D; alignment.xAlign;
			var yAlign &#x3D; alignment.yAlign;
			var paddingAndSize &#x3D; caretSize + caretPadding;
			var radiusAndPadding &#x3D; cornerRadius + caretPadding;

			if (xAlign &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
				x -&#x3D; size.width;
			} else if (xAlign &#x3D;&#x3D;&#x3D; &#x27;center&#x27;) {
				x -&#x3D; (size.width / 2);
				if (x + size.width &gt; chart.width) {
					x &#x3D; chart.width - size.width;
				}
				if (x &lt; 0) {
					x &#x3D; 0;
				}
			}

			if (yAlign &#x3D;&#x3D;&#x3D; &#x27;top&#x27;) {
				y +&#x3D; paddingAndSize;
			} else if (yAlign &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;) {
				y -&#x3D; size.height + paddingAndSize;
			} else {
				y -&#x3D; (size.height / 2);
			}

			if (yAlign &#x3D;&#x3D;&#x3D; &#x27;center&#x27;) {
				if (xAlign &#x3D;&#x3D;&#x3D; &#x27;left&#x27;) {
					x +&#x3D; paddingAndSize;
				} else if (xAlign &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
					x -&#x3D; paddingAndSize;
				}
			} else if (xAlign &#x3D;&#x3D;&#x3D; &#x27;left&#x27;) {
				x -&#x3D; radiusAndPadding;
			} else if (xAlign &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
				x +&#x3D; radiusAndPadding;
			}

			return {
				x: x,
				y: y
			};
		}

		Chart.Tooltip &#x3D; Element.extend({
			initialize: function() {
				this._model &#x3D; getBaseModel(this._options);
				this._lastActive &#x3D; [];
			},

			// Get the title
			// Args are: (tooltipItem, data)
			getTitle: function() {
				var me &#x3D; this;
				var opts &#x3D; me._options;
				var callbacks &#x3D; opts.callbacks;

				var beforeTitle &#x3D; callbacks.beforeTitle.apply(me, arguments);
				var title &#x3D; callbacks.title.apply(me, arguments);
				var afterTitle &#x3D; callbacks.afterTitle.apply(me, arguments);

				var lines &#x3D; [];
				lines &#x3D; pushOrConcat(lines, beforeTitle);
				lines &#x3D; pushOrConcat(lines, title);
				lines &#x3D; pushOrConcat(lines, afterTitle);

				return lines;
			},

			// Args are: (tooltipItem, data)
			getBeforeBody: function() {
				var lines &#x3D; this._options.callbacks.beforeBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !&#x3D;&#x3D; undefined ? [lines] : [];
			},

			// Args are: (tooltipItem, data)
			getBody: function(tooltipItems, data) {
				var me &#x3D; this;
				var callbacks &#x3D; me._options.callbacks;
				var bodyItems &#x3D; [];

				helpers.each(tooltipItems, function(tooltipItem) {
					var bodyItem &#x3D; {
						before: [],
						lines: [],
						after: []
					};
					pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

					bodyItems.push(bodyItem);
				});

				return bodyItems;
			},

			// Args are: (tooltipItem, data)
			getAfterBody: function() {
				var lines &#x3D; this._options.callbacks.afterBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !&#x3D;&#x3D; undefined ? [lines] : [];
			},

			// Get the footer and beforeFooter and afterFooter lines
			// Args are: (tooltipItem, data)
			getFooter: function() {
				var me &#x3D; this;
				var callbacks &#x3D; me._options.callbacks;

				var beforeFooter &#x3D; callbacks.beforeFooter.apply(me, arguments);
				var footer &#x3D; callbacks.footer.apply(me, arguments);
				var afterFooter &#x3D; callbacks.afterFooter.apply(me, arguments);

				var lines &#x3D; [];
				lines &#x3D; pushOrConcat(lines, beforeFooter);
				lines &#x3D; pushOrConcat(lines, footer);
				lines &#x3D; pushOrConcat(lines, afterFooter);

				return lines;
			},

			update: function(changed) {
				var me &#x3D; this;
				var opts &#x3D; me._options;

				// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
				// that does _view &#x3D; _model if ease &#x3D;&#x3D;&#x3D; 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
				// which breaks any animations.
				var existingModel &#x3D; me._model;
				var model &#x3D; me._model &#x3D; getBaseModel(opts);
				var active &#x3D; me._active;

				var data &#x3D; me._data;

				// In the case where active.length &#x3D;&#x3D;&#x3D; 0 we need to keep these at existing values for good animations
				var alignment &#x3D; {
					xAlign: existingModel.xAlign,
					yAlign: existingModel.yAlign
				};
				var backgroundPoint &#x3D; {
					x: existingModel.x,
					y: existingModel.y
				};
				var tooltipSize &#x3D; {
					width: existingModel.width,
					height: existingModel.height
				};
				var tooltipPosition &#x3D; {
					x: existingModel.caretX,
					y: existingModel.caretY
				};

				var i, len;

				if (active.length) {
					model.opacity &#x3D; 1;

					var labelColors &#x3D; [];
					var labelTextColors &#x3D; [];
					tooltipPosition &#x3D; Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);

					var tooltipItems &#x3D; [];
					for (i &#x3D; 0, len &#x3D; active.length; i &lt; len; ++i) {
						tooltipItems.push(createTooltipItem(active[i]));
					}

					// If the user provided a filter function, use it to modify the tooltip items
					if (opts.filter) {
						tooltipItems &#x3D; tooltipItems.filter(function(a) {
							return opts.filter(a, data);
						});
					}

					// If the user provided a sorting function, use it to modify the tooltip items
					if (opts.itemSort) {
						tooltipItems &#x3D; tooltipItems.sort(function(a, b) {
							return opts.itemSort(a, b, data);
						});
					}

					// Determine colors for boxes
					helpers.each(tooltipItems, function(tooltipItem) {
						labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
						labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
					});


					// Build the Text Lines
					model.title &#x3D; me.getTitle(tooltipItems, data);
					model.beforeBody &#x3D; me.getBeforeBody(tooltipItems, data);
					model.body &#x3D; me.getBody(tooltipItems, data);
					model.afterBody &#x3D; me.getAfterBody(tooltipItems, data);
					model.footer &#x3D; me.getFooter(tooltipItems, data);

					// Initial positioning and colors
					model.x &#x3D; Math.round(tooltipPosition.x);
					model.y &#x3D; Math.round(tooltipPosition.y);
					model.caretPadding &#x3D; opts.caretPadding;
					model.labelColors &#x3D; labelColors;
					model.labelTextColors &#x3D; labelTextColors;

					// data points
					model.dataPoints &#x3D; tooltipItems;

					// We need to determine alignment of the tooltip
					tooltipSize &#x3D; getTooltipSize(this, model);
					alignment &#x3D; determineAlignment(this, tooltipSize);
					// Final Size and Position
					backgroundPoint &#x3D; getBackgroundPoint(model, tooltipSize, alignment, me._chart);
				} else {
					model.opacity &#x3D; 0;
				}

				model.xAlign &#x3D; alignment.xAlign;
				model.yAlign &#x3D; alignment.yAlign;
				model.x &#x3D; backgroundPoint.x;
				model.y &#x3D; backgroundPoint.y;
				model.width &#x3D; tooltipSize.width;
				model.height &#x3D; tooltipSize.height;

				// Point where the caret on the tooltip points to
				model.caretX &#x3D; tooltipPosition.x;
				model.caretY &#x3D; tooltipPosition.y;

				me._model &#x3D; model;

				if (changed &amp;&amp; opts.custom) {
					opts.custom.call(me, model);
				}

				return me;
			},
			drawCaret: function(tooltipPoint, size) {
				var ctx &#x3D; this._chart.ctx;
				var vm &#x3D; this._view;
				var caretPosition &#x3D; this.getCaretPosition(tooltipPoint, size, vm);

				ctx.lineTo(caretPosition.x1, caretPosition.y1);
				ctx.lineTo(caretPosition.x2, caretPosition.y2);
				ctx.lineTo(caretPosition.x3, caretPosition.y3);
			},
			getCaretPosition: function(tooltipPoint, size, vm) {
				var x1, x2, x3, y1, y2, y3;
				var caretSize &#x3D; vm.caretSize;
				var cornerRadius &#x3D; vm.cornerRadius;
				var xAlign &#x3D; vm.xAlign;
				var yAlign &#x3D; vm.yAlign;
				var ptX &#x3D; tooltipPoint.x;
				var ptY &#x3D; tooltipPoint.y;
				var width &#x3D; size.width;
				var height &#x3D; size.height;

				if (yAlign &#x3D;&#x3D;&#x3D; &#x27;center&#x27;) {
					y2 &#x3D; ptY + (height / 2);

					if (xAlign &#x3D;&#x3D;&#x3D; &#x27;left&#x27;) {
						x1 &#x3D; ptX;
						x2 &#x3D; x1 - caretSize;
						x3 &#x3D; x1;

						y1 &#x3D; y2 + caretSize;
						y3 &#x3D; y2 - caretSize;
					} else {
						x1 &#x3D; ptX + width;
						x2 &#x3D; x1 + caretSize;
						x3 &#x3D; x1;

						y1 &#x3D; y2 - caretSize;
						y3 &#x3D; y2 + caretSize;
					}
				} else {
					if (xAlign &#x3D;&#x3D;&#x3D; &#x27;left&#x27;) {
						x2 &#x3D; ptX + cornerRadius + (caretSize);
						x1 &#x3D; x2 - caretSize;
						x3 &#x3D; x2 + caretSize;
					} else if (xAlign &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
						x2 &#x3D; ptX + width - cornerRadius - caretSize;
						x1 &#x3D; x2 - caretSize;
						x3 &#x3D; x2 + caretSize;
					} else {
						x2 &#x3D; vm.caretX;
						x1 &#x3D; x2 - caretSize;
						x3 &#x3D; x2 + caretSize;
					}
					if (yAlign &#x3D;&#x3D;&#x3D; &#x27;top&#x27;) {
						y1 &#x3D; ptY;
						y2 &#x3D; y1 - caretSize;
						y3 &#x3D; y1;
					} else {
						y1 &#x3D; ptY + height;
						y2 &#x3D; y1 + caretSize;
						y3 &#x3D; y1;
						// invert drawing order
						var tmp &#x3D; x3;
						x3 &#x3D; x1;
						x1 &#x3D; tmp;
					}
				}
				return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
			},
			drawTitle: function(pt, vm, ctx, opacity) {
				var title &#x3D; vm.title;

				if (title.length) {
					ctx.textAlign &#x3D; vm._titleAlign;
					ctx.textBaseline &#x3D; &#x27;top&#x27;;

					var titleFontSize &#x3D; vm.titleFontSize;
					var titleSpacing &#x3D; vm.titleSpacing;

					ctx.fillStyle &#x3D; mergeOpacity(vm.titleFontColor, opacity);
					ctx.font &#x3D; helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

					var i, len;
					for (i &#x3D; 0, len &#x3D; title.length; i &lt; len; ++i) {
						ctx.fillText(title[i], pt.x, pt.y);
						pt.y +&#x3D; titleFontSize + titleSpacing; // Line Height and spacing

						if (i + 1 &#x3D;&#x3D;&#x3D; title.length) {
							pt.y +&#x3D; vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
						}
					}
				}
			},
			drawBody: function(pt, vm, ctx, opacity) {
				var bodyFontSize &#x3D; vm.bodyFontSize;
				var bodySpacing &#x3D; vm.bodySpacing;
				var body &#x3D; vm.body;

				ctx.textAlign &#x3D; vm._bodyAlign;
				ctx.textBaseline &#x3D; &#x27;top&#x27;;
				ctx.font &#x3D; helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

				// Before Body
				var xLinePadding &#x3D; 0;
				var fillLineOfText &#x3D; function(line) {
					ctx.fillText(line, pt.x + xLinePadding, pt.y);
					pt.y +&#x3D; bodyFontSize + bodySpacing;
				};

				// Before body lines
				ctx.fillStyle &#x3D; mergeOpacity(vm.bodyFontColor, opacity);
				helpers.each(vm.beforeBody, fillLineOfText);

				var drawColorBoxes &#x3D; vm.displayColors;
				xLinePadding &#x3D; drawColorBoxes ? (bodyFontSize + 2) : 0;

				// Draw body lines now
				helpers.each(body, function(bodyItem, i) {
					var textColor &#x3D; mergeOpacity(vm.labelTextColors[i], opacity);
					ctx.fillStyle &#x3D; textColor;
					helpers.each(bodyItem.before, fillLineOfText);

					helpers.each(bodyItem.lines, function(line) {
						// Draw Legend-like boxes if needed
						if (drawColorBoxes) {
							// Fill a white rect so that colours merge nicely if the opacity is &lt; 1
							ctx.fillStyle &#x3D; mergeOpacity(vm.legendColorBackground, opacity);
							ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

							// Border
							ctx.lineWidth &#x3D; 1;
							ctx.strokeStyle &#x3D; mergeOpacity(vm.labelColors[i].borderColor, opacity);
							ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

							// Inner square
							ctx.fillStyle &#x3D; mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
							ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
							ctx.fillStyle &#x3D; textColor;
						}

						fillLineOfText(line);
					});

					helpers.each(bodyItem.after, fillLineOfText);
				});

				// Reset back to 0 for after body
				xLinePadding &#x3D; 0;

				// After body lines
				helpers.each(vm.afterBody, fillLineOfText);
				pt.y -&#x3D; bodySpacing; // Remove last body spacing
			},
			drawFooter: function(pt, vm, ctx, opacity) {
				var footer &#x3D; vm.footer;

				if (footer.length) {
					pt.y +&#x3D; vm.footerMarginTop;

					ctx.textAlign &#x3D; vm._footerAlign;
					ctx.textBaseline &#x3D; &#x27;top&#x27;;

					ctx.fillStyle &#x3D; mergeOpacity(vm.footerFontColor, opacity);
					ctx.font &#x3D; helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

					helpers.each(footer, function(line) {
						ctx.fillText(line, pt.x, pt.y);
						pt.y +&#x3D; vm.footerFontSize + vm.footerSpacing;
					});
				}
			},
			drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
				ctx.fillStyle &#x3D; mergeOpacity(vm.backgroundColor, opacity);
				ctx.strokeStyle &#x3D; mergeOpacity(vm.borderColor, opacity);
				ctx.lineWidth &#x3D; vm.borderWidth;
				var xAlign &#x3D; vm.xAlign;
				var yAlign &#x3D; vm.yAlign;
				var x &#x3D; pt.x;
				var y &#x3D; pt.y;
				var width &#x3D; tooltipSize.width;
				var height &#x3D; tooltipSize.height;
				var radius &#x3D; vm.cornerRadius;

				ctx.beginPath();
				ctx.moveTo(x + radius, y);
				if (yAlign &#x3D;&#x3D;&#x3D; &#x27;top&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width - radius, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
				if (yAlign &#x3D;&#x3D;&#x3D; &#x27;center&#x27; &amp;&amp; xAlign &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width, y + height - radius);
				ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
				if (yAlign &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + radius, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
				if (yAlign &#x3D;&#x3D;&#x3D; &#x27;center&#x27; &amp;&amp; xAlign &#x3D;&#x3D;&#x3D; &#x27;left&#x27;) {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x, y + radius);
				ctx.quadraticCurveTo(x, y, x + radius, y);
				ctx.closePath();

				ctx.fill();

				if (vm.borderWidth &gt; 0) {
					ctx.stroke();
				}
			},
			draw: function() {
				var ctx &#x3D; this._chart.ctx;
				var vm &#x3D; this._view;

				if (vm.opacity &#x3D;&#x3D;&#x3D; 0) {
					return;
				}

				var tooltipSize &#x3D; {
					width: vm.width,
					height: vm.height
				};
				var pt &#x3D; {
					x: vm.x,
					y: vm.y
				};

				// IE11/Edge does not like very small opacities, so snap to 0
				var opacity &#x3D; Math.abs(vm.opacity &lt; 1e-3) ? 0 : vm.opacity;

				// Truthy/falsey value for empty tooltip
				var hasTooltipContent &#x3D; vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

				if (this._options.enabled &amp;&amp; hasTooltipContent) {
					// Draw Background
					this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

					// Draw Title, Body, and Footer
					pt.x +&#x3D; vm.xPadding;
					pt.y +&#x3D; vm.yPadding;

					// Titles
					this.drawTitle(pt, vm, ctx, opacity);

					// Body
					this.drawBody(pt, vm, ctx, opacity);

					// Footer
					this.drawFooter(pt, vm, ctx, opacity);
				}
			},

			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @returns {Boolean} true if the tooltip changed
			 */
			handleEvent: function(e) {
				var me &#x3D; this;
				var options &#x3D; me._options;
				var changed &#x3D; false;

				me._lastActive &#x3D; me._lastActive || [];

				// Find Active Elements for tooltips
				if (e.type &#x3D;&#x3D;&#x3D; &#x27;mouseout&#x27;) {
					me._active &#x3D; [];
				} else {
					me._active &#x3D; me._chart.getElementsAtEventForMode(e, options.mode, options);
				}

				// Remember Last Actives
				changed &#x3D; !helpers.arrayEquals(me._active, me._lastActive);

				// Only handle target event on tooltip change
				if (changed) {
					me._lastActive &#x3D; me._active;

					if (options.enabled || options.custom) {
						me._eventPosition &#x3D; {
							x: e.x,
							y: e.y
						};

						me.update(true);
						me.pivot();
					}
				}

				return changed;
			}
		});

		/**
		 * @namespace Chart.Tooltip.positioners
		 */
		Chart.Tooltip.positioners &#x3D; {
			/**
			 * Average mode places the tooltip at the average position of the elements shown
			 * @function Chart.Tooltip.positioners.average
			 * @param elements {ChartElement[]} the elements being displayed in the tooltip
			 * @returns {Point} tooltip position
			 */
			average: function(elements) {
				if (!elements.length) {
					return false;
				}

				var i, len;
				var x &#x3D; 0;
				var y &#x3D; 0;
				var count &#x3D; 0;

				for (i &#x3D; 0, len &#x3D; elements.length; i &lt; len; ++i) {
					var el &#x3D; elements[i];
					if (el &amp;&amp; el.hasValue()) {
						var pos &#x3D; el.tooltipPosition();
						x +&#x3D; pos.x;
						y +&#x3D; pos.y;
						++count;
					}
				}

				return {
					x: Math.round(x / count),
					y: Math.round(y / count)
				};
			},

			/**
			 * Gets the tooltip position nearest of the item nearest to the event position
			 * @function Chart.Tooltip.positioners.nearest
			 * @param elements {Chart.Element[]} the tooltip elements
			 * @param eventPosition {Point} the position of the event in canvas coordinates
			 * @returns {Point} the tooltip position
			 */
			nearest: function(elements, eventPosition) {
				var x &#x3D; eventPosition.x;
				var y &#x3D; eventPosition.y;
				var minDistance &#x3D; Number.POSITIVE_INFINITY;
				var i, len, nearestElement;

				for (i &#x3D; 0, len &#x3D; elements.length; i &lt; len; ++i) {
					var el &#x3D; elements[i];
					if (el &amp;&amp; el.hasValue()) {
						var center &#x3D; el.getCenterPoint();
						var d &#x3D; helpers.distanceBetweenPoints(eventPosition, center);

						if (d &lt; minDistance) {
							minDistance &#x3D; d;
							nearestElement &#x3D; el;
						}
					}
				}

				if (nearestElement) {
					var tp &#x3D; nearestElement.tooltipPosition();
					x &#x3D; tp.x;
					y &#x3D; tp.y;
				}

				return {
					x: x,
					y: y
				};
			}
		};
	};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);

	/**
	 * Generate a set of linear ticks
	 * @param generationOptions the options used to generate the ticks
	 * @param dataRange the range of the data
	 * @returns {Array&lt;Number&gt;} array of tick values
	 */
	function generateTicks(generationOptions, dataRange) {
		var ticks &#x3D; [];
		// To get a &quot;nice&quot; value for the tick spacing, we will use the appropriately named
		// &quot;nice number&quot; algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
		// for details.

		var spacing;
		if (generationOptions.stepSize &amp;&amp; generationOptions.stepSize &gt; 0) {
			spacing &#x3D; generationOptions.stepSize;
		} else {
			var niceRange &#x3D; helpers.niceNum(dataRange.max - dataRange.min, false);
			spacing &#x3D; helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
		}
		var niceMin &#x3D; Math.floor(dataRange.min / spacing) * spacing;
		var niceMax &#x3D; Math.ceil(dataRange.max / spacing) * spacing;

		// If min, max and stepSize is set and they make an evenly spaced scale use it.
		if (generationOptions.min &amp;&amp; generationOptions.max &amp;&amp; generationOptions.stepSize) {
			// If very close to our whole number, use it.
			if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
				niceMin &#x3D; generationOptions.min;
				niceMax &#x3D; generationOptions.max;
			}
		}

		var numSpaces &#x3D; (niceMax - niceMin) / spacing;
		// If very close to our rounded value, use it.
		if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
			numSpaces &#x3D; Math.round(numSpaces);
		} else {
			numSpaces &#x3D; Math.ceil(numSpaces);
		}

		var precision &#x3D; 1;
		if (spacing &lt; 1) {
			precision &#x3D; Math.pow(10, spacing.toString().length - 2);
			niceMin &#x3D; Math.round(niceMin * precision) / precision;
			niceMax &#x3D; Math.round(niceMax * precision) / precision;
		}
		ticks.push(generationOptions.min !&#x3D;&#x3D; undefined ? generationOptions.min : niceMin);
		for (var j &#x3D; 1; j &lt; numSpaces; ++j) {
			ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);
		}
		ticks.push(generationOptions.max !&#x3D;&#x3D; undefined ? generationOptions.max : niceMax);

		return ticks;
	}


	module.exports &#x3D; function(Chart) {

		var noop &#x3D; helpers.noop;

		Chart.LinearScaleBase &#x3D; Chart.Scale.extend({
			getRightValue: function(value) {
				if (typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
					return +value;
				}
				return Chart.Scale.prototype.getRightValue.call(this, value);
			},

			handleTickRangeOptions: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var tickOpts &#x3D; opts.ticks;

				// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
				// do nothing since that would make the chart weird. If the user really wants a weird chart
				// axis, they can manually override it
				if (tickOpts.beginAtZero) {
					var minSign &#x3D; helpers.sign(me.min);
					var maxSign &#x3D; helpers.sign(me.max);

					if (minSign &lt; 0 &amp;&amp; maxSign &lt; 0) {
						// move the top up to 0
						me.max &#x3D; 0;
					} else if (minSign &gt; 0 &amp;&amp; maxSign &gt; 0) {
						// move the bottom down to 0
						me.min &#x3D; 0;
					}
				}

				var setMin &#x3D; tickOpts.min !&#x3D;&#x3D; undefined || tickOpts.suggestedMin !&#x3D;&#x3D; undefined;
				var setMax &#x3D; tickOpts.max !&#x3D;&#x3D; undefined || tickOpts.suggestedMax !&#x3D;&#x3D; undefined;

				if (tickOpts.min !&#x3D;&#x3D; undefined) {
					me.min &#x3D; tickOpts.min;
				} else if (tickOpts.suggestedMin !&#x3D;&#x3D; undefined) {
					if (me.min &#x3D;&#x3D;&#x3D; null) {
						me.min &#x3D; tickOpts.suggestedMin;
					} else {
						me.min &#x3D; Math.min(me.min, tickOpts.suggestedMin);
					}
				}

				if (tickOpts.max !&#x3D;&#x3D; undefined) {
					me.max &#x3D; tickOpts.max;
				} else if (tickOpts.suggestedMax !&#x3D;&#x3D; undefined) {
					if (me.max &#x3D;&#x3D;&#x3D; null) {
						me.max &#x3D; tickOpts.suggestedMax;
					} else {
						me.max &#x3D; Math.max(me.max, tickOpts.suggestedMax);
					}
				}

				if (setMin !&#x3D;&#x3D; setMax) {
					// We set the min or the max but not both.
					// So ensure that our range is good
					// Inverted or 0 length range can happen when
					// ticks.min is set, and no datasets are visible
					if (me.min &gt;&#x3D; me.max) {
						if (setMin) {
							me.max &#x3D; me.min + 1;
						} else {
							me.min &#x3D; me.max - 1;
						}
					}
				}

				if (me.min &#x3D;&#x3D;&#x3D; me.max) {
					me.max++;

					if (!tickOpts.beginAtZero) {
						me.min--;
					}
				}
			},
			getTickLimit: noop,
			handleDirectionalChanges: noop,

			buildTicks: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var tickOpts &#x3D; opts.ticks;

				// Figure out what the max number of ticks we can support it is based on the size of
				// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
				// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
				// the graph. Make sure we always have at least 2 ticks
				var maxTicks &#x3D; me.getTickLimit();
				maxTicks &#x3D; Math.max(2, maxTicks);

				var numericGeneratorOptions &#x3D; {
					maxTicks: maxTicks,
					min: tickOpts.min,
					max: tickOpts.max,
					stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
				};
				var ticks &#x3D; me.ticks &#x3D; generateTicks(numericGeneratorOptions, me);

				me.handleDirectionalChanges();

				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max &#x3D; helpers.max(ticks);
				me.min &#x3D; helpers.min(ticks);

				if (tickOpts.reverse) {
					ticks.reverse();

					me.start &#x3D; me.max;
					me.end &#x3D; me.min;
				} else {
					me.start &#x3D; me.min;
					me.end &#x3D; me.max;
				}
			},
			convertTicksToLabels: function() {
				var me &#x3D; this;
				me.ticksAsNumbers &#x3D; me.ticks.slice();
				me.zeroLineIndex &#x3D; me.ticks.indexOf(0);

				Chart.Scale.prototype.convertTicksToLabels.call(me);
			}
		});
	};


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {

		// Default config for a category scale
		var defaultConfig &#x3D; {
			position: &#x27;bottom&#x27;
		};

		var DatasetScale &#x3D; Chart.Scale.extend({
			/**
			* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
			* else fall back to data.labels
			* @private
			*/
			getLabels: function() {
				var data &#x3D; this.chart.data;
				return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
			},

			determineDataLimits: function() {
				var me &#x3D; this;
				var labels &#x3D; me.getLabels();
				me.minIndex &#x3D; 0;
				me.maxIndex &#x3D; labels.length - 1;
				var findIndex;

				if (me.options.ticks.min !&#x3D;&#x3D; undefined) {
					// user specified min value
					findIndex &#x3D; labels.indexOf(me.options.ticks.min);
					me.minIndex &#x3D; findIndex !&#x3D;&#x3D; -1 ? findIndex : me.minIndex;
				}

				if (me.options.ticks.max !&#x3D;&#x3D; undefined) {
					// user specified max value
					findIndex &#x3D; labels.indexOf(me.options.ticks.max);
					me.maxIndex &#x3D; findIndex !&#x3D;&#x3D; -1 ? findIndex : me.maxIndex;
				}

				me.min &#x3D; labels[me.minIndex];
				me.max &#x3D; labels[me.maxIndex];
			},

			buildTicks: function() {
				var me &#x3D; this;
				var labels &#x3D; me.getLabels();
				// If we are viewing some subset of labels, slice the original array
				me.ticks &#x3D; (me.minIndex &#x3D;&#x3D;&#x3D; 0 &amp;&amp; me.maxIndex &#x3D;&#x3D;&#x3D; labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
			},

			getLabelForIndex: function(index, datasetIndex) {
				var me &#x3D; this;
				var data &#x3D; me.chart.data;
				var isHorizontal &#x3D; me.isHorizontal();

				if (data.yLabels &amp;&amp; !isHorizontal) {
					return me.getRightValue(data.datasets[datasetIndex].data[index]);
				}
				return me.ticks[index - me.minIndex];
			},

			// Used to get data value locations.  Value can either be an index or a numerical value
			getPixelForValue: function(value, index) {
				var me &#x3D; this;
				var offset &#x3D; me.options.offset;
				// 1 is added because we need the length but we have the indexes
				var offsetAmt &#x3D; Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);

				// If value is a data object, then index is the index in the data array,
				// not the index of the scale. We need to change that.
				var valueCategory;
				if (value !&#x3D;&#x3D; undefined &amp;&amp; value !&#x3D;&#x3D; null) {
					valueCategory &#x3D; me.isHorizontal() ? value.x : value.y;
				}
				if (valueCategory !&#x3D;&#x3D; undefined || (value !&#x3D;&#x3D; undefined &amp;&amp; isNaN(index))) {
					var labels &#x3D; me.getLabels();
					value &#x3D; valueCategory || value;
					var idx &#x3D; labels.indexOf(value);
					index &#x3D; idx !&#x3D;&#x3D; -1 ? idx : index;
				}

				if (me.isHorizontal()) {
					var valueWidth &#x3D; me.width / offsetAmt;
					var widthOffset &#x3D; (valueWidth * (index - me.minIndex));

					if (offset) {
						widthOffset +&#x3D; (valueWidth / 2);
					}

					return me.left + Math.round(widthOffset);
				}
				var valueHeight &#x3D; me.height / offsetAmt;
				var heightOffset &#x3D; (valueHeight * (index - me.minIndex));

				if (offset) {
					heightOffset +&#x3D; (valueHeight / 2);
				}

				return me.top + Math.round(heightOffset);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
			},
			getValueForPixel: function(pixel) {
				var me &#x3D; this;
				var offset &#x3D; me.options.offset;
				var value;
				var offsetAmt &#x3D; Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
				var horz &#x3D; me.isHorizontal();
				var valueDimension &#x3D; (horz ? me.width : me.height) / offsetAmt;

				pixel -&#x3D; horz ? me.left : me.top;

				if (offset) {
					pixel -&#x3D; (valueDimension / 2);
				}

				if (pixel &lt;&#x3D; 0) {
					value &#x3D; 0;
				} else {
					value &#x3D; Math.round(pixel / valueDimension);
				}

				return value + me.minIndex;
			},
			getBasePixel: function() {
				return this.bottom;
			}
		});

		Chart.scaleService.registerScaleType(&#x27;category&#x27;, DatasetScale, defaultConfig);

	};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var helpers &#x3D; __webpack_require__(36);
	var Ticks &#x3D; __webpack_require__(59);

	module.exports &#x3D; function(Chart) {

		var defaultConfig &#x3D; {
			position: &#x27;left&#x27;,
			ticks: {
				callback: Ticks.formatters.linear
			}
		};

		var LinearScale &#x3D; Chart.LinearScaleBase.extend({

			determineDataLimits: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var chart &#x3D; me.chart;
				var data &#x3D; chart.data;
				var datasets &#x3D; data.datasets;
				var isHorizontal &#x3D; me.isHorizontal();
				var DEFAULT_MIN &#x3D; 0;
				var DEFAULT_MAX &#x3D; 1;

				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID &#x3D;&#x3D;&#x3D; me.id : meta.yAxisID &#x3D;&#x3D;&#x3D; me.id;
				}

				// First Calculate the range
				me.min &#x3D; null;
				me.max &#x3D; null;

				var hasStacks &#x3D; opts.stacked;
				if (hasStacks &#x3D;&#x3D;&#x3D; undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}

						var meta &#x3D; chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta) &amp;&amp;
							meta.stack !&#x3D;&#x3D; undefined) {
							hasStacks &#x3D; true;
						}
					});
				}

				if (opts.stacked || hasStacks) {
					var valuesPerStack &#x3D; {};

					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta &#x3D; chart.getDatasetMeta(datasetIndex);
						var key &#x3D; [
							meta.type,
							// we have a separate stack for stack&#x3D;undefined datasets when the opts.stacked is undefined
							((opts.stacked &#x3D;&#x3D;&#x3D; undefined &amp;&amp; meta.stack &#x3D;&#x3D;&#x3D; undefined) ? datasetIndex : &#x27;&#x27;),
							meta.stack
						].join(&#x27;.&#x27;);

						if (valuesPerStack[key] &#x3D;&#x3D;&#x3D; undefined) {
							valuesPerStack[key] &#x3D; {
								positiveValues: [],
								negativeValues: []
							};
						}

						// Store these per type
						var positiveValues &#x3D; valuesPerStack[key].positiveValues;
						var negativeValues &#x3D; valuesPerStack[key].negativeValues;

						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value &#x3D; +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								positiveValues[index] &#x3D; positiveValues[index] || 0;
								negativeValues[index] &#x3D; negativeValues[index] || 0;

								if (opts.relativePoints) {
									positiveValues[index] &#x3D; 100;
								} else if (value &lt; 0) {
									negativeValues[index] +&#x3D; value;
								} else {
									positiveValues[index] +&#x3D; value;
								}
							});
						}
					});

					helpers.each(valuesPerStack, function(valuesForType) {
						var values &#x3D; valuesForType.positiveValues.concat(valuesForType.negativeValues);
						var minVal &#x3D; helpers.min(values);
						var maxVal &#x3D; helpers.max(values);
						me.min &#x3D; me.min &#x3D;&#x3D;&#x3D; null ? minVal : Math.min(me.min, minVal);
						me.max &#x3D; me.max &#x3D;&#x3D;&#x3D; null ? maxVal : Math.max(me.max, maxVal);
					});

				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta &#x3D; chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value &#x3D; +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								if (me.min &#x3D;&#x3D;&#x3D; null) {
									me.min &#x3D; value;
								} else if (value &lt; me.min) {
									me.min &#x3D; value;
								}

								if (me.max &#x3D;&#x3D;&#x3D; null) {
									me.max &#x3D; value;
								} else if (value &gt; me.max) {
									me.max &#x3D; value;
								}
							});
						}
					});
				}

				me.min &#x3D; isFinite(me.min) &amp;&amp; !isNaN(me.min) ? me.min : DEFAULT_MIN;
				me.max &#x3D; isFinite(me.max) &amp;&amp; !isNaN(me.max) ? me.max : DEFAULT_MAX;

				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				this.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var maxTicks;
				var me &#x3D; this;
				var tickOpts &#x3D; me.options.ticks;

				if (me.isHorizontal()) {
					maxTicks &#x3D; Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
				} else {
					// The factor of 2 used to scale the font size has been experimentally determined.
					var tickFontSize &#x3D; helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
					maxTicks &#x3D; Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
				}

				return maxTicks;
			},
			// Called after the ticks are built. We need
			handleDirectionalChanges: function() {
				if (!this.isHorizontal()) {
					// We are in a vertical orientation. The top value is the highest. So reverse the array
					this.ticks.reverse();
				}
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			// Utils
			getPixelForValue: function(value) {
				// This must be called after fit has been run so that
				// this.left, this.top, this.right, and this.bottom have been defined
				var me &#x3D; this;
				var start &#x3D; me.start;

				var rightValue &#x3D; +me.getRightValue(value);
				var pixel;
				var range &#x3D; me.end - start;

				if (me.isHorizontal()) {
					pixel &#x3D; me.left + (me.width / range * (rightValue - start));
				} else {
					pixel &#x3D; me.bottom - (me.height / range * (rightValue - start));
				}
				return pixel;
			},
			getValueForPixel: function(pixel) {
				var me &#x3D; this;
				var isHorizontal &#x3D; me.isHorizontal();
				var innerDimension &#x3D; isHorizontal ? me.width : me.height;
				var offset &#x3D; (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
				return me.start + ((me.end - me.start) * offset);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.ticksAsNumbers[index]);
			}
		});
		Chart.scaleService.registerScaleType(&#x27;linear&#x27;, LinearScale, defaultConfig);

	};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var helpers &#x3D; __webpack_require__(36);
	var Ticks &#x3D; __webpack_require__(59);

	/**
	 * Generate a set of logarithmic ticks
	 * @param generationOptions the options used to generate the ticks
	 * @param dataRange the range of the data
	 * @returns {Array&lt;Number&gt;} array of tick values
	 */
	function generateTicks(generationOptions, dataRange) {
		var ticks &#x3D; [];
		var valueOrDefault &#x3D; helpers.valueOrDefault;

		// Figure out what the max number of ticks we can support it is based on the size of
		// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
		// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
		// the graph
		var tickVal &#x3D; valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

		var endExp &#x3D; Math.floor(helpers.log10(dataRange.max));
		var endSignificand &#x3D; Math.ceil(dataRange.max / Math.pow(10, endExp));
		var exp, significand;

		if (tickVal &#x3D;&#x3D;&#x3D; 0) {
			exp &#x3D; Math.floor(helpers.log10(dataRange.minNotZero));
			significand &#x3D; Math.floor(dataRange.minNotZero / Math.pow(10, exp));

			ticks.push(tickVal);
			tickVal &#x3D; significand * Math.pow(10, exp);
		} else {
			exp &#x3D; Math.floor(helpers.log10(tickVal));
			significand &#x3D; Math.floor(tickVal / Math.pow(10, exp));
		}
		var precision &#x3D; exp &lt; 0 ? Math.pow(10, Math.abs(exp)) : 1;

		do {
			ticks.push(tickVal);

			++significand;
			if (significand &#x3D;&#x3D;&#x3D; 10) {
				significand &#x3D; 1;
				++exp;
				precision &#x3D; exp &gt;&#x3D; 0 ? 1 : precision;
			}

			tickVal &#x3D; Math.round(significand * Math.pow(10, exp) * precision) / precision;
		} while (exp &lt; endExp || (exp &#x3D;&#x3D;&#x3D; endExp &amp;&amp; significand &lt; endSignificand));

		var lastTick &#x3D; valueOrDefault(generationOptions.max, tickVal);
		ticks.push(lastTick);

		return ticks;
	}


	module.exports &#x3D; function(Chart) {

		var defaultConfig &#x3D; {
			position: &#x27;left&#x27;,

			// label settings
			ticks: {
				callback: Ticks.formatters.logarithmic
			}
		};

		var LogarithmicScale &#x3D; Chart.Scale.extend({
			determineDataLimits: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var chart &#x3D; me.chart;
				var data &#x3D; chart.data;
				var datasets &#x3D; data.datasets;
				var isHorizontal &#x3D; me.isHorizontal();
				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID &#x3D;&#x3D;&#x3D; me.id : meta.yAxisID &#x3D;&#x3D;&#x3D; me.id;
				}

				// Calculate Range
				me.min &#x3D; null;
				me.max &#x3D; null;
				me.minNotZero &#x3D; null;

				var hasStacks &#x3D; opts.stacked;
				if (hasStacks &#x3D;&#x3D;&#x3D; undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}

						var meta &#x3D; chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta) &amp;&amp;
							meta.stack !&#x3D;&#x3D; undefined) {
							hasStacks &#x3D; true;
						}
					});
				}

				if (opts.stacked || hasStacks) {
					var valuesPerStack &#x3D; {};

					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta &#x3D; chart.getDatasetMeta(datasetIndex);
						var key &#x3D; [
							meta.type,
							// we have a separate stack for stack&#x3D;undefined datasets when the opts.stacked is undefined
							((opts.stacked &#x3D;&#x3D;&#x3D; undefined &amp;&amp; meta.stack &#x3D;&#x3D;&#x3D; undefined) ? datasetIndex : &#x27;&#x27;),
							meta.stack
						].join(&#x27;.&#x27;);

						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							if (valuesPerStack[key] &#x3D;&#x3D;&#x3D; undefined) {
								valuesPerStack[key] &#x3D; [];
							}

							helpers.each(dataset.data, function(rawValue, index) {
								var values &#x3D; valuesPerStack[key];
								var value &#x3D; +me.getRightValue(rawValue);
								// invalid, hidden and negative values are ignored
								if (isNaN(value) || meta.data[index].hidden || value &lt; 0) {
									return;
								}
								values[index] &#x3D; values[index] || 0;
								values[index] +&#x3D; value;
							});
						}
					});

					helpers.each(valuesPerStack, function(valuesForType) {
						if (valuesForType.length &gt; 0) {
							var minVal &#x3D; helpers.min(valuesForType);
							var maxVal &#x3D; helpers.max(valuesForType);
							me.min &#x3D; me.min &#x3D;&#x3D;&#x3D; null ? minVal : Math.min(me.min, minVal);
							me.max &#x3D; me.max &#x3D;&#x3D;&#x3D; null ? maxVal : Math.max(me.max, maxVal);
						}
					});

				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta &#x3D; chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value &#x3D; +me.getRightValue(rawValue);
								// invalid, hidden and negative values are ignored
								if (isNaN(value) || meta.data[index].hidden || value &lt; 0) {
									return;
								}

								if (me.min &#x3D;&#x3D;&#x3D; null) {
									me.min &#x3D; value;
								} else if (value &lt; me.min) {
									me.min &#x3D; value;
								}

								if (me.max &#x3D;&#x3D;&#x3D; null) {
									me.max &#x3D; value;
								} else if (value &gt; me.max) {
									me.max &#x3D; value;
								}

								if (value !&#x3D;&#x3D; 0 &amp;&amp; (me.minNotZero &#x3D;&#x3D;&#x3D; null || value &lt; me.minNotZero)) {
									me.minNotZero &#x3D; value;
								}
							});
						}
					});
				}

				// Common base implementation to handle ticks.min, ticks.max
				this.handleTickRangeOptions();
			},
			handleTickRangeOptions: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var tickOpts &#x3D; opts.ticks;
				var valueOrDefault &#x3D; helpers.valueOrDefault;
				var DEFAULT_MIN &#x3D; 1;
				var DEFAULT_MAX &#x3D; 10;

				me.min &#x3D; valueOrDefault(tickOpts.min, me.min);
				me.max &#x3D; valueOrDefault(tickOpts.max, me.max);

				if (me.min &#x3D;&#x3D;&#x3D; me.max) {
					if (me.min !&#x3D;&#x3D; 0 &amp;&amp; me.min !&#x3D;&#x3D; null) {
						me.min &#x3D; Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
						me.max &#x3D; Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
					} else {
						me.min &#x3D; DEFAULT_MIN;
						me.max &#x3D; DEFAULT_MAX;
					}
				}
				if (me.min &#x3D;&#x3D;&#x3D; null) {
					me.min &#x3D; Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);
				}
				if (me.max &#x3D;&#x3D;&#x3D; null) {
					me.max &#x3D; me.min !&#x3D;&#x3D; 0
						? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)
						: DEFAULT_MAX;
				}
				if (me.minNotZero &#x3D;&#x3D;&#x3D; null) {
					if (me.min &gt; 0) {
						me.minNotZero &#x3D; me.min;
					} else if (me.max &lt; 1) {
						me.minNotZero &#x3D; Math.pow(10, Math.floor(helpers.log10(me.max)));
					} else {
						me.minNotZero &#x3D; DEFAULT_MIN;
					}
				}
			},
			buildTicks: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var tickOpts &#x3D; opts.ticks;
				var reverse &#x3D; !me.isHorizontal();

				var generationOptions &#x3D; {
					min: tickOpts.min,
					max: tickOpts.max
				};
				var ticks &#x3D; me.ticks &#x3D; generateTicks(generationOptions, me);

				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max &#x3D; helpers.max(ticks);
				me.min &#x3D; helpers.min(ticks);

				if (tickOpts.reverse) {
					reverse &#x3D; !reverse;
					me.start &#x3D; me.max;
					me.end &#x3D; me.min;
				} else {
					me.start &#x3D; me.min;
					me.end &#x3D; me.max;
				}
				if (reverse) {
					ticks.reverse();
				}
			},
			convertTicksToLabels: function() {
				this.tickValues &#x3D; this.ticks.slice();

				Chart.Scale.prototype.convertTicksToLabels.call(this);
			},
			// Get the correct tooltip label
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.tickValues[index]);
			},
			/**
			 * Returns the value of the first tick.
			 * @param {Number} value - The minimum not zero value.
			 * @return {Number} The first tick value.
			 * @private
			 */
			_getFirstTickValue: function(value) {
				var exp &#x3D; Math.floor(helpers.log10(value));
				var significand &#x3D; Math.floor(value / Math.pow(10, exp));

				return significand * Math.pow(10, exp);
			},
			getPixelForValue: function(value) {
				var me &#x3D; this;
				var reverse &#x3D; me.options.ticks.reverse;
				var log10 &#x3D; helpers.log10;
				var firstTickValue &#x3D; me._getFirstTickValue(me.minNotZero);
				var offset &#x3D; 0;
				var innerDimension, pixel, start, end, sign;

				value &#x3D; +me.getRightValue(value);
				if (reverse) {
					start &#x3D; me.end;
					end &#x3D; me.start;
					sign &#x3D; -1;
				} else {
					start &#x3D; me.start;
					end &#x3D; me.end;
					sign &#x3D; 1;
				}
				if (me.isHorizontal()) {
					innerDimension &#x3D; me.width;
					pixel &#x3D; reverse ? me.right : me.left;
				} else {
					innerDimension &#x3D; me.height;
					sign *&#x3D; -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
					pixel &#x3D; reverse ? me.top : me.bottom;
				}
				if (value !&#x3D;&#x3D; start) {
					if (start &#x3D;&#x3D;&#x3D; 0) { // include zero tick
						offset &#x3D; helpers.getValueOrDefault(
							me.options.ticks.fontSize,
							Chart.defaults.global.defaultFontSize
						);
						innerDimension -&#x3D; offset;
						start &#x3D; firstTickValue;
					}
					if (value !&#x3D;&#x3D; 0) {
						offset +&#x3D; innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
					}
					pixel +&#x3D; sign * offset;
				}
				return pixel;
			},
			getValueForPixel: function(pixel) {
				var me &#x3D; this;
				var reverse &#x3D; me.options.ticks.reverse;
				var log10 &#x3D; helpers.log10;
				var firstTickValue &#x3D; me._getFirstTickValue(me.minNotZero);
				var innerDimension, start, end, value;

				if (reverse) {
					start &#x3D; me.end;
					end &#x3D; me.start;
				} else {
					start &#x3D; me.start;
					end &#x3D; me.end;
				}
				if (me.isHorizontal()) {
					innerDimension &#x3D; me.width;
					value &#x3D; reverse ? me.right - pixel : pixel - me.left;
				} else {
					innerDimension &#x3D; me.height;
					value &#x3D; reverse ? pixel - me.top : me.bottom - pixel;
				}
				if (value !&#x3D;&#x3D; start) {
					if (start &#x3D;&#x3D;&#x3D; 0) { // include zero tick
						var offset &#x3D; helpers.getValueOrDefault(
							me.options.ticks.fontSize,
							Chart.defaults.global.defaultFontSize
						);
						value -&#x3D; offset;
						innerDimension -&#x3D; offset;
						start &#x3D; firstTickValue;
					}
					value *&#x3D; log10(end) - log10(start);
					value /&#x3D; innerDimension;
					value &#x3D; Math.pow(10, log10(start) + value);
				}
				return value;
			}
		});
		Chart.scaleService.registerScaleType(&#x27;logarithmic&#x27;, LogarithmicScale, defaultConfig);

	};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var helpers &#x3D; __webpack_require__(36);
	var Ticks &#x3D; __webpack_require__(59);

	module.exports &#x3D; function(Chart) {

		var globalDefaults &#x3D; defaults.global;

		var defaultConfig &#x3D; {
			display: true,

			// Boolean - Whether to animate scaling the chart from the centre
			animate: true,
			position: &#x27;chartArea&#x27;,

			angleLines: {
				display: true,
				color: &#x27;rgba(0, 0, 0, 0.1)&#x27;,
				lineWidth: 1
			},

			gridLines: {
				circular: false
			},

			// label settings
			ticks: {
				// Boolean - Show a backdrop to the scale label
				showLabelBackdrop: true,

				// String - The colour of the label backdrop
				backdropColor: &#x27;rgba(255,255,255,0.75)&#x27;,

				// Number - The backdrop padding above &amp; below the label in pixels
				backdropPaddingY: 2,

				// Number - The backdrop padding to the side of the label in pixels
				backdropPaddingX: 2,

				callback: Ticks.formatters.linear
			},

			pointLabels: {
				// Boolean - if true, show point labels
				display: true,

				// Number - Point label font size in pixels
				fontSize: 10,

				// Function - Used to convert point labels
				callback: function(label) {
					return label;
				}
			}
		};

		function getValueCount(scale) {
			var opts &#x3D; scale.options;
			return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
		}

		function getPointLabelFontOptions(scale) {
			var pointLabelOptions &#x3D; scale.options.pointLabels;
			var fontSize &#x3D; helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
			var fontStyle &#x3D; helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
			var fontFamily &#x3D; helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
			var font &#x3D; helpers.fontString(fontSize, fontStyle, fontFamily);

			return {
				size: fontSize,
				style: fontStyle,
				family: fontFamily,
				font: font
			};
		}

		function measureLabelSize(ctx, fontSize, label) {
			if (helpers.isArray(label)) {
				return {
					w: helpers.longestText(ctx, ctx.font, label),
					h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
				};
			}

			return {
				w: ctx.measureText(label).width,
				h: fontSize
			};
		}

		function determineLimits(angle, pos, size, min, max) {
			if (angle &#x3D;&#x3D;&#x3D; min || angle &#x3D;&#x3D;&#x3D; max) {
				return {
					start: pos - (size / 2),
					end: pos + (size / 2)
				};
			} else if (angle &lt; min || angle &gt; max) {
				return {
					start: pos - size - 5,
					end: pos
				};
			}

			return {
				start: pos,
				end: pos + size + 5
			};
		}

		/**
		 * Helper function to fit a radial linear scale with point labels
		 */
		function fitWithPointLabels(scale) {
			/*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
			 *
			 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
			 */

			var plFont &#x3D; getPointLabelFontOptions(scale);

			// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
			// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
			var largestPossibleRadius &#x3D; Math.min(scale.height / 2, scale.width / 2);
			var furthestLimits &#x3D; {
				r: scale.width,
				l: 0,
				t: scale.height,
				b: 0
			};
			var furthestAngles &#x3D; {};
			var i, textSize, pointPosition;

			scale.ctx.font &#x3D; plFont.font;
			scale._pointLabelSizes &#x3D; [];

			var valueCount &#x3D; getValueCount(scale);
			for (i &#x3D; 0; i &lt; valueCount; i++) {
				pointPosition &#x3D; scale.getPointPosition(i, largestPossibleRadius);
				textSize &#x3D; measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || &#x27;&#x27;);
				scale._pointLabelSizes[i] &#x3D; textSize;

				// Add quarter circle to make degree 0 mean top of circle
				var angleRadians &#x3D; scale.getIndexAngle(i);
				var angle &#x3D; helpers.toDegrees(angleRadians) % 360;
				var hLimits &#x3D; determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
				var vLimits &#x3D; determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

				if (hLimits.start &lt; furthestLimits.l) {
					furthestLimits.l &#x3D; hLimits.start;
					furthestAngles.l &#x3D; angleRadians;
				}

				if (hLimits.end &gt; furthestLimits.r) {
					furthestLimits.r &#x3D; hLimits.end;
					furthestAngles.r &#x3D; angleRadians;
				}

				if (vLimits.start &lt; furthestLimits.t) {
					furthestLimits.t &#x3D; vLimits.start;
					furthestAngles.t &#x3D; angleRadians;
				}

				if (vLimits.end &gt; furthestLimits.b) {
					furthestLimits.b &#x3D; vLimits.end;
					furthestAngles.b &#x3D; angleRadians;
				}
			}

			scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
		}

		/**
		 * Helper function to fit a radial linear scale with no point labels
		 */
		function fit(scale) {
			var largestPossibleRadius &#x3D; Math.min(scale.height / 2, scale.width / 2);
			scale.drawingArea &#x3D; Math.round(largestPossibleRadius);
			scale.setCenterPoint(0, 0, 0, 0);
		}

		function getTextAlignForAngle(angle) {
			if (angle &#x3D;&#x3D;&#x3D; 0 || angle &#x3D;&#x3D;&#x3D; 180) {
				return &#x27;center&#x27;;
			} else if (angle &lt; 180) {
				return &#x27;left&#x27;;
			}

			return &#x27;right&#x27;;
		}

		function fillText(ctx, text, position, fontSize) {
			if (helpers.isArray(text)) {
				var y &#x3D; position.y;
				var spacing &#x3D; 1.5 * fontSize;

				for (var i &#x3D; 0; i &lt; text.length; ++i) {
					ctx.fillText(text[i], position.x, y);
					y +&#x3D; spacing;
				}
			} else {
				ctx.fillText(text, position.x, position.y);
			}
		}

		function adjustPointPositionForLabelHeight(angle, textSize, position) {
			if (angle &#x3D;&#x3D;&#x3D; 90 || angle &#x3D;&#x3D;&#x3D; 270) {
				position.y -&#x3D; (textSize.h / 2);
			} else if (angle &gt; 270 || angle &lt; 90) {
				position.y -&#x3D; textSize.h;
			}
		}

		function drawPointLabels(scale) {
			var ctx &#x3D; scale.ctx;
			var opts &#x3D; scale.options;
			var angleLineOpts &#x3D; opts.angleLines;
			var pointLabelOpts &#x3D; opts.pointLabels;

			ctx.lineWidth &#x3D; angleLineOpts.lineWidth;
			ctx.strokeStyle &#x3D; angleLineOpts.color;

			var outerDistance &#x3D; scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

			// Point Label Font
			var plFont &#x3D; getPointLabelFontOptions(scale);

			ctx.textBaseline &#x3D; &#x27;top&#x27;;

			for (var i &#x3D; getValueCount(scale) - 1; i &gt;&#x3D; 0; i--) {
				if (angleLineOpts.display) {
					var outerPosition &#x3D; scale.getPointPosition(i, outerDistance);
					ctx.beginPath();
					ctx.moveTo(scale.xCenter, scale.yCenter);
					ctx.lineTo(outerPosition.x, outerPosition.y);
					ctx.stroke();
					ctx.closePath();
				}

				if (pointLabelOpts.display) {
					// Extra 3px out for some label spacing
					var pointLabelPosition &#x3D; scale.getPointPosition(i, outerDistance + 5);

					// Keep this in loop since we may support array properties here
					var pointLabelFontColor &#x3D; helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
					ctx.font &#x3D; plFont.font;
					ctx.fillStyle &#x3D; pointLabelFontColor;

					var angleRadians &#x3D; scale.getIndexAngle(i);
					var angle &#x3D; helpers.toDegrees(angleRadians);
					ctx.textAlign &#x3D; getTextAlignForAngle(angle);
					adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
					fillText(ctx, scale.pointLabels[i] || &#x27;&#x27;, pointLabelPosition, plFont.size);
				}
			}
		}

		function drawRadiusLine(scale, gridLineOpts, radius, index) {
			var ctx &#x3D; scale.ctx;
			ctx.strokeStyle &#x3D; helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
			ctx.lineWidth &#x3D; helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

			if (scale.options.gridLines.circular) {
				// Draw circular arcs between the points
				ctx.beginPath();
				ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.stroke();
			} else {
				// Draw straight lines connecting each index
				var valueCount &#x3D; getValueCount(scale);

				if (valueCount &#x3D;&#x3D;&#x3D; 0) {
					return;
				}

				ctx.beginPath();
				var pointPosition &#x3D; scale.getPointPosition(0, radius);
				ctx.moveTo(pointPosition.x, pointPosition.y);

				for (var i &#x3D; 1; i &lt; valueCount; i++) {
					pointPosition &#x3D; scale.getPointPosition(i, radius);
					ctx.lineTo(pointPosition.x, pointPosition.y);
				}

				ctx.closePath();
				ctx.stroke();
			}
		}

		function numberOrZero(param) {
			return helpers.isNumber(param) ? param : 0;
		}

		var LinearRadialScale &#x3D; Chart.LinearScaleBase.extend({
			setDimensions: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var tickOpts &#x3D; opts.ticks;
				// Set the unconstrained dimension before label rotation
				me.width &#x3D; me.maxWidth;
				me.height &#x3D; me.maxHeight;
				me.xCenter &#x3D; Math.round(me.width / 2);
				me.yCenter &#x3D; Math.round(me.height / 2);

				var minSize &#x3D; helpers.min([me.height, me.width]);
				var tickFontSize &#x3D; helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				me.drawingArea &#x3D; opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
			},
			determineDataLimits: function() {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var min &#x3D; Number.POSITIVE_INFINITY;
				var max &#x3D; Number.NEGATIVE_INFINITY;

				helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
					if (chart.isDatasetVisible(datasetIndex)) {
						var meta &#x3D; chart.getDatasetMeta(datasetIndex);

						helpers.each(dataset.data, function(rawValue, index) {
							var value &#x3D; +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							min &#x3D; Math.min(value, min);
							max &#x3D; Math.max(value, max);
						});
					}
				});

				me.min &#x3D; (min &#x3D;&#x3D;&#x3D; Number.POSITIVE_INFINITY ? 0 : min);
				me.max &#x3D; (max &#x3D;&#x3D;&#x3D; Number.NEGATIVE_INFINITY ? 0 : max);

				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				me.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var tickOpts &#x3D; this.options.ticks;
				var tickFontSize &#x3D; helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
			},
			convertTicksToLabels: function() {
				var me &#x3D; this;

				Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

				// Point labels
				me.pointLabels &#x3D; me.chart.data.labels.map(me.options.pointLabels.callback, me);
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			fit: function() {
				if (this.options.pointLabels.display) {
					fitWithPointLabels(this);
				} else {
					fit(this);
				}
			},
			/**
			 * Set radius reductions and determine new radius and center point
			 * @private
			 */
			setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
				var me &#x3D; this;
				var radiusReductionLeft &#x3D; furthestLimits.l / Math.sin(furthestAngles.l);
				var radiusReductionRight &#x3D; Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
				var radiusReductionTop &#x3D; -furthestLimits.t / Math.cos(furthestAngles.t);
				var radiusReductionBottom &#x3D; -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

				radiusReductionLeft &#x3D; numberOrZero(radiusReductionLeft);
				radiusReductionRight &#x3D; numberOrZero(radiusReductionRight);
				radiusReductionTop &#x3D; numberOrZero(radiusReductionTop);
				radiusReductionBottom &#x3D; numberOrZero(radiusReductionBottom);

				me.drawingArea &#x3D; Math.min(
					Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
					Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
				me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
			},
			setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
				var me &#x3D; this;
				var maxRight &#x3D; me.width - rightMovement - me.drawingArea;
				var maxLeft &#x3D; leftMovement + me.drawingArea;
				var maxTop &#x3D; topMovement + me.drawingArea;
				var maxBottom &#x3D; me.height - bottomMovement - me.drawingArea;

				me.xCenter &#x3D; Math.round(((maxLeft + maxRight) / 2) + me.left);
				me.yCenter &#x3D; Math.round(((maxTop + maxBottom) / 2) + me.top);
			},

			getIndexAngle: function(index) {
				var angleMultiplier &#x3D; (Math.PI * 2) / getValueCount(this);
				var startAngle &#x3D; this.chart.options &amp;&amp; this.chart.options.startAngle ?
					this.chart.options.startAngle :
					0;

				var startAngleRadians &#x3D; startAngle * Math.PI * 2 / 360;

				// Start from the top instead of right, so remove a quarter of the circle
				return index * angleMultiplier + startAngleRadians;
			},
			getDistanceFromCenterForValue: function(value) {
				var me &#x3D; this;

				if (value &#x3D;&#x3D;&#x3D; null) {
					return 0; // null always in center
				}

				// Take into account half font size + the yPadding of the top value
				var scalingFactor &#x3D; me.drawingArea / (me.max - me.min);
				if (me.options.ticks.reverse) {
					return (me.max - value) * scalingFactor;
				}
				return (value - me.min) * scalingFactor;
			},
			getPointPosition: function(index, distanceFromCenter) {
				var me &#x3D; this;
				var thisAngle &#x3D; me.getIndexAngle(index) - (Math.PI / 2);
				return {
					x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
					y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
				};
			},
			getPointPositionForValue: function(index, value) {
				return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
			},

			getBasePosition: function() {
				var me &#x3D; this;
				var min &#x3D; me.min;
				var max &#x3D; me.max;

				return me.getPointPositionForValue(0,
					me.beginAtZero ? 0 :
					min &lt; 0 &amp;&amp; max &lt; 0 ? max :
					min &gt; 0 &amp;&amp; max &gt; 0 ? min :
					0);
			},

			draw: function() {
				var me &#x3D; this;
				var opts &#x3D; me.options;
				var gridLineOpts &#x3D; opts.gridLines;
				var tickOpts &#x3D; opts.ticks;
				var valueOrDefault &#x3D; helpers.valueOrDefault;

				if (opts.display) {
					var ctx &#x3D; me.ctx;
					var startAngle &#x3D; this.getIndexAngle(0);

					// Tick Font
					var tickFontSize &#x3D; valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
					var tickFontStyle &#x3D; valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
					var tickFontFamily &#x3D; valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
					var tickLabelFont &#x3D; helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

					helpers.each(me.ticks, function(label, index) {
						// Don&#x27;t draw a centre value (if it is minimum)
						if (index &gt; 0 || tickOpts.reverse) {
							var yCenterOffset &#x3D; me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

							// Draw circular lines around the scale
							if (gridLineOpts.display &amp;&amp; index !&#x3D;&#x3D; 0) {
								drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
							}

							if (tickOpts.display) {
								var tickFontColor &#x3D; valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
								ctx.font &#x3D; tickLabelFont;

								ctx.save();
								ctx.translate(me.xCenter, me.yCenter);
								ctx.rotate(startAngle);

								if (tickOpts.showLabelBackdrop) {
									var labelWidth &#x3D; ctx.measureText(label).width;
									ctx.fillStyle &#x3D; tickOpts.backdropColor;
									ctx.fillRect(
										-labelWidth / 2 - tickOpts.backdropPaddingX,
										-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
										labelWidth + tickOpts.backdropPaddingX * 2,
										tickFontSize + tickOpts.backdropPaddingY * 2
									);
								}

								ctx.textAlign &#x3D; &#x27;center&#x27;;
								ctx.textBaseline &#x3D; &#x27;middle&#x27;;
								ctx.fillStyle &#x3D; tickFontColor;
								ctx.fillText(label, 0, -yCenterOffset);
								ctx.restore();
							}
						}
					});

					if (opts.angleLines.display || opts.pointLabels.display) {
						drawPointLabels(me);
					}
				}
			}
		});
		Chart.scaleService.registerScaleType(&#x27;radialLinear&#x27;, LinearRadialScale, defaultConfig);

	};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	&#x27;use strict&#x27;;

	var moment &#x3D; __webpack_require__(72);
	moment &#x3D; typeof moment &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? moment : window.moment;

	var defaults &#x3D; __webpack_require__(35);
	var helpers &#x3D; __webpack_require__(36);

	// Integer constants are from the ES6 spec.
	var MIN_INTEGER &#x3D; Number.MIN_SAFE_INTEGER || -9007199254740991;
	var MAX_INTEGER &#x3D; Number.MAX_SAFE_INTEGER || 9007199254740991;

	var INTERVALS &#x3D; {
		millisecond: {
			common: true,
			size: 1,
			steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
		},
		second: {
			common: true,
			size: 1000,
			steps: [1, 2, 5, 10, 30]
		},
		minute: {
			common: true,
			size: 60000,
			steps: [1, 2, 5, 10, 30]
		},
		hour: {
			common: true,
			size: 3600000,
			steps: [1, 2, 3, 6, 12]
		},
		day: {
			common: true,
			size: 86400000,
			steps: [1, 2, 5]
		},
		week: {
			common: false,
			size: 604800000,
			steps: [1, 2, 3, 4]
		},
		month: {
			common: true,
			size: 2.628e9,
			steps: [1, 2, 3]
		},
		quarter: {
			common: false,
			size: 7.884e9,
			steps: [1, 2, 3, 4]
		},
		year: {
			common: true,
			size: 3.154e10
		}
	};

	var UNITS &#x3D; Object.keys(INTERVALS);

	function sorter(a, b) {
		return a - b;
	}

	function arrayUnique(items) {
		var hash &#x3D; {};
		var out &#x3D; [];
		var i, ilen, item;

		for (i &#x3D; 0, ilen &#x3D; items.length; i &lt; ilen; ++i) {
			item &#x3D; items[i];
			if (!hash[item]) {
				hash[item] &#x3D; true;
				out.push(item);
			}
		}

		return out;
	}

	/**
	 * Returns an array of {time, pos} objects used to interpolate a specific &#x60;time&#x60; or position
	 * (&#x60;pos&#x60;) on the scale, by searching entries before and after the requested value. &#x60;pos&#x60; is
	 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
	 * extremity (left + width or top + height). Note that it would be more optimized to directly
	 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
	 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
	 *
	 * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
	 * @param {String} distribution - If &#x27;linear&#x27;, timestamps will be spread linearly along the min
	 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
	 * If &#x27;series&#x27;, timestamps will be positioned at the same distance from each other. In this
	 * case, only timestamps that break the time linearity are registered, meaning that in the
	 * best case, all timestamps are linear, the table contains only min and max.
	 */
	function buildLookupTable(timestamps, min, max, distribution) {
		if (distribution &#x3D;&#x3D;&#x3D; &#x27;linear&#x27; || !timestamps.length) {
			return [
				{time: min, pos: 0},
				{time: max, pos: 1}
			];
		}

		var table &#x3D; [];
		var items &#x3D; [min];
		var i, ilen, prev, curr, next;

		for (i &#x3D; 0, ilen &#x3D; timestamps.length; i &lt; ilen; ++i) {
			curr &#x3D; timestamps[i];
			if (curr &gt; min &amp;&amp; curr &lt; max) {
				items.push(curr);
			}
		}

		items.push(max);

		for (i &#x3D; 0, ilen &#x3D; items.length; i &lt; ilen; ++i) {
			next &#x3D; items[i + 1];
			prev &#x3D; items[i - 1];
			curr &#x3D; items[i];

			// only add points that breaks the scale linearity
			if (prev &#x3D;&#x3D;&#x3D; undefined || next &#x3D;&#x3D;&#x3D; undefined || Math.round((next + prev) / 2) !&#x3D;&#x3D; curr) {
				table.push({time: curr, pos: i / (ilen - 1)});
			}
		}

		return table;
	}

	// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
	function lookup(table, key, value) {
		var lo &#x3D; 0;
		var hi &#x3D; table.length - 1;
		var mid, i0, i1;

		while (lo &gt;&#x3D; 0 &amp;&amp; lo &lt;&#x3D; hi) {
			mid &#x3D; (lo + hi) &gt;&gt; 1;
			i0 &#x3D; table[mid - 1] || null;
			i1 &#x3D; table[mid];

			if (!i0) {
				// given value is outside table (before first item)
				return {lo: null, hi: i1};
			} else if (i1[key] &lt; value) {
				lo &#x3D; mid + 1;
			} else if (i0[key] &gt; value) {
				hi &#x3D; mid - 1;
			} else {
				return {lo: i0, hi: i1};
			}
		}

		// given value is outside table (after last item)
		return {lo: i1, hi: null};
	}

	/**
	 * Linearly interpolates the given source &#x60;value&#x60; using the table items &#x60;skey&#x60; values and
	 * returns the associated &#x60;tkey&#x60; value. For example, interpolate(table, &#x27;time&#x27;, 42, &#x27;pos&#x27;)
	 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
	 * index [0, 1] or [n - 1, n] are used for the interpolation.
	 */
	function interpolate(table, skey, sval, tkey) {
		var range &#x3D; lookup(table, skey, sval);

		// Note: the lookup table ALWAYS contains at least 2 items (min and max)
		var prev &#x3D; !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
		var next &#x3D; !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

		var span &#x3D; next[skey] - prev[skey];
		var ratio &#x3D; span ? (sval - prev[skey]) / span : 0;
		var offset &#x3D; (next[tkey] - prev[tkey]) * ratio;

		return prev[tkey] + offset;
	}

	/**
	 * Convert the given value to a moment object using the given time options.
	 * @see http://momentjs.com/docs/#/parsing/
	 */
	function momentify(value, options) {
		var parser &#x3D; options.parser;
		var format &#x3D; options.parser || options.format;

		if (typeof parser &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
			return parser(value);
		}

		if (typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; typeof format &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
			return moment(value, format);
		}

		if (!(value instanceof moment)) {
			value &#x3D; moment(value);
		}

		if (value.isValid()) {
			return value;
		}

		// Labels are in an incompatible moment format and no &#x60;parser&#x60; has been provided.
		// The user might still use the deprecated &#x60;format&#x60; option to convert his inputs.
		if (typeof format &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
			return format(value);
		}

		return value;
	}

	function parse(input, scale) {
		if (helpers.isNullOrUndef(input)) {
			return null;
		}

		var options &#x3D; scale.options.time;
		var value &#x3D; momentify(scale.getRightValue(input), options);
		if (!value.isValid()) {
			return null;
		}

		if (options.round) {
			value.startOf(options.round);
		}

		return value.valueOf();
	}

	/**
	 * Returns the number of unit to skip to be able to display up to &#x60;capacity&#x60; number of ticks
	 * in &#x60;unit&#x60; for the given &#x60;min&#x60; / &#x60;max&#x60; range and respecting the interval steps constraints.
	 */
	function determineStepSize(min, max, unit, capacity) {
		var range &#x3D; max - min;
		var interval &#x3D; INTERVALS[unit];
		var milliseconds &#x3D; interval.size;
		var steps &#x3D; interval.steps;
		var i, ilen, factor;

		if (!steps) {
			return Math.ceil(range / (capacity * milliseconds));
		}

		for (i &#x3D; 0, ilen &#x3D; steps.length; i &lt; ilen; ++i) {
			factor &#x3D; steps[i];
			if (Math.ceil(range / (milliseconds * factor)) &lt;&#x3D; capacity) {
				break;
			}
		}

		return factor;
	}

	/**
	 * Figures out what unit results in an appropriate number of auto-generated ticks
	 */
	function determineUnitForAutoTicks(minUnit, min, max, capacity) {
		var ilen &#x3D; UNITS.length;
		var i, interval, factor;

		for (i &#x3D; UNITS.indexOf(minUnit); i &lt; ilen - 1; ++i) {
			interval &#x3D; INTERVALS[UNITS[i]];
			factor &#x3D; interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

			if (interval.common &amp;&amp; Math.ceil((max - min) / (factor * interval.size)) &lt;&#x3D; capacity) {
				return UNITS[i];
			}
		}

		return UNITS[ilen - 1];
	}

	/**
	 * Figures out what unit to format a set of ticks with
	 */
	function determineUnitForFormatting(ticks, minUnit, min, max) {
		var duration &#x3D; moment.duration(moment(max).diff(moment(min)));
		var ilen &#x3D; UNITS.length;
		var i, unit;

		for (i &#x3D; ilen - 1; i &gt;&#x3D; UNITS.indexOf(minUnit); i--) {
			unit &#x3D; UNITS[i];
			if (INTERVALS[unit].common &amp;&amp; duration.as(unit) &gt;&#x3D; ticks.length) {
				return unit;
			}
		}

		return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
	}

	function determineMajorUnit(unit) {
		for (var i &#x3D; UNITS.indexOf(unit) + 1, ilen &#x3D; UNITS.length; i &lt; ilen; ++i) {
			if (INTERVALS[UNITS[i]].common) {
				return UNITS[i];
			}
		}
	}

	/**
	 * Generates a maximum of &#x60;capacity&#x60; timestamps between min and max, rounded to the
	 * &#x60;minor&#x60; unit, aligned on the &#x60;major&#x60; unit and using the given scale time &#x60;options&#x60;.
	 * Important: this method can return ticks outside the min and max range, it&#x27;s the
	 * responsibility of the calling code to clamp values if needed.
	 */
	function generate(min, max, capacity, options) {
		var timeOpts &#x3D; options.time;
		var minor &#x3D; timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
		var major &#x3D; determineMajorUnit(minor);
		var stepSize &#x3D; helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
		var weekday &#x3D; minor &#x3D;&#x3D;&#x3D; &#x27;week&#x27; ? timeOpts.isoWeekday : false;
		var majorTicksEnabled &#x3D; options.ticks.major.enabled;
		var interval &#x3D; INTERVALS[minor];
		var first &#x3D; moment(min);
		var last &#x3D; moment(max);
		var ticks &#x3D; [];
		var time;

		if (!stepSize) {
			stepSize &#x3D; determineStepSize(min, max, minor, capacity);
		}

		// For &#x27;week&#x27; unit, handle the first day of week option
		if (weekday) {
			first &#x3D; first.isoWeekday(weekday);
			last &#x3D; last.isoWeekday(weekday);
		}

		// Align first/last ticks on unit
		first &#x3D; first.startOf(weekday ? &#x27;day&#x27; : minor);
		last &#x3D; last.startOf(weekday ? &#x27;day&#x27; : minor);

		// Make sure that the last tick include max
		if (last &lt; max) {
			last.add(1, minor);
		}

		time &#x3D; moment(first);

		if (majorTicksEnabled &amp;&amp; major &amp;&amp; !weekday &amp;&amp; !timeOpts.round) {
			// Align the first tick on the previous &#x60;minor&#x60; unit aligned on the &#x60;major&#x60; unit:
			// we first aligned time on the previous &#x60;major&#x60; unit then add the number of full
			// stepSize there is between first and the previous major time.
			time.startOf(major);
			time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
		}

		for (; time &lt; last; time.add(stepSize, minor)) {
			ticks.push(+time);
		}

		ticks.push(+time);

		return ticks;
	}

	/**
	 * Returns the right and left offsets from edges in the form of {left, right}.
	 * Offsets are added when the &#x60;offset&#x60; option is true.
	 */
	function computeOffsets(table, ticks, min, max, options) {
		var left &#x3D; 0;
		var right &#x3D; 0;
		var upper, lower;

		if (options.offset &amp;&amp; ticks.length) {
			if (!options.time.min) {
				upper &#x3D; ticks.length &gt; 1 ? ticks[1] : max;
				lower &#x3D; ticks[0];
				left &#x3D; (
					interpolate(table, &#x27;time&#x27;, upper, &#x27;pos&#x27;) -
					interpolate(table, &#x27;time&#x27;, lower, &#x27;pos&#x27;)
				) / 2;
			}
			if (!options.time.max) {
				upper &#x3D; ticks[ticks.length - 1];
				lower &#x3D; ticks.length &gt; 1 ? ticks[ticks.length - 2] : min;
				right &#x3D; (
					interpolate(table, &#x27;time&#x27;, upper, &#x27;pos&#x27;) -
					interpolate(table, &#x27;time&#x27;, lower, &#x27;pos&#x27;)
				) / 2;
			}
		}

		return {left: left, right: right};
	}

	function ticksFromTimestamps(values, majorUnit) {
		var ticks &#x3D; [];
		var i, ilen, value, major;

		for (i &#x3D; 0, ilen &#x3D; values.length; i &lt; ilen; ++i) {
			value &#x3D; values[i];
			major &#x3D; majorUnit ? value &#x3D;&#x3D;&#x3D; +moment(value).startOf(majorUnit) : false;

			ticks.push({
				value: value,
				major: major
			});
		}

		return ticks;
	}

	function determineLabelFormat(data, timeOpts) {
		var i, momentDate, hasTime;
		var ilen &#x3D; data.length;

		// find the label with the most parts (milliseconds, minutes, etc.)
		// format all labels with the same level of detail as the most specific label
		for (i &#x3D; 0; i &lt; ilen; i++) {
			momentDate &#x3D; momentify(data[i], timeOpts);
			if (momentDate.millisecond() !&#x3D;&#x3D; 0) {
				return &#x27;MMM D, YYYY h:mm:ss.SSS a&#x27;;
			}
			if (momentDate.second() !&#x3D;&#x3D; 0 || momentDate.minute() !&#x3D;&#x3D; 0 || momentDate.hour() !&#x3D;&#x3D; 0) {
				hasTime &#x3D; true;
			}
		}
		if (hasTime) {
			return &#x27;MMM D, YYYY h:mm:ss a&#x27;;
		}
		return &#x27;MMM D, YYYY&#x27;;
	}

	module.exports &#x3D; function(Chart) {

		var defaultConfig &#x3D; {
			position: &#x27;bottom&#x27;,

			/**
			 * Data distribution along the scale:
			 * - &#x27;linear&#x27;: data are spread according to their time (distances can vary),
			 * - &#x27;series&#x27;: data are spread at the same distance from each other.
			 * @see https://github.com/chartjs/Chart.js/pull/4507
			 * @since 2.7.0
			 */
			distribution: &#x27;linear&#x27;,

			/**
			 * Scale boundary strategy (bypassed by min/max time options)
			 * - &#x60;data&#x60;: make sure data are fully visible, ticks outside are removed
			 * - &#x60;ticks&#x60;: make sure ticks are fully visible, data outside are truncated
			 * @see https://github.com/chartjs/Chart.js/pull/4556
			 * @since 2.7.0
			 */
			bounds: &#x27;data&#x27;,

			time: {
				parser: false, // false &#x3D;&#x3D; a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
				format: false, // DEPRECATED false &#x3D;&#x3D; date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
				unit: false, // false &#x3D;&#x3D; automatic or override with week, month, year, etc.
				round: false, // none, or override with week, month, year, etc.
				displayFormat: false, // DEPRECATED
				isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
				minUnit: &#x27;millisecond&#x27;,

				// defaults to unit&#x27;s corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
				displayFormats: {
					millisecond: &#x27;h:mm:ss.SSS a&#x27;, // 11:20:01.123 AM,
					second: &#x27;h:mm:ss a&#x27;, // 11:20:01 AM
					minute: &#x27;h:mm a&#x27;, // 11:20 AM
					hour: &#x27;hA&#x27;, // 5PM
					day: &#x27;MMM D&#x27;, // Sep 4
					week: &#x27;ll&#x27;, // Week 46, or maybe &quot;[W]WW - YYYY&quot; ?
					month: &#x27;MMM YYYY&#x27;, // Sept 2015
					quarter: &#x27;[Q]Q - YYYY&#x27;, // Q3
					year: &#x27;YYYY&#x27; // 2015
				},
			},
			ticks: {
				autoSkip: false,

				/**
				 * Ticks generation input values:
				 * - &#x27;auto&#x27;: generates &quot;optimal&quot; ticks based on scale size and time options.
				 * - &#x27;data&#x27;: generates ticks from data (including labels from data {t|x|y} objects).
				 * - &#x27;labels&#x27;: generates ticks from user given &#x60;data.labels&#x60; values ONLY.
				 * @see https://github.com/chartjs/Chart.js/pull/4507
				 * @since 2.7.0
				 */
				source: &#x27;auto&#x27;,

				major: {
					enabled: false
				}
			}
		};

		var TimeScale &#x3D; Chart.Scale.extend({
			initialize: function() {
				if (!moment) {
					throw new Error(&#x27;Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com&#x27;);
				}

				this.mergeTicksOptions();

				Chart.Scale.prototype.initialize.call(this);
			},

			update: function() {
				var me &#x3D; this;
				var options &#x3D; me.options;

				// DEPRECATIONS: output a message only one time per update
				if (options.time &amp;&amp; options.time.format) {
					console.warn(&#x27;options.time.format is deprecated and replaced by options.time.parser.&#x27;);
				}

				return Chart.Scale.prototype.update.apply(me, arguments);
			},

			/**
			 * Allows data to be referenced via &#x27;t&#x27; attribute
			 */
			getRightValue: function(rawValue) {
				if (rawValue &amp;&amp; rawValue.t !&#x3D;&#x3D; undefined) {
					rawValue &#x3D; rawValue.t;
				}
				return Chart.Scale.prototype.getRightValue.call(this, rawValue);
			},

			determineDataLimits: function() {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var timeOpts &#x3D; me.options.time;
				var unit &#x3D; timeOpts.unit || &#x27;day&#x27;;
				var min &#x3D; MAX_INTEGER;
				var max &#x3D; MIN_INTEGER;
				var timestamps &#x3D; [];
				var datasets &#x3D; [];
				var labels &#x3D; [];
				var i, j, ilen, jlen, data, timestamp;

				// Convert labels to timestamps
				for (i &#x3D; 0, ilen &#x3D; chart.data.labels.length; i &lt; ilen; ++i) {
					labels.push(parse(chart.data.labels[i], me));
				}

				// Convert data to timestamps
				for (i &#x3D; 0, ilen &#x3D; (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					if (chart.isDatasetVisible(i)) {
						data &#x3D; chart.data.datasets[i].data;

						// Let&#x27;s consider that all data have the same format.
						if (helpers.isObject(data[0])) {
							datasets[i] &#x3D; [];

							for (j &#x3D; 0, jlen &#x3D; data.length; j &lt; jlen; ++j) {
								timestamp &#x3D; parse(data[j], me);
								timestamps.push(timestamp);
								datasets[i][j] &#x3D; timestamp;
							}
						} else {
							timestamps.push.apply(timestamps, labels);
							datasets[i] &#x3D; labels.slice(0);
						}
					} else {
						datasets[i] &#x3D; [];
					}
				}

				if (labels.length) {
					// Sort labels **after** data have been converted
					labels &#x3D; arrayUnique(labels).sort(sorter);
					min &#x3D; Math.min(min, labels[0]);
					max &#x3D; Math.max(max, labels[labels.length - 1]);
				}

				if (timestamps.length) {
					timestamps &#x3D; arrayUnique(timestamps).sort(sorter);
					min &#x3D; Math.min(min, timestamps[0]);
					max &#x3D; Math.max(max, timestamps[timestamps.length - 1]);
				}

				min &#x3D; parse(timeOpts.min, me) || min;
				max &#x3D; parse(timeOpts.max, me) || max;

				// In case there is no valid min/max, set limits based on unit time option
				min &#x3D; min &#x3D;&#x3D;&#x3D; MAX_INTEGER ? +moment().startOf(unit) : min;
				max &#x3D; max &#x3D;&#x3D;&#x3D; MIN_INTEGER ? +moment().endOf(unit) + 1 : max;

				// Make sure that max is strictly higher than min (required by the lookup table)
				me.min &#x3D; Math.min(min, max);
				me.max &#x3D; Math.max(min + 1, max);

				// PRIVATE
				me._horizontal &#x3D; me.isHorizontal();
				me._table &#x3D; [];
				me._timestamps &#x3D; {
					data: timestamps,
					datasets: datasets,
					labels: labels
				};
			},

			buildTicks: function() {
				var me &#x3D; this;
				var min &#x3D; me.min;
				var max &#x3D; me.max;
				var options &#x3D; me.options;
				var timeOpts &#x3D; options.time;
				var timestamps &#x3D; [];
				var ticks &#x3D; [];
				var i, ilen, timestamp;

				switch (options.ticks.source) {
				case &#x27;data&#x27;:
					timestamps &#x3D; me._timestamps.data;
					break;
				case &#x27;labels&#x27;:
					timestamps &#x3D; me._timestamps.labels;
					break;
				case &#x27;auto&#x27;:
				default:
					timestamps &#x3D; generate(min, max, me.getLabelCapacity(min), options);
				}

				if (options.bounds &#x3D;&#x3D;&#x3D; &#x27;ticks&#x27; &amp;&amp; timestamps.length) {
					min &#x3D; timestamps[0];
					max &#x3D; timestamps[timestamps.length - 1];
				}

				// Enforce limits with user min/max options
				min &#x3D; parse(timeOpts.min, me) || min;
				max &#x3D; parse(timeOpts.max, me) || max;

				// Remove ticks outside the min/max range
				for (i &#x3D; 0, ilen &#x3D; timestamps.length; i &lt; ilen; ++i) {
					timestamp &#x3D; timestamps[i];
					if (timestamp &gt;&#x3D; min &amp;&amp; timestamp &lt;&#x3D; max) {
						ticks.push(timestamp);
					}
				}

				me.min &#x3D; min;
				me.max &#x3D; max;

				// PRIVATE
				me._unit &#x3D; timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
				me._majorUnit &#x3D; determineMajorUnit(me._unit);
				me._table &#x3D; buildLookupTable(me._timestamps.data, min, max, options.distribution);
				me._offsets &#x3D; computeOffsets(me._table, ticks, min, max, options);
				me._labelFormat &#x3D; determineLabelFormat(me._timestamps.data, timeOpts);

				return ticksFromTimestamps(ticks, me._majorUnit);
			},

			getLabelForIndex: function(index, datasetIndex) {
				var me &#x3D; this;
				var data &#x3D; me.chart.data;
				var timeOpts &#x3D; me.options.time;
				var label &#x3D; data.labels &amp;&amp; index &lt; data.labels.length ? data.labels[index] : &#x27;&#x27;;
				var value &#x3D; data.datasets[datasetIndex].data[index];

				if (helpers.isObject(value)) {
					label &#x3D; me.getRightValue(value);
				}
				if (timeOpts.tooltipFormat) {
					return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
				}
				if (typeof label &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
					return label;
				}

				return momentify(label, timeOpts).format(me._labelFormat);
			},

			/**
			 * Function to format an individual tick mark
			 * @private
			 */
			tickFormatFunction: function(tick, index, ticks, formatOverride) {
				var me &#x3D; this;
				var options &#x3D; me.options;
				var time &#x3D; tick.valueOf();
				var formats &#x3D; options.time.displayFormats;
				var minorFormat &#x3D; formats[me._unit];
				var majorUnit &#x3D; me._majorUnit;
				var majorFormat &#x3D; formats[majorUnit];
				var majorTime &#x3D; tick.clone().startOf(majorUnit).valueOf();
				var majorTickOpts &#x3D; options.ticks.major;
				var major &#x3D; majorTickOpts.enabled &amp;&amp; majorUnit &amp;&amp; majorFormat &amp;&amp; time &#x3D;&#x3D;&#x3D; majorTime;
				var label &#x3D; tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
				var tickOpts &#x3D; major ? majorTickOpts : options.ticks.minor;
				var formatter &#x3D; helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

				return formatter ? formatter(label, index, ticks) : label;
			},

			convertTicksToLabels: function(ticks) {
				var labels &#x3D; [];
				var i, ilen;

				for (i &#x3D; 0, ilen &#x3D; ticks.length; i &lt; ilen; ++i) {
					labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
				}

				return labels;
			},

			/**
			 * @private
			 */
			getPixelForOffset: function(time) {
				var me &#x3D; this;
				var size &#x3D; me._horizontal ? me.width : me.height;
				var start &#x3D; me._horizontal ? me.left : me.top;
				var pos &#x3D; interpolate(me._table, &#x27;time&#x27;, time, &#x27;pos&#x27;);

				return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
			},

			getPixelForValue: function(value, index, datasetIndex) {
				var me &#x3D; this;
				var time &#x3D; null;

				if (index !&#x3D;&#x3D; undefined &amp;&amp; datasetIndex !&#x3D;&#x3D; undefined) {
					time &#x3D; me._timestamps.datasets[datasetIndex][index];
				}

				if (time &#x3D;&#x3D;&#x3D; null) {
					time &#x3D; parse(value, me);
				}

				if (time !&#x3D;&#x3D; null) {
					return me.getPixelForOffset(time);
				}
			},

			getPixelForTick: function(index) {
				var ticks &#x3D; this.getTicks();
				return index &gt;&#x3D; 0 &amp;&amp; index &lt; ticks.length ?
					this.getPixelForOffset(ticks[index].value) :
					null;
			},

			getValueForPixel: function(pixel) {
				var me &#x3D; this;
				var size &#x3D; me._horizontal ? me.width : me.height;
				var start &#x3D; me._horizontal ? me.left : me.top;
				var pos &#x3D; (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
				var time &#x3D; interpolate(me._table, &#x27;pos&#x27;, pos, &#x27;time&#x27;);

				return moment(time);
			},

			/**
			 * Crude approximation of what the label width might be
			 * @private
			 */
			getLabelWidth: function(label) {
				var me &#x3D; this;
				var ticksOpts &#x3D; me.options.ticks;
				var tickLabelWidth &#x3D; me.ctx.measureText(label).width;
				var angle &#x3D; helpers.toRadians(ticksOpts.maxRotation);
				var cosRotation &#x3D; Math.cos(angle);
				var sinRotation &#x3D; Math.sin(angle);
				var tickFontSize &#x3D; helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

				return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
			},

			/**
			 * @private
			 */
			getLabelCapacity: function(exampleTime) {
				var me &#x3D; this;

				var formatOverride &#x3D; me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation

				var exampleLabel &#x3D; me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
				var tickLabelWidth &#x3D; me.getLabelWidth(exampleLabel);
				var innerWidth &#x3D; me.isHorizontal() ? me.width : me.height;

				var capacity &#x3D; Math.floor(innerWidth / tickLabelWidth);
				return capacity &gt; 0 ? capacity : 1;
			}
		});

		Chart.scaleService.registerScaleType(&#x27;time&#x27;, TimeScale, defaultConfig);
	};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(module) {//! moment.js

	;(function (global, factory) {
	     true ? module.exports &#x3D; factory() :
	    typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define(factory) :
	    global.moment &#x3D; factory()
	}(this, (function () { &#x27;use strict&#x27;;

	var hookCallback;

	function hooks () {
	    return hookCallback.apply(null, arguments);
	}

	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback &#x3D; callback;
	}

	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) &#x3D;&#x3D;&#x3D; &#x27;[object Array]&#x27;;
	}

	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn&#x27;t for
	    // input !&#x3D; null
	    return input !&#x3D; null &amp;&amp; Object.prototype.toString.call(input) &#x3D;&#x3D;&#x3D; &#x27;[object Object]&#x27;;
	}

	function isObjectEmpty(obj) {
	    if (Object.getOwnPropertyNames) {
	        return (Object.getOwnPropertyNames(obj).length &#x3D;&#x3D;&#x3D; 0);
	    } else {
	        var k;
	        for (k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                return false;
	            }
	        }
	        return true;
	    }
	}

	function isUndefined(input) {
	    return input &#x3D;&#x3D;&#x3D; void 0;
	}

	function isNumber(input) {
	    return typeof input &#x3D;&#x3D;&#x3D; &#x27;number&#x27; || Object.prototype.toString.call(input) &#x3D;&#x3D;&#x3D; &#x27;[object Number]&#x27;;
	}

	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) &#x3D;&#x3D;&#x3D; &#x27;[object Date]&#x27;;
	}

	function map(arr, fn) {
	    var res &#x3D; [], i;
	    for (i &#x3D; 0; i &lt; arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}

	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] &#x3D; b[i];
	        }
	    }

	    if (hasOwnProp(b, &#x27;toString&#x27;)) {
	        a.toString &#x3D; b.toString;
	    }

	    if (hasOwnProp(b, &#x27;valueOf&#x27;)) {
	        a.valueOf &#x3D; b.valueOf;
	    }

	    return a;
	}

	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null,
	        rfc2822         : false,
	        weekdayMismatch : false
	    };
	}

	function getParsingFlags(m) {
	    if (m._pf &#x3D;&#x3D; null) {
	        m._pf &#x3D; defaultParsingFlags();
	    }
	    return m._pf;
	}

	var some;
	if (Array.prototype.some) {
	    some &#x3D; Array.prototype.some;
	} else {
	    some &#x3D; function (fun) {
	        var t &#x3D; Object(this);
	        var len &#x3D; t.length &gt;&gt;&gt; 0;

	        for (var i &#x3D; 0; i &lt; len; i++) {
	            if (i in t &amp;&amp; fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }

	        return false;
	    };
	}

	function isValid(m) {
	    if (m._isValid &#x3D;&#x3D; null) {
	        var flags &#x3D; getParsingFlags(m);
	        var parsedParts &#x3D; some.call(flags.parsedDateParts, function (i) {
	            return i !&#x3D; null;
	        });
	        var isNowValid &#x3D; !isNaN(m._d.getTime()) &amp;&amp;
	            flags.overflow &lt; 0 &amp;&amp;
	            !flags.empty &amp;&amp;
	            !flags.invalidMonth &amp;&amp;
	            !flags.invalidWeekday &amp;&amp;
	            !flags.weekdayMismatch &amp;&amp;
	            !flags.nullInput &amp;&amp;
	            !flags.invalidFormat &amp;&amp;
	            !flags.userInvalidated &amp;&amp;
	            (!flags.meridiem || (flags.meridiem &amp;&amp; parsedParts));

	        if (m._strict) {
	            isNowValid &#x3D; isNowValid &amp;&amp;
	                flags.charsLeftOver &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
	                flags.unusedTokens.length &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
	                flags.bigHour &#x3D;&#x3D;&#x3D; undefined;
	        }

	        if (Object.isFrozen &#x3D;&#x3D; null || !Object.isFrozen(m)) {
	            m._isValid &#x3D; isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}

	function createInvalid (flags) {
	    var m &#x3D; createUTC(NaN);
	    if (flags !&#x3D; null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated &#x3D; true;
	    }

	    return m;
	}

	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties &#x3D; hooks.momentProperties &#x3D; [];

	function copyConfig(to, from) {
	    var i, prop, val;

	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject &#x3D; from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i &#x3D; from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f &#x3D; from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l &#x3D; from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict &#x3D; from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm &#x3D; from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC &#x3D; from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset &#x3D; from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf &#x3D; getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale &#x3D; from._locale;
	    }

	    if (momentProperties.length &gt; 0) {
	        for (i &#x3D; 0; i &lt; momentProperties.length; i++) {
	            prop &#x3D; momentProperties[i];
	            val &#x3D; from[prop];
	            if (!isUndefined(val)) {
	                to[prop] &#x3D; val;
	            }
	        }
	    }

	    return to;
	}

	var updateInProgress &#x3D; false;

	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d &#x3D; new Date(config._d !&#x3D; null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d &#x3D; new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress &#x3D;&#x3D;&#x3D; false) {
	        updateInProgress &#x3D; true;
	        hooks.updateOffset(this);
	        updateInProgress &#x3D; false;
	    }
	}

	function isMoment (obj) {
	    return obj instanceof Moment || (obj !&#x3D; null &amp;&amp; obj._isAMomentObject !&#x3D; null);
	}

	function absFloor (number) {
	    if (number &lt; 0) {
	        // -0 -&gt; 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}

	function toInt(argumentForCoercion) {
	    var coercedNumber &#x3D; +argumentForCoercion,
	        value &#x3D; 0;

	    if (coercedNumber !&#x3D;&#x3D; 0 &amp;&amp; isFinite(coercedNumber)) {
	        value &#x3D; absFloor(coercedNumber);
	    }

	    return value;
	}

	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len &#x3D; Math.min(array1.length, array2.length),
	        lengthDiff &#x3D; Math.abs(array1.length - array2.length),
	        diffs &#x3D; 0,
	        i;
	    for (i &#x3D; 0; i &lt; len; i++) {
	        if ((dontConvert &amp;&amp; array1[i] !&#x3D;&#x3D; array2[i]) ||
	            (!dontConvert &amp;&amp; toInt(array1[i]) !&#x3D;&#x3D; toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}

	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings &#x3D;&#x3D;&#x3D; false &amp;&amp;
	            (typeof console !&#x3D;&#x3D;  &#x27;undefined&#x27;) &amp;&amp; console.warn) {
	        console.warn(&#x27;Deprecation warning: &#x27; + msg);
	    }
	}

	function deprecate(msg, fn) {
	    var firstTime &#x3D; true;

	    return extend(function () {
	        if (hooks.deprecationHandler !&#x3D; null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args &#x3D; [];
	            var arg;
	            for (var i &#x3D; 0; i &lt; arguments.length; i++) {
	                arg &#x3D; &#x27;&#x27;;
	                if (typeof arguments[i] &#x3D;&#x3D;&#x3D; &#x27;object&#x27;) {
	                    arg +&#x3D; &#x27;\n[&#x27; + i + &#x27;] &#x27;;
	                    for (var key in arguments[0]) {
	                        arg +&#x3D; key + &#x27;: &#x27; + arguments[0][key] + &#x27;, &#x27;;
	                    }
	                    arg &#x3D; arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg &#x3D; arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + &#x27;\nArguments: &#x27; + Array.prototype.slice.call(args).join(&#x27;&#x27;) + &#x27;\n&#x27; + (new Error()).stack);
	            firstTime &#x3D; false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}

	var deprecations &#x3D; {};

	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler !&#x3D; null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] &#x3D; true;
	    }
	}

	hooks.suppressDeprecationWarnings &#x3D; false;
	hooks.deprecationHandler &#x3D; null;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) &#x3D;&#x3D;&#x3D; &#x27;[object Function]&#x27;;
	}

	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop &#x3D; config[i];
	        if (isFunction(prop)) {
	            this[i] &#x3D; prop;
	        } else {
	            this[&#x27;_&#x27; + i] &#x3D; prop;
	        }
	    }
	    this._config &#x3D; config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	    // TODO: Remove &quot;ordinalParse&quot; fallback in next major release.
	    this._dayOfMonthOrdinalParseLenient &#x3D; new RegExp(
	        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	            &#x27;|&#x27; + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
	    var res &#x3D; extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) &amp;&amp; isObject(childConfig[prop])) {
	                res[prop] &#x3D; {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] !&#x3D; null) {
	                res[prop] &#x3D; childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &amp;&amp;
	                !hasOwnProp(childConfig, prop) &amp;&amp;
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don&#x27;t modify parent config
	            res[prop] &#x3D; extend({}, res[prop]);
	        }
	    }
	    return res;
	}

	function Locale(config) {
	    if (config !&#x3D; null) {
	        this.set(config);
	    }
	}

	var keys;

	if (Object.keys) {
	    keys &#x3D; Object.keys;
	} else {
	    keys &#x3D; function (obj) {
	        var i, res &#x3D; [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}

	var defaultCalendar &#x3D; {
	    sameDay : &#x27;[Today at] LT&#x27;,
	    nextDay : &#x27;[Tomorrow at] LT&#x27;,
	    nextWeek : &#x27;dddd [at] LT&#x27;,
	    lastDay : &#x27;[Yesterday at] LT&#x27;,
	    lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	    sameElse : &#x27;L&#x27;
	};

	function calendar (key, mom, now) {
	    var output &#x3D; this._calendar[key] || this._calendar[&#x27;sameElse&#x27;];
	    return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat &#x3D; {
	    LTS  : &#x27;h:mm:ss A&#x27;,
	    LT   : &#x27;h:mm A&#x27;,
	    L    : &#x27;MM/DD/YYYY&#x27;,
	    LL   : &#x27;MMMM D, YYYY&#x27;,
	    LLL  : &#x27;MMMM D, YYYY h:mm A&#x27;,
	    LLLL : &#x27;dddd, MMMM D, YYYY h:mm A&#x27;
	};

	function longDateFormat (key) {
	    var format &#x3D; this._longDateFormat[key],
	        formatUpper &#x3D; this._longDateFormat[key.toUpperCase()];

	    if (format || !formatUpper) {
	        return format;
	    }

	    this._longDateFormat[key] &#x3D; formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });

	    return this._longDateFormat[key];
	}

	var defaultInvalidDate &#x3D; &#x27;Invalid date&#x27;;

	function invalidDate () {
	    return this._invalidDate;
	}

	var defaultOrdinal &#x3D; &#x27;%d&#x27;;
	var defaultDayOfMonthOrdinalParse &#x3D; /\d{1,2}/;

	function ordinal (number) {
	    return this._ordinal.replace(&#x27;%d&#x27;, number);
	}

	var defaultRelativeTime &#x3D; {
	    future : &#x27;in %s&#x27;,
	    past   : &#x27;%s ago&#x27;,
	    s  : &#x27;a few seconds&#x27;,
	    ss : &#x27;%d seconds&#x27;,
	    m  : &#x27;a minute&#x27;,
	    mm : &#x27;%d minutes&#x27;,
	    h  : &#x27;an hour&#x27;,
	    hh : &#x27;%d hours&#x27;,
	    d  : &#x27;a day&#x27;,
	    dd : &#x27;%d days&#x27;,
	    M  : &#x27;a month&#x27;,
	    MM : &#x27;%d months&#x27;,
	    y  : &#x27;a year&#x27;,
	    yy : &#x27;%d years&#x27;
	};

	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output &#x3D; this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}

	function pastFuture (diff, output) {
	    var format &#x3D; this._relativeTime[diff &gt; 0 ? &#x27;future&#x27; : &#x27;past&#x27;];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var aliases &#x3D; {};

	function addUnitAlias (unit, shorthand) {
	    var lowerCase &#x3D; unit.toLowerCase();
	    aliases[lowerCase] &#x3D; aliases[lowerCase + &#x27;s&#x27;] &#x3D; aliases[shorthand] &#x3D; unit;
	}

	function normalizeUnits(units) {
	    return typeof units &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
	    var normalizedInput &#x3D; {},
	        normalizedProp,
	        prop;

	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp &#x3D; normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] &#x3D; inputObject[prop];
	            }
	        }
	    }

	    return normalizedInput;
	}

	var priorities &#x3D; {};

	function addUnitPriority(unit, priority) {
	    priorities[unit] &#x3D; priority;
	}

	function getPrioritizedUnits(unitsObj) {
	    var units &#x3D; [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}

	function zeroFill(number, targetLength, forceSign) {
	    var absNumber &#x3D; &#x27;&#x27; + Math.abs(number),
	        zerosToFill &#x3D; targetLength - absNumber.length,
	        sign &#x3D; number &gt;&#x3D; 0;
	    return (sign ? (forceSign ? &#x27;+&#x27; : &#x27;&#x27;) : &#x27;-&#x27;) +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens &#x3D; /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens &#x3D; /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions &#x3D; {};

	var formatTokenFunctions &#x3D; {};

	// token:    &#x27;M&#x27;
	// padded:   [&#x27;MM&#x27;, 2]
	// ordinal:  &#x27;Mo&#x27;
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func &#x3D; callback;
	    if (typeof callback &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	        func &#x3D; function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] &#x3D; func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] &#x3D; function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] &#x3D; function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}

	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, &#x27;&#x27;);
	    }
	    return input.replace(/\\/g, &#x27;&#x27;);
	}

	function makeFormatFunction(format) {
	    var array &#x3D; format.match(formattingTokens), i, length;

	    for (i &#x3D; 0, length &#x3D; array.length; i &lt; length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] &#x3D; formatTokenFunctions[array[i]];
	        } else {
	            array[i] &#x3D; removeFormattingTokens(array[i]);
	        }
	    }

	    return function (mom) {
	        var output &#x3D; &#x27;&#x27;, i;
	        for (i &#x3D; 0; i &lt; length; i++) {
	            output +&#x3D; isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}

	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }

	    format &#x3D; expandFormat(format, m.localeData());
	    formatFunctions[format] &#x3D; formatFunctions[format] || makeFormatFunction(format);

	    return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
	    var i &#x3D; 5;

	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }

	    localFormattingTokens.lastIndex &#x3D; 0;
	    while (i &gt;&#x3D; 0 &amp;&amp; localFormattingTokens.test(format)) {
	        format &#x3D; format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex &#x3D; 0;
	        i -&#x3D; 1;
	    }

	    return format;
	}

	var match1         &#x3D; /\d/;            //       0 - 9
	var match2         &#x3D; /\d\d/;          //      00 - 99
	var match3         &#x3D; /\d{3}/;         //     000 - 999
	var match4         &#x3D; /\d{4}/;         //    0000 - 9999
	var match6         &#x3D; /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      &#x3D; /\d\d?/;         //       0 - 99
	var match3to4      &#x3D; /\d\d\d\d?/;     //     999 - 9999
	var match5to6      &#x3D; /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      &#x3D; /\d{1,3}/;       //       0 - 999
	var match1to4      &#x3D; /\d{1,4}/;       //       0 - 9999
	var match1to6      &#x3D; /[+-]?\d{1,6}/;  // -999999 - 999999

	var matchUnsigned  &#x3D; /\d+/;           //       0 - inf
	var matchSigned    &#x3D; /[+-]?\d+/;      //    -inf - inf

	var matchOffset    &#x3D; /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset &#x3D; /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp &#x3D; /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord &#x3D; /[0-9]{0,256}[&#x27;a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

	var regexes &#x3D; {};

	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] &#x3D; isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict &amp;&amp; strictRegex) ? strictRegex : regex;
	    };
	}

	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }

	    return regexes[token](config._strict, config._locale);
	}

	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace(&#x27;\\&#x27;, &#x27;&#x27;).replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}

	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, &#x27;\\$&amp;&#x27;);
	}

	var tokens &#x3D; {};

	function addParseToken (token, callback) {
	    var i, func &#x3D; callback;
	    if (typeof token &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	        token &#x3D; [token];
	    }
	    if (isNumber(callback)) {
	        func &#x3D; function (input, array) {
	            array[callback] &#x3D; toInt(input);
	        };
	    }
	    for (i &#x3D; 0; i &lt; token.length; i++) {
	        tokens[token[i]] &#x3D; func;
	    }
	}

	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w &#x3D; config._w || {};
	        callback(input, config._w, config, token);
	    });
	}

	function addTimeToArrayFromToken(token, input, config) {
	    if (input !&#x3D; null &amp;&amp; hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}

	var YEAR &#x3D; 0;
	var MONTH &#x3D; 1;
	var DATE &#x3D; 2;
	var HOUR &#x3D; 3;
	var MINUTE &#x3D; 4;
	var SECOND &#x3D; 5;
	var MILLISECOND &#x3D; 6;
	var WEEK &#x3D; 7;
	var WEEKDAY &#x3D; 8;

	// FORMATTING

	addFormatToken(&#x27;Y&#x27;, 0, 0, function () {
	    var y &#x3D; this.year();
	    return y &lt;&#x3D; 9999 ? &#x27;&#x27; + y : &#x27;+&#x27; + y;
	});

	addFormatToken(0, [&#x27;YY&#x27;, 2], 0, function () {
	    return this.year() % 100;
	});

	addFormatToken(0, [&#x27;YYYY&#x27;,   4],       0, &#x27;year&#x27;);
	addFormatToken(0, [&#x27;YYYYY&#x27;,  5],       0, &#x27;year&#x27;);
	addFormatToken(0, [&#x27;YYYYYY&#x27;, 6, true], 0, &#x27;year&#x27;);

	// ALIASES

	addUnitAlias(&#x27;year&#x27;, &#x27;y&#x27;);

	// PRIORITIES

	addUnitPriority(&#x27;year&#x27;, 1);

	// PARSING

	addRegexToken(&#x27;Y&#x27;,      matchSigned);
	addRegexToken(&#x27;YY&#x27;,     match1to2, match2);
	addRegexToken(&#x27;YYYY&#x27;,   match1to4, match4);
	addRegexToken(&#x27;YYYYY&#x27;,  match1to6, match6);
	addRegexToken(&#x27;YYYYYY&#x27;, match1to6, match6);

	addParseToken([&#x27;YYYYY&#x27;, &#x27;YYYYYY&#x27;], YEAR);
	addParseToken(&#x27;YYYY&#x27;, function (input, array) {
	    array[YEAR] &#x3D; input.length &#x3D;&#x3D;&#x3D; 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken(&#x27;YY&#x27;, function (input, array) {
	    array[YEAR] &#x3D; hooks.parseTwoDigitYear(input);
	});
	addParseToken(&#x27;Y&#x27;, function (input, array) {
	    array[YEAR] &#x3D; parseInt(input, 10);
	});

	// HELPERS

	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
	    return (year % 4 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D;&#x3D; 0) || year % 400 &#x3D;&#x3D;&#x3D; 0;
	}

	// HOOKS

	hooks.parseTwoDigitYear &#x3D; function (input) {
	    return toInt(input) + (toInt(input) &gt; 68 ? 1900 : 2000);
	};

	// MOMENTS

	var getSetYear &#x3D; makeGetSet(&#x27;FullYear&#x27;, true);

	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}

	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value !&#x3D; null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}

	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d[&#x27;get&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + unit]() : NaN;
	}

	function set$1 (mom, unit, value) {
	    if (mom.isValid() &amp;&amp; !isNaN(value)) {
	        if (unit &#x3D;&#x3D;&#x3D; &#x27;FullYear&#x27; &amp;&amp; isLeapYear(mom.year()) &amp;&amp; mom.month() &#x3D;&#x3D;&#x3D; 1 &amp;&amp; mom.date() &#x3D;&#x3D;&#x3D; 29) {
	            mom._d[&#x27;set&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + unit](value, mom.month(), daysInMonth(value, mom.month()));
	        }
	        else {
	            mom._d[&#x27;set&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + unit](value);
	        }
	    }
	}

	// MOMENTS

	function stringGet (units) {
	    units &#x3D; normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}


	function stringSet (units, value) {
	    if (typeof units &#x3D;&#x3D;&#x3D; &#x27;object&#x27;) {
	        units &#x3D; normalizeObjectUnits(units);
	        var prioritized &#x3D; getPrioritizedUnits(units);
	        for (var i &#x3D; 0; i &lt; prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units &#x3D; normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}

	function mod(n, x) {
	    return ((n % x) + x) % x;
	}

	var indexOf;

	if (Array.prototype.indexOf) {
	    indexOf &#x3D; Array.prototype.indexOf;
	} else {
	    indexOf &#x3D; function (o) {
	        // I know
	        var i;
	        for (i &#x3D; 0; i &lt; this.length; ++i) {
	            if (this[i] &#x3D;&#x3D;&#x3D; o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}

	function daysInMonth(year, month) {
	    if (isNaN(year) || isNaN(month)) {
	        return NaN;
	    }
	    var modMonth &#x3D; mod(month, 12);
	    year +&#x3D; (month - modMonth) / 12;
	    return modMonth &#x3D;&#x3D;&#x3D; 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
	}

	// FORMATTING

	addFormatToken(&#x27;M&#x27;, [&#x27;MM&#x27;, 2], &#x27;Mo&#x27;, function () {
	    return this.month() + 1;
	});

	addFormatToken(&#x27;MMM&#x27;, 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});

	addFormatToken(&#x27;MMMM&#x27;, 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});

	// ALIASES

	addUnitAlias(&#x27;month&#x27;, &#x27;M&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;month&#x27;, 8);

	// PARSING

	addRegexToken(&#x27;M&#x27;,    match1to2);
	addRegexToken(&#x27;MM&#x27;,   match1to2, match2);
	addRegexToken(&#x27;MMM&#x27;,  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken(&#x27;MMMM&#x27;, function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});

	addParseToken([&#x27;M&#x27;, &#x27;MM&#x27;], function (input, array) {
	    array[MONTH] &#x3D; toInt(input) - 1;
	});

	addParseToken([&#x27;MMM&#x27;, &#x27;MMMM&#x27;], function (input, array, config, token) {
	    var month &#x3D; config._locale.monthsParse(input, token, config._strict);
	    // if we didn&#x27;t find a month name, mark the date as invalid.
	    if (month !&#x3D; null) {
	        array[MONTH] &#x3D; month;
	    } else {
	        getParsingFlags(config).invalidMonth &#x3D; input;
	    }
	});

	// LOCALES

	var MONTHS_IN_FORMAT &#x3D; /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths &#x3D; &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;);
	function localeMonths (m, format) {
	    if (!m) {
	        return isArray(this._months) ? this._months :
	            this._months[&#x27;standalone&#x27;];
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? &#x27;format&#x27; : &#x27;standalone&#x27;][m.month()];
	}

	var defaultLocaleMonthsShort &#x3D; &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;);
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return isArray(this._monthsShort) ? this._monthsShort :
	            this._monthsShort[&#x27;standalone&#x27;];
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? &#x27;format&#x27; : &#x27;standalone&#x27;][m.month()];
	}

	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc &#x3D; monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse &#x3D; [];
	        this._longMonthsParse &#x3D; [];
	        this._shortMonthsParse &#x3D; [];
	        for (i &#x3D; 0; i &lt; 12; ++i) {
	            mom &#x3D; createUTC([2000, i]);
	            this._shortMonthsParse[i] &#x3D; this.monthsShort(mom, &#x27;&#x27;).toLocaleLowerCase();
	            this._longMonthsParse[i] &#x3D; this.months(mom, &#x27;&#x27;).toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format &#x3D;&#x3D;&#x3D; &#x27;MMM&#x27;) {
	            ii &#x3D; indexOf.call(this._shortMonthsParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        } else {
	            ii &#x3D; indexOf.call(this._longMonthsParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        }
	    } else {
	        if (format &#x3D;&#x3D;&#x3D; &#x27;MMM&#x27;) {
	            ii &#x3D; indexOf.call(this._shortMonthsParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._longMonthsParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        } else {
	            ii &#x3D; indexOf.call(this._longMonthsParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._shortMonthsParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        }
	    }
	}

	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;

	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }

	    if (!this._monthsParse) {
	        this._monthsParse &#x3D; [];
	        this._longMonthsParse &#x3D; [];
	        this._shortMonthsParse &#x3D; [];
	    }

	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i &#x3D; 0; i &lt; 12; i++) {
	        // make the regex if we don&#x27;t have it already
	        mom &#x3D; createUTC([2000, i]);
	        if (strict &amp;&amp; !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] &#x3D; new RegExp(&#x27;^&#x27; + this.months(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	            this._shortMonthsParse[i] &#x3D; new RegExp(&#x27;^&#x27; + this.monthsShort(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        if (!strict &amp;&amp; !this._monthsParse[i]) {
	            regex &#x3D; &#x27;^&#x27; + this.months(mom, &#x27;&#x27;) + &#x27;|^&#x27; + this.monthsShort(mom, &#x27;&#x27;);
	            this._monthsParse[i] &#x3D; new RegExp(regex.replace(&#x27;.&#x27;, &#x27;&#x27;), &#x27;i&#x27;);
	        }
	        // test the regex
	        if (strict &amp;&amp; format &#x3D;&#x3D;&#x3D; &#x27;MMMM&#x27; &amp;&amp; this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict &amp;&amp; format &#x3D;&#x3D;&#x3D; &#x27;MMM&#x27; &amp;&amp; this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict &amp;&amp; this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function setMonth (mom, value) {
	    var dayOfMonth;

	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }

	    if (typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	        if (/^\d+$/.test(value)) {
	            value &#x3D; toInt(value);
	        } else {
	            value &#x3D; mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }

	    dayOfMonth &#x3D; Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d[&#x27;set&#x27; + (mom._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;) + &#x27;Month&#x27;](value, dayOfMonth);
	    return mom;
	}

	function getSetMonth (value) {
	    if (value !&#x3D; null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, &#x27;Month&#x27;);
	    }
	}

	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex &#x3D; matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, &#x27;_monthsRegex&#x27;)) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_monthsShortRegex&#x27;)) {
	            this._monthsShortRegex &#x3D; defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex &amp;&amp; isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}

	var defaultMonthsRegex &#x3D; matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, &#x27;_monthsRegex&#x27;)) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_monthsRegex&#x27;)) {
	            this._monthsRegex &#x3D; defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex &amp;&amp; isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}

	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var shortPieces &#x3D; [], longPieces &#x3D; [], mixedPieces &#x3D; [],
	        i, mom;
	    for (i &#x3D; 0; i &lt; 12; i++) {
	        // make the regex if we don&#x27;t have it already
	        mom &#x3D; createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, &#x27;&#x27;));
	        longPieces.push(this.months(mom, &#x27;&#x27;));
	        mixedPieces.push(this.months(mom, &#x27;&#x27;));
	        mixedPieces.push(this.monthsShort(mom, &#x27;&#x27;));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i &#x3D; 0; i &lt; 12; i++) {
	        shortPieces[i] &#x3D; regexEscape(shortPieces[i]);
	        longPieces[i] &#x3D; regexEscape(longPieces[i]);
	    }
	    for (i &#x3D; 0; i &lt; 24; i++) {
	        mixedPieces[i] &#x3D; regexEscape(mixedPieces[i]);
	    }

	    this._monthsRegex &#x3D; new RegExp(&#x27;^(&#x27; + mixedPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._monthsShortRegex &#x3D; this._monthsRegex;
	    this._monthsStrictRegex &#x3D; new RegExp(&#x27;^(&#x27; + longPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._monthsShortStrictRegex &#x3D; new RegExp(&#x27;^(&#x27; + shortPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	}

	function createDate (y, m, d, h, M, s, ms) {
	    // can&#x27;t just apply() to create a date:
	    // https://stackoverflow.com/q/181348
	    var date &#x3D; new Date(y, m, d, h, M, s, ms);

	    // the date constructor remaps years 0-99 to 1900-1999
	    if (y &lt; 100 &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	    }
	    return date;
	}

	function createUTCDate (y) {
	    var date &#x3D; new Date(Date.UTC.apply(null, arguments));

	    // the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y &lt; 100 &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	    }
	    return date;
	}

	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd &#x3D; 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw &#x3D; (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	    return -fwdlw + fwd - 1;
	}

	// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday &#x3D; (7 + weekday - dow) % 7,
	        weekOffset &#x3D; firstWeekOffset(year, dow, doy),
	        dayOfYear &#x3D; 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;

	    if (dayOfYear &lt;&#x3D; 0) {
	        resYear &#x3D; year - 1;
	        resDayOfYear &#x3D; daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear &gt; daysInYear(year)) {
	        resYear &#x3D; year + 1;
	        resDayOfYear &#x3D; dayOfYear - daysInYear(year);
	    } else {
	        resYear &#x3D; year;
	        resDayOfYear &#x3D; dayOfYear;
	    }

	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}

	function weekOfYear(mom, dow, doy) {
	    var weekOffset &#x3D; firstWeekOffset(mom.year(), dow, doy),
	        week &#x3D; Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;

	    if (week &lt; 1) {
	        resYear &#x3D; mom.year() - 1;
	        resWeek &#x3D; week + weeksInYear(resYear, dow, doy);
	    } else if (week &gt; weeksInYear(mom.year(), dow, doy)) {
	        resWeek &#x3D; week - weeksInYear(mom.year(), dow, doy);
	        resYear &#x3D; mom.year() + 1;
	    } else {
	        resYear &#x3D; mom.year();
	        resWeek &#x3D; week;
	    }

	    return {
	        week: resWeek,
	        year: resYear
	    };
	}

	function weeksInYear(year, dow, doy) {
	    var weekOffset &#x3D; firstWeekOffset(year, dow, doy),
	        weekOffsetNext &#x3D; firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

	// FORMATTING

	addFormatToken(&#x27;w&#x27;, [&#x27;ww&#x27;, 2], &#x27;wo&#x27;, &#x27;week&#x27;);
	addFormatToken(&#x27;W&#x27;, [&#x27;WW&#x27;, 2], &#x27;Wo&#x27;, &#x27;isoWeek&#x27;);

	// ALIASES

	addUnitAlias(&#x27;week&#x27;, &#x27;w&#x27;);
	addUnitAlias(&#x27;isoWeek&#x27;, &#x27;W&#x27;);

	// PRIORITIES

	addUnitPriority(&#x27;week&#x27;, 5);
	addUnitPriority(&#x27;isoWeek&#x27;, 5);

	// PARSING

	addRegexToken(&#x27;w&#x27;,  match1to2);
	addRegexToken(&#x27;ww&#x27;, match1to2, match2);
	addRegexToken(&#x27;W&#x27;,  match1to2);
	addRegexToken(&#x27;WW&#x27;, match1to2, match2);

	addWeekParseToken([&#x27;w&#x27;, &#x27;ww&#x27;, &#x27;W&#x27;, &#x27;WW&#x27;], function (input, week, config, token) {
	    week[token.substr(0, 1)] &#x3D; toInt(input);
	});

	// HELPERS

	// LOCALES

	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek &#x3D; {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 1st is the first week of the year.
	};

	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}

	function localeFirstDayOfYear () {
	    return this._week.doy;
	}

	// MOMENTS

	function getSetWeek (input) {
	    var week &#x3D; this.localeData().week(this);
	    return input &#x3D;&#x3D; null ? week : this.add((input - week) * 7, &#x27;d&#x27;);
	}

	function getSetISOWeek (input) {
	    var week &#x3D; weekOfYear(this, 1, 4).week;
	    return input &#x3D;&#x3D; null ? week : this.add((input - week) * 7, &#x27;d&#x27;);
	}

	// FORMATTING

	addFormatToken(&#x27;d&#x27;, 0, &#x27;do&#x27;, &#x27;day&#x27;);

	addFormatToken(&#x27;dd&#x27;, 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken(&#x27;ddd&#x27;, 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken(&#x27;dddd&#x27;, 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});

	addFormatToken(&#x27;e&#x27;, 0, 0, &#x27;weekday&#x27;);
	addFormatToken(&#x27;E&#x27;, 0, 0, &#x27;isoWeekday&#x27;);

	// ALIASES

	addUnitAlias(&#x27;day&#x27;, &#x27;d&#x27;);
	addUnitAlias(&#x27;weekday&#x27;, &#x27;e&#x27;);
	addUnitAlias(&#x27;isoWeekday&#x27;, &#x27;E&#x27;);

	// PRIORITY
	addUnitPriority(&#x27;day&#x27;, 11);
	addUnitPriority(&#x27;weekday&#x27;, 11);
	addUnitPriority(&#x27;isoWeekday&#x27;, 11);

	// PARSING

	addRegexToken(&#x27;d&#x27;,    match1to2);
	addRegexToken(&#x27;e&#x27;,    match1to2);
	addRegexToken(&#x27;E&#x27;,    match1to2);
	addRegexToken(&#x27;dd&#x27;,   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken(&#x27;ddd&#x27;,   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken(&#x27;dddd&#x27;,   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});

	addWeekParseToken([&#x27;dd&#x27;, &#x27;ddd&#x27;, &#x27;dddd&#x27;], function (input, week, config, token) {
	    var weekday &#x3D; config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn&#x27;t get a weekday name, mark the date as invalid
	    if (weekday !&#x3D; null) {
	        week.d &#x3D; weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday &#x3D; input;
	    }
	});

	addWeekParseToken([&#x27;d&#x27;, &#x27;e&#x27;, &#x27;E&#x27;], function (input, week, config, token) {
	    week[token] &#x3D; toInt(input);
	});

	// HELPERS

	function parseWeekday(input, locale) {
	    if (typeof input !&#x3D;&#x3D; &#x27;string&#x27;) {
	        return input;
	    }

	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }

	    input &#x3D; locale.weekdaysParse(input);
	    if (typeof input &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
	        return input;
	    }

	    return null;
	}

	function parseIsoWeekday(input, locale) {
	    if (typeof input &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}

	// LOCALES

	var defaultLocaleWeekdays &#x3D; &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;);
	function localeWeekdays (m, format) {
	    if (!m) {
	        return isArray(this._weekdays) ? this._weekdays :
	            this._weekdays[&#x27;standalone&#x27;];
	    }
	    return isArray(this._weekdays) ? this._weekdays[m.day()] :
	        this._weekdays[this._weekdays.isFormat.test(format) ? &#x27;format&#x27; : &#x27;standalone&#x27;][m.day()];
	}

	var defaultLocaleWeekdaysShort &#x3D; &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;);
	function localeWeekdaysShort (m) {
	    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}

	var defaultLocaleWeekdaysMin &#x3D; &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;);
	function localeWeekdaysMin (m) {
	    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}

	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc &#x3D; weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse &#x3D; [];
	        this._shortWeekdaysParse &#x3D; [];
	        this._minWeekdaysParse &#x3D; [];

	        for (i &#x3D; 0; i &lt; 7; ++i) {
	            mom &#x3D; createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] &#x3D; this.weekdaysMin(mom, &#x27;&#x27;).toLocaleLowerCase();
	            this._shortWeekdaysParse[i] &#x3D; this.weekdaysShort(mom, &#x27;&#x27;).toLocaleLowerCase();
	            this._weekdaysParse[i] &#x3D; this.weekdays(mom, &#x27;&#x27;).toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format &#x3D;&#x3D;&#x3D; &#x27;dddd&#x27;) {
	            ii &#x3D; indexOf.call(this._weekdaysParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        } else if (format &#x3D;&#x3D;&#x3D; &#x27;ddd&#x27;) {
	            ii &#x3D; indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        } else {
	            ii &#x3D; indexOf.call(this._minWeekdaysParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        }
	    } else {
	        if (format &#x3D;&#x3D;&#x3D; &#x27;dddd&#x27;) {
	            ii &#x3D; indexOf.call(this._weekdaysParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._minWeekdaysParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        } else if (format &#x3D;&#x3D;&#x3D; &#x27;ddd&#x27;) {
	            ii &#x3D; indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._weekdaysParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._minWeekdaysParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        } else {
	            ii &#x3D; indexOf.call(this._minWeekdaysParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._weekdaysParse, llc);
	            if (ii !&#x3D;&#x3D; -1) {
	                return ii;
	            }
	            ii &#x3D; indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !&#x3D;&#x3D; -1 ? ii : null;
	        }
	    }
	}

	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;

	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }

	    if (!this._weekdaysParse) {
	        this._weekdaysParse &#x3D; [];
	        this._minWeekdaysParse &#x3D; [];
	        this._shortWeekdaysParse &#x3D; [];
	        this._fullWeekdaysParse &#x3D; [];
	    }

	    for (i &#x3D; 0; i &lt; 7; i++) {
	        // make the regex if we don&#x27;t have it already

	        mom &#x3D; createUTC([2000, 1]).day(i);
	        if (strict &amp;&amp; !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] &#x3D; new RegExp(&#x27;^&#x27; + this.weekdays(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;\.?&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	            this._shortWeekdaysParse[i] &#x3D; new RegExp(&#x27;^&#x27; + this.weekdaysShort(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;\.?&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	            this._minWeekdaysParse[i] &#x3D; new RegExp(&#x27;^&#x27; + this.weekdaysMin(mom, &#x27;&#x27;).replace(&#x27;.&#x27;, &#x27;\.?&#x27;) + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        if (!this._weekdaysParse[i]) {
	            regex &#x3D; &#x27;^&#x27; + this.weekdays(mom, &#x27;&#x27;) + &#x27;|^&#x27; + this.weekdaysShort(mom, &#x27;&#x27;) + &#x27;|^&#x27; + this.weekdaysMin(mom, &#x27;&#x27;);
	            this._weekdaysParse[i] &#x3D; new RegExp(regex.replace(&#x27;.&#x27;, &#x27;&#x27;), &#x27;i&#x27;);
	        }
	        // test the regex
	        if (strict &amp;&amp; format &#x3D;&#x3D;&#x3D; &#x27;dddd&#x27; &amp;&amp; this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict &amp;&amp; format &#x3D;&#x3D;&#x3D; &#x27;ddd&#x27; &amp;&amp; this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict &amp;&amp; format &#x3D;&#x3D;&#x3D; &#x27;dd&#x27; &amp;&amp; this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict &amp;&amp; this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input !&#x3D; null ? this : NaN;
	    }
	    var day &#x3D; this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input !&#x3D; null) {
	        input &#x3D; parseWeekday(input, this.localeData());
	        return this.add(input - day, &#x27;d&#x27;);
	    } else {
	        return day;
	    }
	}

	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input !&#x3D; null ? this : NaN;
	    }
	    var weekday &#x3D; (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input &#x3D;&#x3D; null ? weekday : this.add(input - weekday, &#x27;d&#x27;);
	}

	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input !&#x3D; null ? this : NaN;
	    }

	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.

	    if (input !&#x3D; null) {
	        var weekday &#x3D; parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}

	var defaultWeekdaysRegex &#x3D; matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            this._weekdaysRegex &#x3D; defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex &amp;&amp; isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}

	var defaultWeekdaysShortRegex &#x3D; matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_weekdaysShortRegex&#x27;)) {
	            this._weekdaysShortRegex &#x3D; defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex &amp;&amp; isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}

	var defaultWeekdaysMinRegex &#x3D; matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, &#x27;_weekdaysRegex&#x27;)) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, &#x27;_weekdaysMinRegex&#x27;)) {
	            this._weekdaysMinRegex &#x3D; defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex &amp;&amp; isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}


	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var minPieces &#x3D; [], shortPieces &#x3D; [], longPieces &#x3D; [], mixedPieces &#x3D; [],
	        i, mom, minp, shortp, longp;
	    for (i &#x3D; 0; i &lt; 7; i++) {
	        // make the regex if we don&#x27;t have it already
	        mom &#x3D; createUTC([2000, 1]).day(i);
	        minp &#x3D; this.weekdaysMin(mom, &#x27;&#x27;);
	        shortp &#x3D; this.weekdaysShort(mom, &#x27;&#x27;);
	        longp &#x3D; this.weekdays(mom, &#x27;&#x27;);
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i &#x3D; 0; i &lt; 7; i++) {
	        shortPieces[i] &#x3D; regexEscape(shortPieces[i]);
	        longPieces[i] &#x3D; regexEscape(longPieces[i]);
	        mixedPieces[i] &#x3D; regexEscape(mixedPieces[i]);
	    }

	    this._weekdaysRegex &#x3D; new RegExp(&#x27;^(&#x27; + mixedPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._weekdaysShortRegex &#x3D; this._weekdaysRegex;
	    this._weekdaysMinRegex &#x3D; this._weekdaysRegex;

	    this._weekdaysStrictRegex &#x3D; new RegExp(&#x27;^(&#x27; + longPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._weekdaysShortStrictRegex &#x3D; new RegExp(&#x27;^(&#x27; + shortPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	    this._weekdaysMinStrictRegex &#x3D; new RegExp(&#x27;^(&#x27; + minPieces.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;i&#x27;);
	}

	// FORMATTING

	function hFormat() {
	    return this.hours() % 12 || 12;
	}

	function kFormat() {
	    return this.hours() || 24;
	}

	addFormatToken(&#x27;H&#x27;, [&#x27;HH&#x27;, 2], 0, &#x27;hour&#x27;);
	addFormatToken(&#x27;h&#x27;, [&#x27;hh&#x27;, 2], 0, hFormat);
	addFormatToken(&#x27;k&#x27;, [&#x27;kk&#x27;, 2], 0, kFormat);

	addFormatToken(&#x27;hmm&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken(&#x27;hmmss&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	addFormatToken(&#x27;Hmm&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken(&#x27;Hmmss&#x27;, 0, 0, function () {
	    return &#x27;&#x27; + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}

	meridiem(&#x27;a&#x27;, true);
	meridiem(&#x27;A&#x27;, false);

	// ALIASES

	addUnitAlias(&#x27;hour&#x27;, &#x27;h&#x27;);

	// PRIORITY
	addUnitPriority(&#x27;hour&#x27;, 13);

	// PARSING

	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}

	addRegexToken(&#x27;a&#x27;,  matchMeridiem);
	addRegexToken(&#x27;A&#x27;,  matchMeridiem);
	addRegexToken(&#x27;H&#x27;,  match1to2);
	addRegexToken(&#x27;h&#x27;,  match1to2);
	addRegexToken(&#x27;k&#x27;,  match1to2);
	addRegexToken(&#x27;HH&#x27;, match1to2, match2);
	addRegexToken(&#x27;hh&#x27;, match1to2, match2);
	addRegexToken(&#x27;kk&#x27;, match1to2, match2);

	addRegexToken(&#x27;hmm&#x27;, match3to4);
	addRegexToken(&#x27;hmmss&#x27;, match5to6);
	addRegexToken(&#x27;Hmm&#x27;, match3to4);
	addRegexToken(&#x27;Hmmss&#x27;, match5to6);

	addParseToken([&#x27;H&#x27;, &#x27;HH&#x27;], HOUR);
	addParseToken([&#x27;k&#x27;, &#x27;kk&#x27;], function (input, array, config) {
	    var kInput &#x3D; toInt(input);
	    array[HOUR] &#x3D; kInput &#x3D;&#x3D;&#x3D; 24 ? 0 : kInput;
	});
	addParseToken([&#x27;a&#x27;, &#x27;A&#x27;], function (input, array, config) {
	    config._isPm &#x3D; config._locale.isPM(input);
	    config._meridiem &#x3D; input;
	});
	addParseToken([&#x27;h&#x27;, &#x27;hh&#x27;], function (input, array, config) {
	    array[HOUR] &#x3D; toInt(input);
	    getParsingFlags(config).bigHour &#x3D; true;
	});
	addParseToken(&#x27;hmm&#x27;, function (input, array, config) {
	    var pos &#x3D; input.length - 2;
	    array[HOUR] &#x3D; toInt(input.substr(0, pos));
	    array[MINUTE] &#x3D; toInt(input.substr(pos));
	    getParsingFlags(config).bigHour &#x3D; true;
	});
	addParseToken(&#x27;hmmss&#x27;, function (input, array, config) {
	    var pos1 &#x3D; input.length - 4;
	    var pos2 &#x3D; input.length - 2;
	    array[HOUR] &#x3D; toInt(input.substr(0, pos1));
	    array[MINUTE] &#x3D; toInt(input.substr(pos1, 2));
	    array[SECOND] &#x3D; toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour &#x3D; true;
	});
	addParseToken(&#x27;Hmm&#x27;, function (input, array, config) {
	    var pos &#x3D; input.length - 2;
	    array[HOUR] &#x3D; toInt(input.substr(0, pos));
	    array[MINUTE] &#x3D; toInt(input.substr(pos));
	});
	addParseToken(&#x27;Hmmss&#x27;, function (input, array, config) {
	    var pos1 &#x3D; input.length - 4;
	    var pos2 &#x3D; input.length - 2;
	    array[HOUR] &#x3D; toInt(input.substr(0, pos1));
	    array[MINUTE] &#x3D; toInt(input.substr(pos1, 2));
	    array[SECOND] &#x3D; toInt(input.substr(pos2));
	});

	// LOCALES

	function localeIsPM (input) {
	    // IE8 Quirks Mode &amp; IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + &#x27;&#x27;).toLowerCase().charAt(0) &#x3D;&#x3D;&#x3D; &#x27;p&#x27;);
	}

	var defaultLocaleMeridiemParse &#x3D; /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours &gt; 11) {
	        return isLower ? &#x27;pm&#x27; : &#x27;PM&#x27;;
	    } else {
	        return isLower ? &#x27;am&#x27; : &#x27;AM&#x27;;
	    }
	}


	// MOMENTS

	// Setting the hour should keep the time, because the user explicitly
	// specified which hour he wants. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour &#x3D; makeGetSet(&#x27;Hours&#x27;, true);

	var baseConfig &#x3D; {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	    relativeTime: defaultRelativeTime,

	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,

	    week: defaultLocaleWeek,

	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,

	    meridiemParse: defaultLocaleMeridiemParse
	};

	// internal storage for locale config files
	var locales &#x3D; {};
	var localeFamilies &#x3D; {};
	var globalLocale;

	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace(&#x27;_&#x27;, &#x27;-&#x27;) : key;
	}

	// pick the locale from the array
	// try [&#x27;en-au&#x27;, &#x27;en-gb&#x27;] as &#x27;en-au&#x27;, &#x27;en-gb&#x27;, &#x27;en&#x27;, as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it&#x27;s a more specific variant than the current root
	function chooseLocale(names) {
	    var i &#x3D; 0, j, next, locale, split;

	    while (i &lt; names.length) {
	        split &#x3D; normalizeLocale(names[i]).split(&#x27;-&#x27;);
	        j &#x3D; split.length;
	        next &#x3D; normalizeLocale(names[i + 1]);
	        next &#x3D; next ? next.split(&#x27;-&#x27;) : null;
	        while (j &gt; 0) {
	            locale &#x3D; loadLocale(split.slice(0, j).join(&#x27;-&#x27;));
	            if (locale) {
	                return locale;
	            }
	            if (next &amp;&amp; next.length &gt;&#x3D; j &amp;&amp; compareArrays(split, next, true) &gt;&#x3D; j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return globalLocale;
	}

	function loadLocale(name) {
	    var oldLocale &#x3D; null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] &amp;&amp; (typeof module !&#x3D;&#x3D; &#x27;undefined&#x27;) &amp;&amp;
	            module &amp;&amp; module.exports) {
	        try {
	            oldLocale &#x3D; globalLocale._abbr;
	            var aliasedRequire &#x3D; require;
	            __webpack_require__(74)(&quot;./&quot; + name);
	            getSetGlobalLocale(oldLocale);
	        } catch (e) {}
	    }
	    return locales[name];
	}

	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data &#x3D; getLocale(key);
	        }
	        else {
	            data &#x3D; defineLocale(key, values);
	        }

	        if (data) {
	            // moment.duration._locale &#x3D; moment._locale &#x3D; data;
	            globalLocale &#x3D; data;
	        }
	        else {
	            if ((typeof console !&#x3D;&#x3D;  &#x27;undefined&#x27;) &amp;&amp; console.warn) {
	                //warn user if arguments are passed but the locale could not be set
	                console.warn(&#x27;Locale &#x27; + key +  &#x27; not found. Did you forget to load it?&#x27;);
	            }
	        }
	    }

	    return globalLocale._abbr;
	}

	function defineLocale (name, config) {
	    if (config !&#x3D;&#x3D; null) {
	        var locale, parentConfig &#x3D; baseConfig;
	        config.abbr &#x3D; name;
	        if (locales[name] !&#x3D; null) {
	            deprecateSimple(&#x27;defineLocaleOverride&#x27;,
	                    &#x27;use moment.updateLocale(localeName, config) to change &#x27; +
	                    &#x27;an existing locale. moment.defineLocale(localeName, &#x27; +
	                    &#x27;config) should only be used for creating a new locale &#x27; +
	                    &#x27;See http://momentjs.com/guides/#/warnings/define-locale/ for more info.&#x27;);
	            parentConfig &#x3D; locales[name]._config;
	        } else if (config.parentLocale !&#x3D; null) {
	            if (locales[config.parentLocale] !&#x3D; null) {
	                parentConfig &#x3D; locales[config.parentLocale]._config;
	            } else {
	                locale &#x3D; loadLocale(config.parentLocale);
	                if (locale !&#x3D; null) {
	                    parentConfig &#x3D; locale._config;
	                } else {
	                    if (!localeFamilies[config.parentLocale]) {
	                        localeFamilies[config.parentLocale] &#x3D; [];
	                    }
	                    localeFamilies[config.parentLocale].push({
	                        name: name,
	                        config: config
	                    });
	                    return null;
	                }
	            }
	        }
	        locales[name] &#x3D; new Locale(mergeConfigs(parentConfig, config));

	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }

	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won&#x27;t end up with the child locale set.
	        getSetGlobalLocale(name);


	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}

	function updateLocale(name, config) {
	    if (config !&#x3D; null) {
	        var locale, tmpLocale, parentConfig &#x3D; baseConfig;
	        // MERGE
	        tmpLocale &#x3D; loadLocale(name);
	        if (tmpLocale !&#x3D; null) {
	            parentConfig &#x3D; tmpLocale._config;
	        }
	        config &#x3D; mergeConfigs(parentConfig, config);
	        locale &#x3D; new Locale(config);
	        locale.parentLocale &#x3D; locales[name];
	        locales[name] &#x3D; locale;

	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] !&#x3D; null) {
	            if (locales[name].parentLocale !&#x3D; null) {
	                locales[name] &#x3D; locales[name].parentLocale;
	            } else if (locales[name] !&#x3D; null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}

	// returns locale data
	function getLocale (key) {
	    var locale;

	    if (key &amp;&amp; key._locale &amp;&amp; key._locale._abbr) {
	        key &#x3D; key._locale._abbr;
	    }

	    if (!key) {
	        return globalLocale;
	    }

	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale &#x3D; loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key &#x3D; [key];
	    }

	    return chooseLocale(key);
	}

	function listLocales() {
	    return keys(locales);
	}

	function checkOverflow (m) {
	    var overflow;
	    var a &#x3D; m._a;

	    if (a &amp;&amp; getParsingFlags(m).overflow &#x3D;&#x3D;&#x3D; -2) {
	        overflow &#x3D;
	            a[MONTH]       &lt; 0 || a[MONTH]       &gt; 11  ? MONTH :
	            a[DATE]        &lt; 1 || a[DATE]        &gt; daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        &lt; 0 || a[HOUR]        &gt; 24 || (a[HOUR] &#x3D;&#x3D;&#x3D; 24 &amp;&amp; (a[MINUTE] !&#x3D;&#x3D; 0 || a[SECOND] !&#x3D;&#x3D; 0 || a[MILLISECOND] !&#x3D;&#x3D; 0)) ? HOUR :
	            a[MINUTE]      &lt; 0 || a[MINUTE]      &gt; 59  ? MINUTE :
	            a[SECOND]      &lt; 0 || a[SECOND]      &gt; 59  ? SECOND :
	            a[MILLISECOND] &lt; 0 || a[MILLISECOND] &gt; 999 ? MILLISECOND :
	            -1;

	        if (getParsingFlags(m)._overflowDayOfYear &amp;&amp; (overflow &lt; YEAR || overflow &gt; DATE)) {
	            overflow &#x3D; DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks &amp;&amp; overflow &#x3D;&#x3D;&#x3D; -1) {
	            overflow &#x3D; WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday &amp;&amp; overflow &#x3D;&#x3D;&#x3D; -1) {
	            overflow &#x3D; WEEKDAY;
	        }

	        getParsingFlags(m).overflow &#x3D; overflow;
	    }

	    return m;
	}

	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a !&#x3D; null) {
	        return a;
	    }
	    if (b !&#x3D; null) {
	        return b;
	    }
	    return c;
	}

	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue &#x3D; new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input &#x3D; [], currentDate, expectedWeekday, yearToUse;

	    if (config._d) {
	        return;
	    }

	    currentDate &#x3D; currentDateArray(config);

	    //compute day of the year from weeks and weekdays
	    if (config._w &amp;&amp; config._a[DATE] &#x3D;&#x3D; null &amp;&amp; config._a[MONTH] &#x3D;&#x3D; null) {
	        dayOfYearFromWeekInfo(config);
	    }

	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear !&#x3D; null) {
	        yearToUse &#x3D; defaults(config._a[YEAR], currentDate[YEAR]);

	        if (config._dayOfYear &gt; daysInYear(yearToUse) || config._dayOfYear &#x3D;&#x3D;&#x3D; 0) {
	            getParsingFlags(config)._overflowDayOfYear &#x3D; true;
	        }

	        date &#x3D; createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] &#x3D; date.getUTCMonth();
	        config._a[DATE] &#x3D; date.getUTCDate();
	    }

	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don&#x27;t default anything
	    for (i &#x3D; 0; i &lt; 3 &amp;&amp; config._a[i] &#x3D;&#x3D; null; ++i) {
	        config._a[i] &#x3D; input[i] &#x3D; currentDate[i];
	    }

	    // Zero out whatever was not defaulted, including time
	    for (; i &lt; 7; i++) {
	        config._a[i] &#x3D; input[i] &#x3D; (config._a[i] &#x3D;&#x3D; null) ? (i &#x3D;&#x3D;&#x3D; 2 ? 1 : 0) : config._a[i];
	    }

	    // Check for 24:00:00.000
	    if (config._a[HOUR] &#x3D;&#x3D;&#x3D; 24 &amp;&amp;
	            config._a[MINUTE] &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
	            config._a[SECOND] &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
	            config._a[MILLISECOND] &#x3D;&#x3D;&#x3D; 0) {
	        config._nextDay &#x3D; true;
	        config._a[HOUR] &#x3D; 0;
	    }

	    config._d &#x3D; (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    expectedWeekday &#x3D; config._useUTC ? config._d.getUTCDay() : config._d.getDay();

	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm !&#x3D; null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }

	    if (config._nextDay) {
	        config._a[HOUR] &#x3D; 24;
	    }

	    // check for mismatching day of week
	    if (config._w &amp;&amp; typeof config._w.d !&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp; config._w.d !&#x3D;&#x3D; expectedWeekday) {
	        getParsingFlags(config).weekdayMismatch &#x3D; true;
	    }
	}

	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	    w &#x3D; config._w;
	    if (w.GG !&#x3D; null || w.W !&#x3D; null || w.E !&#x3D; null) {
	        dow &#x3D; 1;
	        doy &#x3D; 4;

	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear &#x3D; defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week &#x3D; defaults(w.W, 1);
	        weekday &#x3D; defaults(w.E, 1);
	        if (weekday &lt; 1 || weekday &gt; 7) {
	            weekdayOverflow &#x3D; true;
	        }
	    } else {
	        dow &#x3D; config._locale._week.dow;
	        doy &#x3D; config._locale._week.doy;

	        var curWeek &#x3D; weekOfYear(createLocal(), dow, doy);

	        weekYear &#x3D; defaults(w.gg, config._a[YEAR], curWeek.year);

	        // Default to current week.
	        week &#x3D; defaults(w.w, curWeek.week);

	        if (w.d !&#x3D; null) {
	            // weekday -- low day numbers are considered next week
	            weekday &#x3D; w.d;
	            if (weekday &lt; 0 || weekday &gt; 6) {
	                weekdayOverflow &#x3D; true;
	            }
	        } else if (w.e !&#x3D; null) {
	            // local weekday -- counting starts from begining of week
	            weekday &#x3D; w.e + dow;
	            if (w.e &lt; 0 || w.e &gt; 6) {
	                weekdayOverflow &#x3D; true;
	            }
	        } else {
	            // default to begining of week
	            weekday &#x3D; dow;
	        }
	    }
	    if (week &lt; 1 || week &gt; weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks &#x3D; true;
	    } else if (weekdayOverflow !&#x3D; null) {
	        getParsingFlags(config)._overflowWeekday &#x3D; true;
	    } else {
	        temp &#x3D; dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] &#x3D; temp.year;
	        config._dayOfYear &#x3D; temp.dayOfYear;
	    }
	}

	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex &#x3D; /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex &#x3D; /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	var tzRegex &#x3D; /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates &#x3D; [
	    [&#x27;YYYYYY-MM-DD&#x27;, /[+-]\d{6}-\d\d-\d\d/],
	    [&#x27;YYYY-MM-DD&#x27;, /\d{4}-\d\d-\d\d/],
	    [&#x27;GGGG-[W]WW-E&#x27;, /\d{4}-W\d\d-\d/],
	    [&#x27;GGGG-[W]WW&#x27;, /\d{4}-W\d\d/, false],
	    [&#x27;YYYY-DDD&#x27;, /\d{4}-\d{3}/],
	    [&#x27;YYYY-MM&#x27;, /\d{4}-\d\d/, false],
	    [&#x27;YYYYYYMMDD&#x27;, /[+-]\d{10}/],
	    [&#x27;YYYYMMDD&#x27;, /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    [&#x27;GGGG[W]WWE&#x27;, /\d{4}W\d{3}/],
	    [&#x27;GGGG[W]WW&#x27;, /\d{4}W\d{2}/, false],
	    [&#x27;YYYYDDD&#x27;, /\d{7}/]
	];

	// iso time formats and regexes
	var isoTimes &#x3D; [
	    [&#x27;HH:mm:ss.SSSS&#x27;, /\d\d:\d\d:\d\d\.\d+/],
	    [&#x27;HH:mm:ss,SSSS&#x27;, /\d\d:\d\d:\d\d,\d+/],
	    [&#x27;HH:mm:ss&#x27;, /\d\d:\d\d:\d\d/],
	    [&#x27;HH:mm&#x27;, /\d\d:\d\d/],
	    [&#x27;HHmmss.SSSS&#x27;, /\d\d\d\d\d\d\.\d+/],
	    [&#x27;HHmmss,SSSS&#x27;, /\d\d\d\d\d\d,\d+/],
	    [&#x27;HHmmss&#x27;, /\d\d\d\d\d\d/],
	    [&#x27;HHmm&#x27;, /\d\d\d\d/],
	    [&#x27;HH&#x27;, /\d\d/]
	];

	var aspNetJsonRegex &#x3D; /^\/?Date\((\-?\d+)/i;

	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string &#x3D; config._i,
	        match &#x3D; extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;

	    if (match) {
	        getParsingFlags(config).iso &#x3D; true;

	        for (i &#x3D; 0, l &#x3D; isoDates.length; i &lt; l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat &#x3D; isoDates[i][0];
	                allowTime &#x3D; isoDates[i][2] !&#x3D;&#x3D; false;
	                break;
	            }
	        }
	        if (dateFormat &#x3D;&#x3D; null) {
	            config._isValid &#x3D; false;
	            return;
	        }
	        if (match[3]) {
	            for (i &#x3D; 0, l &#x3D; isoTimes.length; i &lt; l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be &#x27;T&#x27; or space
	                    timeFormat &#x3D; (match[2] || &#x27; &#x27;) + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat &#x3D;&#x3D; null) {
	                config._isValid &#x3D; false;
	                return;
	            }
	        }
	        if (!allowTime &amp;&amp; timeFormat !&#x3D; null) {
	            config._isValid &#x3D; false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat &#x3D; &#x27;Z&#x27;;
	            } else {
	                config._isValid &#x3D; false;
	                return;
	            }
	        }
	        config._f &#x3D; dateFormat + (timeFormat || &#x27;&#x27;) + (tzFormat || &#x27;&#x27;);
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid &#x3D; false;
	    }
	}

	// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	var rfc2822 &#x3D; /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	    var result &#x3D; [
	        untruncateYear(yearStr),
	        defaultLocaleMonthsShort.indexOf(monthStr),
	        parseInt(dayStr, 10),
	        parseInt(hourStr, 10),
	        parseInt(minuteStr, 10)
	    ];

	    if (secondStr) {
	        result.push(parseInt(secondStr, 10));
	    }

	    return result;
	}

	function untruncateYear(yearStr) {
	    var year &#x3D; parseInt(yearStr, 10);
	    if (year &lt;&#x3D; 49) {
	        return 2000 + year;
	    } else if (year &lt;&#x3D; 999) {
	        return 1900 + year;
	    }
	    return year;
	}

	function preprocessRFC2822(s) {
	    // Remove comments and folding whitespace and replace multiple-spaces with a single space
	    return s.replace(/\([^)]*\)|[\n\t]/g, &#x27; &#x27;).replace(/(\s\s+)/g, &#x27; &#x27;).trim();
	}

	function checkWeekday(weekdayStr, parsedInput, config) {
	    if (weekdayStr) {
	        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	        var weekdayProvided &#x3D; defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	            weekdayActual &#x3D; new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
	        if (weekdayProvided !&#x3D;&#x3D; weekdayActual) {
	            getParsingFlags(config).weekdayMismatch &#x3D; true;
	            config._isValid &#x3D; false;
	            return false;
	        }
	    }
	    return true;
	}

	var obsOffsets &#x3D; {
	    UT: 0,
	    GMT: 0,
	    EDT: -4 * 60,
	    EST: -5 * 60,
	    CDT: -5 * 60,
	    CST: -6 * 60,
	    MDT: -6 * 60,
	    MST: -7 * 60,
	    PDT: -7 * 60,
	    PST: -8 * 60
	};

	function calculateOffset(obsOffset, militaryOffset, numOffset) {
	    if (obsOffset) {
	        return obsOffsets[obsOffset];
	    } else if (militaryOffset) {
	        // the only allowed military tz is Z
	        return 0;
	    } else {
	        var hm &#x3D; parseInt(numOffset, 10);
	        var m &#x3D; hm % 100, h &#x3D; (hm - m) / 100;
	        return h * 60 + m;
	    }
	}

	// date and time from ref 2822 format
	function configFromRFC2822(config) {
	    var match &#x3D; rfc2822.exec(preprocessRFC2822(config._i));
	    if (match) {
	        var parsedArray &#x3D; extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
	        if (!checkWeekday(match[1], parsedArray, config)) {
	            return;
	        }

	        config._a &#x3D; parsedArray;
	        config._tzm &#x3D; calculateOffset(match[8], match[9], match[10]);

	        config._d &#x3D; createUTCDate.apply(null, config._a);
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	        getParsingFlags(config).rfc2822 &#x3D; true;
	    } else {
	        config._isValid &#x3D; false;
	    }
	}

	// date from iso format or fallback
	function configFromString(config) {
	    var matched &#x3D; aspNetJsonRegex.exec(config._i);

	    if (matched !&#x3D;&#x3D; null) {
	        config._d &#x3D; new Date(+matched[1]);
	        return;
	    }

	    configFromISO(config);
	    if (config._isValid &#x3D;&#x3D;&#x3D; false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    configFromRFC2822(config);
	    if (config._isValid &#x3D;&#x3D;&#x3D; false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    // Final attempt, use Input Fallback
	    hooks.createFromInputFallback(config);
	}

	hooks.createFromInputFallback &#x3D; deprecate(
	    &#x27;value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), &#x27; +
	    &#x27;which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are &#x27; +
	    &#x27;discouraged and will be removed in an upcoming major release. Please refer to &#x27; +
	    &#x27;http://momentjs.com/guides/#/warnings/js-date/ for more info.&#x27;,
	    function (config) {
	        config._d &#x3D; new Date(config._i + (config._useUTC ? &#x27; UTC&#x27; : &#x27;&#x27;));
	    }
	);

	// constant that refers to the ISO standard
	hooks.ISO_8601 &#x3D; function () {};

	// constant that refers to the RFC 2822 form
	hooks.RFC_2822 &#x3D; function () {};

	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f &#x3D;&#x3D;&#x3D; hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }
	    if (config._f &#x3D;&#x3D;&#x3D; hooks.RFC_2822) {
	        configFromRFC2822(config);
	        return;
	    }
	    config._a &#x3D; [];
	    getParsingFlags(config).empty &#x3D; true;

	    // This array is used to make a Date, either with &#x60;new Date&#x60; or &#x60;Date.UTC&#x60;
	    var string &#x3D; &#x27;&#x27; + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength &#x3D; string.length,
	        totalParsedInputLength &#x3D; 0;

	    tokens &#x3D; expandFormat(config._f, config._locale).match(formattingTokens) || [];

	    for (i &#x3D; 0; i &lt; tokens.length; i++) {
	        token &#x3D; tokens[i];
	        parsedInput &#x3D; (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log(&#x27;token&#x27;, token, &#x27;parsedInput&#x27;, parsedInput,
	        //         &#x27;regex&#x27;, getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped &#x3D; string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length &gt; 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string &#x3D; string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength +&#x3D; parsedInput.length;
	        }
	        // don&#x27;t parse if it&#x27;s not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty &#x3D; false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict &amp;&amp; !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }

	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver &#x3D; stringLength - totalParsedInputLength;
	    if (string.length &gt; 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }

	    // clear _12h flag if hour is &lt;&#x3D; 12
	    if (config._a[HOUR] &lt;&#x3D; 12 &amp;&amp;
	        getParsingFlags(config).bigHour &#x3D;&#x3D;&#x3D; true &amp;&amp;
	        config._a[HOUR] &gt; 0) {
	        getParsingFlags(config).bigHour &#x3D; undefined;
	    }

	    getParsingFlags(config).parsedDateParts &#x3D; config._a.slice(0);
	    getParsingFlags(config).meridiem &#x3D; config._meridiem;
	    // handle meridiem
	    config._a[HOUR] &#x3D; meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	    configFromArray(config);
	    checkOverflow(config);
	}


	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;

	    if (meridiem &#x3D;&#x3D; null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour !&#x3D; null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM !&#x3D; null) {
	        // Fallback
	        isPm &#x3D; locale.isPM(meridiem);
	        if (isPm &amp;&amp; hour &lt; 12) {
	            hour +&#x3D; 12;
	        }
	        if (!isPm &amp;&amp; hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}

	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,

	        scoreToBeat,
	        i,
	        currentScore;

	    if (config._f.length &#x3D;&#x3D;&#x3D; 0) {
	        getParsingFlags(config).invalidFormat &#x3D; true;
	        config._d &#x3D; new Date(NaN);
	        return;
	    }

	    for (i &#x3D; 0; i &lt; config._f.length; i++) {
	        currentScore &#x3D; 0;
	        tempConfig &#x3D; copyConfig({}, config);
	        if (config._useUTC !&#x3D; null) {
	            tempConfig._useUTC &#x3D; config._useUTC;
	        }
	        tempConfig._f &#x3D; config._f[i];
	        configFromStringAndFormat(tempConfig);

	        if (!isValid(tempConfig)) {
	            continue;
	        }

	        // if there is any input that was not parsed add a penalty for that format
	        currentScore +&#x3D; getParsingFlags(tempConfig).charsLeftOver;

	        //or tokens
	        currentScore +&#x3D; getParsingFlags(tempConfig).unusedTokens.length * 10;

	        getParsingFlags(tempConfig).score &#x3D; currentScore;

	        if (scoreToBeat &#x3D;&#x3D; null || currentScore &lt; scoreToBeat) {
	            scoreToBeat &#x3D; currentScore;
	            bestMoment &#x3D; tempConfig;
	        }
	    }

	    extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }

	    var i &#x3D; normalizeObjectUnits(config._i);
	    config._a &#x3D; map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj &amp;&amp; parseInt(obj, 10);
	    });

	    configFromArray(config);
	}

	function createFromConfig (config) {
	    var res &#x3D; new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, &#x27;d&#x27;);
	        res._nextDay &#x3D; undefined;
	    }

	    return res;
	}

	function prepareConfig (config) {
	    var input &#x3D; config._i,
	        format &#x3D; config._f;

	    config._locale &#x3D; config._locale || getLocale(config._l);

	    if (input &#x3D;&#x3D;&#x3D; null || (format &#x3D;&#x3D;&#x3D; undefined &amp;&amp; input &#x3D;&#x3D;&#x3D; &#x27;&#x27;)) {
	        return createInvalid({nullInput: true});
	    }

	    if (typeof input &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	        config._i &#x3D; input &#x3D; config._locale.preparse(input);
	    }

	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d &#x3D; input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }

	    if (!isValid(config)) {
	        config._d &#x3D; null;
	    }

	    return config;
	}

	function configFromInput(config) {
	    var input &#x3D; config._i;
	    if (isUndefined(input)) {
	        config._d &#x3D; new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d &#x3D; new Date(input.valueOf());
	    } else if (typeof input &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a &#x3D; map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (isObject(input)) {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d &#x3D; new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}

	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c &#x3D; {};

	    if (locale &#x3D;&#x3D;&#x3D; true || locale &#x3D;&#x3D;&#x3D; false) {
	        strict &#x3D; locale;
	        locale &#x3D; undefined;
	    }

	    if ((isObject(input) &amp;&amp; isObjectEmpty(input)) ||
	            (isArray(input) &amp;&amp; input.length &#x3D;&#x3D;&#x3D; 0)) {
	        input &#x3D; undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject &#x3D; true;
	    c._useUTC &#x3D; c._isUTC &#x3D; isUTC;
	    c._l &#x3D; locale;
	    c._i &#x3D; input;
	    c._f &#x3D; format;
	    c._strict &#x3D; strict;

	    return createFromConfig(c);
	}

	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin &#x3D; deprecate(
	    &#x27;moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/&#x27;,
	    function () {
	        var other &#x3D; createLocal.apply(null, arguments);
	        if (this.isValid() &amp;&amp; other.isValid()) {
	            return other &lt; this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	var prototypeMax &#x3D; deprecate(
	    &#x27;moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/&#x27;,
	    function () {
	        var other &#x3D; createLocal.apply(null, arguments);
	        if (this.isValid() &amp;&amp; other.isValid()) {
	            return other &gt; this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; isArray(moments[0])) {
	        moments &#x3D; moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res &#x3D; moments[0];
	    for (i &#x3D; 1; i &lt; moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res &#x3D; moments[i];
	        }
	    }
	    return res;
	}

	// TODO: Use [].sort instead?
	function min () {
	    var args &#x3D; [].slice.call(arguments, 0);

	    return pickBy(&#x27;isBefore&#x27;, args);
	}

	function max () {
	    var args &#x3D; [].slice.call(arguments, 0);

	    return pickBy(&#x27;isAfter&#x27;, args);
	}

	var now &#x3D; function () {
	    return Date.now ? Date.now() : +(new Date());
	};

	var ordering &#x3D; [&#x27;year&#x27;, &#x27;quarter&#x27;, &#x27;month&#x27;, &#x27;week&#x27;, &#x27;day&#x27;, &#x27;hour&#x27;, &#x27;minute&#x27;, &#x27;second&#x27;, &#x27;millisecond&#x27;];

	function isDurationValid(m) {
	    for (var key in m) {
	        if (!(indexOf.call(ordering, key) !&#x3D;&#x3D; -1 &amp;&amp; (m[key] &#x3D;&#x3D; null || !isNaN(m[key])))) {
	            return false;
	        }
	    }

	    var unitHasDecimal &#x3D; false;
	    for (var i &#x3D; 0; i &lt; ordering.length; ++i) {
	        if (m[ordering[i]]) {
	            if (unitHasDecimal) {
	                return false; // only allow non-integers for smallest unit
	            }
	            if (parseFloat(m[ordering[i]]) !&#x3D;&#x3D; toInt(m[ordering[i]])) {
	                unitHasDecimal &#x3D; true;
	            }
	        }
	    }

	    return true;
	}

	function isValid$1() {
	    return this._isValid;
	}

	function createInvalid$1() {
	    return createDuration(NaN);
	}

	function Duration (duration) {
	    var normalizedInput &#x3D; normalizeObjectUnits(duration),
	        years &#x3D; normalizedInput.year || 0,
	        quarters &#x3D; normalizedInput.quarter || 0,
	        months &#x3D; normalizedInput.month || 0,
	        weeks &#x3D; normalizedInput.week || 0,
	        days &#x3D; normalizedInput.day || 0,
	        hours &#x3D; normalizedInput.hour || 0,
	        minutes &#x3D; normalizedInput.minute || 0,
	        seconds &#x3D; normalizedInput.second || 0,
	        milliseconds &#x3D; normalizedInput.millisecond || 0;

	    this._isValid &#x3D; isDurationValid(normalizedInput);

	    // representation for dateAddRemove
	    this._milliseconds &#x3D; +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days &#x3D; +days +
	        weeks * 7;
	    // It is impossible to translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months &#x3D; +months +
	        quarters * 3 +
	        years * 12;

	    this._data &#x3D; {};

	    this._locale &#x3D; getLocale();

	    this._bubble();
	}

	function isDuration (obj) {
	    return obj instanceof Duration;
	}

	function absRound (number) {
	    if (number &lt; 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}

	// FORMATTING

	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset &#x3D; this.utcOffset();
	        var sign &#x3D; &#x27;+&#x27;;
	        if (offset &lt; 0) {
	            offset &#x3D; -offset;
	            sign &#x3D; &#x27;-&#x27;;
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}

	offset(&#x27;Z&#x27;, &#x27;:&#x27;);
	offset(&#x27;ZZ&#x27;, &#x27;&#x27;);

	// PARSING

	addRegexToken(&#x27;Z&#x27;,  matchShortOffset);
	addRegexToken(&#x27;ZZ&#x27;, matchShortOffset);
	addParseToken([&#x27;Z&#x27;, &#x27;ZZ&#x27;], function (input, array, config) {
	    config._useUTC &#x3D; true;
	    config._tzm &#x3D; offsetFromString(matchShortOffset, input);
	});

	// HELPERS

	// timezone chunker
	// &#x27;+10:00&#x27; &gt; [&#x27;10&#x27;,  &#x27;00&#x27;]
	// &#x27;-1530&#x27;  &gt; [&#x27;-15&#x27;, &#x27;30&#x27;]
	var chunkOffset &#x3D; /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
	    var matches &#x3D; (string || &#x27;&#x27;).match(matcher);

	    if (matches &#x3D;&#x3D;&#x3D; null) {
	        return null;
	    }

	    var chunk   &#x3D; matches[matches.length - 1] || [];
	    var parts   &#x3D; (chunk + &#x27;&#x27;).match(chunkOffset) || [&#x27;-&#x27;, 0, 0];
	    var minutes &#x3D; +(parts[1] * 60) + toInt(parts[2]);

	    return minutes &#x3D;&#x3D;&#x3D; 0 ?
	      0 :
	      parts[0] &#x3D;&#x3D;&#x3D; &#x27;+&#x27; ? minutes : -minutes;
	}

	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res &#x3D; model.clone();
	        diff &#x3D; (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}

	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

	// HOOKS

	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset &#x3D; function () {};

	// MOMENTS

	// keepLocalTime &#x3D; true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--&gt;
	// 5:31:26 +0200 It is possible that 5:31:26 doesn&#x27;t exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress &#x3D;&#x3D; true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime, keepMinutes) {
	    var offset &#x3D; this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input !&#x3D; null ? this : NaN;
	    }
	    if (input !&#x3D; null) {
	        if (typeof input &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	            input &#x3D; offsetFromString(matchShortOffset, input);
	            if (input &#x3D;&#x3D;&#x3D; null) {
	                return this;
	            }
	        } else if (Math.abs(input) &lt; 16 &amp;&amp; !keepMinutes) {
	            input &#x3D; input * 60;
	        }
	        if (!this._isUTC &amp;&amp; keepLocalTime) {
	            localAdjust &#x3D; getDateOffset(this);
	        }
	        this._offset &#x3D; input;
	        this._isUTC &#x3D; true;
	        if (localAdjust !&#x3D; null) {
	            this.add(localAdjust, &#x27;m&#x27;);
	        }
	        if (offset !&#x3D;&#x3D; input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, &#x27;m&#x27;), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress &#x3D; true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress &#x3D; null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}

	function getSetZone (input, keepLocalTime) {
	    if (input !&#x3D; null) {
	        if (typeof input !&#x3D;&#x3D; &#x27;string&#x27;) {
	            input &#x3D; -input;
	        }

	        this.utcOffset(input, keepLocalTime);

	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}

	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC &#x3D; false;

	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), &#x27;m&#x27;);
	        }
	    }
	    return this;
	}

	function setOffsetToParsedOffset () {
	    if (this._tzm !&#x3D; null) {
	        this.utcOffset(this._tzm, false, true);
	    } else if (typeof this._i &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	        var tZone &#x3D; offsetFromString(matchOffset, this._i);
	        if (tZone !&#x3D; null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}

	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input &#x3D; input ? createLocal(input).utcOffset() : 0;

	    return (this.utcOffset() - input) % 60 &#x3D;&#x3D;&#x3D; 0;
	}

	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() &gt; this.clone().month(0).utcOffset() ||
	        this.utcOffset() &gt; this.clone().month(5).utcOffset()
	    );
	}

	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }

	    var c &#x3D; {};

	    copyConfig(c, this);
	    c &#x3D; prepareConfig(c);

	    if (c._a) {
	        var other &#x3D; c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted &#x3D; this.isValid() &amp;&amp;
	            compareArrays(c._a, other.toArray()) &gt; 0;
	    } else {
	        this._isDSTShifted &#x3D; false;
	    }

	    return this._isDSTShifted;
	}

	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}

	function isUtc () {
	    return this.isValid() ? this._isUTC &amp;&amp; this._offset &#x3D;&#x3D;&#x3D; 0 : false;
	}

	// ASP.NET json date format regex
	var aspNetRegex &#x3D; /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex &#x3D; /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	function createDuration (input, key) {
	    var duration &#x3D; input,
	        // matching against regexp is expensive, do it on demand
	        match &#x3D; null,
	        sign,
	        ret,
	        diffRes;

	    if (isDuration(input)) {
	        duration &#x3D; {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration &#x3D; {};
	        if (key) {
	            duration[key] &#x3D; input;
	        } else {
	            duration.milliseconds &#x3D; input;
	        }
	    } else if (!!(match &#x3D; aspNetRegex.exec(input))) {
	        sign &#x3D; (match[1] &#x3D;&#x3D;&#x3D; &#x27;-&#x27;) ? -1 : 1;
	        duration &#x3D; {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match &#x3D; isoRegex.exec(input))) {
	        sign &#x3D; (match[1] &#x3D;&#x3D;&#x3D; &#x27;-&#x27;) ? -1 : (match[1] &#x3D;&#x3D;&#x3D; &#x27;+&#x27;) ? 1 : 1;
	        duration &#x3D; {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration &#x3D;&#x3D; null) {// checks for null or undefined
	        duration &#x3D; {};
	    } else if (typeof duration &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; (&#x27;from&#x27; in duration || &#x27;to&#x27; in duration)) {
	        diffRes &#x3D; momentsDifference(createLocal(duration.from), createLocal(duration.to));

	        duration &#x3D; {};
	        duration.ms &#x3D; diffRes.milliseconds;
	        duration.M &#x3D; diffRes.months;
	    }

	    ret &#x3D; new Duration(duration);

	    if (isDuration(input) &amp;&amp; hasOwnProp(input, &#x27;_locale&#x27;)) {
	        ret._locale &#x3D; input._locale;
	    }

	    return ret;
	}

	createDuration.fn &#x3D; Duration.prototype;
	createDuration.invalid &#x3D; createInvalid$1;

	function parseIso (inp, sign) {
	    // We&#x27;d normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res &#x3D; inp &amp;&amp; parseFloat(inp.replace(&#x27;,&#x27;, &#x27;.&#x27;));
	    // apply sign while we&#x27;re at it
	    return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
	    var res &#x3D; {milliseconds: 0, months: 0};

	    res.months &#x3D; other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, &#x27;M&#x27;).isAfter(other)) {
	        --res.months;
	    }

	    res.milliseconds &#x3D; +other - +(base.clone().add(res.months, &#x27;M&#x27;));

	    return res;
	}

	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() &amp;&amp; other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }

	    other &#x3D; cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res &#x3D; positiveMomentsDifference(base, other);
	    } else {
	        res &#x3D; positiveMomentsDifference(other, base);
	        res.milliseconds &#x3D; -res.milliseconds;
	        res.months &#x3D; -res.months;
	    }

	    return res;
	}

	// TODO: remove &#x27;name&#x27; arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !&#x3D;&#x3D; null &amp;&amp; !isNaN(+period)) {
	            deprecateSimple(name, &#x27;moment().&#x27; + name  + &#x27;(period, number) is deprecated. Please use moment().&#x27; + name + &#x27;(number, period). &#x27; +
	            &#x27;See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.&#x27;);
	            tmp &#x3D; val; val &#x3D; period; period &#x3D; tmp;
	        }

	        val &#x3D; typeof val &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? +val : val;
	        dur &#x3D; createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}

	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds &#x3D; duration._milliseconds,
	        days &#x3D; absRound(duration._days),
	        months &#x3D; absRound(duration._months);

	    if (!mom.isValid()) {
	        // No op
	        return;
	    }

	    updateOffset &#x3D; updateOffset &#x3D;&#x3D; null ? true : updateOffset;

	    if (months) {
	        setMonth(mom, get(mom, &#x27;Month&#x27;) + months * isAdding);
	    }
	    if (days) {
	        set$1(mom, &#x27;Date&#x27;, get(mom, &#x27;Date&#x27;) + days * isAdding);
	    }
	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}

	var add      &#x3D; createAdder(1, &#x27;add&#x27;);
	var subtract &#x3D; createAdder(-1, &#x27;subtract&#x27;);

	function getCalendarFormat(myMoment, now) {
	    var diff &#x3D; myMoment.diff(now, &#x27;days&#x27;, true);
	    return diff &lt; -6 ? &#x27;sameElse&#x27; :
	            diff &lt; -1 ? &#x27;lastWeek&#x27; :
	            diff &lt; 0 ? &#x27;lastDay&#x27; :
	            diff &lt; 1 ? &#x27;sameDay&#x27; :
	            diff &lt; 2 ? &#x27;nextDay&#x27; :
	            diff &lt; 7 ? &#x27;nextWeek&#x27; : &#x27;sameElse&#x27;;
	}

	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we&#x27;re local/utc/offset or not.
	    var now &#x3D; time || createLocal(),
	        sod &#x3D; cloneWithOffset(now, this).startOf(&#x27;day&#x27;),
	        format &#x3D; hooks.calendarFormat(this, sod) || &#x27;sameElse&#x27;;

	    var output &#x3D; formats &amp;&amp; (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}

	function clone () {
	    return new Moment(this);
	}

	function isAfter (input, units) {
	    var localInput &#x3D; isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() &amp;&amp; localInput.isValid())) {
	        return false;
	    }
	    units &#x3D; normalizeUnits(!isUndefined(units) ? units : &#x27;millisecond&#x27;);
	    if (units &#x3D;&#x3D;&#x3D; &#x27;millisecond&#x27;) {
	        return this.valueOf() &gt; localInput.valueOf();
	    } else {
	        return localInput.valueOf() &lt; this.clone().startOf(units).valueOf();
	    }
	}

	function isBefore (input, units) {
	    var localInput &#x3D; isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() &amp;&amp; localInput.isValid())) {
	        return false;
	    }
	    units &#x3D; normalizeUnits(!isUndefined(units) ? units : &#x27;millisecond&#x27;);
	    if (units &#x3D;&#x3D;&#x3D; &#x27;millisecond&#x27;) {
	        return this.valueOf() &lt; localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() &lt; localInput.valueOf();
	    }
	}

	function isBetween (from, to, units, inclusivity) {
	    inclusivity &#x3D; inclusivity || &#x27;()&#x27;;
	    return (inclusivity[0] &#x3D;&#x3D;&#x3D; &#x27;(&#x27; ? this.isAfter(from, units) : !this.isBefore(from, units)) &amp;&amp;
	        (inclusivity[1] &#x3D;&#x3D;&#x3D; &#x27;)&#x27; ? this.isBefore(to, units) : !this.isAfter(to, units));
	}

	function isSame (input, units) {
	    var localInput &#x3D; isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() &amp;&amp; localInput.isValid())) {
	        return false;
	    }
	    units &#x3D; normalizeUnits(units || &#x27;millisecond&#x27;);
	    if (units &#x3D;&#x3D;&#x3D; &#x27;millisecond&#x27;) {
	        return this.valueOf() &#x3D;&#x3D;&#x3D; localInput.valueOf();
	    } else {
	        inputMs &#x3D; localInput.valueOf();
	        return this.clone().startOf(units).valueOf() &lt;&#x3D; inputMs &amp;&amp; inputMs &lt;&#x3D; this.clone().endOf(units).valueOf();
	    }
	}

	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input,units);
	}

	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input,units);
	}

	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        output;

	    if (!this.isValid()) {
	        return NaN;
	    }

	    that &#x3D; cloneWithOffset(input, this);

	    if (!that.isValid()) {
	        return NaN;
	    }

	    zoneDelta &#x3D; (that.utcOffset() - this.utcOffset()) * 6e4;

	    units &#x3D; normalizeUnits(units);

	    switch (units) {
	        case &#x27;year&#x27;: output &#x3D; monthDiff(this, that) / 12; break;
	        case &#x27;month&#x27;: output &#x3D; monthDiff(this, that); break;
	        case &#x27;quarter&#x27;: output &#x3D; monthDiff(this, that) / 3; break;
	        case &#x27;second&#x27;: output &#x3D; (this - that) / 1e3; break; // 1000
	        case &#x27;minute&#x27;: output &#x3D; (this - that) / 6e4; break; // 1000 * 60
	        case &#x27;hour&#x27;: output &#x3D; (this - that) / 36e5; break; // 1000 * 60 * 60
	        case &#x27;day&#x27;: output &#x3D; (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
	        case &#x27;week&#x27;: output &#x3D; (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
	        default: output &#x3D; this - that;
	    }

	    return asFloat ? output : absFloor(output);
	}

	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff &#x3D; ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor &#x3D; a.clone().add(wholeMonthDiff, &#x27;months&#x27;),
	        anchor2, adjust;

	    if (b - anchor &lt; 0) {
	        anchor2 &#x3D; a.clone().add(wholeMonthDiff - 1, &#x27;months&#x27;);
	        // linear across the month
	        adjust &#x3D; (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 &#x3D; a.clone().add(wholeMonthDiff + 1, &#x27;months&#x27;);
	        // linear across the month
	        adjust &#x3D; (b - anchor) / (anchor2 - anchor);
	    }

	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}

	hooks.defaultFormat &#x3D; &#x27;YYYY-MM-DDTHH:mm:ssZ&#x27;;
	hooks.defaultFormatUtc &#x3D; &#x27;YYYY-MM-DDTHH:mm:ss[Z]&#x27;;

	function toString () {
	    return this.clone().locale(&#x27;en&#x27;).format(&#x27;ddd MMM DD YYYY HH:mm:ss [GMT]ZZ&#x27;);
	}

	function toISOString(keepOffset) {
	    if (!this.isValid()) {
	        return null;
	    }
	    var utc &#x3D; keepOffset !&#x3D;&#x3D; true;
	    var m &#x3D; utc ? this.clone().utc() : this;
	    if (m.year() &lt; 0 || m.year() &gt; 9999) {
	        return formatMoment(m, utc ? &#x27;YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]&#x27; : &#x27;YYYYYY-MM-DD[T]HH:mm:ss.SSSZ&#x27;);
	    }
	    if (isFunction(Date.prototype.toISOString)) {
	        // native implementation is ~50x faster, use it when we can
	        if (utc) {
	            return this.toDate().toISOString();
	        } else {
	            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace(&#x27;Z&#x27;, formatMoment(m, &#x27;Z&#x27;));
	        }
	    }
	    return formatMoment(m, utc ? &#x27;YYYY-MM-DD[T]HH:mm:ss.SSS[Z]&#x27; : &#x27;YYYY-MM-DD[T]HH:mm:ss.SSSZ&#x27;);
	}

	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return &#x27;moment.invalid(/* &#x27; + this._i + &#x27; */)&#x27;;
	    }
	    var func &#x3D; &#x27;moment&#x27;;
	    var zone &#x3D; &#x27;&#x27;;
	    if (!this.isLocal()) {
	        func &#x3D; this.utcOffset() &#x3D;&#x3D;&#x3D; 0 ? &#x27;moment.utc&#x27; : &#x27;moment.parseZone&#x27;;
	        zone &#x3D; &#x27;Z&#x27;;
	    }
	    var prefix &#x3D; &#x27;[&#x27; + func + &#x27;(&quot;]&#x27;;
	    var year &#x3D; (0 &lt;&#x3D; this.year() &amp;&amp; this.year() &lt;&#x3D; 9999) ? &#x27;YYYY&#x27; : &#x27;YYYYYY&#x27;;
	    var datetime &#x3D; &#x27;-MM-DD[T]HH:mm:ss.SSS&#x27;;
	    var suffix &#x3D; zone + &#x27;[&quot;)]&#x27;;

	    return this.format(prefix + year + datetime + suffix);
	}

	function format (inputString) {
	    if (!inputString) {
	        inputString &#x3D; this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output &#x3D; formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}

	function from (time, withoutSuffix) {
	    if (this.isValid() &amp;&amp;
	            ((isMoment(time) &amp;&amp; time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}

	function to (time, withoutSuffix) {
	    if (this.isValid() &amp;&amp;
	            ((isMoment(time) &amp;&amp; time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}

	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;

	    if (key &#x3D;&#x3D;&#x3D; undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData &#x3D; getLocale(key);
	        if (newLocaleData !&#x3D; null) {
	            this._locale &#x3D; newLocaleData;
	        }
	        return this;
	    }
	}

	var lang &#x3D; deprecate(
	    &#x27;moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.&#x27;,
	    function (key) {
	        if (key &#x3D;&#x3D;&#x3D; undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);

	function localeData () {
	    return this._locale;
	}

	function startOf (units) {
	    units &#x3D; normalizeUnits(units);
	    // the following switch intentionally omits break keywords
	    // to utilize falling through the cases.
	    switch (units) {
	        case &#x27;year&#x27;:
	            this.month(0);
	            /* falls through */
	        case &#x27;quarter&#x27;:
	        case &#x27;month&#x27;:
	            this.date(1);
	            /* falls through */
	        case &#x27;week&#x27;:
	        case &#x27;isoWeek&#x27;:
	        case &#x27;day&#x27;:
	        case &#x27;date&#x27;:
	            this.hours(0);
	            /* falls through */
	        case &#x27;hour&#x27;:
	            this.minutes(0);
	            /* falls through */
	        case &#x27;minute&#x27;:
	            this.seconds(0);
	            /* falls through */
	        case &#x27;second&#x27;:
	            this.milliseconds(0);
	    }

	    // weeks are a special case
	    if (units &#x3D;&#x3D;&#x3D; &#x27;week&#x27;) {
	        this.weekday(0);
	    }
	    if (units &#x3D;&#x3D;&#x3D; &#x27;isoWeek&#x27;) {
	        this.isoWeekday(1);
	    }

	    // quarters are also special
	    if (units &#x3D;&#x3D;&#x3D; &#x27;quarter&#x27;) {
	        this.month(Math.floor(this.month() / 3) * 3);
	    }

	    return this;
	}

	function endOf (units) {
	    units &#x3D; normalizeUnits(units);
	    if (units &#x3D;&#x3D;&#x3D; undefined || units &#x3D;&#x3D;&#x3D; &#x27;millisecond&#x27;) {
	        return this;
	    }

	    // &#x27;date&#x27; is an alias for &#x27;day&#x27;, so it should be considered as such.
	    if (units &#x3D;&#x3D;&#x3D; &#x27;date&#x27;) {
	        units &#x3D; &#x27;day&#x27;;
	    }

	    return this.startOf(units).add(1, (units &#x3D;&#x3D;&#x3D; &#x27;isoWeek&#x27; ? &#x27;week&#x27; : units)).subtract(1, &#x27;ms&#x27;);
	}

	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}

	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}

	function toDate () {
	    return new Date(this.valueOf());
	}

	function toArray () {
	    var m &#x3D; this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject () {
	    var m &#x3D; this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}

	function toJSON () {
	    // new Date(NaN).toJSON() &#x3D;&#x3D;&#x3D; null
	    return this.isValid() ? this.toISOString() : null;
	}

	function isValid$2 () {
	    return isValid(this);
	}

	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}

	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}

	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}

	// FORMATTING

	addFormatToken(0, [&#x27;gg&#x27;, 2], 0, function () {
	    return this.weekYear() % 100;
	});

	addFormatToken(0, [&#x27;GG&#x27;, 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken(&#x27;gggg&#x27;,     &#x27;weekYear&#x27;);
	addWeekYearFormatToken(&#x27;ggggg&#x27;,    &#x27;weekYear&#x27;);
	addWeekYearFormatToken(&#x27;GGGG&#x27;,  &#x27;isoWeekYear&#x27;);
	addWeekYearFormatToken(&#x27;GGGGG&#x27;, &#x27;isoWeekYear&#x27;);

	// ALIASES

	addUnitAlias(&#x27;weekYear&#x27;, &#x27;gg&#x27;);
	addUnitAlias(&#x27;isoWeekYear&#x27;, &#x27;GG&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;weekYear&#x27;, 1);
	addUnitPriority(&#x27;isoWeekYear&#x27;, 1);


	// PARSING

	addRegexToken(&#x27;G&#x27;,      matchSigned);
	addRegexToken(&#x27;g&#x27;,      matchSigned);
	addRegexToken(&#x27;GG&#x27;,     match1to2, match2);
	addRegexToken(&#x27;gg&#x27;,     match1to2, match2);
	addRegexToken(&#x27;GGGG&#x27;,   match1to4, match4);
	addRegexToken(&#x27;gggg&#x27;,   match1to4, match4);
	addRegexToken(&#x27;GGGGG&#x27;,  match1to6, match6);
	addRegexToken(&#x27;ggggg&#x27;,  match1to6, match6);

	addWeekParseToken([&#x27;gggg&#x27;, &#x27;ggggg&#x27;, &#x27;GGGG&#x27;, &#x27;GGGGG&#x27;], function (input, week, config, token) {
	    week[token.substr(0, 2)] &#x3D; toInt(input);
	});

	addWeekParseToken([&#x27;gg&#x27;, &#x27;GG&#x27;], function (input, week, config, token) {
	    week[token] &#x3D; hooks.parseTwoDigitYear(input);
	});

	// MOMENTS

	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}

	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear () {
	    var weekInfo &#x3D; this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input &#x3D;&#x3D; null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget &#x3D; weeksInYear(input, dow, doy);
	        if (week &gt; weeksTarget) {
	            week &#x3D; weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData &#x3D; dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date &#x3D; createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}

	// FORMATTING

	addFormatToken(&#x27;Q&#x27;, 0, &#x27;Qo&#x27;, &#x27;quarter&#x27;);

	// ALIASES

	addUnitAlias(&#x27;quarter&#x27;, &#x27;Q&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;quarter&#x27;, 7);

	// PARSING

	addRegexToken(&#x27;Q&#x27;, match1);
	addParseToken(&#x27;Q&#x27;, function (input, array) {
	    array[MONTH] &#x3D; (toInt(input) - 1) * 3;
	});

	// MOMENTS

	function getSetQuarter (input) {
	    return input &#x3D;&#x3D; null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

	// FORMATTING

	addFormatToken(&#x27;D&#x27;, [&#x27;DD&#x27;, 2], &#x27;Do&#x27;, &#x27;date&#x27;);

	// ALIASES

	addUnitAlias(&#x27;date&#x27;, &#x27;D&#x27;);

	// PRIOROITY
	addUnitPriority(&#x27;date&#x27;, 9);

	// PARSING

	addRegexToken(&#x27;D&#x27;,  match1to2);
	addRegexToken(&#x27;DD&#x27;, match1to2, match2);
	addRegexToken(&#x27;Do&#x27;, function (isStrict, locale) {
	    // TODO: Remove &quot;ordinalParse&quot; fallback in next major release.
	    return isStrict ?
	      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
	      locale._dayOfMonthOrdinalParseLenient;
	});

	addParseToken([&#x27;D&#x27;, &#x27;DD&#x27;], DATE);
	addParseToken(&#x27;Do&#x27;, function (input, array) {
	    array[DATE] &#x3D; toInt(input.match(match1to2)[0]);
	});

	// MOMENTS

	var getSetDayOfMonth &#x3D; makeGetSet(&#x27;Date&#x27;, true);

	// FORMATTING

	addFormatToken(&#x27;DDD&#x27;, [&#x27;DDDD&#x27;, 3], &#x27;DDDo&#x27;, &#x27;dayOfYear&#x27;);

	// ALIASES

	addUnitAlias(&#x27;dayOfYear&#x27;, &#x27;DDD&#x27;);

	// PRIORITY
	addUnitPriority(&#x27;dayOfYear&#x27;, 4);

	// PARSING

	addRegexToken(&#x27;DDD&#x27;,  match1to3);
	addRegexToken(&#x27;DDDD&#x27;, match3);
	addParseToken([&#x27;DDD&#x27;, &#x27;DDDD&#x27;], function (input, array, config) {
	    config._dayOfYear &#x3D; toInt(input);
	});

	// HELPERS

	// MOMENTS

	function getSetDayOfYear (input) {
	    var dayOfYear &#x3D; Math.round((this.clone().startOf(&#x27;day&#x27;) - this.clone().startOf(&#x27;year&#x27;)) / 864e5) + 1;
	    return input &#x3D;&#x3D; null ? dayOfYear : this.add((input - dayOfYear), &#x27;d&#x27;);
	}

	// FORMATTING

	addFormatToken(&#x27;m&#x27;, [&#x27;mm&#x27;, 2], 0, &#x27;minute&#x27;);

	// ALIASES

	addUnitAlias(&#x27;minute&#x27;, &#x27;m&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;minute&#x27;, 14);

	// PARSING

	addRegexToken(&#x27;m&#x27;,  match1to2);
	addRegexToken(&#x27;mm&#x27;, match1to2, match2);
	addParseToken([&#x27;m&#x27;, &#x27;mm&#x27;], MINUTE);

	// MOMENTS

	var getSetMinute &#x3D; makeGetSet(&#x27;Minutes&#x27;, false);

	// FORMATTING

	addFormatToken(&#x27;s&#x27;, [&#x27;ss&#x27;, 2], 0, &#x27;second&#x27;);

	// ALIASES

	addUnitAlias(&#x27;second&#x27;, &#x27;s&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;second&#x27;, 15);

	// PARSING

	addRegexToken(&#x27;s&#x27;,  match1to2);
	addRegexToken(&#x27;ss&#x27;, match1to2, match2);
	addParseToken([&#x27;s&#x27;, &#x27;ss&#x27;], SECOND);

	// MOMENTS

	var getSetSecond &#x3D; makeGetSet(&#x27;Seconds&#x27;, false);

	// FORMATTING

	addFormatToken(&#x27;S&#x27;, 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, [&#x27;SS&#x27;, 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, [&#x27;SSS&#x27;, 3], 0, &#x27;millisecond&#x27;);
	addFormatToken(0, [&#x27;SSSS&#x27;, 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, [&#x27;SSSSS&#x27;, 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, [&#x27;SSSSSS&#x27;, 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, [&#x27;SSSSSSS&#x27;, 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, [&#x27;SSSSSSSS&#x27;, 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, [&#x27;SSSSSSSSS&#x27;, 9], 0, function () {
	    return this.millisecond() * 1000000;
	});


	// ALIASES

	addUnitAlias(&#x27;millisecond&#x27;, &#x27;ms&#x27;);

	// PRIORITY

	addUnitPriority(&#x27;millisecond&#x27;, 16);

	// PARSING

	addRegexToken(&#x27;S&#x27;,    match1to3, match1);
	addRegexToken(&#x27;SS&#x27;,   match1to3, match2);
	addRegexToken(&#x27;SSS&#x27;,  match1to3, match3);

	var token;
	for (token &#x3D; &#x27;SSSS&#x27;; token.length &lt;&#x3D; 9; token +&#x3D; &#x27;S&#x27;) {
	    addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
	    array[MILLISECOND] &#x3D; toInt((&#x27;0.&#x27; + input) * 1000);
	}

	for (token &#x3D; &#x27;S&#x27;; token.length &lt;&#x3D; 9; token +&#x3D; &#x27;S&#x27;) {
	    addParseToken(token, parseMs);
	}
	// MOMENTS

	var getSetMillisecond &#x3D; makeGetSet(&#x27;Milliseconds&#x27;, false);

	// FORMATTING

	addFormatToken(&#x27;z&#x27;,  0, 0, &#x27;zoneAbbr&#x27;);
	addFormatToken(&#x27;zz&#x27;, 0, 0, &#x27;zoneName&#x27;);

	// MOMENTS

	function getZoneAbbr () {
	    return this._isUTC ? &#x27;UTC&#x27; : &#x27;&#x27;;
	}

	function getZoneName () {
	    return this._isUTC ? &#x27;Coordinated Universal Time&#x27; : &#x27;&#x27;;
	}

	var proto &#x3D; Moment.prototype;

	proto.add               &#x3D; add;
	proto.calendar          &#x3D; calendar$1;
	proto.clone             &#x3D; clone;
	proto.diff              &#x3D; diff;
	proto.endOf             &#x3D; endOf;
	proto.format            &#x3D; format;
	proto.from              &#x3D; from;
	proto.fromNow           &#x3D; fromNow;
	proto.to                &#x3D; to;
	proto.toNow             &#x3D; toNow;
	proto.get               &#x3D; stringGet;
	proto.invalidAt         &#x3D; invalidAt;
	proto.isAfter           &#x3D; isAfter;
	proto.isBefore          &#x3D; isBefore;
	proto.isBetween         &#x3D; isBetween;
	proto.isSame            &#x3D; isSame;
	proto.isSameOrAfter     &#x3D; isSameOrAfter;
	proto.isSameOrBefore    &#x3D; isSameOrBefore;
	proto.isValid           &#x3D; isValid$2;
	proto.lang              &#x3D; lang;
	proto.locale            &#x3D; locale;
	proto.localeData        &#x3D; localeData;
	proto.max               &#x3D; prototypeMax;
	proto.min               &#x3D; prototypeMin;
	proto.parsingFlags      &#x3D; parsingFlags;
	proto.set               &#x3D; stringSet;
	proto.startOf           &#x3D; startOf;
	proto.subtract          &#x3D; subtract;
	proto.toArray           &#x3D; toArray;
	proto.toObject          &#x3D; toObject;
	proto.toDate            &#x3D; toDate;
	proto.toISOString       &#x3D; toISOString;
	proto.inspect           &#x3D; inspect;
	proto.toJSON            &#x3D; toJSON;
	proto.toString          &#x3D; toString;
	proto.unix              &#x3D; unix;
	proto.valueOf           &#x3D; valueOf;
	proto.creationData      &#x3D; creationData;
	proto.year       &#x3D; getSetYear;
	proto.isLeapYear &#x3D; getIsLeapYear;
	proto.weekYear    &#x3D; getSetWeekYear;
	proto.isoWeekYear &#x3D; getSetISOWeekYear;
	proto.quarter &#x3D; proto.quarters &#x3D; getSetQuarter;
	proto.month       &#x3D; getSetMonth;
	proto.daysInMonth &#x3D; getDaysInMonth;
	proto.week           &#x3D; proto.weeks        &#x3D; getSetWeek;
	proto.isoWeek        &#x3D; proto.isoWeeks     &#x3D; getSetISOWeek;
	proto.weeksInYear    &#x3D; getWeeksInYear;
	proto.isoWeeksInYear &#x3D; getISOWeeksInYear;
	proto.date       &#x3D; getSetDayOfMonth;
	proto.day        &#x3D; proto.days             &#x3D; getSetDayOfWeek;
	proto.weekday    &#x3D; getSetLocaleDayOfWeek;
	proto.isoWeekday &#x3D; getSetISODayOfWeek;
	proto.dayOfYear  &#x3D; getSetDayOfYear;
	proto.hour &#x3D; proto.hours &#x3D; getSetHour;
	proto.minute &#x3D; proto.minutes &#x3D; getSetMinute;
	proto.second &#x3D; proto.seconds &#x3D; getSetSecond;
	proto.millisecond &#x3D; proto.milliseconds &#x3D; getSetMillisecond;
	proto.utcOffset            &#x3D; getSetOffset;
	proto.utc                  &#x3D; setOffsetToUTC;
	proto.local                &#x3D; setOffsetToLocal;
	proto.parseZone            &#x3D; setOffsetToParsedOffset;
	proto.hasAlignedHourOffset &#x3D; hasAlignedHourOffset;
	proto.isDST                &#x3D; isDaylightSavingTime;
	proto.isLocal              &#x3D; isLocal;
	proto.isUtcOffset          &#x3D; isUtcOffset;
	proto.isUtc                &#x3D; isUtc;
	proto.isUTC                &#x3D; isUtc;
	proto.zoneAbbr &#x3D; getZoneAbbr;
	proto.zoneName &#x3D; getZoneName;
	proto.dates  &#x3D; deprecate(&#x27;dates accessor is deprecated. Use date instead.&#x27;, getSetDayOfMonth);
	proto.months &#x3D; deprecate(&#x27;months accessor is deprecated. Use month instead&#x27;, getSetMonth);
	proto.years  &#x3D; deprecate(&#x27;years accessor is deprecated. Use year instead&#x27;, getSetYear);
	proto.zone   &#x3D; deprecate(&#x27;moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/&#x27;, getSetZone);
	proto.isDSTShifted &#x3D; deprecate(&#x27;isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information&#x27;, isDaylightSavingTimeShifted);

	function createUnix (input) {
	    return createLocal(input * 1000);
	}

	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}

	function preParsePostFormat (string) {
	    return string;
	}

	var proto$1 &#x3D; Locale.prototype;

	proto$1.calendar        &#x3D; calendar;
	proto$1.longDateFormat  &#x3D; longDateFormat;
	proto$1.invalidDate     &#x3D; invalidDate;
	proto$1.ordinal         &#x3D; ordinal;
	proto$1.preparse        &#x3D; preParsePostFormat;
	proto$1.postformat      &#x3D; preParsePostFormat;
	proto$1.relativeTime    &#x3D; relativeTime;
	proto$1.pastFuture      &#x3D; pastFuture;
	proto$1.set             &#x3D; set;

	proto$1.months            &#x3D;        localeMonths;
	proto$1.monthsShort       &#x3D;        localeMonthsShort;
	proto$1.monthsParse       &#x3D;        localeMonthsParse;
	proto$1.monthsRegex       &#x3D; monthsRegex;
	proto$1.monthsShortRegex  &#x3D; monthsShortRegex;
	proto$1.week &#x3D; localeWeek;
	proto$1.firstDayOfYear &#x3D; localeFirstDayOfYear;
	proto$1.firstDayOfWeek &#x3D; localeFirstDayOfWeek;

	proto$1.weekdays       &#x3D;        localeWeekdays;
	proto$1.weekdaysMin    &#x3D;        localeWeekdaysMin;
	proto$1.weekdaysShort  &#x3D;        localeWeekdaysShort;
	proto$1.weekdaysParse  &#x3D;        localeWeekdaysParse;

	proto$1.weekdaysRegex       &#x3D;        weekdaysRegex;
	proto$1.weekdaysShortRegex  &#x3D;        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    &#x3D;        weekdaysMinRegex;

	proto$1.isPM &#x3D; localeIsPM;
	proto$1.meridiem &#x3D; localeMeridiem;

	function get$1 (format, index, field, setter) {
	    var locale &#x3D; getLocale();
	    var utc &#x3D; createUTC().set(setter, index);
	    return locale[field](utc, format);
	}

	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index &#x3D; format;
	        format &#x3D; undefined;
	    }

	    format &#x3D; format || &#x27;&#x27;;

	    if (index !&#x3D; null) {
	        return get$1(format, index, field, &#x27;month&#x27;);
	    }

	    var i;
	    var out &#x3D; [];
	    for (i &#x3D; 0; i &lt; 12; i++) {
	        out[i] &#x3D; get$1(format, i, field, &#x27;month&#x27;);
	    }
	    return out;
	}

	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
	        if (isNumber(format)) {
	            index &#x3D; format;
	            format &#x3D; undefined;
	        }

	        format &#x3D; format || &#x27;&#x27;;
	    } else {
	        format &#x3D; localeSorted;
	        index &#x3D; format;
	        localeSorted &#x3D; false;

	        if (isNumber(format)) {
	            index &#x3D; format;
	            format &#x3D; undefined;
	        }

	        format &#x3D; format || &#x27;&#x27;;
	    }

	    var locale &#x3D; getLocale(),
	        shift &#x3D; localeSorted ? locale._week.dow : 0;

	    if (index !&#x3D; null) {
	        return get$1(format, (index + shift) % 7, field, &#x27;day&#x27;);
	    }

	    var i;
	    var out &#x3D; [];
	    for (i &#x3D; 0; i &lt; 7; i++) {
	        out[i] &#x3D; get$1(format, (i + shift) % 7, field, &#x27;day&#x27;);
	    }
	    return out;
	}

	function listMonths (format, index) {
	    return listMonthsImpl(format, index, &#x27;months&#x27;);
	}

	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, &#x27;monthsShort&#x27;);
	}

	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, &#x27;weekdays&#x27;);
	}

	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, &#x27;weekdaysShort&#x27;);
	}

	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, &#x27;weekdaysMin&#x27;);
	}

	getSetGlobalLocale(&#x27;en&#x27;, {
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (toInt(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    }
	});

	// Side effect imports

	hooks.lang &#x3D; deprecate(&#x27;moment.lang is deprecated. Use moment.locale instead.&#x27;, getSetGlobalLocale);
	hooks.langData &#x3D; deprecate(&#x27;moment.langData is deprecated. Use moment.localeData instead.&#x27;, getLocale);

	var mathAbs &#x3D; Math.abs;

	function abs () {
	    var data           &#x3D; this._data;

	    this._milliseconds &#x3D; mathAbs(this._milliseconds);
	    this._days         &#x3D; mathAbs(this._days);
	    this._months       &#x3D; mathAbs(this._months);

	    data.milliseconds  &#x3D; mathAbs(data.milliseconds);
	    data.seconds       &#x3D; mathAbs(data.seconds);
	    data.minutes       &#x3D; mathAbs(data.minutes);
	    data.hours         &#x3D; mathAbs(data.hours);
	    data.months        &#x3D; mathAbs(data.months);
	    data.years         &#x3D; mathAbs(data.years);

	    return this;
	}

	function addSubtract$1 (duration, input, value, direction) {
	    var other &#x3D; createDuration(input, value);

	    duration._milliseconds +&#x3D; direction * other._milliseconds;
	    duration._days         +&#x3D; direction * other._days;
	    duration._months       +&#x3D; direction * other._months;

	    return duration._bubble();
	}

	// supports only 2.0-style add(1, &#x27;s&#x27;) or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}

	// supports only 2.0-style subtract(1, &#x27;s&#x27;) or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}

	function absCeil (number) {
	    if (number &lt; 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}

	function bubble () {
	    var milliseconds &#x3D; this._milliseconds;
	    var days         &#x3D; this._days;
	    var months       &#x3D; this._months;
	    var data         &#x3D; this._data;
	    var seconds, minutes, hours, years, monthsFromDays;

	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds &gt;&#x3D; 0 &amp;&amp; days &gt;&#x3D; 0 &amp;&amp; months &gt;&#x3D; 0) ||
	            (milliseconds &lt;&#x3D; 0 &amp;&amp; days &lt;&#x3D; 0 &amp;&amp; months &lt;&#x3D; 0))) {
	        milliseconds +&#x3D; absCeil(monthsToDays(months) + days) * 864e5;
	        days &#x3D; 0;
	        months &#x3D; 0;
	    }

	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds &#x3D; milliseconds % 1000;

	    seconds           &#x3D; absFloor(milliseconds / 1000);
	    data.seconds      &#x3D; seconds % 60;

	    minutes           &#x3D; absFloor(seconds / 60);
	    data.minutes      &#x3D; minutes % 60;

	    hours             &#x3D; absFloor(minutes / 60);
	    data.hours        &#x3D; hours % 24;

	    days +&#x3D; absFloor(hours / 24);

	    // convert days to months
	    monthsFromDays &#x3D; absFloor(daysToMonths(days));
	    months +&#x3D; monthsFromDays;
	    days -&#x3D; absCeil(monthsToDays(monthsFromDays));

	    // 12 months -&gt; 1 year
	    years &#x3D; absFloor(months / 12);
	    months %&#x3D; 12;

	    data.days   &#x3D; days;
	    data.months &#x3D; months;
	    data.years  &#x3D; years;

	    return this;
	}

	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months &#x3D;&#x3D;&#x3D; 4800
	    return days * 4800 / 146097;
	}

	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}

	function as (units) {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    var days;
	    var months;
	    var milliseconds &#x3D; this._milliseconds;

	    units &#x3D; normalizeUnits(units);

	    if (units &#x3D;&#x3D;&#x3D; &#x27;month&#x27; || units &#x3D;&#x3D;&#x3D; &#x27;year&#x27;) {
	        days   &#x3D; this._days   + milliseconds / 864e5;
	        months &#x3D; this._months + daysToMonths(days);
	        return units &#x3D;&#x3D;&#x3D; &#x27;month&#x27; ? months : months / 12;
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days &#x3D; this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case &#x27;week&#x27;   : return days / 7     + milliseconds / 6048e5;
	            case &#x27;day&#x27;    : return days         + milliseconds / 864e5;
	            case &#x27;hour&#x27;   : return days * 24    + milliseconds / 36e5;
	            case &#x27;minute&#x27; : return days * 1440  + milliseconds / 6e4;
	            case &#x27;second&#x27; : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case &#x27;millisecond&#x27;: return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error(&#x27;Unknown unit &#x27; + units);
	        }
	    }
	}

	// TODO: Use this.as(&#x27;ms&#x27;)?
	function valueOf$1 () {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}

	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}

	var asMilliseconds &#x3D; makeAs(&#x27;ms&#x27;);
	var asSeconds      &#x3D; makeAs(&#x27;s&#x27;);
	var asMinutes      &#x3D; makeAs(&#x27;m&#x27;);
	var asHours        &#x3D; makeAs(&#x27;h&#x27;);
	var asDays         &#x3D; makeAs(&#x27;d&#x27;);
	var asWeeks        &#x3D; makeAs(&#x27;w&#x27;);
	var asMonths       &#x3D; makeAs(&#x27;M&#x27;);
	var asYears        &#x3D; makeAs(&#x27;y&#x27;);

	function clone$1 () {
	    return createDuration(this);
	}

	function get$2 (units) {
	    units &#x3D; normalizeUnits(units);
	    return this.isValid() ? this[units + &#x27;s&#x27;]() : NaN;
	}

	function makeGetter(name) {
	    return function () {
	        return this.isValid() ? this._data[name] : NaN;
	    };
	}

	var milliseconds &#x3D; makeGetter(&#x27;milliseconds&#x27;);
	var seconds      &#x3D; makeGetter(&#x27;seconds&#x27;);
	var minutes      &#x3D; makeGetter(&#x27;minutes&#x27;);
	var hours        &#x3D; makeGetter(&#x27;hours&#x27;);
	var days         &#x3D; makeGetter(&#x27;days&#x27;);
	var months       &#x3D; makeGetter(&#x27;months&#x27;);
	var years        &#x3D; makeGetter(&#x27;years&#x27;);

	function weeks () {
	    return absFloor(this.days() / 7);
	}

	var round &#x3D; Math.round;
	var thresholds &#x3D; {
	    ss: 44,         // a few seconds to seconds
	    s : 45,         // seconds to minute
	    m : 45,         // minutes to hour
	    h : 22,         // hours to day
	    d : 26,         // days to month
	    M : 11          // months to year
	};

	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration &#x3D; createDuration(posNegDuration).abs();
	    var seconds  &#x3D; round(duration.as(&#x27;s&#x27;));
	    var minutes  &#x3D; round(duration.as(&#x27;m&#x27;));
	    var hours    &#x3D; round(duration.as(&#x27;h&#x27;));
	    var days     &#x3D; round(duration.as(&#x27;d&#x27;));
	    var months   &#x3D; round(duration.as(&#x27;M&#x27;));
	    var years    &#x3D; round(duration.as(&#x27;y&#x27;));

	    var a &#x3D; seconds &lt;&#x3D; thresholds.ss &amp;&amp; [&#x27;s&#x27;, seconds]  ||
	            seconds &lt; thresholds.s   &amp;&amp; [&#x27;ss&#x27;, seconds] ||
	            minutes &lt;&#x3D; 1             &amp;&amp; [&#x27;m&#x27;]           ||
	            minutes &lt; thresholds.m   &amp;&amp; [&#x27;mm&#x27;, minutes] ||
	            hours   &lt;&#x3D; 1             &amp;&amp; [&#x27;h&#x27;]           ||
	            hours   &lt; thresholds.h   &amp;&amp; [&#x27;hh&#x27;, hours]   ||
	            days    &lt;&#x3D; 1             &amp;&amp; [&#x27;d&#x27;]           ||
	            days    &lt; thresholds.d   &amp;&amp; [&#x27;dd&#x27;, days]    ||
	            months  &lt;&#x3D; 1             &amp;&amp; [&#x27;M&#x27;]           ||
	            months  &lt; thresholds.M   &amp;&amp; [&#x27;MM&#x27;, months]  ||
	            years   &lt;&#x3D; 1             &amp;&amp; [&#x27;y&#x27;]           || [&#x27;yy&#x27;, years];

	    a[2] &#x3D; withoutSuffix;
	    a[3] &#x3D; +posNegDuration &gt; 0;
	    a[4] &#x3D; locale;
	    return substituteTimeAgo.apply(null, a);
	}

	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction &#x3D;&#x3D;&#x3D; undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
	        round &#x3D; roundingFunction;
	        return true;
	    }
	    return false;
	}

	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] &#x3D;&#x3D;&#x3D; undefined) {
	        return false;
	    }
	    if (limit &#x3D;&#x3D;&#x3D; undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] &#x3D; limit;
	    if (threshold &#x3D;&#x3D;&#x3D; &#x27;s&#x27;) {
	        thresholds.ss &#x3D; limit - 1;
	    }
	    return true;
	}

	function humanize (withSuffix) {
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var locale &#x3D; this.localeData();
	    var output &#x3D; relativeTime$1(this, !withSuffix, locale);

	    if (withSuffix) {
	        output &#x3D; locale.pastFuture(+this, output);
	    }

	    return locale.postformat(output);
	}

	var abs$1 &#x3D; Math.abs;

	function sign(x) {
	    return ((x &gt; 0) - (x &lt; 0)) || +x;
	}

	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var seconds &#x3D; abs$1(this._milliseconds) / 1000;
	    var days         &#x3D; abs$1(this._days);
	    var months       &#x3D; abs$1(this._months);
	    var minutes, hours, years;

	    // 3600 seconds -&gt; 60 minutes -&gt; 1 hour
	    minutes           &#x3D; absFloor(seconds / 60);
	    hours             &#x3D; absFloor(minutes / 60);
	    seconds %&#x3D; 60;
	    minutes %&#x3D; 60;

	    // 12 months -&gt; 1 year
	    years  &#x3D; absFloor(months / 12);
	    months %&#x3D; 12;


	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y &#x3D; years;
	    var M &#x3D; months;
	    var D &#x3D; days;
	    var h &#x3D; hours;
	    var m &#x3D; minutes;
	    var s &#x3D; seconds ? seconds.toFixed(3).replace(/\.?0+$/, &#x27;&#x27;) : &#x27;&#x27;;
	    var total &#x3D; this.asSeconds();

	    if (!total) {
	        // this is the same as C#&#x27;s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return &#x27;P0D&#x27;;
	    }

	    var totalSign &#x3D; total &lt; 0 ? &#x27;-&#x27; : &#x27;&#x27;;
	    var ymSign &#x3D; sign(this._months) !&#x3D;&#x3D; sign(total) ? &#x27;-&#x27; : &#x27;&#x27;;
	    var daysSign &#x3D; sign(this._days) !&#x3D;&#x3D; sign(total) ? &#x27;-&#x27; : &#x27;&#x27;;
	    var hmsSign &#x3D; sign(this._milliseconds) !&#x3D;&#x3D; sign(total) ? &#x27;-&#x27; : &#x27;&#x27;;

	    return totalSign + &#x27;P&#x27; +
	        (Y ? ymSign + Y + &#x27;Y&#x27; : &#x27;&#x27;) +
	        (M ? ymSign + M + &#x27;M&#x27; : &#x27;&#x27;) +
	        (D ? daysSign + D + &#x27;D&#x27; : &#x27;&#x27;) +
	        ((h || m || s) ? &#x27;T&#x27; : &#x27;&#x27;) +
	        (h ? hmsSign + h + &#x27;H&#x27; : &#x27;&#x27;) +
	        (m ? hmsSign + m + &#x27;M&#x27; : &#x27;&#x27;) +
	        (s ? hmsSign + s + &#x27;S&#x27; : &#x27;&#x27;);
	}

	var proto$2 &#x3D; Duration.prototype;

	proto$2.isValid        &#x3D; isValid$1;
	proto$2.abs            &#x3D; abs;
	proto$2.add            &#x3D; add$1;
	proto$2.subtract       &#x3D; subtract$1;
	proto$2.as             &#x3D; as;
	proto$2.asMilliseconds &#x3D; asMilliseconds;
	proto$2.asSeconds      &#x3D; asSeconds;
	proto$2.asMinutes      &#x3D; asMinutes;
	proto$2.asHours        &#x3D; asHours;
	proto$2.asDays         &#x3D; asDays;
	proto$2.asWeeks        &#x3D; asWeeks;
	proto$2.asMonths       &#x3D; asMonths;
	proto$2.asYears        &#x3D; asYears;
	proto$2.valueOf        &#x3D; valueOf$1;
	proto$2._bubble        &#x3D; bubble;
	proto$2.clone          &#x3D; clone$1;
	proto$2.get            &#x3D; get$2;
	proto$2.milliseconds   &#x3D; milliseconds;
	proto$2.seconds        &#x3D; seconds;
	proto$2.minutes        &#x3D; minutes;
	proto$2.hours          &#x3D; hours;
	proto$2.days           &#x3D; days;
	proto$2.weeks          &#x3D; weeks;
	proto$2.months         &#x3D; months;
	proto$2.years          &#x3D; years;
	proto$2.humanize       &#x3D; humanize;
	proto$2.toISOString    &#x3D; toISOString$1;
	proto$2.toString       &#x3D; toISOString$1;
	proto$2.toJSON         &#x3D; toISOString$1;
	proto$2.locale         &#x3D; locale;
	proto$2.localeData     &#x3D; localeData;

	proto$2.toIsoString &#x3D; deprecate(&#x27;toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)&#x27;, toISOString$1);
	proto$2.lang &#x3D; lang;

	// Side effect imports

	// FORMATTING

	addFormatToken(&#x27;X&#x27;, 0, 0, &#x27;unix&#x27;);
	addFormatToken(&#x27;x&#x27;, 0, 0, &#x27;valueOf&#x27;);

	// PARSING

	addRegexToken(&#x27;x&#x27;, matchSigned);
	addRegexToken(&#x27;X&#x27;, matchTimestamp);
	addParseToken(&#x27;X&#x27;, function (input, array, config) {
	    config._d &#x3D; new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken(&#x27;x&#x27;, function (input, array, config) {
	    config._d &#x3D; new Date(toInt(input));
	});

	// Side effect imports


	hooks.version &#x3D; &#x27;2.21.0&#x27;;

	setHookCallback(createLocal);

	hooks.fn                    &#x3D; proto;
	hooks.min                   &#x3D; min;
	hooks.max                   &#x3D; max;
	hooks.now                   &#x3D; now;
	hooks.utc                   &#x3D; createUTC;
	hooks.unix                  &#x3D; createUnix;
	hooks.months                &#x3D; listMonths;
	hooks.isDate                &#x3D; isDate;
	hooks.locale                &#x3D; getSetGlobalLocale;
	hooks.invalid               &#x3D; createInvalid;
	hooks.duration              &#x3D; createDuration;
	hooks.isMoment              &#x3D; isMoment;
	hooks.weekdays              &#x3D; listWeekdays;
	hooks.parseZone             &#x3D; createInZone;
	hooks.localeData            &#x3D; getLocale;
	hooks.isDuration            &#x3D; isDuration;
	hooks.monthsShort           &#x3D; listMonthsShort;
	hooks.weekdaysMin           &#x3D; listWeekdaysMin;
	hooks.defineLocale          &#x3D; defineLocale;
	hooks.updateLocale          &#x3D; updateLocale;
	hooks.locales               &#x3D; listLocales;
	hooks.weekdaysShort         &#x3D; listWeekdaysShort;
	hooks.normalizeUnits        &#x3D; normalizeUnits;
	hooks.relativeTimeRounding  &#x3D; getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold &#x3D; getSetRelativeTimeThreshold;
	hooks.calendarFormat        &#x3D; getCalendarFormat;
	hooks.prototype             &#x3D; proto;

	// currently HTML5 input type only supports 24-hour formats
	hooks.HTML5_FMT &#x3D; {
	    DATETIME_LOCAL: &#x27;YYYY-MM-DDTHH:mm&#x27;,             // &lt;input type&#x3D;&quot;datetime-local&quot; /&gt;
	    DATETIME_LOCAL_SECONDS: &#x27;YYYY-MM-DDTHH:mm:ss&#x27;,  // &lt;input type&#x3D;&quot;datetime-local&quot; step&#x3D;&quot;1&quot; /&gt;
	    DATETIME_LOCAL_MS: &#x27;YYYY-MM-DDTHH:mm:ss.SSS&#x27;,   // &lt;input type&#x3D;&quot;datetime-local&quot; step&#x3D;&quot;0.001&quot; /&gt;
	    DATE: &#x27;YYYY-MM-DD&#x27;,                             // &lt;input type&#x3D;&quot;date&quot; /&gt;
	    TIME: &#x27;HH:mm&#x27;,                                  // &lt;input type&#x3D;&quot;time&quot; /&gt;
	    TIME_SECONDS: &#x27;HH:mm:ss&#x27;,                       // &lt;input type&#x3D;&quot;time&quot; step&#x3D;&quot;1&quot; /&gt;
	    TIME_MS: &#x27;HH:mm:ss.SSS&#x27;,                        // &lt;input type&#x3D;&quot;time&quot; step&#x3D;&quot;0.001&quot; /&gt;
	    WEEK: &#x27;YYYY-[W]WW&#x27;,                             // &lt;input type&#x3D;&quot;week&quot; /&gt;
	    MONTH: &#x27;YYYY-MM&#x27;                                // &lt;input type&#x3D;&quot;month&quot; /&gt;
	};

	return hooks;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)(module)))

/***/ }),
/* 73 */
/***/ (function(module, exports) {

	module.exports &#x3D; function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate &#x3D; function() {};
			module.paths &#x3D; [];
			// module.parent &#x3D; undefined by default
			module.children &#x3D; [];
			module.webpackPolyfill &#x3D; 1;
		}
		return module;
	}


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var map &#x3D; {
		&quot;./af&quot;: 75,
		&quot;./af.js&quot;: 75,
		&quot;./ar&quot;: 76,
		&quot;./ar-dz&quot;: 77,
		&quot;./ar-dz.js&quot;: 77,
		&quot;./ar-kw&quot;: 78,
		&quot;./ar-kw.js&quot;: 78,
		&quot;./ar-ly&quot;: 79,
		&quot;./ar-ly.js&quot;: 79,
		&quot;./ar-ma&quot;: 80,
		&quot;./ar-ma.js&quot;: 80,
		&quot;./ar-sa&quot;: 81,
		&quot;./ar-sa.js&quot;: 81,
		&quot;./ar-tn&quot;: 82,
		&quot;./ar-tn.js&quot;: 82,
		&quot;./ar.js&quot;: 76,
		&quot;./az&quot;: 83,
		&quot;./az.js&quot;: 83,
		&quot;./be&quot;: 84,
		&quot;./be.js&quot;: 84,
		&quot;./bg&quot;: 85,
		&quot;./bg.js&quot;: 85,
		&quot;./bm&quot;: 86,
		&quot;./bm.js&quot;: 86,
		&quot;./bn&quot;: 87,
		&quot;./bn.js&quot;: 87,
		&quot;./bo&quot;: 88,
		&quot;./bo.js&quot;: 88,
		&quot;./br&quot;: 89,
		&quot;./br.js&quot;: 89,
		&quot;./bs&quot;: 90,
		&quot;./bs.js&quot;: 90,
		&quot;./ca&quot;: 91,
		&quot;./ca.js&quot;: 91,
		&quot;./cs&quot;: 92,
		&quot;./cs.js&quot;: 92,
		&quot;./cv&quot;: 93,
		&quot;./cv.js&quot;: 93,
		&quot;./cy&quot;: 94,
		&quot;./cy.js&quot;: 94,
		&quot;./da&quot;: 95,
		&quot;./da.js&quot;: 95,
		&quot;./de&quot;: 96,
		&quot;./de-at&quot;: 97,
		&quot;./de-at.js&quot;: 97,
		&quot;./de-ch&quot;: 98,
		&quot;./de-ch.js&quot;: 98,
		&quot;./de.js&quot;: 96,
		&quot;./dv&quot;: 99,
		&quot;./dv.js&quot;: 99,
		&quot;./el&quot;: 100,
		&quot;./el.js&quot;: 100,
		&quot;./en-au&quot;: 101,
		&quot;./en-au.js&quot;: 101,
		&quot;./en-ca&quot;: 102,
		&quot;./en-ca.js&quot;: 102,
		&quot;./en-gb&quot;: 103,
		&quot;./en-gb.js&quot;: 103,
		&quot;./en-ie&quot;: 104,
		&quot;./en-ie.js&quot;: 104,
		&quot;./en-il&quot;: 105,
		&quot;./en-il.js&quot;: 105,
		&quot;./en-nz&quot;: 106,
		&quot;./en-nz.js&quot;: 106,
		&quot;./eo&quot;: 107,
		&quot;./eo.js&quot;: 107,
		&quot;./es&quot;: 108,
		&quot;./es-do&quot;: 109,
		&quot;./es-do.js&quot;: 109,
		&quot;./es-us&quot;: 110,
		&quot;./es-us.js&quot;: 110,
		&quot;./es.js&quot;: 108,
		&quot;./et&quot;: 111,
		&quot;./et.js&quot;: 111,
		&quot;./eu&quot;: 112,
		&quot;./eu.js&quot;: 112,
		&quot;./fa&quot;: 113,
		&quot;./fa.js&quot;: 113,
		&quot;./fi&quot;: 114,
		&quot;./fi.js&quot;: 114,
		&quot;./fo&quot;: 115,
		&quot;./fo.js&quot;: 115,
		&quot;./fr&quot;: 116,
		&quot;./fr-ca&quot;: 117,
		&quot;./fr-ca.js&quot;: 117,
		&quot;./fr-ch&quot;: 118,
		&quot;./fr-ch.js&quot;: 118,
		&quot;./fr.js&quot;: 116,
		&quot;./fy&quot;: 119,
		&quot;./fy.js&quot;: 119,
		&quot;./gd&quot;: 120,
		&quot;./gd.js&quot;: 120,
		&quot;./gl&quot;: 121,
		&quot;./gl.js&quot;: 121,
		&quot;./gom-latn&quot;: 122,
		&quot;./gom-latn.js&quot;: 122,
		&quot;./gu&quot;: 123,
		&quot;./gu.js&quot;: 123,
		&quot;./he&quot;: 124,
		&quot;./he.js&quot;: 124,
		&quot;./hi&quot;: 125,
		&quot;./hi.js&quot;: 125,
		&quot;./hr&quot;: 126,
		&quot;./hr.js&quot;: 126,
		&quot;./hu&quot;: 127,
		&quot;./hu.js&quot;: 127,
		&quot;./hy-am&quot;: 128,
		&quot;./hy-am.js&quot;: 128,
		&quot;./id&quot;: 129,
		&quot;./id.js&quot;: 129,
		&quot;./is&quot;: 130,
		&quot;./is.js&quot;: 130,
		&quot;./it&quot;: 131,
		&quot;./it.js&quot;: 131,
		&quot;./ja&quot;: 132,
		&quot;./ja.js&quot;: 132,
		&quot;./jv&quot;: 133,
		&quot;./jv.js&quot;: 133,
		&quot;./ka&quot;: 134,
		&quot;./ka.js&quot;: 134,
		&quot;./kk&quot;: 135,
		&quot;./kk.js&quot;: 135,
		&quot;./km&quot;: 136,
		&quot;./km.js&quot;: 136,
		&quot;./kn&quot;: 137,
		&quot;./kn.js&quot;: 137,
		&quot;./ko&quot;: 138,
		&quot;./ko.js&quot;: 138,
		&quot;./ky&quot;: 139,
		&quot;./ky.js&quot;: 139,
		&quot;./lb&quot;: 140,
		&quot;./lb.js&quot;: 140,
		&quot;./lo&quot;: 141,
		&quot;./lo.js&quot;: 141,
		&quot;./lt&quot;: 142,
		&quot;./lt.js&quot;: 142,
		&quot;./lv&quot;: 143,
		&quot;./lv.js&quot;: 143,
		&quot;./me&quot;: 144,
		&quot;./me.js&quot;: 144,
		&quot;./mi&quot;: 145,
		&quot;./mi.js&quot;: 145,
		&quot;./mk&quot;: 146,
		&quot;./mk.js&quot;: 146,
		&quot;./ml&quot;: 147,
		&quot;./ml.js&quot;: 147,
		&quot;./mr&quot;: 148,
		&quot;./mr.js&quot;: 148,
		&quot;./ms&quot;: 149,
		&quot;./ms-my&quot;: 150,
		&quot;./ms-my.js&quot;: 150,
		&quot;./ms.js&quot;: 149,
		&quot;./mt&quot;: 151,
		&quot;./mt.js&quot;: 151,
		&quot;./my&quot;: 152,
		&quot;./my.js&quot;: 152,
		&quot;./nb&quot;: 153,
		&quot;./nb.js&quot;: 153,
		&quot;./ne&quot;: 154,
		&quot;./ne.js&quot;: 154,
		&quot;./nl&quot;: 155,
		&quot;./nl-be&quot;: 156,
		&quot;./nl-be.js&quot;: 156,
		&quot;./nl.js&quot;: 155,
		&quot;./nn&quot;: 157,
		&quot;./nn.js&quot;: 157,
		&quot;./pa-in&quot;: 158,
		&quot;./pa-in.js&quot;: 158,
		&quot;./pl&quot;: 159,
		&quot;./pl.js&quot;: 159,
		&quot;./pt&quot;: 160,
		&quot;./pt-br&quot;: 161,
		&quot;./pt-br.js&quot;: 161,
		&quot;./pt.js&quot;: 160,
		&quot;./ro&quot;: 162,
		&quot;./ro.js&quot;: 162,
		&quot;./ru&quot;: 163,
		&quot;./ru.js&quot;: 163,
		&quot;./sd&quot;: 164,
		&quot;./sd.js&quot;: 164,
		&quot;./se&quot;: 165,
		&quot;./se.js&quot;: 165,
		&quot;./si&quot;: 166,
		&quot;./si.js&quot;: 166,
		&quot;./sk&quot;: 167,
		&quot;./sk.js&quot;: 167,
		&quot;./sl&quot;: 168,
		&quot;./sl.js&quot;: 168,
		&quot;./sq&quot;: 169,
		&quot;./sq.js&quot;: 169,
		&quot;./sr&quot;: 170,
		&quot;./sr-cyrl&quot;: 171,
		&quot;./sr-cyrl.js&quot;: 171,
		&quot;./sr.js&quot;: 170,
		&quot;./ss&quot;: 172,
		&quot;./ss.js&quot;: 172,
		&quot;./sv&quot;: 173,
		&quot;./sv.js&quot;: 173,
		&quot;./sw&quot;: 174,
		&quot;./sw.js&quot;: 174,
		&quot;./ta&quot;: 175,
		&quot;./ta.js&quot;: 175,
		&quot;./te&quot;: 176,
		&quot;./te.js&quot;: 176,
		&quot;./tet&quot;: 177,
		&quot;./tet.js&quot;: 177,
		&quot;./tg&quot;: 178,
		&quot;./tg.js&quot;: 178,
		&quot;./th&quot;: 179,
		&quot;./th.js&quot;: 179,
		&quot;./tl-ph&quot;: 180,
		&quot;./tl-ph.js&quot;: 180,
		&quot;./tlh&quot;: 181,
		&quot;./tlh.js&quot;: 181,
		&quot;./tr&quot;: 182,
		&quot;./tr.js&quot;: 182,
		&quot;./tzl&quot;: 183,
		&quot;./tzl.js&quot;: 183,
		&quot;./tzm&quot;: 184,
		&quot;./tzm-latn&quot;: 185,
		&quot;./tzm-latn.js&quot;: 185,
		&quot;./tzm.js&quot;: 184,
		&quot;./ug-cn&quot;: 186,
		&quot;./ug-cn.js&quot;: 186,
		&quot;./uk&quot;: 187,
		&quot;./uk.js&quot;: 187,
		&quot;./ur&quot;: 188,
		&quot;./ur.js&quot;: 188,
		&quot;./uz&quot;: 189,
		&quot;./uz-latn&quot;: 190,
		&quot;./uz-latn.js&quot;: 190,
		&quot;./uz.js&quot;: 189,
		&quot;./vi&quot;: 191,
		&quot;./vi.js&quot;: 191,
		&quot;./x-pseudo&quot;: 192,
		&quot;./x-pseudo.js&quot;: 192,
		&quot;./yo&quot;: 193,
		&quot;./yo.js&quot;: 193,
		&quot;./zh-cn&quot;: 194,
		&quot;./zh-cn.js&quot;: 194,
		&quot;./zh-hk&quot;: 195,
		&quot;./zh-hk.js&quot;: 195,
		&quot;./zh-tw&quot;: 196,
		&quot;./zh-tw.js&quot;: 196
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error(&quot;Cannot find module &#x27;&quot; + req + &quot;&#x27;.&quot;) }());
	};
	webpackContext.keys &#x3D; function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve &#x3D; webpackContextResolve;
	module.exports &#x3D; webpackContext;
	webpackContext.id &#x3D; 74;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var af &#x3D; moment.defineLocale(&#x27;af&#x27;, {
	    months : &#x27;Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Son_Maa_Din_Woe_Don_Vry_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Ma_Di_Wo_Do_Vr_Sa&#x27;.split(&#x27;_&#x27;),
	    meridiemParse: /vm|nm/i,
	    isPM : function (input) {
	        return /^nm$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 12) {
	            return isLower ? &#x27;vm&#x27; : &#x27;VM&#x27;;
	        } else {
	            return isLower ? &#x27;nm&#x27; : &#x27;NM&#x27;;
	        }
	    },
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Vandag om] LT&#x27;,
	        nextDay : &#x27;[Môre om] LT&#x27;,
	        nextWeek : &#x27;dddd [om] LT&#x27;,
	        lastDay : &#x27;[Gister om] LT&#x27;,
	        lastWeek : &#x27;[Laas] dddd [om] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;oor %s&#x27;,
	        past : &#x27;%s gelede&#x27;,
	        s : &#x27;\&#x27;n paar sekondes&#x27;,
	        ss : &#x27;%d sekondes&#x27;,
	        m : &#x27;\&#x27;n minuut&#x27;,
	        mm : &#x27;%d minute&#x27;,
	        h : &#x27;\&#x27;n uur&#x27;,
	        hh : &#x27;%d ure&#x27;,
	        d : &#x27;\&#x27;n dag&#x27;,
	        dd : &#x27;%d dae&#x27;,
	        M : &#x27;\&#x27;n maand&#x27;,
	        MM : &#x27;%d maande&#x27;,
	        y : &#x27;\&#x27;n jaar&#x27;,
	        yy : &#x27;%d jaar&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number &#x3D;&#x3D;&#x3D; 1 || number &#x3D;&#x3D;&#x3D; 8 || number &gt;&#x3D; 20) ? &#x27;ste&#x27; : &#x27;de&#x27;); // Thanks to Joris Röling : https://github.com/jjupiter
	    },
	    week : {
	        dow : 1, // Maandag is die eerste dag van die week.
	        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	    }
	});

	return af;

	})));


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;١&#x27;,
	    &#x27;2&#x27;: &#x27;٢&#x27;,
	    &#x27;3&#x27;: &#x27;٣&#x27;,
	    &#x27;4&#x27;: &#x27;٤&#x27;,
	    &#x27;5&#x27;: &#x27;٥&#x27;,
	    &#x27;6&#x27;: &#x27;٦&#x27;,
	    &#x27;7&#x27;: &#x27;٧&#x27;,
	    &#x27;8&#x27;: &#x27;٨&#x27;,
	    &#x27;9&#x27;: &#x27;٩&#x27;,
	    &#x27;0&#x27;: &#x27;٠&#x27;
	}, numberMap &#x3D; {
	    &#x27;١&#x27;: &#x27;1&#x27;,
	    &#x27;٢&#x27;: &#x27;2&#x27;,
	    &#x27;٣&#x27;: &#x27;3&#x27;,
	    &#x27;٤&#x27;: &#x27;4&#x27;,
	    &#x27;٥&#x27;: &#x27;5&#x27;,
	    &#x27;٦&#x27;: &#x27;6&#x27;,
	    &#x27;٧&#x27;: &#x27;7&#x27;,
	    &#x27;٨&#x27;: &#x27;8&#x27;,
	    &#x27;٩&#x27;: &#x27;9&#x27;,
	    &#x27;٠&#x27;: &#x27;0&#x27;
	}, pluralForm &#x3D; function (n) {
	    return n &#x3D;&#x3D;&#x3D; 0 ? 0 : n &#x3D;&#x3D;&#x3D; 1 ? 1 : n &#x3D;&#x3D;&#x3D; 2 ? 2 : n % 100 &gt;&#x3D; 3 &amp;&amp; n % 100 &lt;&#x3D; 10 ? 3 : n % 100 &gt;&#x3D; 11 ? 4 : 5;
	}, plurals &#x3D; {
	    s : [&#x27;أقل من ثانية&#x27;, &#x27;ثانية واحدة&#x27;, [&#x27;ثانيتان&#x27;, &#x27;ثانيتين&#x27;], &#x27;%d ثوان&#x27;, &#x27;%d ثانية&#x27;, &#x27;%d ثانية&#x27;],
	    m : [&#x27;أقل من دقيقة&#x27;, &#x27;دقيقة واحدة&#x27;, [&#x27;دقيقتان&#x27;, &#x27;دقيقتين&#x27;], &#x27;%d دقائق&#x27;, &#x27;%d دقيقة&#x27;, &#x27;%d دقيقة&#x27;],
	    h : [&#x27;أقل من ساعة&#x27;, &#x27;ساعة واحدة&#x27;, [&#x27;ساعتان&#x27;, &#x27;ساعتين&#x27;], &#x27;%d ساعات&#x27;, &#x27;%d ساعة&#x27;, &#x27;%d ساعة&#x27;],
	    d : [&#x27;أقل من يوم&#x27;, &#x27;يوم واحد&#x27;, [&#x27;يومان&#x27;, &#x27;يومين&#x27;], &#x27;%d أيام&#x27;, &#x27;%d يومًا&#x27;, &#x27;%d يوم&#x27;],
	    M : [&#x27;أقل من شهر&#x27;, &#x27;شهر واحد&#x27;, [&#x27;شهران&#x27;, &#x27;شهرين&#x27;], &#x27;%d أشهر&#x27;, &#x27;%d شهرا&#x27;, &#x27;%d شهر&#x27;],
	    y : [&#x27;أقل من عام&#x27;, &#x27;عام واحد&#x27;, [&#x27;عامان&#x27;, &#x27;عامين&#x27;], &#x27;%d أعوام&#x27;, &#x27;%d عامًا&#x27;, &#x27;%d عام&#x27;]
	}, pluralize &#x3D; function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f &#x3D; pluralForm(number),
	            str &#x3D; plurals[u][pluralForm(number)];
	        if (f &#x3D;&#x3D;&#x3D; 2) {
	            str &#x3D; str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	}, months &#x3D; [
	    &#x27;يناير&#x27;,
	    &#x27;فبراير&#x27;,
	    &#x27;مارس&#x27;,
	    &#x27;أبريل&#x27;,
	    &#x27;مايو&#x27;,
	    &#x27;يونيو&#x27;,
	    &#x27;يوليو&#x27;,
	    &#x27;أغسطس&#x27;,
	    &#x27;سبتمبر&#x27;,
	    &#x27;أكتوبر&#x27;,
	    &#x27;نوفمبر&#x27;,
	    &#x27;ديسمبر&#x27;
	];

	var ar &#x3D; moment.defineLocale(&#x27;ar&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;D/\u200FM/\u200FYYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return &#x27;م&#x27; &#x3D;&#x3D;&#x3D; input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ص&#x27;;
	        } else {
	            return &#x27;م&#x27;;
	        }
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم عند الساعة] LT&#x27;,
	        nextDay: &#x27;[غدًا عند الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس عند الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;بعد %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : pluralize(&#x27;s&#x27;),
	        ss : pluralize(&#x27;s&#x27;),
	        m : pluralize(&#x27;m&#x27;),
	        mm : pluralize(&#x27;m&#x27;),
	        h : pluralize(&#x27;h&#x27;),
	        hh : pluralize(&#x27;h&#x27;),
	        d : pluralize(&#x27;d&#x27;),
	        dd : pluralize(&#x27;d&#x27;),
	        M : pluralize(&#x27;M&#x27;),
	        MM : pluralize(&#x27;M&#x27;),
	        y : pluralize(&#x27;y&#x27;),
	        yy : pluralize(&#x27;y&#x27;)
	    },
	    preparse: function (string) {
	        return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ar;

	})));


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arDz &#x3D; moment.defineLocale(&#x27;ar-dz&#x27;, {
	    months : &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;أح_إث_ثلا_أر_خم_جم_سب&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 4  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arDz;

	})));


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arKw &#x3D; moment.defineLocale(&#x27;ar-kw&#x27;, {
	    months : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arKw;

	})));


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;1&#x27;,
	    &#x27;2&#x27;: &#x27;2&#x27;,
	    &#x27;3&#x27;: &#x27;3&#x27;,
	    &#x27;4&#x27;: &#x27;4&#x27;,
	    &#x27;5&#x27;: &#x27;5&#x27;,
	    &#x27;6&#x27;: &#x27;6&#x27;,
	    &#x27;7&#x27;: &#x27;7&#x27;,
	    &#x27;8&#x27;: &#x27;8&#x27;,
	    &#x27;9&#x27;: &#x27;9&#x27;,
	    &#x27;0&#x27;: &#x27;0&#x27;
	}, pluralForm &#x3D; function (n) {
	    return n &#x3D;&#x3D;&#x3D; 0 ? 0 : n &#x3D;&#x3D;&#x3D; 1 ? 1 : n &#x3D;&#x3D;&#x3D; 2 ? 2 : n % 100 &gt;&#x3D; 3 &amp;&amp; n % 100 &lt;&#x3D; 10 ? 3 : n % 100 &gt;&#x3D; 11 ? 4 : 5;
	}, plurals &#x3D; {
	    s : [&#x27;أقل من ثانية&#x27;, &#x27;ثانية واحدة&#x27;, [&#x27;ثانيتان&#x27;, &#x27;ثانيتين&#x27;], &#x27;%d ثوان&#x27;, &#x27;%d ثانية&#x27;, &#x27;%d ثانية&#x27;],
	    m : [&#x27;أقل من دقيقة&#x27;, &#x27;دقيقة واحدة&#x27;, [&#x27;دقيقتان&#x27;, &#x27;دقيقتين&#x27;], &#x27;%d دقائق&#x27;, &#x27;%d دقيقة&#x27;, &#x27;%d دقيقة&#x27;],
	    h : [&#x27;أقل من ساعة&#x27;, &#x27;ساعة واحدة&#x27;, [&#x27;ساعتان&#x27;, &#x27;ساعتين&#x27;], &#x27;%d ساعات&#x27;, &#x27;%d ساعة&#x27;, &#x27;%d ساعة&#x27;],
	    d : [&#x27;أقل من يوم&#x27;, &#x27;يوم واحد&#x27;, [&#x27;يومان&#x27;, &#x27;يومين&#x27;], &#x27;%d أيام&#x27;, &#x27;%d يومًا&#x27;, &#x27;%d يوم&#x27;],
	    M : [&#x27;أقل من شهر&#x27;, &#x27;شهر واحد&#x27;, [&#x27;شهران&#x27;, &#x27;شهرين&#x27;], &#x27;%d أشهر&#x27;, &#x27;%d شهرا&#x27;, &#x27;%d شهر&#x27;],
	    y : [&#x27;أقل من عام&#x27;, &#x27;عام واحد&#x27;, [&#x27;عامان&#x27;, &#x27;عامين&#x27;], &#x27;%d أعوام&#x27;, &#x27;%d عامًا&#x27;, &#x27;%d عام&#x27;]
	}, pluralize &#x3D; function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f &#x3D; pluralForm(number),
	            str &#x3D; plurals[u][pluralForm(number)];
	        if (f &#x3D;&#x3D;&#x3D; 2) {
	            str &#x3D; str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	}, months &#x3D; [
	    &#x27;يناير&#x27;,
	    &#x27;فبراير&#x27;,
	    &#x27;مارس&#x27;,
	    &#x27;أبريل&#x27;,
	    &#x27;مايو&#x27;,
	    &#x27;يونيو&#x27;,
	    &#x27;يوليو&#x27;,
	    &#x27;أغسطس&#x27;,
	    &#x27;سبتمبر&#x27;,
	    &#x27;أكتوبر&#x27;,
	    &#x27;نوفمبر&#x27;,
	    &#x27;ديسمبر&#x27;
	];

	var arLy &#x3D; moment.defineLocale(&#x27;ar-ly&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;D/\u200FM/\u200FYYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return &#x27;م&#x27; &#x3D;&#x3D;&#x3D; input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ص&#x27;;
	        } else {
	            return &#x27;م&#x27;;
	        }
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم عند الساعة] LT&#x27;,
	        nextDay: &#x27;[غدًا عند الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس عند الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [عند الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;بعد %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : pluralize(&#x27;s&#x27;),
	        ss : pluralize(&#x27;s&#x27;),
	        m : pluralize(&#x27;m&#x27;),
	        mm : pluralize(&#x27;m&#x27;),
	        h : pluralize(&#x27;h&#x27;),
	        hh : pluralize(&#x27;h&#x27;),
	        d : pluralize(&#x27;d&#x27;),
	        dd : pluralize(&#x27;d&#x27;),
	        M : pluralize(&#x27;M&#x27;),
	        MM : pluralize(&#x27;M&#x27;),
	        y : pluralize(&#x27;y&#x27;),
	        yy : pluralize(&#x27;y&#x27;)
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arLy;

	})));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arMa &#x3D; moment.defineLocale(&#x27;ar-ma&#x27;, {
	    months : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arMa;

	})));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;١&#x27;,
	    &#x27;2&#x27;: &#x27;٢&#x27;,
	    &#x27;3&#x27;: &#x27;٣&#x27;,
	    &#x27;4&#x27;: &#x27;٤&#x27;,
	    &#x27;5&#x27;: &#x27;٥&#x27;,
	    &#x27;6&#x27;: &#x27;٦&#x27;,
	    &#x27;7&#x27;: &#x27;٧&#x27;,
	    &#x27;8&#x27;: &#x27;٨&#x27;,
	    &#x27;9&#x27;: &#x27;٩&#x27;,
	    &#x27;0&#x27;: &#x27;٠&#x27;
	}, numberMap &#x3D; {
	    &#x27;١&#x27;: &#x27;1&#x27;,
	    &#x27;٢&#x27;: &#x27;2&#x27;,
	    &#x27;٣&#x27;: &#x27;3&#x27;,
	    &#x27;٤&#x27;: &#x27;4&#x27;,
	    &#x27;٥&#x27;: &#x27;5&#x27;,
	    &#x27;٦&#x27;: &#x27;6&#x27;,
	    &#x27;٧&#x27;: &#x27;7&#x27;,
	    &#x27;٨&#x27;: &#x27;8&#x27;,
	    &#x27;٩&#x27;: &#x27;9&#x27;,
	    &#x27;٠&#x27;: &#x27;0&#x27;
	};

	var arSa &#x3D; moment.defineLocale(&#x27;ar-sa&#x27;, {
	    months : &#x27;يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return &#x27;م&#x27; &#x3D;&#x3D;&#x3D; input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ص&#x27;;
	        } else {
	            return &#x27;م&#x27;;
	        }
	    },
	    calendar : {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;في %s&#x27;,
	        past : &#x27;منذ %s&#x27;,
	        s : &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m : &#x27;دقيقة&#x27;,
	        mm : &#x27;%d دقائق&#x27;,
	        h : &#x27;ساعة&#x27;,
	        hh : &#x27;%d ساعات&#x27;,
	        d : &#x27;يوم&#x27;,
	        dd : &#x27;%d أيام&#x27;,
	        M : &#x27;شهر&#x27;,
	        MM : &#x27;%d أشهر&#x27;,
	        y : &#x27;سنة&#x27;,
	        yy : &#x27;%d سنوات&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arSa;

	})));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var arTn &#x3D; moment.defineLocale(&#x27;ar-tn&#x27;, {
	    months: &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ح_ن_ث_ر_خ_ج_س&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[اليوم على الساعة] LT&#x27;,
	        nextDay: &#x27;[غدا على الساعة] LT&#x27;,
	        nextWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        lastDay: &#x27;[أمس على الساعة] LT&#x27;,
	        lastWeek: &#x27;dddd [على الساعة] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;في %s&#x27;,
	        past: &#x27;منذ %s&#x27;,
	        s: &#x27;ثوان&#x27;,
	        ss : &#x27;%d ثانية&#x27;,
	        m: &#x27;دقيقة&#x27;,
	        mm: &#x27;%d دقائق&#x27;,
	        h: &#x27;ساعة&#x27;,
	        hh: &#x27;%d ساعات&#x27;,
	        d: &#x27;يوم&#x27;,
	        dd: &#x27;%d أيام&#x27;,
	        M: &#x27;شهر&#x27;,
	        MM: &#x27;%d أشهر&#x27;,
	        y: &#x27;سنة&#x27;,
	        yy: &#x27;%d سنوات&#x27;
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return arTn;

	})));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes &#x3D; {
	    1: &#x27;-inci&#x27;,
	    5: &#x27;-inci&#x27;,
	    8: &#x27;-inci&#x27;,
	    70: &#x27;-inci&#x27;,
	    80: &#x27;-inci&#x27;,
	    2: &#x27;-nci&#x27;,
	    7: &#x27;-nci&#x27;,
	    20: &#x27;-nci&#x27;,
	    50: &#x27;-nci&#x27;,
	    3: &#x27;-üncü&#x27;,
	    4: &#x27;-üncü&#x27;,
	    100: &#x27;-üncü&#x27;,
	    6: &#x27;-ncı&#x27;,
	    9: &#x27;-uncu&#x27;,
	    10: &#x27;-uncu&#x27;,
	    30: &#x27;-uncu&#x27;,
	    60: &#x27;-ıncı&#x27;,
	    90: &#x27;-ıncı&#x27;
	};

	var az &#x3D; moment.defineLocale(&#x27;az&#x27;, {
	    months : &#x27;yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Bz_BE_ÇA_Çə_CA_Cü_Şə&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[bugün saat] LT&#x27;,
	        nextDay : &#x27;[sabah saat] LT&#x27;,
	        nextWeek : &#x27;[gələn həftə] dddd [saat] LT&#x27;,
	        lastDay : &#x27;[dünən] LT&#x27;,
	        lastWeek : &#x27;[keçən həftə] dddd [saat] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s sonra&#x27;,
	        past : &#x27;%s əvvəl&#x27;,
	        s : &#x27;birneçə saniyyə&#x27;,
	        ss : &#x27;%d saniyə&#x27;,
	        m : &#x27;bir dəqiqə&#x27;,
	        mm : &#x27;%d dəqiqə&#x27;,
	        h : &#x27;bir saat&#x27;,
	        hh : &#x27;%d saat&#x27;,
	        d : &#x27;bir gün&#x27;,
	        dd : &#x27;%d gün&#x27;,
	        M : &#x27;bir ay&#x27;,
	        MM : &#x27;%d ay&#x27;,
	        y : &#x27;bir il&#x27;,
	        yy : &#x27;%d il&#x27;
	    },
	    meridiemParse: /gecə|səhər|gündüz|axşam/,
	    isPM : function (input) {
	        return /^(gündüz|axşam)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;gecə&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;səhər&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;gündüz&#x27;;
	        } else {
	            return &#x27;axşam&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	    ordinal : function (number) {
	        if (number &#x3D;&#x3D;&#x3D; 0) {  // special case for zero
	            return number + &#x27;-ıncı&#x27;;
	        }
	        var a &#x3D; number % 10,
	            b &#x3D; number % 100 - a,
	            c &#x3D; number &gt;&#x3D; 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return az;

	})));


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(word, num) {
	    var forms &#x3D; word.split(&#x27;_&#x27;);
	    return num % 10 &#x3D;&#x3D;&#x3D; 1 &amp;&amp; num % 100 !&#x3D;&#x3D; 11 ? forms[0] : (num % 10 &gt;&#x3D; 2 &amp;&amp; num % 10 &lt;&#x3D; 4 &amp;&amp; (num % 100 &lt; 10 || num % 100 &gt;&#x3D; 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format &#x3D; {
	        &#x27;ss&#x27;: withoutSuffix ? &#x27;секунда_секунды_секунд&#x27; : &#x27;секунду_секунды_секунд&#x27;,
	        &#x27;mm&#x27;: withoutSuffix ? &#x27;хвіліна_хвіліны_хвілін&#x27; : &#x27;хвіліну_хвіліны_хвілін&#x27;,
	        &#x27;hh&#x27;: withoutSuffix ? &#x27;гадзіна_гадзіны_гадзін&#x27; : &#x27;гадзіну_гадзіны_гадзін&#x27;,
	        &#x27;dd&#x27;: &#x27;дзень_дні_дзён&#x27;,
	        &#x27;MM&#x27;: &#x27;месяц_месяцы_месяцаў&#x27;,
	        &#x27;yy&#x27;: &#x27;год_гады_гадоў&#x27;
	    };
	    if (key &#x3D;&#x3D;&#x3D; &#x27;m&#x27;) {
	        return withoutSuffix ? &#x27;хвіліна&#x27; : &#x27;хвіліну&#x27;;
	    }
	    else if (key &#x3D;&#x3D;&#x3D; &#x27;h&#x27;) {
	        return withoutSuffix ? &#x27;гадзіна&#x27; : &#x27;гадзіну&#x27;;
	    }
	    else {
	        return number + &#x27; &#x27; + plural(format[key], +number);
	    }
	}

	var be &#x3D; moment.defineLocale(&#x27;be&#x27;, {
	    months : {
	        format: &#x27;студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж&#x27;.split(&#x27;_&#x27;),
	    weekdays : {
	        format: &#x27;нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота&#x27;.split(&#x27;_&#x27;),
	        isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
	    },
	    weekdaysShort : &#x27;нд_пн_ат_ср_чц_пт_сб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нд_пн_ат_ср_чц_пт_сб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY г.&#x27;,
	        LLL : &#x27;D MMMM YYYY г., HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY г., HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Сёння ў] LT&#x27;,
	        nextDay: &#x27;[Заўтра ў] LT&#x27;,
	        lastDay: &#x27;[Учора ў] LT&#x27;,
	        nextWeek: function () {
	            return &#x27;[У] dddd [ў] LT&#x27;;
	        },
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return &#x27;[У мінулую] dddd [ў] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                    return &#x27;[У мінулы] dddd [ў] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;праз %s&#x27;,
	        past : &#x27;%s таму&#x27;,
	        s : &#x27;некалькі секунд&#x27;,
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithPlural,
	        hh : relativeTimeWithPlural,
	        d : &#x27;дзень&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;месяц&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;год&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночы|раніцы|дня|вечара/,
	    isPM : function (input) {
	        return /^(дня|вечара)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ночы&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;раніцы&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;дня&#x27;;
	        } else {
	            return &#x27;вечара&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;M&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return (number % 10 &#x3D;&#x3D;&#x3D; 2 || number % 10 &#x3D;&#x3D;&#x3D; 3) &amp;&amp; (number % 100 !&#x3D;&#x3D; 12 &amp;&amp; number % 100 !&#x3D;&#x3D; 13) ? number + &#x27;-і&#x27; : number + &#x27;-ы&#x27;;
	            case &#x27;D&#x27;:
	                return number + &#x27;-га&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return be;

	})));


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var bg &#x3D; moment.defineLocale(&#x27;bg&#x27;, {
	    months : &#x27;януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;неделя_понеделник_вторник_сряда_четвъртък_петък_събота&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;нед_пон_вто_сря_чет_пет_съб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нд_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;D.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Днес в] LT&#x27;,
	        nextDay : &#x27;[Утре в] LT&#x27;,
	        nextWeek : &#x27;dddd [в] LT&#x27;,
	        lastDay : &#x27;[Вчера в] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return &#x27;[В изминалата] dddd [в] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[В изминалия] dddd [в] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;след %s&#x27;,
	        past : &#x27;преди %s&#x27;,
	        s : &#x27;няколко секунди&#x27;,
	        ss : &#x27;%d секунди&#x27;,
	        m : &#x27;минута&#x27;,
	        mm : &#x27;%d минути&#x27;,
	        h : &#x27;час&#x27;,
	        hh : &#x27;%d часа&#x27;,
	        d : &#x27;ден&#x27;,
	        dd : &#x27;%d дни&#x27;,
	        M : &#x27;месец&#x27;,
	        MM : &#x27;%d месеца&#x27;,
	        y : &#x27;година&#x27;,
	        yy : &#x27;%d години&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit &#x3D; number % 10,
	            last2Digits &#x3D; number % 100;
	        if (number &#x3D;&#x3D;&#x3D; 0) {
	            return number + &#x27;-ев&#x27;;
	        } else if (last2Digits &#x3D;&#x3D;&#x3D; 0) {
	            return number + &#x27;-ен&#x27;;
	        } else if (last2Digits &gt; 10 &amp;&amp; last2Digits &lt; 20) {
	            return number + &#x27;-ти&#x27;;
	        } else if (lastDigit &#x3D;&#x3D;&#x3D; 1) {
	            return number + &#x27;-ви&#x27;;
	        } else if (lastDigit &#x3D;&#x3D;&#x3D; 2) {
	            return number + &#x27;-ри&#x27;;
	        } else if (lastDigit &#x3D;&#x3D;&#x3D; 7 || lastDigit &#x3D;&#x3D;&#x3D; 8) {
	            return number + &#x27;-ми&#x27;;
	        } else {
	            return number + &#x27;-ти&#x27;;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bg;

	})));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var bm &#x3D; moment.defineLocale(&#x27;bm&#x27;, {
	    months : &#x27;Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ka_Nt_Ta_Ar_Al_Ju_Si&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;MMMM [tile] D [san] YYYY&#x27;,
	        LLL : &#x27;MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm&#x27;,
	        LLLL : &#x27;dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Bi lɛrɛ] LT&#x27;,
	        nextDay : &#x27;[Sini lɛrɛ] LT&#x27;,
	        nextWeek : &#x27;dddd [don lɛrɛ] LT&#x27;,
	        lastDay : &#x27;[Kunu lɛrɛ] LT&#x27;,
	        lastWeek : &#x27;dddd [tɛmɛnen lɛrɛ] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s kɔnɔ&#x27;,
	        past : &#x27;a bɛ %s bɔ&#x27;,
	        s : &#x27;sanga dama dama&#x27;,
	        ss : &#x27;sekondi %d&#x27;,
	        m : &#x27;miniti kelen&#x27;,
	        mm : &#x27;miniti %d&#x27;,
	        h : &#x27;lɛrɛ kelen&#x27;,
	        hh : &#x27;lɛrɛ %d&#x27;,
	        d : &#x27;tile kelen&#x27;,
	        dd : &#x27;tile %d&#x27;,
	        M : &#x27;kalo kelen&#x27;,
	        MM : &#x27;kalo %d&#x27;,
	        y : &#x27;san kelen&#x27;,
	        yy : &#x27;san %d&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return bm;

	})));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;১&#x27;,
	    &#x27;2&#x27;: &#x27;২&#x27;,
	    &#x27;3&#x27;: &#x27;৩&#x27;,
	    &#x27;4&#x27;: &#x27;৪&#x27;,
	    &#x27;5&#x27;: &#x27;৫&#x27;,
	    &#x27;6&#x27;: &#x27;৬&#x27;,
	    &#x27;7&#x27;: &#x27;৭&#x27;,
	    &#x27;8&#x27;: &#x27;৮&#x27;,
	    &#x27;9&#x27;: &#x27;৯&#x27;,
	    &#x27;0&#x27;: &#x27;০&#x27;
	},
	numberMap &#x3D; {
	    &#x27;১&#x27;: &#x27;1&#x27;,
	    &#x27;২&#x27;: &#x27;2&#x27;,
	    &#x27;৩&#x27;: &#x27;3&#x27;,
	    &#x27;৪&#x27;: &#x27;4&#x27;,
	    &#x27;৫&#x27;: &#x27;5&#x27;,
	    &#x27;৬&#x27;: &#x27;6&#x27;,
	    &#x27;৭&#x27;: &#x27;7&#x27;,
	    &#x27;৮&#x27;: &#x27;8&#x27;,
	    &#x27;৯&#x27;: &#x27;9&#x27;,
	    &#x27;০&#x27;: &#x27;0&#x27;
	};

	var bn &#x3D; moment.defineLocale(&#x27;bn&#x27;, {
	    months : &#x27;জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm সময়&#x27;,
	        LTS : &#x27;A h:mm:ss সময়&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm সময়&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm সময়&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[আজ] LT&#x27;,
	        nextDay : &#x27;[আগামীকাল] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[গতকাল] LT&#x27;,
	        lastWeek : &#x27;[গত] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s পরে&#x27;,
	        past : &#x27;%s আগে&#x27;,
	        s : &#x27;কয়েক সেকেন্ড&#x27;,
	        ss : &#x27;%d সেকেন্ড&#x27;,
	        m : &#x27;এক মিনিট&#x27;,
	        mm : &#x27;%d মিনিট&#x27;,
	        h : &#x27;এক ঘন্টা&#x27;,
	        hh : &#x27;%d ঘন্টা&#x27;,
	        d : &#x27;এক দিন&#x27;,
	        dd : &#x27;%d দিন&#x27;,
	        M : &#x27;এক মাস&#x27;,
	        MM : &#x27;%d মাস&#x27;,
	        y : &#x27;এক বছর&#x27;,
	        yy : &#x27;%d বছর&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if ((meridiem &#x3D;&#x3D;&#x3D; &#x27;রাত&#x27; &amp;&amp; hour &gt;&#x3D; 4) ||
	                (meridiem &#x3D;&#x3D;&#x3D; &#x27;দুপুর&#x27; &amp;&amp; hour &lt; 5) ||
	                meridiem &#x3D;&#x3D;&#x3D; &#x27;বিকাল&#x27;) {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;রাত&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;সকাল&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;দুপুর&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;বিকাল&#x27;;
	        } else {
	            return &#x27;রাত&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bn;

	})));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;༡&#x27;,
	    &#x27;2&#x27;: &#x27;༢&#x27;,
	    &#x27;3&#x27;: &#x27;༣&#x27;,
	    &#x27;4&#x27;: &#x27;༤&#x27;,
	    &#x27;5&#x27;: &#x27;༥&#x27;,
	    &#x27;6&#x27;: &#x27;༦&#x27;,
	    &#x27;7&#x27;: &#x27;༧&#x27;,
	    &#x27;8&#x27;: &#x27;༨&#x27;,
	    &#x27;9&#x27;: &#x27;༩&#x27;,
	    &#x27;0&#x27;: &#x27;༠&#x27;
	},
	numberMap &#x3D; {
	    &#x27;༡&#x27;: &#x27;1&#x27;,
	    &#x27;༢&#x27;: &#x27;2&#x27;,
	    &#x27;༣&#x27;: &#x27;3&#x27;,
	    &#x27;༤&#x27;: &#x27;4&#x27;,
	    &#x27;༥&#x27;: &#x27;5&#x27;,
	    &#x27;༦&#x27;: &#x27;6&#x27;,
	    &#x27;༧&#x27;: &#x27;7&#x27;,
	    &#x27;༨&#x27;: &#x27;8&#x27;,
	    &#x27;༩&#x27;: &#x27;9&#x27;,
	    &#x27;༠&#x27;: &#x27;0&#x27;
	};

	var bo &#x3D; moment.defineLocale(&#x27;bo&#x27;, {
	    months : &#x27;ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[དི་རིང] LT&#x27;,
	        nextDay : &#x27;[སང་ཉིན] LT&#x27;,
	        nextWeek : &#x27;[བདུན་ཕྲག་རྗེས་མ], LT&#x27;,
	        lastDay : &#x27;[ཁ་སང] LT&#x27;,
	        lastWeek : &#x27;[བདུན་ཕྲག་མཐའ་མ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ལ་&#x27;,
	        past : &#x27;%s སྔན་ལ&#x27;,
	        s : &#x27;ལམ་སང&#x27;,
	        ss : &#x27;%d སྐར་ཆ།&#x27;,
	        m : &#x27;སྐར་མ་གཅིག&#x27;,
	        mm : &#x27;%d སྐར་མ&#x27;,
	        h : &#x27;ཆུ་ཚོད་གཅིག&#x27;,
	        hh : &#x27;%d ཆུ་ཚོད&#x27;,
	        d : &#x27;ཉིན་གཅིག&#x27;,
	        dd : &#x27;%d ཉིན་&#x27;,
	        M : &#x27;ཟླ་བ་གཅིག&#x27;,
	        MM : &#x27;%d ཟླ་བ&#x27;,
	        y : &#x27;ལོ་གཅིག&#x27;,
	        yy : &#x27;%d ལོ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if ((meridiem &#x3D;&#x3D;&#x3D; &#x27;མཚན་མོ&#x27; &amp;&amp; hour &gt;&#x3D; 4) ||
	                (meridiem &#x3D;&#x3D;&#x3D; &#x27;ཉིན་གུང&#x27; &amp;&amp; hour &lt; 5) ||
	                meridiem &#x3D;&#x3D;&#x3D; &#x27;དགོང་དག&#x27;) {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;མཚན་མོ&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ཞོགས་ཀས&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ཉིན་གུང&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;དགོང་དག&#x27;;
	        } else {
	            return &#x27;མཚན་མོ&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bo;

	})));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function relativeTimeWithMutation(number, withoutSuffix, key) {
	    var format &#x3D; {
	        &#x27;mm&#x27;: &#x27;munutenn&#x27;,
	        &#x27;MM&#x27;: &#x27;miz&#x27;,
	        &#x27;dd&#x27;: &#x27;devezh&#x27;
	    };
	    return number + &#x27; &#x27; + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
	    switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + &#x27; bloaz&#x27;;
	        default:
	            return number + &#x27; vloaz&#x27;;
	    }
	}
	function lastNumber(number) {
	    if (number &gt; 9) {
	        return lastNumber(number % 10);
	    }
	    return number;
	}
	function mutation(text, number) {
	    if (number &#x3D;&#x3D;&#x3D; 2) {
	        return softMutation(text);
	    }
	    return text;
	}
	function softMutation(text) {
	    var mutationTable &#x3D; {
	        &#x27;m&#x27;: &#x27;v&#x27;,
	        &#x27;b&#x27;: &#x27;v&#x27;,
	        &#x27;d&#x27;: &#x27;z&#x27;
	    };
	    if (mutationTable[text.charAt(0)] &#x3D;&#x3D;&#x3D; undefined) {
	        return text;
	    }
	    return mutationTable[text.charAt(0)] + text.substring(1);
	}

	var br &#x3D; moment.defineLocale(&#x27;br&#x27;, {
	    months : &#x27;Genver_C\&#x27;hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Gen_C\&#x27;hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sul_Lun_Meurzh_Merc\&#x27;her_Yaou_Gwener_Sadorn&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sul_Lun_Meu_Mer_Yao_Gwe_Sad&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Lu_Me_Mer_Ya_Gw_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h[e]mm A&#x27;,
	        LTS : &#x27;h[e]mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [a viz] MMMM YYYY&#x27;,
	        LLL : &#x27;D [a viz] MMMM YYYY h[e]mm A&#x27;,
	        LLLL : &#x27;dddd, D [a viz] MMMM YYYY h[e]mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Hiziv da] LT&#x27;,
	        nextDay : &#x27;[Warc\&#x27;hoazh da] LT&#x27;,
	        nextWeek : &#x27;dddd [da] LT&#x27;,
	        lastDay : &#x27;[Dec\&#x27;h da] LT&#x27;,
	        lastWeek : &#x27;dddd [paset da] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;a-benn %s&#x27;,
	        past : &#x27;%s \&#x27;zo&#x27;,
	        s : &#x27;un nebeud segondennoù&#x27;,
	        ss : &#x27;%d eilenn&#x27;,
	        m : &#x27;ur vunutenn&#x27;,
	        mm : relativeTimeWithMutation,
	        h : &#x27;un eur&#x27;,
	        hh : &#x27;%d eur&#x27;,
	        d : &#x27;un devezh&#x27;,
	        dd : relativeTimeWithMutation,
	        M : &#x27;ur miz&#x27;,
	        MM : relativeTimeWithMutation,
	        y : &#x27;ur bloaz&#x27;,
	        yy : specialMutationForYears
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
	    ordinal : function (number) {
	        var output &#x3D; (number &#x3D;&#x3D;&#x3D; 1) ? &#x27;añ&#x27; : &#x27;vet&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return br;

	})));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function translate(number, withoutSuffix, key) {
	    var result &#x3D; number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;ss&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;sekunda&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;sekunde&#x27;;
	            } else {
	                result +&#x3D; &#x27;sekundi&#x27;;
	            }
	            return result;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;jedna minuta&#x27; : &#x27;jedne minute&#x27;;
	        case &#x27;mm&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;minuta&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;minute&#x27;;
	            } else {
	                result +&#x3D; &#x27;minuta&#x27;;
	            }
	            return result;
	        case &#x27;h&#x27;:
	            return withoutSuffix ? &#x27;jedan sat&#x27; : &#x27;jednog sata&#x27;;
	        case &#x27;hh&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;sat&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;sata&#x27;;
	            } else {
	                result +&#x3D; &#x27;sati&#x27;;
	            }
	            return result;
	        case &#x27;dd&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;dan&#x27;;
	            } else {
	                result +&#x3D; &#x27;dana&#x27;;
	            }
	            return result;
	        case &#x27;MM&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;mjesec&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;mjeseca&#x27;;
	            } else {
	                result +&#x3D; &#x27;mjeseci&#x27;;
	            }
	            return result;
	        case &#x27;yy&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;godina&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;godine&#x27;;
	            } else {
	                result +&#x3D; &#x27;godina&#x27;;
	            }
	            return result;
	    }
	}

	var bs &#x3D; moment.defineLocale(&#x27;bs&#x27;, {
	    months : &#x27;januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ned._pon._uto._sri._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[danas u] LT&#x27;,
	        nextDay  : &#x27;[sutra u] LT&#x27;,
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedjelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [srijedu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[jučer u] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return &#x27;[prošlu] dddd [u] LT&#x27;;
	                case 6:
	                    return &#x27;[prošle] [subote] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[prošli] dddd [u] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;prije %s&#x27;,
	        s      : &#x27;par sekundi&#x27;,
	        ss     : translate,
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translate,
	        M      : &#x27;mjesec&#x27;,
	        MM     : translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bs;

	})));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ca &#x3D; moment.defineLocale(&#x27;ca&#x27;, {
	    months : {
	        standalone: &#x27;gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;de gener_de febrer_de març_d\&#x27;abril_de maig_de juny_de juliol_d\&#x27;agost_de setembre_d\&#x27;octubre_de novembre_de desembre&#x27;.split(&#x27;_&#x27;),
	        isFormat: /D[oD]?(\s)+MMMM/
	    },
	    monthsShort : &#x27;gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dg._dl._dt._dc._dj._dv._ds.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;dg_dl_dt_dc_dj_dv_ds&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM [de] YYYY&#x27;,
	        ll : &#x27;D MMM YYYY&#x27;,
	        LLL : &#x27;D MMMM [de] YYYY [a les] H:mm&#x27;,
	        lll : &#x27;D MMM YYYY, H:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM [de] YYYY [a les] H:mm&#x27;,
	        llll : &#x27;ddd D MMM YYYY, H:mm&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[avui a &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[demà a &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ahir a &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [passat a &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;les&#x27; : &#x27;la&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;d\&#x27;aquí %s&#x27;,
	        past : &#x27;fa %s&#x27;,
	        s : &#x27;uns segons&#x27;,
	        ss : &#x27;%d segons&#x27;,
	        m : &#x27;un minut&#x27;,
	        mm : &#x27;%d minuts&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d hores&#x27;,
	        d : &#x27;un dia&#x27;,
	        dd : &#x27;%d dies&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d mesos&#x27;,
	        y : &#x27;un any&#x27;,
	        yy : &#x27;%d anys&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
	    ordinal : function (number, period) {
	        var output &#x3D; (number &#x3D;&#x3D;&#x3D; 1) ? &#x27;r&#x27; :
	            (number &#x3D;&#x3D;&#x3D; 2) ? &#x27;n&#x27; :
	            (number &#x3D;&#x3D;&#x3D; 3) ? &#x27;r&#x27; :
	            (number &#x3D;&#x3D;&#x3D; 4) ? &#x27;t&#x27; : &#x27;è&#x27;;
	        if (period &#x3D;&#x3D;&#x3D; &#x27;w&#x27; || period &#x3D;&#x3D;&#x3D; &#x27;W&#x27;) {
	            output &#x3D; &#x27;a&#x27;;
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ca;

	})));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months &#x3D; &#x27;leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec&#x27;.split(&#x27;_&#x27;),
	    monthsShort &#x3D; &#x27;led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro&#x27;.split(&#x27;_&#x27;);
	function plural(n) {
	    return (n &gt; 1) &amp;&amp; (n &lt; 5) &amp;&amp; (~~(n / 10) !&#x3D;&#x3D; 1);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result &#x3D; number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? &#x27;pár sekund&#x27; : &#x27;pár sekundami&#x27;;
	        case &#x27;ss&#x27;: // 9 seconds / in 9 seconds / 9 seconds ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;sekundy&#x27; : &#x27;sekund&#x27;);
	            } else {
	                return result + &#x27;sekundami&#x27;;
	            }
	            break;
	        case &#x27;m&#x27;:  // a minute / in a minute / a minute ago
	            return withoutSuffix ? &#x27;minuta&#x27; : (isFuture ? &#x27;minutu&#x27; : &#x27;minutou&#x27;);
	        case &#x27;mm&#x27;: // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;minuty&#x27; : &#x27;minut&#x27;);
	            } else {
	                return result + &#x27;minutami&#x27;;
	            }
	            break;
	        case &#x27;h&#x27;:  // an hour / in an hour / an hour ago
	            return withoutSuffix ? &#x27;hodina&#x27; : (isFuture ? &#x27;hodinu&#x27; : &#x27;hodinou&#x27;);
	        case &#x27;hh&#x27;: // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;hodiny&#x27; : &#x27;hodin&#x27;);
	            } else {
	                return result + &#x27;hodinami&#x27;;
	            }
	            break;
	        case &#x27;d&#x27;:  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? &#x27;den&#x27; : &#x27;dnem&#x27;;
	        case &#x27;dd&#x27;: // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;dny&#x27; : &#x27;dní&#x27;);
	            } else {
	                return result + &#x27;dny&#x27;;
	            }
	            break;
	        case &#x27;M&#x27;:  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? &#x27;měsíc&#x27; : &#x27;měsícem&#x27;;
	        case &#x27;MM&#x27;: // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;měsíce&#x27; : &#x27;měsíců&#x27;);
	            } else {
	                return result + &#x27;měsíci&#x27;;
	            }
	            break;
	        case &#x27;y&#x27;:  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? &#x27;rok&#x27; : &#x27;rokem&#x27;;
	        case &#x27;yy&#x27;: // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;roky&#x27; : &#x27;let&#x27;);
	            } else {
	                return result + &#x27;lety&#x27;;
	            }
	            break;
	    }
	}

	var cs &#x3D; moment.defineLocale(&#x27;cs&#x27;, {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParse : (function (months, monthsShort) {
	        var i, _monthsParse &#x3D; [];
	        for (i &#x3D; 0; i &lt; 12; i++) {
	            // use custom parser to solve problem with July (červenec)
	            _monthsParse[i] &#x3D; new RegExp(&#x27;^&#x27; + months[i] + &#x27;$|^&#x27; + monthsShort[i] + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        return _monthsParse;
	    }(months, monthsShort)),
	    shortMonthsParse : (function (monthsShort) {
	        var i, _shortMonthsParse &#x3D; [];
	        for (i &#x3D; 0; i &lt; 12; i++) {
	            _shortMonthsParse[i] &#x3D; new RegExp(&#x27;^&#x27; + monthsShort[i] + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        return _shortMonthsParse;
	    }(monthsShort)),
	    longMonthsParse : (function (months) {
	        var i, _longMonthsParse &#x3D; [];
	        for (i &#x3D; 0; i &lt; 12; i++) {
	            _longMonthsParse[i] &#x3D; new RegExp(&#x27;^&#x27; + months[i] + &#x27;$&#x27;, &#x27;i&#x27;);
	        }
	        return _longMonthsParse;
	    }(months)),
	    weekdays : &#x27;neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ne_po_út_st_čt_pá_so&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_út_st_čt_pá_so&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY H:mm&#x27;,
	        l : &#x27;D. M. YYYY&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[dnes v] LT&#x27;,
	        nextDay: &#x27;[zítra v] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[v neděli v] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[v] dddd [v] LT&#x27;;
	                case 3:
	                    return &#x27;[ve středu v] LT&#x27;;
	                case 4:
	                    return &#x27;[ve čtvrtek v] LT&#x27;;
	                case 5:
	                    return &#x27;[v pátek v] LT&#x27;;
	                case 6:
	                    return &#x27;[v sobotu v] LT&#x27;;
	            }
	        },
	        lastDay: &#x27;[včera v] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[minulou neděli v] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[minulé] dddd [v] LT&#x27;;
	                case 3:
	                    return &#x27;[minulou středu v] LT&#x27;;
	                case 4:
	                case 5:
	                    return &#x27;[minulý] dddd [v] LT&#x27;;
	                case 6:
	                    return &#x27;[minulou sobotu v] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past : &#x27;před %s&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cs;

	})));


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var cv &#x3D; moment.defineLocale(&#x27;cv&#x27;, {
	    months : &#x27;кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;выр_тун_ытл_юн_кӗҫ_эрн_шӑм&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;вр_тн_ыт_юн_кҫ_эр_шм&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]&#x27;,
	        LLL : &#x27;YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm&#x27;,
	        LLLL : &#x27;dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Паян] LT [сехетре]&#x27;,
	        nextDay: &#x27;[Ыран] LT [сехетре]&#x27;,
	        lastDay: &#x27;[Ӗнер] LT [сехетре]&#x27;,
	        nextWeek: &#x27;[Ҫитес] dddd LT [сехетре]&#x27;,
	        lastWeek: &#x27;[Иртнӗ] dddd LT [сехетре]&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (output) {
	            var affix &#x3D; /сехет$/i.exec(output) ? &#x27;рен&#x27; : /ҫул$/i.exec(output) ? &#x27;тан&#x27; : &#x27;ран&#x27;;
	            return output + affix;
	        },
	        past : &#x27;%s каялла&#x27;,
	        s : &#x27;пӗр-ик ҫеккунт&#x27;,
	        ss : &#x27;%d ҫеккунт&#x27;,
	        m : &#x27;пӗр минут&#x27;,
	        mm : &#x27;%d минут&#x27;,
	        h : &#x27;пӗр сехет&#x27;,
	        hh : &#x27;%d сехет&#x27;,
	        d : &#x27;пӗр кун&#x27;,
	        dd : &#x27;%d кун&#x27;,
	        M : &#x27;пӗр уйӑх&#x27;,
	        MM : &#x27;%d уйӑх&#x27;,
	        y : &#x27;пӗр ҫул&#x27;,
	        yy : &#x27;%d ҫул&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
	    ordinal : &#x27;%d-мӗш&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return cv;

	})));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var cy &#x3D; moment.defineLocale(&#x27;cy&#x27;, {
	    months: &#x27;Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;Sul_Llun_Maw_Mer_Iau_Gwe_Sad&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;Su_Ll_Ma_Me_Ia_Gw_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    // time formats are the same as en-gb
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[Heddiw am] LT&#x27;,
	        nextDay: &#x27;[Yfory am] LT&#x27;,
	        nextWeek: &#x27;dddd [am] LT&#x27;,
	        lastDay: &#x27;[Ddoe am] LT&#x27;,
	        lastWeek: &#x27;dddd [diwethaf am] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;mewn %s&#x27;,
	        past: &#x27;%s yn ôl&#x27;,
	        s: &#x27;ychydig eiliadau&#x27;,
	        ss: &#x27;%d eiliad&#x27;,
	        m: &#x27;munud&#x27;,
	        mm: &#x27;%d munud&#x27;,
	        h: &#x27;awr&#x27;,
	        hh: &#x27;%d awr&#x27;,
	        d: &#x27;diwrnod&#x27;,
	        dd: &#x27;%d diwrnod&#x27;,
	        M: &#x27;mis&#x27;,
	        MM: &#x27;%d mis&#x27;,
	        y: &#x27;blwyddyn&#x27;,
	        yy: &#x27;%d flynedd&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	    ordinal: function (number) {
	        var b &#x3D; number,
	            output &#x3D; &#x27;&#x27;,
	            lookup &#x3D; [
	                &#x27;&#x27;, &#x27;af&#x27;, &#x27;il&#x27;, &#x27;ydd&#x27;, &#x27;ydd&#x27;, &#x27;ed&#x27;, &#x27;ed&#x27;, &#x27;ed&#x27;, &#x27;fed&#x27;, &#x27;fed&#x27;, &#x27;fed&#x27;, // 1af to 10fed
	                &#x27;eg&#x27;, &#x27;fed&#x27;, &#x27;eg&#x27;, &#x27;eg&#x27;, &#x27;fed&#x27;, &#x27;eg&#x27;, &#x27;eg&#x27;, &#x27;fed&#x27;, &#x27;eg&#x27;, &#x27;fed&#x27; // 11eg to 20fed
	            ];
	        if (b &gt; 20) {
	            if (b &#x3D;&#x3D;&#x3D; 40 || b &#x3D;&#x3D;&#x3D; 50 || b &#x3D;&#x3D;&#x3D; 60 || b &#x3D;&#x3D;&#x3D; 80 || b &#x3D;&#x3D;&#x3D; 100) {
	                output &#x3D; &#x27;fed&#x27;; // not 30ain, 70ain or 90ain
	            } else {
	                output &#x3D; &#x27;ain&#x27;;
	            }
	        } else if (b &gt; 0) {
	            output &#x3D; lookup[b];
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cy;

	})));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var da &#x3D; moment.defineLocale(&#x27;da&#x27;, {
	    months : &#x27;januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;søn_man_tir_ons_tor_fre_lør&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;sø_ma_ti_on_to_fr_lø&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd [d.] D. MMMM YYYY [kl.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[i dag kl.] LT&#x27;,
	        nextDay : &#x27;[i morgen kl.] LT&#x27;,
	        nextWeek : &#x27;på dddd [kl.] LT&#x27;,
	        lastDay : &#x27;[i går kl.] LT&#x27;,
	        lastWeek : &#x27;[i] dddd[s kl.] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;%s siden&#x27;,
	        s : &#x27;få sekunder&#x27;,
	        ss : &#x27;%d sekunder&#x27;,
	        m : &#x27;et minut&#x27;,
	        mm : &#x27;%d minutter&#x27;,
	        h : &#x27;en time&#x27;,
	        hh : &#x27;%d timer&#x27;,
	        d : &#x27;en dag&#x27;,
	        dd : &#x27;%d dage&#x27;,
	        M : &#x27;en måned&#x27;,
	        MM : &#x27;%d måneder&#x27;,
	        y : &#x27;et år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return da;

	})));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format &#x3D; {
	        &#x27;m&#x27;: [&#x27;eine Minute&#x27;, &#x27;einer Minute&#x27;],
	        &#x27;h&#x27;: [&#x27;eine Stunde&#x27;, &#x27;einer Stunde&#x27;],
	        &#x27;d&#x27;: [&#x27;ein Tag&#x27;, &#x27;einem Tag&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; Tage&#x27;, number + &#x27; Tagen&#x27;],
	        &#x27;M&#x27;: [&#x27;ein Monat&#x27;, &#x27;einem Monat&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; Monate&#x27;, number + &#x27; Monaten&#x27;],
	        &#x27;y&#x27;: [&#x27;ein Jahr&#x27;, &#x27;einem Jahr&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; Jahre&#x27;, number + &#x27; Jahren&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var de &#x3D; moment.defineLocale(&#x27;de&#x27;, {
	    months : &#x27;Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;So._Mo._Di._Mi._Do._Fr._Sa.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[heute um] LT [Uhr]&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[morgen um] LT [Uhr]&#x27;,
	        nextWeek: &#x27;dddd [um] LT [Uhr]&#x27;,
	        lastDay: &#x27;[gestern um] LT [Uhr]&#x27;,
	        lastWeek: &#x27;[letzten] dddd [um] LT [Uhr]&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;vor %s&#x27;,
	        s : &#x27;ein paar Sekunden&#x27;,
	        ss : &#x27;%d Sekunden&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minuten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stunden&#x27;,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return de;

	})));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format &#x3D; {
	        &#x27;m&#x27;: [&#x27;eine Minute&#x27;, &#x27;einer Minute&#x27;],
	        &#x27;h&#x27;: [&#x27;eine Stunde&#x27;, &#x27;einer Stunde&#x27;],
	        &#x27;d&#x27;: [&#x27;ein Tag&#x27;, &#x27;einem Tag&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; Tage&#x27;, number + &#x27; Tagen&#x27;],
	        &#x27;M&#x27;: [&#x27;ein Monat&#x27;, &#x27;einem Monat&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; Monate&#x27;, number + &#x27; Monaten&#x27;],
	        &#x27;y&#x27;: [&#x27;ein Jahr&#x27;, &#x27;einem Jahr&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; Jahre&#x27;, number + &#x27; Jahren&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deAt &#x3D; moment.defineLocale(&#x27;de-at&#x27;, {
	    months : &#x27;Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;So._Mo._Di._Mi._Do._Fr._Sa.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[heute um] LT [Uhr]&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[morgen um] LT [Uhr]&#x27;,
	        nextWeek: &#x27;dddd [um] LT [Uhr]&#x27;,
	        lastDay: &#x27;[gestern um] LT [Uhr]&#x27;,
	        lastWeek: &#x27;[letzten] dddd [um] LT [Uhr]&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;vor %s&#x27;,
	        s : &#x27;ein paar Sekunden&#x27;,
	        ss : &#x27;%d Sekunden&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minuten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stunden&#x27;,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deAt;

	})));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format &#x3D; {
	        &#x27;m&#x27;: [&#x27;eine Minute&#x27;, &#x27;einer Minute&#x27;],
	        &#x27;h&#x27;: [&#x27;eine Stunde&#x27;, &#x27;einer Stunde&#x27;],
	        &#x27;d&#x27;: [&#x27;ein Tag&#x27;, &#x27;einem Tag&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; Tage&#x27;, number + &#x27; Tagen&#x27;],
	        &#x27;M&#x27;: [&#x27;ein Monat&#x27;, &#x27;einem Monat&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; Monate&#x27;, number + &#x27; Monaten&#x27;],
	        &#x27;y&#x27;: [&#x27;ein Jahr&#x27;, &#x27;einem Jahr&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; Jahre&#x27;, number + &#x27; Jahren&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deCh &#x3D; moment.defineLocale(&#x27;de-ch&#x27;, {
	    months : &#x27;Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;So_Mo_Di_Mi_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[heute um] LT [Uhr]&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[morgen um] LT [Uhr]&#x27;,
	        nextWeek: &#x27;dddd [um] LT [Uhr]&#x27;,
	        lastDay: &#x27;[gestern um] LT [Uhr]&#x27;,
	        lastWeek: &#x27;[letzten] dddd [um] LT [Uhr]&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;vor %s&#x27;,
	        s : &#x27;ein paar Sekunden&#x27;,
	        ss : &#x27;%d Sekunden&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minuten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stunden&#x27;,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deCh;

	})));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months &#x3D; [
	    &#x27;ޖެނުއަރީ&#x27;,
	    &#x27;ފެބްރުއަރީ&#x27;,
	    &#x27;މާރިޗު&#x27;,
	    &#x27;އޭޕްރީލު&#x27;,
	    &#x27;މޭ&#x27;,
	    &#x27;ޖޫން&#x27;,
	    &#x27;ޖުލައި&#x27;,
	    &#x27;އޯގަސްޓު&#x27;,
	    &#x27;ސެޕްޓެމްބަރު&#x27;,
	    &#x27;އޮކްޓޯބަރު&#x27;,
	    &#x27;ނޮވެމްބަރު&#x27;,
	    &#x27;ޑިސެމްބަރު&#x27;
	], weekdays &#x3D; [
	    &#x27;އާދިއްތަ&#x27;,
	    &#x27;ހޯމަ&#x27;,
	    &#x27;އަންގާރަ&#x27;,
	    &#x27;ބުދަ&#x27;,
	    &#x27;ބުރާސްފަތި&#x27;,
	    &#x27;ހުކުރު&#x27;,
	    &#x27;ހޮނިހިރު&#x27;
	];

	var dv &#x3D; moment.defineLocale(&#x27;dv&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : weekdays,
	    weekdaysShort : weekdays,
	    weekdaysMin : &#x27;އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {

	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;D/M/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /މކ|މފ/,
	    isPM : function (input) {
	        return &#x27;މފ&#x27; &#x3D;&#x3D;&#x3D; input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;މކ&#x27;;
	        } else {
	            return &#x27;މފ&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[މިއަދު] LT&#x27;,
	        nextDay : &#x27;[މާދަމާ] LT&#x27;,
	        nextWeek : &#x27;dddd LT&#x27;,
	        lastDay : &#x27;[އިއްޔެ] LT&#x27;,
	        lastWeek : &#x27;[ފާއިތުވި] dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ތެރޭގައި %s&#x27;,
	        past : &#x27;ކުރިން %s&#x27;,
	        s : &#x27;ސިކުންތުކޮޅެއް&#x27;,
	        ss : &#x27;d% ސިކުންތު&#x27;,
	        m : &#x27;މިނިޓެއް&#x27;,
	        mm : &#x27;މިނިޓު %d&#x27;,
	        h : &#x27;ގަޑިއިރެއް&#x27;,
	        hh : &#x27;ގަޑިއިރު %d&#x27;,
	        d : &#x27;ދުވަހެއް&#x27;,
	        dd : &#x27;ދުވަސް %d&#x27;,
	        M : &#x27;މަހެއް&#x27;,
	        MM : &#x27;މަސް %d&#x27;,
	        y : &#x27;އަހަރެއް&#x27;,
	        yy : &#x27;އަހަރު %d&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 7,  // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return dv;

	})));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) &#x3D;&#x3D;&#x3D; &#x27;[object Function]&#x27;;
	}


	var el &#x3D; moment.defineLocale(&#x27;el&#x27;, {
	    monthsNominativeEl : &#x27;Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος&#x27;.split(&#x27;_&#x27;),
	    monthsGenitiveEl : &#x27;Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου&#x27;.split(&#x27;_&#x27;),
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return this._monthsNominativeEl;
	        } else if (typeof format &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; /D/.test(format.substring(0, format.indexOf(&#x27;MMMM&#x27;)))) { // if there is a day number before &#x27;MMMM&#x27;
	            return this._monthsGenitiveEl[momentToFormat.month()];
	        } else {
	            return this._monthsNominativeEl[momentToFormat.month()];
	        }
	    },
	    monthsShort : &#x27;Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Κυ_Δε_Τρ_Τε_Πε_Πα_Σα&#x27;.split(&#x27;_&#x27;),
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;μμ&#x27; : &#x27;ΜΜ&#x27;;
	        } else {
	            return isLower ? &#x27;πμ&#x27; : &#x27;ΠΜ&#x27;;
	        }
	    },
	    isPM : function (input) {
	        return ((input + &#x27;&#x27;).toLowerCase()[0] &#x3D;&#x3D;&#x3D; &#x27;μ&#x27;);
	    },
	    meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendarEl : {
	        sameDay : &#x27;[Σήμερα {}] LT&#x27;,
	        nextDay : &#x27;[Αύριο {}] LT&#x27;,
	        nextWeek : &#x27;dddd [{}] LT&#x27;,
	        lastDay : &#x27;[Χθες {}] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 6:
	                    return &#x27;[το προηγούμενο] dddd [{}] LT&#x27;;
	                default:
	                    return &#x27;[την προηγούμενη] dddd [{}] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    calendar : function (key, mom) {
	        var output &#x3D; this._calendarEl[key],
	            hours &#x3D; mom &amp;&amp; mom.hours();
	        if (isFunction(output)) {
	            output &#x3D; output.apply(mom);
	        }
	        return output.replace(&#x27;{}&#x27;, (hours % 12 &#x3D;&#x3D;&#x3D; 1 ? &#x27;στη&#x27; : &#x27;στις&#x27;));
	    },
	    relativeTime : {
	        future : &#x27;σε %s&#x27;,
	        past : &#x27;%s πριν&#x27;,
	        s : &#x27;λίγα δευτερόλεπτα&#x27;,
	        ss : &#x27;%d δευτερόλεπτα&#x27;,
	        m : &#x27;ένα λεπτό&#x27;,
	        mm : &#x27;%d λεπτά&#x27;,
	        h : &#x27;μία ώρα&#x27;,
	        hh : &#x27;%d ώρες&#x27;,
	        d : &#x27;μία μέρα&#x27;,
	        dd : &#x27;%d μέρες&#x27;,
	        M : &#x27;ένας μήνας&#x27;,
	        MM : &#x27;%d μήνες&#x27;,
	        y : &#x27;ένας χρόνος&#x27;,
	        yy : &#x27;%d χρόνια&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}η/,
	    ordinal: &#x27;%dη&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4st is the first week of the year.
	    }
	});

	return el;

	})));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enAu &#x3D; moment.defineLocale(&#x27;en-au&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enAu;

	})));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enCa &#x3D; moment.defineLocale(&#x27;en-ca&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;MMMM D, YYYY&#x27;,
	        LLL : &#x27;MMMM D, YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, MMMM D, YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    }
	});

	return enCa;

	})));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enGb &#x3D; moment.defineLocale(&#x27;en-gb&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enGb;

	})));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enIe &#x3D; moment.defineLocale(&#x27;en-ie&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enIe;

	})));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enIl &#x3D; moment.defineLocale(&#x27;en-il&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    }
	});

	return enIl;

	})));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var enNz &#x3D; moment.defineLocale(&#x27;en-nz&#x27;, {
	    months : &#x27;January_February_March_April_May_June_July_August_September_October_November_December&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sun_Mon_Tue_Wed_Thu_Fri_Sat&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Mo_Tu_We_Th_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Today at] LT&#x27;,
	        nextDay : &#x27;[Tomorrow at] LT&#x27;,
	        nextWeek : &#x27;dddd [at] LT&#x27;,
	        lastDay : &#x27;[Yesterday at] LT&#x27;,
	        lastWeek : &#x27;[Last] dddd [at] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;in %s&#x27;,
	        past : &#x27;%s ago&#x27;,
	        s : &#x27;a few seconds&#x27;,
	        ss : &#x27;%d seconds&#x27;,
	        m : &#x27;a minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;an hour&#x27;,
	        hh : &#x27;%d hours&#x27;,
	        d : &#x27;a day&#x27;,
	        dd : &#x27;%d days&#x27;,
	        M : &#x27;a month&#x27;,
	        MM : &#x27;%d months&#x27;,
	        y : &#x27;a year&#x27;,
	        yy : &#x27;%d years&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enNz;

	})));


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var eo &#x3D; moment.defineLocale(&#x27;eo&#x27;, {
	    months : &#x27;januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim_lun_mard_merk_ĵaŭ_ven_sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_ĵa_ve_sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;D[-a de] MMMM, YYYY&#x27;,
	        LLL : &#x27;D[-a de] MMMM, YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, [la] D[-a de] MMMM, YYYY HH:mm&#x27;
	    },
	    meridiemParse: /[ap]\.t\.m/i,
	    isPM: function (input) {
	        return input.charAt(0).toLowerCase() &#x3D;&#x3D;&#x3D; &#x27;p&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;p.t.m.&#x27; : &#x27;P.T.M.&#x27;;
	        } else {
	            return isLower ? &#x27;a.t.m.&#x27; : &#x27;A.T.M.&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hodiaŭ je] LT&#x27;,
	        nextDay : &#x27;[Morgaŭ je] LT&#x27;,
	        nextWeek : &#x27;dddd [je] LT&#x27;,
	        lastDay : &#x27;[Hieraŭ je] LT&#x27;,
	        lastWeek : &#x27;[pasinta] dddd [je] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;post %s&#x27;,
	        past : &#x27;antaŭ %s&#x27;,
	        s : &#x27;sekundoj&#x27;,
	        ss : &#x27;%d sekundoj&#x27;,
	        m : &#x27;minuto&#x27;,
	        mm : &#x27;%d minutoj&#x27;,
	        h : &#x27;horo&#x27;,
	        hh : &#x27;%d horoj&#x27;,
	        d : &#x27;tago&#x27;,//ne &#x27;diurno&#x27;, ĉar estas uzita por proksimumo
	        dd : &#x27;%d tagoj&#x27;,
	        M : &#x27;monato&#x27;,
	        MM : &#x27;%d monatoj&#x27;,
	        y : &#x27;jaro&#x27;,
	        yy : &#x27;%d jaroj&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}a/,
	    ordinal : &#x27;%da&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eo;

	})));


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortDot &#x3D; &#x27;ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.&#x27;.split(&#x27;_&#x27;),
	    monthsShort &#x3D; &#x27;ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic&#x27;.split(&#x27;_&#x27;);

	var monthsParse &#x3D; [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex &#x3D; /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	var es &#x3D; moment.defineLocale(&#x27;es&#x27;, {
	    months : &#x27;enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsRegex : monthsRegex,
	    monthsShortRegex : monthsRegex,
	    monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
	    monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	    weekdays : &#x27;domingo_lunes_martes_miércoles_jueves_viernes_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mié._jue._vie._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mi_ju_vi_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoy a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañana a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ayer a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [pasado a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;en %s&#x27;,
	        past : &#x27;hace %s&#x27;,
	        s : &#x27;unos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un año&#x27;,
	        yy : &#x27;%d años&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return es;

	})));


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortDot &#x3D; &#x27;ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.&#x27;.split(&#x27;_&#x27;),
	    monthsShort &#x3D; &#x27;ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic&#x27;.split(&#x27;_&#x27;);

	var monthsParse &#x3D; [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex &#x3D; /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	var esDo &#x3D; moment.defineLocale(&#x27;es-do&#x27;, {
	    months : &#x27;enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
	    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
	    monthsParse: monthsParse,
	    longMonthsParse: monthsParse,
	    shortMonthsParse: monthsParse,
	    weekdays : &#x27;domingo_lunes_martes_miércoles_jueves_viernes_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mié._jue._vie._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mi_ju_vi_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoy a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañana a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ayer a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [pasado a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;en %s&#x27;,
	        past : &#x27;hace %s&#x27;,
	        s : &#x27;unos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un año&#x27;,
	        yy : &#x27;%d años&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return esDo;

	})));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortDot &#x3D; &#x27;ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.&#x27;.split(&#x27;_&#x27;),
	    monthsShort &#x3D; &#x27;ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic&#x27;.split(&#x27;_&#x27;);

	var esUs &#x3D; moment.defineLocale(&#x27;es-us&#x27;, {
	    months : &#x27;enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : &#x27;domingo_lunes_martes_miércoles_jueves_viernes_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mié._jue._vie._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mi_ju_vi_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;MM/DD/YYYY&#x27;,
	        LL : &#x27;MMMM [de] D [de] YYYY&#x27;,
	        LLL : &#x27;MMMM [de] D [de] YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, MMMM [de] D [de] YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoy a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañana a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[ayer a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[el] dddd [pasado a la&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;en %s&#x27;,
	        past : &#x27;hace %s&#x27;,
	        s : &#x27;unos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;una hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un año&#x27;,
	        yy : &#x27;%d años&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return esUs;

	})));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format &#x3D; {
	        &#x27;s&#x27; : [&#x27;mõne sekundi&#x27;, &#x27;mõni sekund&#x27;, &#x27;paar sekundit&#x27;],
	        &#x27;ss&#x27;: [number + &#x27;sekundi&#x27;, number + &#x27;sekundit&#x27;],
	        &#x27;m&#x27; : [&#x27;ühe minuti&#x27;, &#x27;üks minut&#x27;],
	        &#x27;mm&#x27;: [number + &#x27; minuti&#x27;, number + &#x27; minutit&#x27;],
	        &#x27;h&#x27; : [&#x27;ühe tunni&#x27;, &#x27;tund aega&#x27;, &#x27;üks tund&#x27;],
	        &#x27;hh&#x27;: [number + &#x27; tunni&#x27;, number + &#x27; tundi&#x27;],
	        &#x27;d&#x27; : [&#x27;ühe päeva&#x27;, &#x27;üks päev&#x27;],
	        &#x27;M&#x27; : [&#x27;kuu aja&#x27;, &#x27;kuu aega&#x27;, &#x27;üks kuu&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; kuu&#x27;, number + &#x27; kuud&#x27;],
	        &#x27;y&#x27; : [&#x27;ühe aasta&#x27;, &#x27;aasta&#x27;, &#x27;üks aasta&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; aasta&#x27;, number + &#x27; aastat&#x27;]
	    };
	    if (withoutSuffix) {
	        return format[key][2] ? format[key][2] : format[key][1];
	    }
	    return isFuture ? format[key][0] : format[key][1];
	}

	var et &#x3D; moment.defineLocale(&#x27;et&#x27;, {
	    months        : &#x27;jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember&#x27;.split(&#x27;_&#x27;),
	    monthsShort   : &#x27;jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets&#x27;.split(&#x27;_&#x27;),
	    weekdays      : &#x27;pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;P_E_T_K_N_R_L&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin   : &#x27;P_E_T_K_N_R_L&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT   : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L    : &#x27;DD.MM.YYYY&#x27;,
	        LL   : &#x27;D. MMMM YYYY&#x27;,
	        LLL  : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[Täna,] LT&#x27;,
	        nextDay  : &#x27;[Homme,] LT&#x27;,
	        nextWeek : &#x27;[Järgmine] dddd LT&#x27;,
	        lastDay  : &#x27;[Eile,] LT&#x27;,
	        lastWeek : &#x27;[Eelmine] dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s pärast&#x27;,
	        past   : &#x27;%s tagasi&#x27;,
	        s      : processRelativeTime,
	        ss     : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : &#x27;%d päeva&#x27;,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return et;

	})));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var eu &#x3D; moment.defineLocale(&#x27;eu&#x27;, {
	    months : &#x27;urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ig._al._ar._az._og._ol._lr.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ig_al_ar_az_og_ol_lr&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;YYYY[ko] MMMM[ren] D[a]&#x27;,
	        LLL : &#x27;YYYY[ko] MMMM[ren] D[a] HH:mm&#x27;,
	        LLLL : &#x27;dddd, YYYY[ko] MMMM[ren] D[a] HH:mm&#x27;,
	        l : &#x27;YYYY-M-D&#x27;,
	        ll : &#x27;YYYY[ko] MMM D[a]&#x27;,
	        lll : &#x27;YYYY[ko] MMM D[a] HH:mm&#x27;,
	        llll : &#x27;ddd, YYYY[ko] MMM D[a] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[gaur] LT[etan]&#x27;,
	        nextDay : &#x27;[bihar] LT[etan]&#x27;,
	        nextWeek : &#x27;dddd LT[etan]&#x27;,
	        lastDay : &#x27;[atzo] LT[etan]&#x27;,
	        lastWeek : &#x27;[aurreko] dddd LT[etan]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s barru&#x27;,
	        past : &#x27;duela %s&#x27;,
	        s : &#x27;segundo batzuk&#x27;,
	        ss : &#x27;%d segundo&#x27;,
	        m : &#x27;minutu bat&#x27;,
	        mm : &#x27;%d minutu&#x27;,
	        h : &#x27;ordu bat&#x27;,
	        hh : &#x27;%d ordu&#x27;,
	        d : &#x27;egun bat&#x27;,
	        dd : &#x27;%d egun&#x27;,
	        M : &#x27;hilabete bat&#x27;,
	        MM : &#x27;%d hilabete&#x27;,
	        y : &#x27;urte bat&#x27;,
	        yy : &#x27;%d urte&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eu;

	})));


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;۱&#x27;,
	    &#x27;2&#x27;: &#x27;۲&#x27;,
	    &#x27;3&#x27;: &#x27;۳&#x27;,
	    &#x27;4&#x27;: &#x27;۴&#x27;,
	    &#x27;5&#x27;: &#x27;۵&#x27;,
	    &#x27;6&#x27;: &#x27;۶&#x27;,
	    &#x27;7&#x27;: &#x27;۷&#x27;,
	    &#x27;8&#x27;: &#x27;۸&#x27;,
	    &#x27;9&#x27;: &#x27;۹&#x27;,
	    &#x27;0&#x27;: &#x27;۰&#x27;
	}, numberMap &#x3D; {
	    &#x27;۱&#x27;: &#x27;1&#x27;,
	    &#x27;۲&#x27;: &#x27;2&#x27;,
	    &#x27;۳&#x27;: &#x27;3&#x27;,
	    &#x27;۴&#x27;: &#x27;4&#x27;,
	    &#x27;۵&#x27;: &#x27;5&#x27;,
	    &#x27;۶&#x27;: &#x27;6&#x27;,
	    &#x27;۷&#x27;: &#x27;7&#x27;,
	    &#x27;۸&#x27;: &#x27;8&#x27;,
	    &#x27;۹&#x27;: &#x27;9&#x27;,
	    &#x27;۰&#x27;: &#x27;0&#x27;
	};

	var fa &#x3D; moment.defineLocale(&#x27;fa&#x27;, {
	    months : &#x27;ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ی_د_س_چ_پ_ج_ش&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /قبل از ظهر|بعد از ظهر/,
	    isPM: function (input) {
	        return /بعد از ظهر/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;قبل از ظهر&#x27;;
	        } else {
	            return &#x27;بعد از ظهر&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[امروز ساعت] LT&#x27;,
	        nextDay : &#x27;[فردا ساعت] LT&#x27;,
	        nextWeek : &#x27;dddd [ساعت] LT&#x27;,
	        lastDay : &#x27;[دیروز ساعت] LT&#x27;,
	        lastWeek : &#x27;dddd [پیش] [ساعت] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;در %s&#x27;,
	        past : &#x27;%s پیش&#x27;,
	        s : &#x27;چند ثانیه&#x27;,
	        ss : &#x27;ثانیه d%&#x27;,
	        m : &#x27;یک دقیقه&#x27;,
	        mm : &#x27;%d دقیقه&#x27;,
	        h : &#x27;یک ساعت&#x27;,
	        hh : &#x27;%d ساعت&#x27;,
	        d : &#x27;یک روز&#x27;,
	        dd : &#x27;%d روز&#x27;,
	        M : &#x27;یک ماه&#x27;,
	        MM : &#x27;%d ماه&#x27;,
	        y : &#x27;یک سال&#x27;,
	        yy : &#x27;%d سال&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[۰-۹]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, &#x27;،&#x27;);
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}م/,
	    ordinal : &#x27;%dم&#x27;,
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return fa;

	})));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var numbersPast &#x3D; &#x27;nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän&#x27;.split(&#x27; &#x27;),
	    numbersFuture &#x3D; [
	        &#x27;nolla&#x27;, &#x27;yhden&#x27;, &#x27;kahden&#x27;, &#x27;kolmen&#x27;, &#x27;neljän&#x27;, &#x27;viiden&#x27;, &#x27;kuuden&#x27;,
	        numbersPast[7], numbersPast[8], numbersPast[9]
	    ];
	function translate(number, withoutSuffix, key, isFuture) {
	    var result &#x3D; &#x27;&#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return isFuture ? &#x27;muutaman sekunnin&#x27; : &#x27;muutama sekunti&#x27;;
	        case &#x27;ss&#x27;:
	            return isFuture ? &#x27;sekunnin&#x27; : &#x27;sekuntia&#x27;;
	        case &#x27;m&#x27;:
	            return isFuture ? &#x27;minuutin&#x27; : &#x27;minuutti&#x27;;
	        case &#x27;mm&#x27;:
	            result &#x3D; isFuture ? &#x27;minuutin&#x27; : &#x27;minuuttia&#x27;;
	            break;
	        case &#x27;h&#x27;:
	            return isFuture ? &#x27;tunnin&#x27; : &#x27;tunti&#x27;;
	        case &#x27;hh&#x27;:
	            result &#x3D; isFuture ? &#x27;tunnin&#x27; : &#x27;tuntia&#x27;;
	            break;
	        case &#x27;d&#x27;:
	            return isFuture ? &#x27;päivän&#x27; : &#x27;päivä&#x27;;
	        case &#x27;dd&#x27;:
	            result &#x3D; isFuture ? &#x27;päivän&#x27; : &#x27;päivää&#x27;;
	            break;
	        case &#x27;M&#x27;:
	            return isFuture ? &#x27;kuukauden&#x27; : &#x27;kuukausi&#x27;;
	        case &#x27;MM&#x27;:
	            result &#x3D; isFuture ? &#x27;kuukauden&#x27; : &#x27;kuukautta&#x27;;
	            break;
	        case &#x27;y&#x27;:
	            return isFuture ? &#x27;vuoden&#x27; : &#x27;vuosi&#x27;;
	        case &#x27;yy&#x27;:
	            result &#x3D; isFuture ? &#x27;vuoden&#x27; : &#x27;vuotta&#x27;;
	            break;
	    }
	    result &#x3D; verbalNumber(number, isFuture) + &#x27; &#x27; + result;
	    return result;
	}
	function verbalNumber(number, isFuture) {
	    return number &lt; 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}

	var fi &#x3D; moment.defineLocale(&#x27;fi&#x27;, {
	    months : &#x27;tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;su_ma_ti_ke_to_pe_la&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;su_ma_ti_ke_to_pe_la&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;Do MMMM[ta] YYYY&#x27;,
	        LLL : &#x27;Do MMMM[ta] YYYY, [klo] HH.mm&#x27;,
	        LLLL : &#x27;dddd, Do MMMM[ta] YYYY, [klo] HH.mm&#x27;,
	        l : &#x27;D.M.YYYY&#x27;,
	        ll : &#x27;Do MMM YYYY&#x27;,
	        lll : &#x27;Do MMM YYYY, [klo] HH.mm&#x27;,
	        llll : &#x27;ddd, Do MMM YYYY, [klo] HH.mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[tänään] [klo] LT&#x27;,
	        nextDay : &#x27;[huomenna] [klo] LT&#x27;,
	        nextWeek : &#x27;dddd [klo] LT&#x27;,
	        lastDay : &#x27;[eilen] [klo] LT&#x27;,
	        lastWeek : &#x27;[viime] dddd[na] [klo] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s päästä&#x27;,
	        past : &#x27;%s sitten&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fi;

	})));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var fo &#x3D; moment.defineLocale(&#x27;fo&#x27;, {
	    months : &#x27;januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sun_mán_týs_mik_hós_frí_ley&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;su_má_tý_mi_hó_fr_le&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM, YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Í dag kl.] LT&#x27;,
	        nextDay : &#x27;[Í morgin kl.] LT&#x27;,
	        nextWeek : &#x27;dddd [kl.] LT&#x27;,
	        lastDay : &#x27;[Í gjár kl.] LT&#x27;,
	        lastWeek : &#x27;[síðstu] dddd [kl] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;um %s&#x27;,
	        past : &#x27;%s síðani&#x27;,
	        s : &#x27;fá sekund&#x27;,
	        ss : &#x27;%d sekundir&#x27;,
	        m : &#x27;ein minutt&#x27;,
	        mm : &#x27;%d minuttir&#x27;,
	        h : &#x27;ein tími&#x27;,
	        hh : &#x27;%d tímar&#x27;,
	        d : &#x27;ein dagur&#x27;,
	        dd : &#x27;%d dagar&#x27;,
	        M : &#x27;ein mánaði&#x27;,
	        MM : &#x27;%d mánaðir&#x27;,
	        y : &#x27;eitt ár&#x27;,
	        yy : &#x27;%d ár&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fo;

	})));


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var fr &#x3D; moment.defineLocale(&#x27;fr&#x27;, {
	    months : &#x27;janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim._lun._mar._mer._jeu._ven._sam.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_je_ve_sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Aujourd’hui à] LT&#x27;,
	        nextDay : &#x27;[Demain à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[Hier à] LT&#x27;,
	        lastWeek : &#x27;dddd [dernier à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dans %s&#x27;,
	        past : &#x27;il y a %s&#x27;,
	        s : &#x27;quelques secondes&#x27;,
	        ss : &#x27;%d secondes&#x27;,
	        m : &#x27;une minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;une heure&#x27;,
	        hh : &#x27;%d heures&#x27;,
	        d : &#x27;un jour&#x27;,
	        dd : &#x27;%d jours&#x27;,
	        M : &#x27;un mois&#x27;,
	        MM : &#x27;%d mois&#x27;,
	        y : &#x27;un an&#x27;,
	        yy : &#x27;%d ans&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // TODO: Return &#x27;e&#x27; when day of month &gt; 1. Move this case inside
	            // block for masculine words below.
	            // See https://github.com/moment/moment/issues/3375
	            case &#x27;D&#x27;:
	                return number + (number &#x3D;&#x3D;&#x3D; 1 ? &#x27;er&#x27; : &#x27;&#x27;);

	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	                return number + (number &#x3D;&#x3D;&#x3D; 1 ? &#x27;er&#x27; : &#x27;e&#x27;);

	            // Words with feminine grammatical gender: semaine
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + (number &#x3D;&#x3D;&#x3D; 1 ? &#x27;re&#x27; : &#x27;e&#x27;);
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fr;

	})));


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var frCa &#x3D; moment.defineLocale(&#x27;fr-ca&#x27;, {
	    months : &#x27;janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim._lun._mar._mer._jeu._ven._sam.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_je_ve_sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Aujourd’hui à] LT&#x27;,
	        nextDay : &#x27;[Demain à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[Hier à] LT&#x27;,
	        lastWeek : &#x27;dddd [dernier à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dans %s&#x27;,
	        past : &#x27;il y a %s&#x27;,
	        s : &#x27;quelques secondes&#x27;,
	        ss : &#x27;%d secondes&#x27;,
	        m : &#x27;une minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;une heure&#x27;,
	        hh : &#x27;%d heures&#x27;,
	        d : &#x27;un jour&#x27;,
	        dd : &#x27;%d jours&#x27;,
	        M : &#x27;un mois&#x27;,
	        MM : &#x27;%d mois&#x27;,
	        y : &#x27;un an&#x27;,
	        yy : &#x27;%d ans&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	                return number + (number &#x3D;&#x3D;&#x3D; 1 ? &#x27;er&#x27; : &#x27;e&#x27;);

	            // Words with feminine grammatical gender: semaine
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + (number &#x3D;&#x3D;&#x3D; 1 ? &#x27;re&#x27; : &#x27;e&#x27;);
	        }
	    }
	});

	return frCa;

	})));


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var frCh &#x3D; moment.defineLocale(&#x27;fr-ch&#x27;, {
	    months : &#x27;janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dim._lun._mar._mer._jeu._ven._sam.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;di_lu_ma_me_je_ve_sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Aujourd’hui à] LT&#x27;,
	        nextDay : &#x27;[Demain à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[Hier à] LT&#x27;,
	        lastWeek : &#x27;dddd [dernier à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dans %s&#x27;,
	        past : &#x27;il y a %s&#x27;,
	        s : &#x27;quelques secondes&#x27;,
	        ss : &#x27;%d secondes&#x27;,
	        m : &#x27;une minute&#x27;,
	        mm : &#x27;%d minutes&#x27;,
	        h : &#x27;une heure&#x27;,
	        hh : &#x27;%d heures&#x27;,
	        d : &#x27;un jour&#x27;,
	        dd : &#x27;%d jours&#x27;,
	        M : &#x27;un mois&#x27;,
	        MM : &#x27;%d mois&#x27;,
	        y : &#x27;un an&#x27;,
	        yy : &#x27;%d ans&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	                return number + (number &#x3D;&#x3D;&#x3D; 1 ? &#x27;er&#x27; : &#x27;e&#x27;);

	            // Words with feminine grammatical gender: semaine
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + (number &#x3D;&#x3D;&#x3D; 1 ? &#x27;re&#x27; : &#x27;e&#x27;);
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return frCh;

	})));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortWithDots &#x3D; &#x27;jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.&#x27;.split(&#x27;_&#x27;),
	    monthsShortWithoutDots &#x3D; &#x27;jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des&#x27;.split(&#x27;_&#x27;);

	var fy &#x3D; moment.defineLocale(&#x27;fy&#x27;, {
	    months : &#x27;jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : &#x27;snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;si._mo._ti._wo._to._fr._so.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Si_Mo_Ti_Wo_To_Fr_So&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[hjoed om] LT&#x27;,
	        nextDay: &#x27;[moarn om] LT&#x27;,
	        nextWeek: &#x27;dddd [om] LT&#x27;,
	        lastDay: &#x27;[juster om] LT&#x27;,
	        lastWeek: &#x27;[ôfrûne] dddd [om] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;oer %s&#x27;,
	        past : &#x27;%s lyn&#x27;,
	        s : &#x27;in pear sekonden&#x27;,
	        ss : &#x27;%d sekonden&#x27;,
	        m : &#x27;ien minút&#x27;,
	        mm : &#x27;%d minuten&#x27;,
	        h : &#x27;ien oere&#x27;,
	        hh : &#x27;%d oeren&#x27;,
	        d : &#x27;ien dei&#x27;,
	        dd : &#x27;%d dagen&#x27;,
	        M : &#x27;ien moanne&#x27;,
	        MM : &#x27;%d moannen&#x27;,
	        y : &#x27;ien jier&#x27;,
	        yy : &#x27;%d jierren&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number &#x3D;&#x3D;&#x3D; 1 || number &#x3D;&#x3D;&#x3D; 8 || number &gt;&#x3D; 20) ? &#x27;ste&#x27; : &#x27;de&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fy;

	})));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months &#x3D; [
	    &#x27;Am Faoilleach&#x27;, &#x27;An Gearran&#x27;, &#x27;Am Màrt&#x27;, &#x27;An Giblean&#x27;, &#x27;An Cèitean&#x27;, &#x27;An t-Ògmhios&#x27;, &#x27;An t-Iuchar&#x27;, &#x27;An Lùnastal&#x27;, &#x27;An t-Sultain&#x27;, &#x27;An Dàmhair&#x27;, &#x27;An t-Samhain&#x27;, &#x27;An Dùbhlachd&#x27;
	];

	var monthsShort &#x3D; [&#x27;Faoi&#x27;, &#x27;Gear&#x27;, &#x27;Màrt&#x27;, &#x27;Gibl&#x27;, &#x27;Cèit&#x27;, &#x27;Ògmh&#x27;, &#x27;Iuch&#x27;, &#x27;Lùn&#x27;, &#x27;Sult&#x27;, &#x27;Dàmh&#x27;, &#x27;Samh&#x27;, &#x27;Dùbh&#x27;];

	var weekdays &#x3D; [&#x27;Didòmhnaich&#x27;, &#x27;Diluain&#x27;, &#x27;Dimàirt&#x27;, &#x27;Diciadain&#x27;, &#x27;Diardaoin&#x27;, &#x27;Dihaoine&#x27;, &#x27;Disathairne&#x27;];

	var weekdaysShort &#x3D; [&#x27;Did&#x27;, &#x27;Dil&#x27;, &#x27;Dim&#x27;, &#x27;Dic&#x27;, &#x27;Dia&#x27;, &#x27;Dih&#x27;, &#x27;Dis&#x27;];

	var weekdaysMin &#x3D; [&#x27;Dò&#x27;, &#x27;Lu&#x27;, &#x27;Mà&#x27;, &#x27;Ci&#x27;, &#x27;Ar&#x27;, &#x27;Ha&#x27;, &#x27;Sa&#x27;];

	var gd &#x3D; moment.defineLocale(&#x27;gd&#x27;, {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParseExact : true,
	    weekdays : weekdays,
	    weekdaysShort : weekdaysShort,
	    weekdaysMin : weekdaysMin,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[An-diugh aig] LT&#x27;,
	        nextDay : &#x27;[A-màireach aig] LT&#x27;,
	        nextWeek : &#x27;dddd [aig] LT&#x27;,
	        lastDay : &#x27;[An-dè aig] LT&#x27;,
	        lastWeek : &#x27;dddd [seo chaidh] [aig] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ann an %s&#x27;,
	        past : &#x27;bho chionn %s&#x27;,
	        s : &#x27;beagan diogan&#x27;,
	        ss : &#x27;%d diogan&#x27;,
	        m : &#x27;mionaid&#x27;,
	        mm : &#x27;%d mionaidean&#x27;,
	        h : &#x27;uair&#x27;,
	        hh : &#x27;%d uairean&#x27;,
	        d : &#x27;latha&#x27;,
	        dd : &#x27;%d latha&#x27;,
	        M : &#x27;mìos&#x27;,
	        MM : &#x27;%d mìosan&#x27;,
	        y : &#x27;bliadhna&#x27;,
	        yy : &#x27;%d bliadhna&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
	    ordinal : function (number) {
	        var output &#x3D; number &#x3D;&#x3D;&#x3D; 1 ? &#x27;d&#x27; : number % 10 &#x3D;&#x3D;&#x3D; 2 ? &#x27;na&#x27; : &#x27;mh&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gd;

	})));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var gl &#x3D; moment.defineLocale(&#x27;gl&#x27;, {
	    months : &#x27;xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;domingo_luns_martes_mércores_xoves_venres_sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom._lun._mar._mér._xov._ven._sáb.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_mé_xo_ve_sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : function () {
	            return &#x27;[hoxe &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;ás&#x27; : &#x27;á&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextDay : function () {
	            return &#x27;[mañá &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;ás&#x27; : &#x27;á&#x27;) + &#x27;] LT&#x27;;
	        },
	        nextWeek : function () {
	            return &#x27;dddd [&#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;ás&#x27; : &#x27;a&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastDay : function () {
	            return &#x27;[onte &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;á&#x27; : &#x27;a&#x27;) + &#x27;] LT&#x27;;
	        },
	        lastWeek : function () {
	            return &#x27;[o] dddd [pasado &#x27; + ((this.hours() !&#x3D;&#x3D; 1) ? &#x27;ás&#x27; : &#x27;a&#x27;) + &#x27;] LT&#x27;;
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (str) {
	            if (str.indexOf(&#x27;un&#x27;) &#x3D;&#x3D;&#x3D; 0) {
	                return &#x27;n&#x27; + str;
	            }
	            return &#x27;en &#x27; + str;
	        },
	        past : &#x27;hai %s&#x27;,
	        s : &#x27;uns segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;unha hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;un día&#x27;,
	        dd : &#x27;%d días&#x27;,
	        M : &#x27;un mes&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;un ano&#x27;,
	        yy : &#x27;%d anos&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gl;

	})));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format &#x3D; {
	        &#x27;s&#x27;: [&#x27;thodde secondanim&#x27;, &#x27;thodde second&#x27;],
	        &#x27;ss&#x27;: [number + &#x27; secondanim&#x27;, number + &#x27; second&#x27;],
	        &#x27;m&#x27;: [&#x27;eka mintan&#x27;, &#x27;ek minute&#x27;],
	        &#x27;mm&#x27;: [number + &#x27; mintanim&#x27;, number + &#x27; mintam&#x27;],
	        &#x27;h&#x27;: [&#x27;eka horan&#x27;, &#x27;ek hor&#x27;],
	        &#x27;hh&#x27;: [number + &#x27; horanim&#x27;, number + &#x27; hor&#x27;],
	        &#x27;d&#x27;: [&#x27;eka disan&#x27;, &#x27;ek dis&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; disanim&#x27;, number + &#x27; dis&#x27;],
	        &#x27;M&#x27;: [&#x27;eka mhoinean&#x27;, &#x27;ek mhoino&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; mhoineanim&#x27;, number + &#x27; mhoine&#x27;],
	        &#x27;y&#x27;: [&#x27;eka vorsan&#x27;, &#x27;ek voros&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; vorsanim&#x27;, number + &#x27; vorsam&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var gomLatn &#x3D; moment.defineLocale(&#x27;gom-latn&#x27;, {
	    months : &#x27;Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\&#x27;var&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ait._Som._Mon._Bud._Bre._Suk._Son.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ai_Sm_Mo_Bu_Br_Su_Sn&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;A h:mm [vazta]&#x27;,
	        LTS : &#x27;A h:mm:ss [vazta]&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY A h:mm [vazta]&#x27;,
	        LLLL : &#x27;dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]&#x27;,
	        llll: &#x27;ddd, D MMM YYYY, A h:mm [vazta]&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Aiz] LT&#x27;,
	        nextDay: &#x27;[Faleam] LT&#x27;,
	        nextWeek: &#x27;[Ieta to] dddd[,] LT&#x27;,
	        lastDay: &#x27;[Kal] LT&#x27;,
	        lastWeek: &#x27;[Fatlo] dddd[,] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s&#x27;,
	        past : &#x27;%s adim&#x27;,
	        s : processRelativeTime,
	        ss : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // the ordinal &#x27;er&#x27; only applies to day of the month
	            case &#x27;D&#x27;:
	                return number + &#x27;er&#x27;;
	            default:
	            case &#x27;M&#x27;:
	            case &#x27;Q&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    },
	    meridiemParse: /rati|sokalli|donparam|sanje/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;rati&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;sokalli&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;donparam&#x27;) {
	            return hour &gt; 12 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;sanje&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;rati&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;sokalli&#x27;;
	        } else if (hour &lt; 16) {
	            return &#x27;donparam&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;sanje&#x27;;
	        } else {
	            return &#x27;rati&#x27;;
	        }
	    }
	});

	return gomLatn;

	})));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	        &#x27;1&#x27;: &#x27;૧&#x27;,
	        &#x27;2&#x27;: &#x27;૨&#x27;,
	        &#x27;3&#x27;: &#x27;૩&#x27;,
	        &#x27;4&#x27;: &#x27;૪&#x27;,
	        &#x27;5&#x27;: &#x27;૫&#x27;,
	        &#x27;6&#x27;: &#x27;૬&#x27;,
	        &#x27;7&#x27;: &#x27;૭&#x27;,
	        &#x27;8&#x27;: &#x27;૮&#x27;,
	        &#x27;9&#x27;: &#x27;૯&#x27;,
	        &#x27;0&#x27;: &#x27;૦&#x27;
	    },
	    numberMap &#x3D; {
	        &#x27;૧&#x27;: &#x27;1&#x27;,
	        &#x27;૨&#x27;: &#x27;2&#x27;,
	        &#x27;૩&#x27;: &#x27;3&#x27;,
	        &#x27;૪&#x27;: &#x27;4&#x27;,
	        &#x27;૫&#x27;: &#x27;5&#x27;,
	        &#x27;૬&#x27;: &#x27;6&#x27;,
	        &#x27;૭&#x27;: &#x27;7&#x27;,
	        &#x27;૮&#x27;: &#x27;8&#x27;,
	        &#x27;૯&#x27;: &#x27;9&#x27;,
	        &#x27;૦&#x27;: &#x27;0&#x27;
	    };

	var gu &#x3D; moment.defineLocale(&#x27;gu&#x27;, {
	    months: &#x27;જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays: &#x27;રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ર_સો_મં_બુ_ગુ_શુ_શ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;A h:mm વાગ્યે&#x27;,
	        LTS: &#x27;A h:mm:ss વાગ્યે&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY, A h:mm વાગ્યે&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY, A h:mm વાગ્યે&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[આજ] LT&#x27;,
	        nextDay: &#x27;[કાલે] LT&#x27;,
	        nextWeek: &#x27;dddd, LT&#x27;,
	        lastDay: &#x27;[ગઇકાલે] LT&#x27;,
	        lastWeek: &#x27;[પાછલા] dddd, LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;%s મા&#x27;,
	        past: &#x27;%s પેહલા&#x27;,
	        s: &#x27;અમુક પળો&#x27;,
	        ss: &#x27;%d સેકંડ&#x27;,
	        m: &#x27;એક મિનિટ&#x27;,
	        mm: &#x27;%d મિનિટ&#x27;,
	        h: &#x27;એક કલાક&#x27;,
	        hh: &#x27;%d કલાક&#x27;,
	        d: &#x27;એક દિવસ&#x27;,
	        dd: &#x27;%d દિવસ&#x27;,
	        M: &#x27;એક મહિનો&#x27;,
	        MM: &#x27;%d મહિનો&#x27;,
	        y: &#x27;એક વર્ષ&#x27;,
	        yy: &#x27;%d વર્ષ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a &#x27;Pahar&#x27; it is not used as rigidly in modern Gujarati.
	    meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;રાત&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;સવાર&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;બપોર&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;સાંજ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;રાત&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;સવાર&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;બપોર&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;સાંજ&#x27;;
	        } else {
	            return &#x27;રાત&#x27;;
	        }
	    },
	    week: {
	        dow: 0, // Sunday is the first day of the week.
	        doy: 6 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return gu;

	})));


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var he &#x3D; moment.defineLocale(&#x27;he&#x27;, {
	    months : &#x27;ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;א_ב_ג_ד_ה_ו_ש&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [ב]MMMM YYYY&#x27;,
	        LLL : &#x27;D [ב]MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D [ב]MMMM YYYY HH:mm&#x27;,
	        l : &#x27;D/M/YYYY&#x27;,
	        ll : &#x27;D MMM YYYY&#x27;,
	        lll : &#x27;D MMM YYYY HH:mm&#x27;,
	        llll : &#x27;ddd, D MMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[היום ב־]LT&#x27;,
	        nextDay : &#x27;[מחר ב־]LT&#x27;,
	        nextWeek : &#x27;dddd [בשעה] LT&#x27;,
	        lastDay : &#x27;[אתמול ב־]LT&#x27;,
	        lastWeek : &#x27;[ביום] dddd [האחרון בשעה] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;בעוד %s&#x27;,
	        past : &#x27;לפני %s&#x27;,
	        s : &#x27;מספר שניות&#x27;,
	        ss : &#x27;%d שניות&#x27;,
	        m : &#x27;דקה&#x27;,
	        mm : &#x27;%d דקות&#x27;,
	        h : &#x27;שעה&#x27;,
	        hh : function (number) {
	            if (number &#x3D;&#x3D;&#x3D; 2) {
	                return &#x27;שעתיים&#x27;;
	            }
	            return number + &#x27; שעות&#x27;;
	        },
	        d : &#x27;יום&#x27;,
	        dd : function (number) {
	            if (number &#x3D;&#x3D;&#x3D; 2) {
	                return &#x27;יומיים&#x27;;
	            }
	            return number + &#x27; ימים&#x27;;
	        },
	        M : &#x27;חודש&#x27;,
	        MM : function (number) {
	            if (number &#x3D;&#x3D;&#x3D; 2) {
	                return &#x27;חודשיים&#x27;;
	            }
	            return number + &#x27; חודשים&#x27;;
	        },
	        y : &#x27;שנה&#x27;,
	        yy : function (number) {
	            if (number &#x3D;&#x3D;&#x3D; 2) {
	                return &#x27;שנתיים&#x27;;
	            } else if (number % 10 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; number !&#x3D;&#x3D; 10) {
	                return number + &#x27; שנה&#x27;;
	            }
	            return number + &#x27; שנים&#x27;;
	        }
	    },
	    meridiemParse: /אחה&quot;צ|לפנה&quot;צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
	    isPM : function (input) {
	        return /^(אחה&quot;צ|אחרי הצהריים|בערב)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 5) {
	            return &#x27;לפנות בוקר&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;בבוקר&#x27;;
	        } else if (hour &lt; 12) {
	            return isLower ? &#x27;לפנה&quot;צ&#x27; : &#x27;לפני הצהריים&#x27;;
	        } else if (hour &lt; 18) {
	            return isLower ? &#x27;אחה&quot;צ&#x27; : &#x27;אחרי הצהריים&#x27;;
	        } else {
	            return &#x27;בערב&#x27;;
	        }
	    }
	});

	return he;

	})));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;१&#x27;,
	    &#x27;2&#x27;: &#x27;२&#x27;,
	    &#x27;3&#x27;: &#x27;३&#x27;,
	    &#x27;4&#x27;: &#x27;४&#x27;,
	    &#x27;5&#x27;: &#x27;५&#x27;,
	    &#x27;6&#x27;: &#x27;६&#x27;,
	    &#x27;7&#x27;: &#x27;७&#x27;,
	    &#x27;8&#x27;: &#x27;८&#x27;,
	    &#x27;9&#x27;: &#x27;९&#x27;,
	    &#x27;0&#x27;: &#x27;०&#x27;
	},
	numberMap &#x3D; {
	    &#x27;१&#x27;: &#x27;1&#x27;,
	    &#x27;२&#x27;: &#x27;2&#x27;,
	    &#x27;३&#x27;: &#x27;3&#x27;,
	    &#x27;४&#x27;: &#x27;4&#x27;,
	    &#x27;५&#x27;: &#x27;5&#x27;,
	    &#x27;६&#x27;: &#x27;6&#x27;,
	    &#x27;७&#x27;: &#x27;7&#x27;,
	    &#x27;८&#x27;: &#x27;8&#x27;,
	    &#x27;९&#x27;: &#x27;9&#x27;,
	    &#x27;०&#x27;: &#x27;0&#x27;
	};

	var hi &#x3D; moment.defineLocale(&#x27;hi&#x27;, {
	    months : &#x27;जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;र_सो_मं_बु_गु_शु_श&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm बजे&#x27;,
	        LTS : &#x27;A h:mm:ss बजे&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm बजे&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm बजे&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[आज] LT&#x27;,
	        nextDay : &#x27;[कल] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[कल] LT&#x27;,
	        lastWeek : &#x27;[पिछले] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s में&#x27;,
	        past : &#x27;%s पहले&#x27;,
	        s : &#x27;कुछ ही क्षण&#x27;,
	        ss : &#x27;%d सेकंड&#x27;,
	        m : &#x27;एक मिनट&#x27;,
	        mm : &#x27;%d मिनट&#x27;,
	        h : &#x27;एक घंटा&#x27;,
	        hh : &#x27;%d घंटे&#x27;,
	        d : &#x27;एक दिन&#x27;,
	        dd : &#x27;%d दिन&#x27;,
	        M : &#x27;एक महीने&#x27;,
	        MM : &#x27;%d महीने&#x27;,
	        y : &#x27;एक वर्ष&#x27;,
	        yy : &#x27;%d वर्ष&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a &#x27;Pahar&#x27; it is not used as rigidly in modern Hindi.
	    meridiemParse: /रात|सुबह|दोपहर|शाम/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;रात&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;सुबह&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;दोपहर&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;शाम&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;रात&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;सुबह&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;दोपहर&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;शाम&#x27;;
	        } else {
	            return &#x27;रात&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hi;

	})));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function translate(number, withoutSuffix, key) {
	    var result &#x3D; number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;ss&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;sekunda&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;sekunde&#x27;;
	            } else {
	                result +&#x3D; &#x27;sekundi&#x27;;
	            }
	            return result;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;jedna minuta&#x27; : &#x27;jedne minute&#x27;;
	        case &#x27;mm&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;minuta&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;minute&#x27;;
	            } else {
	                result +&#x3D; &#x27;minuta&#x27;;
	            }
	            return result;
	        case &#x27;h&#x27;:
	            return withoutSuffix ? &#x27;jedan sat&#x27; : &#x27;jednog sata&#x27;;
	        case &#x27;hh&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;sat&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;sata&#x27;;
	            } else {
	                result +&#x3D; &#x27;sati&#x27;;
	            }
	            return result;
	        case &#x27;dd&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;dan&#x27;;
	            } else {
	                result +&#x3D; &#x27;dana&#x27;;
	            }
	            return result;
	        case &#x27;MM&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;mjesec&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;mjeseca&#x27;;
	            } else {
	                result +&#x3D; &#x27;mjeseci&#x27;;
	            }
	            return result;
	        case &#x27;yy&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; &#x27;godina&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2 || number &#x3D;&#x3D;&#x3D; 3 || number &#x3D;&#x3D;&#x3D; 4) {
	                result +&#x3D; &#x27;godine&#x27;;
	            } else {
	                result +&#x3D; &#x27;godina&#x27;;
	            }
	            return result;
	    }
	}

	var hr &#x3D; moment.defineLocale(&#x27;hr&#x27;, {
	    months : {
	        format: &#x27;siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ned._pon._uto._sri._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[danas u] LT&#x27;,
	        nextDay  : &#x27;[sutra u] LT&#x27;,
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedjelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [srijedu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[jučer u] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return &#x27;[prošlu] dddd [u] LT&#x27;;
	                case 6:
	                    return &#x27;[prošle] [subote] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[prošli] dddd [u] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;prije %s&#x27;,
	        s      : &#x27;par sekundi&#x27;,
	        ss     : translate,
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translate,
	        M      : &#x27;mjesec&#x27;,
	        MM     : translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hr;

	})));


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var weekEndings &#x3D; &#x27;vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton&#x27;.split(&#x27; &#x27;);
	function translate(number, withoutSuffix, key, isFuture) {
	    var num &#x3D; number;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return (isFuture || withoutSuffix) ? &#x27;néhány másodperc&#x27; : &#x27;néhány másodperce&#x27;;
	        case &#x27;ss&#x27;:
	            return num + (isFuture || withoutSuffix) ? &#x27; másodperc&#x27; : &#x27; másodperce&#x27;;
	        case &#x27;m&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; perc&#x27; : &#x27; perce&#x27;);
	        case &#x27;mm&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; perc&#x27; : &#x27; perce&#x27;);
	        case &#x27;h&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; óra&#x27; : &#x27; órája&#x27;);
	        case &#x27;hh&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; óra&#x27; : &#x27; órája&#x27;);
	        case &#x27;d&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; nap&#x27; : &#x27; napja&#x27;);
	        case &#x27;dd&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; nap&#x27; : &#x27; napja&#x27;);
	        case &#x27;M&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; hónap&#x27; : &#x27; hónapja&#x27;);
	        case &#x27;MM&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; hónap&#x27; : &#x27; hónapja&#x27;);
	        case &#x27;y&#x27;:
	            return &#x27;egy&#x27; + (isFuture || withoutSuffix ? &#x27; év&#x27; : &#x27; éve&#x27;);
	        case &#x27;yy&#x27;:
	            return num + (isFuture || withoutSuffix ? &#x27; év&#x27; : &#x27; éve&#x27;);
	    }
	    return &#x27;&#x27;;
	}
	function week(isFuture) {
	    return (isFuture ? &#x27;&#x27; : &#x27;[múlt] &#x27;) + &#x27;[&#x27; + weekEndings[this.day()] + &#x27;] LT[-kor]&#x27;;
	}

	var hu &#x3D; moment.defineLocale(&#x27;hu&#x27;, {
	    months : &#x27;január_február_március_április_május_június_július_augusztus_szeptember_október_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;vas_hét_kedd_sze_csüt_pén_szo&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;v_h_k_sze_cs_p_szo&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;YYYY.MM.DD.&#x27;,
	        LL : &#x27;YYYY. MMMM D.&#x27;,
	        LLL : &#x27;YYYY. MMMM D. H:mm&#x27;,
	        LLLL : &#x27;YYYY. MMMM D., dddd H:mm&#x27;
	    },
	    meridiemParse: /de|du/i,
	    isPM: function (input) {
	        return input.charAt(1).toLowerCase() &#x3D;&#x3D;&#x3D; &#x27;u&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 12) {
	            return isLower &#x3D;&#x3D;&#x3D; true ? &#x27;de&#x27; : &#x27;DE&#x27;;
	        } else {
	            return isLower &#x3D;&#x3D;&#x3D; true ? &#x27;du&#x27; : &#x27;DU&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[ma] LT[-kor]&#x27;,
	        nextDay : &#x27;[holnap] LT[-kor]&#x27;,
	        nextWeek : function () {
	            return week.call(this, true);
	        },
	        lastDay : &#x27;[tegnap] LT[-kor]&#x27;,
	        lastWeek : function () {
	            return week.call(this, false);
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s múlva&#x27;,
	        past : &#x27;%s&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return hu;

	})));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var hyAm &#x3D; moment.defineLocale(&#x27;hy-am&#x27;, {
	    months : {
	        format: &#x27;հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY թ.&#x27;,
	        LLL : &#x27;D MMMM YYYY թ., HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY թ., HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[այսօր] LT&#x27;,
	        nextDay: &#x27;[վաղը] LT&#x27;,
	        lastDay: &#x27;[երեկ] LT&#x27;,
	        nextWeek: function () {
	            return &#x27;dddd [օրը ժամը] LT&#x27;;
	        },
	        lastWeek: function () {
	            return &#x27;[անցած] dddd [օրը ժամը] LT&#x27;;
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s հետո&#x27;,
	        past : &#x27;%s առաջ&#x27;,
	        s : &#x27;մի քանի վայրկյան&#x27;,
	        ss : &#x27;%d վայրկյան&#x27;,
	        m : &#x27;րոպե&#x27;,
	        mm : &#x27;%d րոպե&#x27;,
	        h : &#x27;ժամ&#x27;,
	        hh : &#x27;%d ժամ&#x27;,
	        d : &#x27;օր&#x27;,
	        dd : &#x27;%d օր&#x27;,
	        M : &#x27;ամիս&#x27;,
	        MM : &#x27;%d ամիս&#x27;,
	        y : &#x27;տարի&#x27;,
	        yy : &#x27;%d տարի&#x27;
	    },
	    meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	    isPM: function (input) {
	        return /^(ցերեկվա|երեկոյան)$/.test(input);
	    },
	    meridiem : function (hour) {
	        if (hour &lt; 4) {
	            return &#x27;գիշերվա&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;առավոտվա&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ցերեկվա&#x27;;
	        } else {
	            return &#x27;երեկոյան&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;DDD&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	            case &#x27;DDDo&#x27;:
	                if (number &#x3D;&#x3D;&#x3D; 1) {
	                    return number + &#x27;-ին&#x27;;
	                }
	                return number + &#x27;-րդ&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hyAm;

	})));


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var id &#x3D; moment.defineLocale(&#x27;id&#x27;, {
	    months : &#x27;Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Min_Sen_Sel_Rab_Kam_Jum_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Mg_Sn_Sl_Rb_Km_Jm_Sb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /pagi|siang|sore|malam/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;pagi&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;siang&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;sore&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;malam&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;pagi&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;siang&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;sore&#x27;;
	        } else {
	            return &#x27;malam&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hari ini pukul] LT&#x27;,
	        nextDay : &#x27;[Besok pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kemarin pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [lalu pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dalam %s&#x27;,
	        past : &#x27;%s yang lalu&#x27;,
	        s : &#x27;beberapa detik&#x27;,
	        ss : &#x27;%d detik&#x27;,
	        m : &#x27;semenit&#x27;,
	        mm : &#x27;%d menit&#x27;,
	        h : &#x27;sejam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sehari&#x27;,
	        dd : &#x27;%d hari&#x27;,
	        M : &#x27;sebulan&#x27;,
	        MM : &#x27;%d bulan&#x27;,
	        y : &#x27;setahun&#x27;,
	        yy : &#x27;%d tahun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return id;

	})));


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(n) {
	    if (n % 100 &#x3D;&#x3D;&#x3D; 11) {
	        return true;
	    } else if (n % 10 &#x3D;&#x3D;&#x3D; 1) {
	        return false;
	    }
	    return true;
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result &#x3D; number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return withoutSuffix || isFuture ? &#x27;nokkrar sekúndur&#x27; : &#x27;nokkrum sekúndum&#x27;;
	        case &#x27;ss&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;sekúndur&#x27; : &#x27;sekúndum&#x27;);
	            }
	            return result + &#x27;sekúnda&#x27;;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;mínúta&#x27; : &#x27;mínútu&#x27;;
	        case &#x27;mm&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;mínútur&#x27; : &#x27;mínútum&#x27;);
	            } else if (withoutSuffix) {
	                return result + &#x27;mínúta&#x27;;
	            }
	            return result + &#x27;mínútu&#x27;;
	        case &#x27;hh&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;klukkustundir&#x27; : &#x27;klukkustundum&#x27;);
	            }
	            return result + &#x27;klukkustund&#x27;;
	        case &#x27;d&#x27;:
	            if (withoutSuffix) {
	                return &#x27;dagur&#x27;;
	            }
	            return isFuture ? &#x27;dag&#x27; : &#x27;degi&#x27;;
	        case &#x27;dd&#x27;:
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + &#x27;dagar&#x27;;
	                }
	                return result + (isFuture ? &#x27;daga&#x27; : &#x27;dögum&#x27;);
	            } else if (withoutSuffix) {
	                return result + &#x27;dagur&#x27;;
	            }
	            return result + (isFuture ? &#x27;dag&#x27; : &#x27;degi&#x27;);
	        case &#x27;M&#x27;:
	            if (withoutSuffix) {
	                return &#x27;mánuður&#x27;;
	            }
	            return isFuture ? &#x27;mánuð&#x27; : &#x27;mánuði&#x27;;
	        case &#x27;MM&#x27;:
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + &#x27;mánuðir&#x27;;
	                }
	                return result + (isFuture ? &#x27;mánuði&#x27; : &#x27;mánuðum&#x27;);
	            } else if (withoutSuffix) {
	                return result + &#x27;mánuður&#x27;;
	            }
	            return result + (isFuture ? &#x27;mánuð&#x27; : &#x27;mánuði&#x27;);
	        case &#x27;y&#x27;:
	            return withoutSuffix || isFuture ? &#x27;ár&#x27; : &#x27;ári&#x27;;
	        case &#x27;yy&#x27;:
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? &#x27;ár&#x27; : &#x27;árum&#x27;);
	            }
	            return result + (withoutSuffix || isFuture ? &#x27;ár&#x27; : &#x27;ári&#x27;);
	    }
	}

	var is &#x3D; moment.defineLocale(&#x27;is&#x27;, {
	    months : &#x27;janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sun_mán_þri_mið_fim_fös_lau&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Su_Má_Þr_Mi_Fi_Fö_La&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY [kl.] H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY [kl.] H:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[í dag kl.] LT&#x27;,
	        nextDay : &#x27;[á morgun kl.] LT&#x27;,
	        nextWeek : &#x27;dddd [kl.] LT&#x27;,
	        lastDay : &#x27;[í gær kl.] LT&#x27;,
	        lastWeek : &#x27;[síðasta] dddd [kl.] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;eftir %s&#x27;,
	        past : &#x27;fyrir %s síðan&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : &#x27;klukkustund&#x27;,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return is;

	})));


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var it &#x3D; moment.defineLocale(&#x27;it&#x27;, {
	    months : &#x27;gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;dom_lun_mar_mer_gio_ven_sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;do_lu_ma_me_gi_ve_sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Oggi alle] LT&#x27;,
	        nextDay: &#x27;[Domani alle] LT&#x27;,
	        nextWeek: &#x27;dddd [alle] LT&#x27;,
	        lastDay: &#x27;[Ieri alle] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[la scorsa] dddd [alle] LT&#x27;;
	                default:
	                    return &#x27;[lo scorso] dddd [alle] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (s) {
	            return ((/^[0-9].+$/).test(s) ? &#x27;tra&#x27; : &#x27;in&#x27;) + &#x27; &#x27; + s;
	        },
	        past : &#x27;%s fa&#x27;,
	        s : &#x27;alcuni secondi&#x27;,
	        ss : &#x27;%d secondi&#x27;,
	        m : &#x27;un minuto&#x27;,
	        mm : &#x27;%d minuti&#x27;,
	        h : &#x27;un\&#x27;ora&#x27;,
	        hh : &#x27;%d ore&#x27;,
	        d : &#x27;un giorno&#x27;,
	        dd : &#x27;%d giorni&#x27;,
	        M : &#x27;un mese&#x27;,
	        MM : &#x27;%d mesi&#x27;,
	        y : &#x27;un anno&#x27;,
	        yy : &#x27;%d anni&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal: &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return it;

	})));


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ja &#x3D; moment.defineLocale(&#x27;ja&#x27;, {
	    months : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;日_月_火_水_木_金_土&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_月_火_水_木_金_土&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        LLLL : &#x27;YYYY年M月D日 HH:mm dddd&#x27;,
	        l : &#x27;YYYY/MM/DD&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日 HH:mm dddd&#x27;
	    },
	    meridiemParse: /午前|午後/i,
	    isPM : function (input) {
	        return input &#x3D;&#x3D;&#x3D; &#x27;午後&#x27;;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;午前&#x27;;
	        } else {
	            return &#x27;午後&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今日] LT&#x27;,
	        nextDay : &#x27;[明日] LT&#x27;,
	        nextWeek : &#x27;[来週]dddd LT&#x27;,
	        lastDay : &#x27;[昨日] LT&#x27;,
	        lastWeek : &#x27;[前週]dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}日/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;日&#x27;;
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s後&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;数秒&#x27;,
	        ss : &#x27;%d秒&#x27;,
	        m : &#x27;1分&#x27;,
	        mm : &#x27;%d分&#x27;,
	        h : &#x27;1時間&#x27;,
	        hh : &#x27;%d時間&#x27;,
	        d : &#x27;1日&#x27;,
	        dd : &#x27;%d日&#x27;,
	        M : &#x27;1ヶ月&#x27;,
	        MM : &#x27;%dヶ月&#x27;,
	        y : &#x27;1年&#x27;,
	        yy : &#x27;%d年&#x27;
	    }
	});

	return ja;

	})));


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var jv &#x3D; moment.defineLocale(&#x27;jv&#x27;, {
	    months : &#x27;Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Min_Sen_Sel_Reb_Kem_Jem_Sep&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Mg_Sn_Sl_Rb_Km_Jm_Sp&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /enjing|siyang|sonten|ndalu/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;enjing&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;siyang&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;sonten&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;ndalu&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;enjing&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;siyang&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;sonten&#x27;;
	        } else {
	            return &#x27;ndalu&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Dinten puniko pukul] LT&#x27;,
	        nextDay : &#x27;[Mbenjang pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kala wingi pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [kepengker pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;wonten ing %s&#x27;,
	        past : &#x27;%s ingkang kepengker&#x27;,
	        s : &#x27;sawetawis detik&#x27;,
	        ss : &#x27;%d detik&#x27;,
	        m : &#x27;setunggal menit&#x27;,
	        mm : &#x27;%d menit&#x27;,
	        h : &#x27;setunggal jam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sedinten&#x27;,
	        dd : &#x27;%d dinten&#x27;,
	        M : &#x27;sewulan&#x27;,
	        MM : &#x27;%d wulan&#x27;,
	        y : &#x27;setaun&#x27;,
	        yy : &#x27;%d taun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return jv;

	})));


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ka &#x3D; moment.defineLocale(&#x27;ka&#x27;, {
	    months : {
	        standalone: &#x27;იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ&#x27;.split(&#x27;_&#x27;),
	    weekdays : {
	        standalone: &#x27;კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს&#x27;.split(&#x27;_&#x27;),
	        isFormat: /(წინა|შემდეგ)/
	    },
	    weekdaysShort : &#x27;კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;კვ_ორ_სა_ოთ_ხუ_პა_შა&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[დღეს] LT[-ზე]&#x27;,
	        nextDay : &#x27;[ხვალ] LT[-ზე]&#x27;,
	        lastDay : &#x27;[გუშინ] LT[-ზე]&#x27;,
	        nextWeek : &#x27;[შემდეგ] dddd LT[-ზე]&#x27;,
	        lastWeek : &#x27;[წინა] dddd LT-ზე&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : function (s) {
	            return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                s.replace(/ი$/, &#x27;ში&#x27;) :
	                s + &#x27;ში&#x27;;
	        },
	        past : function (s) {
	            if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                return s.replace(/(ი|ე)$/, &#x27;ის უკან&#x27;);
	            }
	            if ((/წელი/).test(s)) {
	                return s.replace(/წელი$/, &#x27;წლის უკან&#x27;);
	            }
	        },
	        s : &#x27;რამდენიმე წამი&#x27;,
	        ss : &#x27;%d წამი&#x27;,
	        m : &#x27;წუთი&#x27;,
	        mm : &#x27;%d წუთი&#x27;,
	        h : &#x27;საათი&#x27;,
	        hh : &#x27;%d საათი&#x27;,
	        d : &#x27;დღე&#x27;,
	        dd : &#x27;%d დღე&#x27;,
	        M : &#x27;თვე&#x27;,
	        MM : &#x27;%d თვე&#x27;,
	        y : &#x27;წელი&#x27;,
	        yy : &#x27;%d წელი&#x27;
	    },
	    dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	    ordinal : function (number) {
	        if (number &#x3D;&#x3D;&#x3D; 0) {
	            return number;
	        }
	        if (number &#x3D;&#x3D;&#x3D; 1) {
	            return number + &#x27;-ლი&#x27;;
	        }
	        if ((number &lt; 20) || (number &lt;&#x3D; 100 &amp;&amp; (number % 20 &#x3D;&#x3D;&#x3D; 0)) || (number % 100 &#x3D;&#x3D;&#x3D; 0)) {
	            return &#x27;მე-&#x27; + number;
	        }
	        return number + &#x27;-ე&#x27;;
	    },
	    week : {
	        dow : 1,
	        doy : 7
	    }
	});

	return ka;

	})));


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes &#x3D; {
	    0: &#x27;-ші&#x27;,
	    1: &#x27;-ші&#x27;,
	    2: &#x27;-ші&#x27;,
	    3: &#x27;-ші&#x27;,
	    4: &#x27;-ші&#x27;,
	    5: &#x27;-ші&#x27;,
	    6: &#x27;-шы&#x27;,
	    7: &#x27;-ші&#x27;,
	    8: &#x27;-ші&#x27;,
	    9: &#x27;-шы&#x27;,
	    10: &#x27;-шы&#x27;,
	    20: &#x27;-шы&#x27;,
	    30: &#x27;-шы&#x27;,
	    40: &#x27;-шы&#x27;,
	    50: &#x27;-ші&#x27;,
	    60: &#x27;-шы&#x27;,
	    70: &#x27;-ші&#x27;,
	    80: &#x27;-ші&#x27;,
	    90: &#x27;-шы&#x27;,
	    100: &#x27;-ші&#x27;
	};

	var kk &#x3D; moment.defineLocale(&#x27;kk&#x27;, {
	    months : &#x27;қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;жек_дүй_сей_сәр_бей_жұм_сен&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;жк_дй_сй_ср_бй_жм_сн&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Бүгін сағат] LT&#x27;,
	        nextDay : &#x27;[Ертең сағат] LT&#x27;,
	        nextWeek : &#x27;dddd [сағат] LT&#x27;,
	        lastDay : &#x27;[Кеше сағат] LT&#x27;,
	        lastWeek : &#x27;[Өткен аптаның] dddd [сағат] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ішінде&#x27;,
	        past : &#x27;%s бұрын&#x27;,
	        s : &#x27;бірнеше секунд&#x27;,
	        ss : &#x27;%d секунд&#x27;,
	        m : &#x27;бір минут&#x27;,
	        mm : &#x27;%d минут&#x27;,
	        h : &#x27;бір сағат&#x27;,
	        hh : &#x27;%d сағат&#x27;,
	        d : &#x27;бір күн&#x27;,
	        dd : &#x27;%d күн&#x27;,
	        M : &#x27;бір ай&#x27;,
	        MM : &#x27;%d ай&#x27;,
	        y : &#x27;бір жыл&#x27;,
	        yy : &#x27;%d жыл&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
	    ordinal : function (number) {
	        var a &#x3D; number % 10,
	            b &#x3D; number &gt;&#x3D; 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kk;

	})));


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var km &#x3D; moment.defineLocale(&#x27;km&#x27;, {
	    months: &#x27;មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[ថ្ងៃនេះ ម៉ោង] LT&#x27;,
	        nextDay: &#x27;[ស្អែក ម៉ោង] LT&#x27;,
	        nextWeek: &#x27;dddd [ម៉ោង] LT&#x27;,
	        lastDay: &#x27;[ម្សិលមិញ ម៉ោង] LT&#x27;,
	        lastWeek: &#x27;dddd [សប្តាហ៍មុន] [ម៉ោង] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;%sទៀត&#x27;,
	        past: &#x27;%sមុន&#x27;,
	        s: &#x27;ប៉ុន្មានវិនាទី&#x27;,
	        ss: &#x27;%d វិនាទី&#x27;,
	        m: &#x27;មួយនាទី&#x27;,
	        mm: &#x27;%d នាទី&#x27;,
	        h: &#x27;មួយម៉ោង&#x27;,
	        hh: &#x27;%d ម៉ោង&#x27;,
	        d: &#x27;មួយថ្ងៃ&#x27;,
	        dd: &#x27;%d ថ្ងៃ&#x27;,
	        M: &#x27;មួយខែ&#x27;,
	        MM: &#x27;%d ខែ&#x27;,
	        y: &#x27;មួយឆ្នាំ&#x27;,
	        yy: &#x27;%d ឆ្នាំ&#x27;
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return km;

	})));


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;೧&#x27;,
	    &#x27;2&#x27;: &#x27;೨&#x27;,
	    &#x27;3&#x27;: &#x27;೩&#x27;,
	    &#x27;4&#x27;: &#x27;೪&#x27;,
	    &#x27;5&#x27;: &#x27;೫&#x27;,
	    &#x27;6&#x27;: &#x27;೬&#x27;,
	    &#x27;7&#x27;: &#x27;೭&#x27;,
	    &#x27;8&#x27;: &#x27;೮&#x27;,
	    &#x27;9&#x27;: &#x27;೯&#x27;,
	    &#x27;0&#x27;: &#x27;೦&#x27;
	},
	numberMap &#x3D; {
	    &#x27;೧&#x27;: &#x27;1&#x27;,
	    &#x27;೨&#x27;: &#x27;2&#x27;,
	    &#x27;೩&#x27;: &#x27;3&#x27;,
	    &#x27;೪&#x27;: &#x27;4&#x27;,
	    &#x27;೫&#x27;: &#x27;5&#x27;,
	    &#x27;೬&#x27;: &#x27;6&#x27;,
	    &#x27;೭&#x27;: &#x27;7&#x27;,
	    &#x27;೮&#x27;: &#x27;8&#x27;,
	    &#x27;೯&#x27;: &#x27;9&#x27;,
	    &#x27;೦&#x27;: &#x27;0&#x27;
	};

	var kn &#x3D; moment.defineLocale(&#x27;kn&#x27;, {
	    months : &#x27;ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[ಇಂದು] LT&#x27;,
	        nextDay : &#x27;[ನಾಳೆ] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[ನಿನ್ನೆ] LT&#x27;,
	        lastWeek : &#x27;[ಕೊನೆಯ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ನಂತರ&#x27;,
	        past : &#x27;%s ಹಿಂದೆ&#x27;,
	        s : &#x27;ಕೆಲವು ಕ್ಷಣಗಳು&#x27;,
	        ss : &#x27;%d ಸೆಕೆಂಡುಗಳು&#x27;,
	        m : &#x27;ಒಂದು ನಿಮಿಷ&#x27;,
	        mm : &#x27;%d ನಿಮಿಷ&#x27;,
	        h : &#x27;ಒಂದು ಗಂಟೆ&#x27;,
	        hh : &#x27;%d ಗಂಟೆ&#x27;,
	        d : &#x27;ಒಂದು ದಿನ&#x27;,
	        dd : &#x27;%d ದಿನ&#x27;,
	        M : &#x27;ಒಂದು ತಿಂಗಳು&#x27;,
	        MM : &#x27;%d ತಿಂಗಳು&#x27;,
	        y : &#x27;ಒಂದು ವರ್ಷ&#x27;,
	        yy : &#x27;%d ವರ್ಷ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ರಾತ್ರಿ&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ಬೆಳಿಗ್ಗೆ&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ಮಧ್ಯಾಹ್ನ&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ಸಂಜೆ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ರಾತ್ರಿ&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ಬೆಳಿಗ್ಗೆ&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ಮಧ್ಯಾಹ್ನ&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;ಸಂಜೆ&#x27;;
	        } else {
	            return &#x27;ರಾತ್ರಿ&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
	    ordinal : function (number) {
	        return number + &#x27;ನೇ&#x27;;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kn;

	})));


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ko &#x3D; moment.defineLocale(&#x27;ko&#x27;, {
	    months : &#x27;1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;일요일_월요일_화요일_수요일_목요일_금요일_토요일&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;일_월_화_수_목_금_토&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;일_월_화_수_목_금_토&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;YYYY.MM.DD.&#x27;,
	        LL : &#x27;YYYY년 MMMM D일&#x27;,
	        LLL : &#x27;YYYY년 MMMM D일 A h:mm&#x27;,
	        LLLL : &#x27;YYYY년 MMMM D일 dddd A h:mm&#x27;,
	        l : &#x27;YYYY.MM.DD.&#x27;,
	        ll : &#x27;YYYY년 MMMM D일&#x27;,
	        lll : &#x27;YYYY년 MMMM D일 A h:mm&#x27;,
	        llll : &#x27;YYYY년 MMMM D일 dddd A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;오늘 LT&#x27;,
	        nextDay : &#x27;내일 LT&#x27;,
	        nextWeek : &#x27;dddd LT&#x27;,
	        lastDay : &#x27;어제 LT&#x27;,
	        lastWeek : &#x27;지난주 dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s 후&#x27;,
	        past : &#x27;%s 전&#x27;,
	        s : &#x27;몇 초&#x27;,
	        ss : &#x27;%d초&#x27;,
	        m : &#x27;1분&#x27;,
	        mm : &#x27;%d분&#x27;,
	        h : &#x27;한 시간&#x27;,
	        hh : &#x27;%d시간&#x27;,
	        d : &#x27;하루&#x27;,
	        dd : &#x27;%d일&#x27;,
	        M : &#x27;한 달&#x27;,
	        MM : &#x27;%d달&#x27;,
	        y : &#x27;일 년&#x27;,
	        yy : &#x27;%d년&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(일|월|주)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;일&#x27;;
	            case &#x27;M&#x27;:
	                return number + &#x27;월&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;주&#x27;;
	            default:
	                return number;
	        }
	    },
	    meridiemParse : /오전|오후/,
	    isPM : function (token) {
	        return token &#x3D;&#x3D;&#x3D; &#x27;오후&#x27;;
	    },
	    meridiem : function (hour, minute, isUpper) {
	        return hour &lt; 12 ? &#x27;오전&#x27; : &#x27;오후&#x27;;
	    }
	});

	return ko;

	})));


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes &#x3D; {
	    0: &#x27;-чү&#x27;,
	    1: &#x27;-чи&#x27;,
	    2: &#x27;-чи&#x27;,
	    3: &#x27;-чү&#x27;,
	    4: &#x27;-чү&#x27;,
	    5: &#x27;-чи&#x27;,
	    6: &#x27;-чы&#x27;,
	    7: &#x27;-чи&#x27;,
	    8: &#x27;-чи&#x27;,
	    9: &#x27;-чу&#x27;,
	    10: &#x27;-чу&#x27;,
	    20: &#x27;-чы&#x27;,
	    30: &#x27;-чу&#x27;,
	    40: &#x27;-чы&#x27;,
	    50: &#x27;-чү&#x27;,
	    60: &#x27;-чы&#x27;,
	    70: &#x27;-чи&#x27;,
	    80: &#x27;-чи&#x27;,
	    90: &#x27;-чу&#x27;,
	    100: &#x27;-чү&#x27;
	};

	var ky &#x3D; moment.defineLocale(&#x27;ky&#x27;, {
	    months : &#x27;январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Жек_Дүй_Шей_Шар_Бей_Жум_Ише&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Жк_Дй_Шй_Шр_Бй_Жм_Иш&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Бүгүн саат] LT&#x27;,
	        nextDay : &#x27;[Эртең саат] LT&#x27;,
	        nextWeek : &#x27;dddd [саат] LT&#x27;,
	        lastDay : &#x27;[Кече саат] LT&#x27;,
	        lastWeek : &#x27;[Өткен аптанын] dddd [күнү] [саат] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ичинде&#x27;,
	        past : &#x27;%s мурун&#x27;,
	        s : &#x27;бирнече секунд&#x27;,
	        ss : &#x27;%d секунд&#x27;,
	        m : &#x27;бир мүнөт&#x27;,
	        mm : &#x27;%d мүнөт&#x27;,
	        h : &#x27;бир саат&#x27;,
	        hh : &#x27;%d саат&#x27;,
	        d : &#x27;бир күн&#x27;,
	        dd : &#x27;%d күн&#x27;,
	        M : &#x27;бир ай&#x27;,
	        MM : &#x27;%d ай&#x27;,
	        y : &#x27;бир жыл&#x27;,
	        yy : &#x27;%d жыл&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
	    ordinal : function (number) {
	        var a &#x3D; number % 10,
	            b &#x3D; number &gt;&#x3D; 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ky;

	})));


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format &#x3D; {
	        &#x27;m&#x27;: [&#x27;eng Minutt&#x27;, &#x27;enger Minutt&#x27;],
	        &#x27;h&#x27;: [&#x27;eng Stonn&#x27;, &#x27;enger Stonn&#x27;],
	        &#x27;d&#x27;: [&#x27;een Dag&#x27;, &#x27;engem Dag&#x27;],
	        &#x27;M&#x27;: [&#x27;ee Mount&#x27;, &#x27;engem Mount&#x27;],
	        &#x27;y&#x27;: [&#x27;ee Joer&#x27;, &#x27;engem Joer&#x27;]
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
	    var number &#x3D; string.substr(0, string.indexOf(&#x27; &#x27;));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return &#x27;a &#x27; + string;
	    }
	    return &#x27;an &#x27; + string;
	}
	function processPastTime(string) {
	    var number &#x3D; string.substr(0, string.indexOf(&#x27; &#x27;));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return &#x27;viru &#x27; + string;
	    }
	    return &#x27;virun &#x27; + string;
	}
	/**
	 * Returns true if the word before the given number loses the &#x27;-n&#x27; ending.
	 * e.g. &#x27;an 10 Deeg&#x27; but &#x27;a 5 Deeg&#x27;
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
	    number &#x3D; parseInt(number, 10);
	    if (isNaN(number)) {
	        return false;
	    }
	    if (number &lt; 0) {
	        // Negative Number --&gt; always true
	        return true;
	    } else if (number &lt; 10) {
	        // Only 1 digit
	        if (4 &lt;&#x3D; number &amp;&amp; number &lt;&#x3D; 7) {
	            return true;
	        }
	        return false;
	    } else if (number &lt; 100) {
	        // 2 digits
	        var lastDigit &#x3D; number % 10, firstDigit &#x3D; number / 10;
	        if (lastDigit &#x3D;&#x3D;&#x3D; 0) {
	            return eifelerRegelAppliesToNumber(firstDigit);
	        }
	        return eifelerRegelAppliesToNumber(lastDigit);
	    } else if (number &lt; 10000) {
	        // 3 or 4 digits --&gt; recursively check first digit
	        while (number &gt;&#x3D; 10) {
	            number &#x3D; number / 10;
	        }
	        return eifelerRegelAppliesToNumber(number);
	    } else {
	        // Anything larger than 4 digits: recursively check first n-3 digits
	        number &#x3D; number / 1000;
	        return eifelerRegelAppliesToNumber(number);
	    }
	}

	var lb &#x3D; moment.defineLocale(&#x27;lb&#x27;, {
	    months: &#x27;Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays: &#x27;Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;So._Mé._Dë._Më._Do._Fr._Sa.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;So_Mé_Dë_Më_Do_Fr_Sa&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm [Auer]&#x27;,
	        LTS: &#x27;H:mm:ss [Auer]&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm [Auer]&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm [Auer]&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[Haut um] LT&#x27;,
	        sameElse: &#x27;L&#x27;,
	        nextDay: &#x27;[Muer um] LT&#x27;,
	        nextWeek: &#x27;dddd [um] LT&#x27;,
	        lastDay: &#x27;[Gëschter um] LT&#x27;,
	        lastWeek: function () {
	            // Different date string for &#x27;Dënschdeg&#x27; (Tuesday) and &#x27;Donneschdeg&#x27; (Thursday) due to phonological rule
	            switch (this.day()) {
	                case 2:
	                case 4:
	                    return &#x27;[Leschten] dddd [um] LT&#x27;;
	                default:
	                    return &#x27;[Leschte] dddd [um] LT&#x27;;
	            }
	        }
	    },
	    relativeTime : {
	        future : processFutureTime,
	        past : processPastTime,
	        s : &#x27;e puer Sekonnen&#x27;,
	        ss : &#x27;%d Sekonnen&#x27;,
	        m : processRelativeTime,
	        mm : &#x27;%d Minutten&#x27;,
	        h : processRelativeTime,
	        hh : &#x27;%d Stonnen&#x27;,
	        d : processRelativeTime,
	        dd : &#x27;%d Deeg&#x27;,
	        M : processRelativeTime,
	        MM : &#x27;%d Méint&#x27;,
	        y : processRelativeTime,
	        yy : &#x27;%d Joer&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal: &#x27;%d.&#x27;,
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lb;

	})));


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var lo &#x3D; moment.defineLocale(&#x27;lo&#x27;, {
	    months : &#x27;ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;ວັນdddd D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
	    isPM: function (input) {
	        return input &#x3D;&#x3D;&#x3D; &#x27;ຕອນແລງ&#x27;;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ຕອນເຊົ້າ&#x27;;
	        } else {
	            return &#x27;ຕອນແລງ&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[ມື້ນີ້ເວລາ] LT&#x27;,
	        nextDay : &#x27;[ມື້ອື່ນເວລາ] LT&#x27;,
	        nextWeek : &#x27;[ວັນ]dddd[ໜ້າເວລາ] LT&#x27;,
	        lastDay : &#x27;[ມື້ວານນີ້ເວລາ] LT&#x27;,
	        lastWeek : &#x27;[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ອີກ %s&#x27;,
	        past : &#x27;%sຜ່ານມາ&#x27;,
	        s : &#x27;ບໍ່ເທົ່າໃດວິນາທີ&#x27;,
	        ss : &#x27;%d ວິນາທີ&#x27; ,
	        m : &#x27;1 ນາທີ&#x27;,
	        mm : &#x27;%d ນາທີ&#x27;,
	        h : &#x27;1 ຊົ່ວໂມງ&#x27;,
	        hh : &#x27;%d ຊົ່ວໂມງ&#x27;,
	        d : &#x27;1 ມື້&#x27;,
	        dd : &#x27;%d ມື້&#x27;,
	        M : &#x27;1 ເດືອນ&#x27;,
	        MM : &#x27;%d ເດືອນ&#x27;,
	        y : &#x27;1 ປີ&#x27;,
	        yy : &#x27;%d ປີ&#x27;
	    },
	    dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
	    ordinal : function (number) {
	        return &#x27;ທີ່&#x27; + number;
	    }
	});

	return lo;

	})));


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var units &#x3D; {
	    &#x27;ss&#x27; : &#x27;sekundė_sekundžių_sekundes&#x27;,
	    &#x27;m&#x27; : &#x27;minutė_minutės_minutę&#x27;,
	    &#x27;mm&#x27;: &#x27;minutės_minučių_minutes&#x27;,
	    &#x27;h&#x27; : &#x27;valanda_valandos_valandą&#x27;,
	    &#x27;hh&#x27;: &#x27;valandos_valandų_valandas&#x27;,
	    &#x27;d&#x27; : &#x27;diena_dienos_dieną&#x27;,
	    &#x27;dd&#x27;: &#x27;dienos_dienų_dienas&#x27;,
	    &#x27;M&#x27; : &#x27;mėnuo_mėnesio_mėnesį&#x27;,
	    &#x27;MM&#x27;: &#x27;mėnesiai_mėnesių_mėnesius&#x27;,
	    &#x27;y&#x27; : &#x27;metai_metų_metus&#x27;,
	    &#x27;yy&#x27;: &#x27;metai_metų_metus&#x27;
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
	    if (withoutSuffix) {
	        return &#x27;kelios sekundės&#x27;;
	    } else {
	        return isFuture ? &#x27;kelių sekundžių&#x27; : &#x27;kelias sekundes&#x27;;
	    }
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
	    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
	    return number % 10 &#x3D;&#x3D;&#x3D; 0 || (number &gt; 10 &amp;&amp; number &lt; 20);
	}
	function forms(key) {
	    return units[key].split(&#x27;_&#x27;);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result &#x3D; number + &#x27; &#x27;;
	    if (number &#x3D;&#x3D;&#x3D; 1) {
	        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	    } else if (withoutSuffix) {
	        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	    } else {
	        if (isFuture) {
	            return result + forms(key)[1];
	        } else {
	            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	        }
	    }
	}
	var lt &#x3D; moment.defineLocale(&#x27;lt&#x27;, {
	    months : {
	        format: &#x27;sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis&#x27;.split(&#x27;_&#x27;),
	        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	    },
	    monthsShort : &#x27;sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd&#x27;.split(&#x27;_&#x27;),
	    weekdays : {
	        format: &#x27;sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis&#x27;.split(&#x27;_&#x27;),
	        isFormat: /dddd HH:mm/
	    },
	    weekdaysShort : &#x27;Sek_Pir_Ant_Tre_Ket_Pen_Šeš&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;S_P_A_T_K_Pn_Š&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;YYYY [m.] MMMM D [d.]&#x27;,
	        LLL : &#x27;YYYY [m.] MMMM D [d.], HH:mm [val.]&#x27;,
	        LLLL : &#x27;YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]&#x27;,
	        l : &#x27;YYYY-MM-DD&#x27;,
	        ll : &#x27;YYYY [m.] MMMM D [d.]&#x27;,
	        lll : &#x27;YYYY [m.] MMMM D [d.], HH:mm [val.]&#x27;,
	        llll : &#x27;YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Šiandien] LT&#x27;,
	        nextDay : &#x27;[Rytoj] LT&#x27;,
	        nextWeek : &#x27;dddd LT&#x27;,
	        lastDay : &#x27;[Vakar] LT&#x27;,
	        lastWeek : &#x27;[Praėjusį] dddd LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;po %s&#x27;,
	        past : &#x27;prieš %s&#x27;,
	        s : translateSeconds,
	        ss : translate,
	        m : translateSingular,
	        mm : translate,
	        h : translateSingular,
	        hh : translate,
	        d : translateSingular,
	        dd : translate,
	        M : translateSingular,
	        MM : translate,
	        y : translateSingular,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
	    ordinal : function (number) {
	        return number + &#x27;-oji&#x27;;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lt;

	})));


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var units &#x3D; {
	    &#x27;ss&#x27;: &#x27;sekundes_sekundēm_sekunde_sekundes&#x27;.split(&#x27;_&#x27;),
	    &#x27;m&#x27;: &#x27;minūtes_minūtēm_minūte_minūtes&#x27;.split(&#x27;_&#x27;),
	    &#x27;mm&#x27;: &#x27;minūtes_minūtēm_minūte_minūtes&#x27;.split(&#x27;_&#x27;),
	    &#x27;h&#x27;: &#x27;stundas_stundām_stunda_stundas&#x27;.split(&#x27;_&#x27;),
	    &#x27;hh&#x27;: &#x27;stundas_stundām_stunda_stundas&#x27;.split(&#x27;_&#x27;),
	    &#x27;d&#x27;: &#x27;dienas_dienām_diena_dienas&#x27;.split(&#x27;_&#x27;),
	    &#x27;dd&#x27;: &#x27;dienas_dienām_diena_dienas&#x27;.split(&#x27;_&#x27;),
	    &#x27;M&#x27;: &#x27;mēneša_mēnešiem_mēnesis_mēneši&#x27;.split(&#x27;_&#x27;),
	    &#x27;MM&#x27;: &#x27;mēneša_mēnešiem_mēnesis_mēneši&#x27;.split(&#x27;_&#x27;),
	    &#x27;y&#x27;: &#x27;gada_gadiem_gads_gadi&#x27;.split(&#x27;_&#x27;),
	    &#x27;yy&#x27;: &#x27;gada_gadiem_gads_gadi&#x27;.split(&#x27;_&#x27;)
	};
	/**
	 * @param withoutSuffix boolean true &#x3D; a length of time; false &#x3D; before/after a period of time.
	 */
	function format(forms, number, withoutSuffix) {
	    if (withoutSuffix) {
	        // E.g. &quot;21 minūte&quot;, &quot;3 minūtes&quot;.
	        return number % 10 &#x3D;&#x3D;&#x3D; 1 &amp;&amp; number % 100 !&#x3D;&#x3D; 11 ? forms[2] : forms[3];
	    } else {
	        // E.g. &quot;21 minūtes&quot; as in &quot;pēc 21 minūtes&quot;.
	        // E.g. &quot;3 minūtēm&quot; as in &quot;pēc 3 minūtēm&quot;.
	        return number % 10 &#x3D;&#x3D;&#x3D; 1 &amp;&amp; number % 100 !&#x3D;&#x3D; 11 ? forms[0] : forms[1];
	    }
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    return number + &#x27; &#x27; + format(units[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
	    return format(units[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
	    return withoutSuffix ? &#x27;dažas sekundes&#x27; : &#x27;dažām sekundēm&#x27;;
	}

	var lv &#x3D; moment.defineLocale(&#x27;lv&#x27;, {
	    months : &#x27;janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Sv_P_O_T_C_Pk_S&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Sv_P_O_T_C_Pk_S&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY.&#x27;,
	        LL : &#x27;YYYY. [gada] D. MMMM&#x27;,
	        LLL : &#x27;YYYY. [gada] D. MMMM, HH:mm&#x27;,
	        LLLL : &#x27;YYYY. [gada] D. MMMM, dddd, HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Šodien pulksten] LT&#x27;,
	        nextDay : &#x27;[Rīt pulksten] LT&#x27;,
	        nextWeek : &#x27;dddd [pulksten] LT&#x27;,
	        lastDay : &#x27;[Vakar pulksten] LT&#x27;,
	        lastWeek : &#x27;[Pagājušā] dddd [pulksten] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;pēc %s&#x27;,
	        past : &#x27;pirms %s&#x27;,
	        s : relativeSeconds,
	        ss : relativeTimeWithPlural,
	        m : relativeTimeWithSingular,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithSingular,
	        hh : relativeTimeWithPlural,
	        d : relativeTimeWithSingular,
	        dd : relativeTimeWithPlural,
	        M : relativeTimeWithSingular,
	        MM : relativeTimeWithPlural,
	        y : relativeTimeWithSingular,
	        yy : relativeTimeWithPlural
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lv;

	})));


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var translator &#x3D; {
	    words: { //Different grammatical cases
	        ss: [&#x27;sekund&#x27;, &#x27;sekunda&#x27;, &#x27;sekundi&#x27;],
	        m: [&#x27;jedan minut&#x27;, &#x27;jednog minuta&#x27;],
	        mm: [&#x27;minut&#x27;, &#x27;minuta&#x27;, &#x27;minuta&#x27;],
	        h: [&#x27;jedan sat&#x27;, &#x27;jednog sata&#x27;],
	        hh: [&#x27;sat&#x27;, &#x27;sata&#x27;, &#x27;sati&#x27;],
	        dd: [&#x27;dan&#x27;, &#x27;dana&#x27;, &#x27;dana&#x27;],
	        MM: [&#x27;mjesec&#x27;, &#x27;mjeseca&#x27;, &#x27;mjeseci&#x27;],
	        yy: [&#x27;godina&#x27;, &#x27;godine&#x27;, &#x27;godina&#x27;]
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number &#x3D;&#x3D;&#x3D; 1 ? wordKey[0] : (number &gt;&#x3D; 2 &amp;&amp; number &lt;&#x3D; 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey &#x3D; translator.words[key];
	        if (key.length &#x3D;&#x3D;&#x3D; 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + &#x27; &#x27; + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var me &#x3D; moment.defineLocale(&#x27;me&#x27;, {
	    months: &#x27;januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays: &#x27;nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;ned._pon._uto._sri._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[danas u] LT&#x27;,
	        nextDay: &#x27;[sjutra u] LT&#x27;,

	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedjelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [srijedu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[juče u] LT&#x27;,
	        lastWeek : function () {
	            var lastWeekDays &#x3D; [
	                &#x27;[prošle] [nedjelje] [u] LT&#x27;,
	                &#x27;[prošlog] [ponedjeljka] [u] LT&#x27;,
	                &#x27;[prošlog] [utorka] [u] LT&#x27;,
	                &#x27;[prošle] [srijede] [u] LT&#x27;,
	                &#x27;[prošlog] [četvrtka] [u] LT&#x27;,
	                &#x27;[prošlog] [petka] [u] LT&#x27;,
	                &#x27;[prošle] [subote] [u] LT&#x27;
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;prije %s&#x27;,
	        s      : &#x27;nekoliko sekundi&#x27;,
	        ss     : translator.translate,
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translator.translate,
	        M      : &#x27;mjesec&#x27;,
	        MM     : translator.translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return me;

	})));


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var mi &#x3D; moment.defineLocale(&#x27;mi&#x27;, {
	    months: &#x27;Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki&#x27;.split(&#x27;_&#x27;),
	    monthsRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsStrictRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortStrictRegex: /(?:[&#x27;a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	    weekdays: &#x27;Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;Ta_Ma_Tū_We_Tāi_Pa_Hā&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;Ta_Ma_Tū_We_Tāi_Pa_Hā&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY [i] HH:mm&#x27;,
	        LLLL: &#x27;dddd, D MMMM YYYY [i] HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[i teie mahana, i] LT&#x27;,
	        nextDay: &#x27;[apopo i] LT&#x27;,
	        nextWeek: &#x27;dddd [i] LT&#x27;,
	        lastDay: &#x27;[inanahi i] LT&#x27;,
	        lastWeek: &#x27;dddd [whakamutunga i] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;i roto i %s&#x27;,
	        past: &#x27;%s i mua&#x27;,
	        s: &#x27;te hēkona ruarua&#x27;,
	        ss: &#x27;%d hēkona&#x27;,
	        m: &#x27;he meneti&#x27;,
	        mm: &#x27;%d meneti&#x27;,
	        h: &#x27;te haora&#x27;,
	        hh: &#x27;%d haora&#x27;,
	        d: &#x27;he ra&#x27;,
	        dd: &#x27;%d ra&#x27;,
	        M: &#x27;he marama&#x27;,
	        MM: &#x27;%d marama&#x27;,
	        y: &#x27;he tau&#x27;,
	        yy: &#x27;%d tau&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal: &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return mi;

	})));


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var mk &#x3D; moment.defineLocale(&#x27;mk&#x27;, {
	    months : &#x27;јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;недела_понеделник_вторник_среда_четврток_петок_сабота&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;нед_пон_вто_сре_чет_пет_саб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нe_пo_вт_ср_че_пе_сa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;D.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Денес во] LT&#x27;,
	        nextDay : &#x27;[Утре во] LT&#x27;,
	        nextWeek : &#x27;[Во] dddd [во] LT&#x27;,
	        lastDay : &#x27;[Вчера во] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return &#x27;[Изминатата] dddd [во] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[Изминатиот] dddd [во] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;после %s&#x27;,
	        past : &#x27;пред %s&#x27;,
	        s : &#x27;неколку секунди&#x27;,
	        ss : &#x27;%d секунди&#x27;,
	        m : &#x27;минута&#x27;,
	        mm : &#x27;%d минути&#x27;,
	        h : &#x27;час&#x27;,
	        hh : &#x27;%d часа&#x27;,
	        d : &#x27;ден&#x27;,
	        dd : &#x27;%d дена&#x27;,
	        M : &#x27;месец&#x27;,
	        MM : &#x27;%d месеци&#x27;,
	        y : &#x27;година&#x27;,
	        yy : &#x27;%d години&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit &#x3D; number % 10,
	            last2Digits &#x3D; number % 100;
	        if (number &#x3D;&#x3D;&#x3D; 0) {
	            return number + &#x27;-ев&#x27;;
	        } else if (last2Digits &#x3D;&#x3D;&#x3D; 0) {
	            return number + &#x27;-ен&#x27;;
	        } else if (last2Digits &gt; 10 &amp;&amp; last2Digits &lt; 20) {
	            return number + &#x27;-ти&#x27;;
	        } else if (lastDigit &#x3D;&#x3D;&#x3D; 1) {
	            return number + &#x27;-ви&#x27;;
	        } else if (lastDigit &#x3D;&#x3D;&#x3D; 2) {
	            return number + &#x27;-ри&#x27;;
	        } else if (lastDigit &#x3D;&#x3D;&#x3D; 7 || lastDigit &#x3D;&#x3D;&#x3D; 8) {
	            return number + &#x27;-ми&#x27;;
	        } else {
	            return number + &#x27;-ти&#x27;;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mk;

	})));


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ml &#x3D; moment.defineLocale(&#x27;ml&#x27;, {
	    months : &#x27;ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm -നു&#x27;,
	        LTS : &#x27;A h:mm:ss -നു&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm -നു&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm -നു&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[ഇന്ന്] LT&#x27;,
	        nextDay : &#x27;[നാളെ] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[ഇന്നലെ] LT&#x27;,
	        lastWeek : &#x27;[കഴിഞ്ഞ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s കഴിഞ്ഞ്&#x27;,
	        past : &#x27;%s മുൻപ്&#x27;,
	        s : &#x27;അൽപ നിമിഷങ്ങൾ&#x27;,
	        ss : &#x27;%d സെക്കൻഡ്&#x27;,
	        m : &#x27;ഒരു മിനിറ്റ്&#x27;,
	        mm : &#x27;%d മിനിറ്റ്&#x27;,
	        h : &#x27;ഒരു മണിക്കൂർ&#x27;,
	        hh : &#x27;%d മണിക്കൂർ&#x27;,
	        d : &#x27;ഒരു ദിവസം&#x27;,
	        dd : &#x27;%d ദിവസം&#x27;,
	        M : &#x27;ഒരു മാസം&#x27;,
	        MM : &#x27;%d മാസം&#x27;,
	        y : &#x27;ഒരു വർഷം&#x27;,
	        yy : &#x27;%d വർഷം&#x27;
	    },
	    meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if ((meridiem &#x3D;&#x3D;&#x3D; &#x27;രാത്രി&#x27; &amp;&amp; hour &gt;&#x3D; 4) ||
	                meridiem &#x3D;&#x3D;&#x3D; &#x27;ഉച്ച കഴിഞ്ഞ്&#x27; ||
	                meridiem &#x3D;&#x3D;&#x3D; &#x27;വൈകുന്നേരം&#x27;) {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;രാത്രി&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;രാവിലെ&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ഉച്ച കഴിഞ്ഞ്&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;വൈകുന്നേരം&#x27;;
	        } else {
	            return &#x27;രാത്രി&#x27;;
	        }
	    }
	});

	return ml;

	})));


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;१&#x27;,
	    &#x27;2&#x27;: &#x27;२&#x27;,
	    &#x27;3&#x27;: &#x27;३&#x27;,
	    &#x27;4&#x27;: &#x27;४&#x27;,
	    &#x27;5&#x27;: &#x27;५&#x27;,
	    &#x27;6&#x27;: &#x27;६&#x27;,
	    &#x27;7&#x27;: &#x27;७&#x27;,
	    &#x27;8&#x27;: &#x27;८&#x27;,
	    &#x27;9&#x27;: &#x27;९&#x27;,
	    &#x27;0&#x27;: &#x27;०&#x27;
	},
	numberMap &#x3D; {
	    &#x27;१&#x27;: &#x27;1&#x27;,
	    &#x27;२&#x27;: &#x27;2&#x27;,
	    &#x27;३&#x27;: &#x27;3&#x27;,
	    &#x27;४&#x27;: &#x27;4&#x27;,
	    &#x27;५&#x27;: &#x27;5&#x27;,
	    &#x27;६&#x27;: &#x27;6&#x27;,
	    &#x27;७&#x27;: &#x27;7&#x27;,
	    &#x27;८&#x27;: &#x27;8&#x27;,
	    &#x27;९&#x27;: &#x27;9&#x27;,
	    &#x27;०&#x27;: &#x27;0&#x27;
	};

	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
	    var output &#x3D; &#x27;&#x27;;
	    if (withoutSuffix) {
	        switch (string) {
	            case &#x27;s&#x27;: output &#x3D; &#x27;काही सेकंद&#x27;; break;
	            case &#x27;ss&#x27;: output &#x3D; &#x27;%d सेकंद&#x27;; break;
	            case &#x27;m&#x27;: output &#x3D; &#x27;एक मिनिट&#x27;; break;
	            case &#x27;mm&#x27;: output &#x3D; &#x27;%d मिनिटे&#x27;; break;
	            case &#x27;h&#x27;: output &#x3D; &#x27;एक तास&#x27;; break;
	            case &#x27;hh&#x27;: output &#x3D; &#x27;%d तास&#x27;; break;
	            case &#x27;d&#x27;: output &#x3D; &#x27;एक दिवस&#x27;; break;
	            case &#x27;dd&#x27;: output &#x3D; &#x27;%d दिवस&#x27;; break;
	            case &#x27;M&#x27;: output &#x3D; &#x27;एक महिना&#x27;; break;
	            case &#x27;MM&#x27;: output &#x3D; &#x27;%d महिने&#x27;; break;
	            case &#x27;y&#x27;: output &#x3D; &#x27;एक वर्ष&#x27;; break;
	            case &#x27;yy&#x27;: output &#x3D; &#x27;%d वर्षे&#x27;; break;
	        }
	    }
	    else {
	        switch (string) {
	            case &#x27;s&#x27;: output &#x3D; &#x27;काही सेकंदां&#x27;; break;
	            case &#x27;ss&#x27;: output &#x3D; &#x27;%d सेकंदां&#x27;; break;
	            case &#x27;m&#x27;: output &#x3D; &#x27;एका मिनिटा&#x27;; break;
	            case &#x27;mm&#x27;: output &#x3D; &#x27;%d मिनिटां&#x27;; break;
	            case &#x27;h&#x27;: output &#x3D; &#x27;एका तासा&#x27;; break;
	            case &#x27;hh&#x27;: output &#x3D; &#x27;%d तासां&#x27;; break;
	            case &#x27;d&#x27;: output &#x3D; &#x27;एका दिवसा&#x27;; break;
	            case &#x27;dd&#x27;: output &#x3D; &#x27;%d दिवसां&#x27;; break;
	            case &#x27;M&#x27;: output &#x3D; &#x27;एका महिन्या&#x27;; break;
	            case &#x27;MM&#x27;: output &#x3D; &#x27;%d महिन्यां&#x27;; break;
	            case &#x27;y&#x27;: output &#x3D; &#x27;एका वर्षा&#x27;; break;
	            case &#x27;yy&#x27;: output &#x3D; &#x27;%d वर्षां&#x27;; break;
	        }
	    }
	    return output.replace(/%d/i, number);
	}

	var mr &#x3D; moment.defineLocale(&#x27;mr&#x27;, {
	    months : &#x27;जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;र_सो_मं_बु_गु_शु_श&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm वाजता&#x27;,
	        LTS : &#x27;A h:mm:ss वाजता&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm वाजता&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm वाजता&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[आज] LT&#x27;,
	        nextDay : &#x27;[उद्या] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[काल] LT&#x27;,
	        lastWeek: &#x27;[मागील] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future: &#x27;%sमध्ये&#x27;,
	        past: &#x27;%sपूर्वी&#x27;,
	        s: relativeTimeMr,
	        ss: relativeTimeMr,
	        m: relativeTimeMr,
	        mm: relativeTimeMr,
	        h: relativeTimeMr,
	        hh: relativeTimeMr,
	        d: relativeTimeMr,
	        dd: relativeTimeMr,
	        M: relativeTimeMr,
	        MM: relativeTimeMr,
	        y: relativeTimeMr,
	        yy: relativeTimeMr
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;रात्री&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;सकाळी&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;दुपारी&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;सायंकाळी&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;रात्री&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;सकाळी&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;दुपारी&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;सायंकाळी&#x27;;
	        } else {
	            return &#x27;रात्री&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mr;

	})));


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ms &#x3D; moment.defineLocale(&#x27;ms&#x27;, {
	    months : &#x27;Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ahd_Isn_Sel_Rab_Kha_Jum_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ah_Is_Sl_Rb_Km_Jm_Sb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;pagi&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;tengahari&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;petang&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;malam&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;pagi&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;tengahari&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;petang&#x27;;
	        } else {
	            return &#x27;malam&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hari ini pukul] LT&#x27;,
	        nextDay : &#x27;[Esok pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kelmarin pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [lepas pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dalam %s&#x27;,
	        past : &#x27;%s yang lepas&#x27;,
	        s : &#x27;beberapa saat&#x27;,
	        ss : &#x27;%d saat&#x27;,
	        m : &#x27;seminit&#x27;,
	        mm : &#x27;%d minit&#x27;,
	        h : &#x27;sejam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sehari&#x27;,
	        dd : &#x27;%d hari&#x27;,
	        M : &#x27;sebulan&#x27;,
	        MM : &#x27;%d bulan&#x27;,
	        y : &#x27;setahun&#x27;,
	        yy : &#x27;%d tahun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ms;

	})));


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var msMy &#x3D; moment.defineLocale(&#x27;ms-my&#x27;, {
	    months : &#x27;Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ahd_Isn_Sel_Rab_Kha_Jum_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ah_Is_Sl_Rb_Km_Jm_Sb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [pukul] HH.mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY [pukul] HH.mm&#x27;
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;pagi&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;tengahari&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;petang&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;malam&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;pagi&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;tengahari&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;petang&#x27;;
	        } else {
	            return &#x27;malam&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[Hari ini pukul] LT&#x27;,
	        nextDay : &#x27;[Esok pukul] LT&#x27;,
	        nextWeek : &#x27;dddd [pukul] LT&#x27;,
	        lastDay : &#x27;[Kelmarin pukul] LT&#x27;,
	        lastWeek : &#x27;dddd [lepas pukul] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dalam %s&#x27;,
	        past : &#x27;%s yang lepas&#x27;,
	        s : &#x27;beberapa saat&#x27;,
	        ss : &#x27;%d saat&#x27;,
	        m : &#x27;seminit&#x27;,
	        mm : &#x27;%d minit&#x27;,
	        h : &#x27;sejam&#x27;,
	        hh : &#x27;%d jam&#x27;,
	        d : &#x27;sehari&#x27;,
	        dd : &#x27;%d hari&#x27;,
	        M : &#x27;sebulan&#x27;,
	        MM : &#x27;%d bulan&#x27;,
	        y : &#x27;setahun&#x27;,
	        yy : &#x27;%d tahun&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return msMy;

	})));


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var mt &#x3D; moment.defineLocale(&#x27;mt&#x27;, {
	    months : &#x27;Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ħa_Tn_Tl_Er_Ħa_Ġi_Si&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Illum fil-]LT&#x27;,
	        nextDay : &#x27;[Għada fil-]LT&#x27;,
	        nextWeek : &#x27;dddd [fil-]LT&#x27;,
	        lastDay : &#x27;[Il-bieraħ fil-]LT&#x27;,
	        lastWeek : &#x27;dddd [li għadda] [fil-]LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;f’ %s&#x27;,
	        past : &#x27;%s ilu&#x27;,
	        s : &#x27;ftit sekondi&#x27;,
	        ss : &#x27;%d sekondi&#x27;,
	        m : &#x27;minuta&#x27;,
	        mm : &#x27;%d minuti&#x27;,
	        h : &#x27;siegħa&#x27;,
	        hh : &#x27;%d siegħat&#x27;,
	        d : &#x27;ġurnata&#x27;,
	        dd : &#x27;%d ġranet&#x27;,
	        M : &#x27;xahar&#x27;,
	        MM : &#x27;%d xhur&#x27;,
	        y : &#x27;sena&#x27;,
	        yy : &#x27;%d sni&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal: &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return mt;

	})));


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;၁&#x27;,
	    &#x27;2&#x27;: &#x27;၂&#x27;,
	    &#x27;3&#x27;: &#x27;၃&#x27;,
	    &#x27;4&#x27;: &#x27;၄&#x27;,
	    &#x27;5&#x27;: &#x27;၅&#x27;,
	    &#x27;6&#x27;: &#x27;၆&#x27;,
	    &#x27;7&#x27;: &#x27;၇&#x27;,
	    &#x27;8&#x27;: &#x27;၈&#x27;,
	    &#x27;9&#x27;: &#x27;၉&#x27;,
	    &#x27;0&#x27;: &#x27;၀&#x27;
	}, numberMap &#x3D; {
	    &#x27;၁&#x27;: &#x27;1&#x27;,
	    &#x27;၂&#x27;: &#x27;2&#x27;,
	    &#x27;၃&#x27;: &#x27;3&#x27;,
	    &#x27;၄&#x27;: &#x27;4&#x27;,
	    &#x27;၅&#x27;: &#x27;5&#x27;,
	    &#x27;၆&#x27;: &#x27;6&#x27;,
	    &#x27;၇&#x27;: &#x27;7&#x27;,
	    &#x27;၈&#x27;: &#x27;8&#x27;,
	    &#x27;၉&#x27;: &#x27;9&#x27;,
	    &#x27;၀&#x27;: &#x27;0&#x27;
	};

	var my &#x3D; moment.defineLocale(&#x27;my&#x27;, {
	    months: &#x27;ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ&#x27;.split(&#x27;_&#x27;),
	    weekdays: &#x27;တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ&#x27;.split(&#x27;_&#x27;),

	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;DD/MM/YYYY&#x27;,
	        LL: &#x27;D MMMM YYYY&#x27;,
	        LLL: &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL: &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[ယနေ.] LT [မှာ]&#x27;,
	        nextDay: &#x27;[မနက်ဖြန်] LT [မှာ]&#x27;,
	        nextWeek: &#x27;dddd LT [မှာ]&#x27;,
	        lastDay: &#x27;[မနေ.က] LT [မှာ]&#x27;,
	        lastWeek: &#x27;[ပြီးခဲ့သော] dddd LT [မှာ]&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;လာမည့် %s မှာ&#x27;,
	        past: &#x27;လွန်ခဲ့သော %s က&#x27;,
	        s: &#x27;စက္ကန်.အနည်းငယ်&#x27;,
	        ss : &#x27;%d စက္ကန့်&#x27;,
	        m: &#x27;တစ်မိနစ်&#x27;,
	        mm: &#x27;%d မိနစ်&#x27;,
	        h: &#x27;တစ်နာရီ&#x27;,
	        hh: &#x27;%d နာရီ&#x27;,
	        d: &#x27;တစ်ရက်&#x27;,
	        dd: &#x27;%d ရက်&#x27;,
	        M: &#x27;တစ်လ&#x27;,
	        MM: &#x27;%d လ&#x27;,
	        y: &#x27;တစ်နှစ်&#x27;,
	        yy: &#x27;%d နှစ်&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return my;

	})));


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var nb &#x3D; moment.defineLocale(&#x27;nb&#x27;, {
	    months : &#x27;januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sø._ma._ti._on._to._fr._lø.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;sø_ma_ti_on_to_fr_lø&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY [kl.] HH:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY [kl.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[i dag kl.] LT&#x27;,
	        nextDay: &#x27;[i morgen kl.] LT&#x27;,
	        nextWeek: &#x27;dddd [kl.] LT&#x27;,
	        lastDay: &#x27;[i går kl.] LT&#x27;,
	        lastWeek: &#x27;[forrige] dddd [kl.] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;%s siden&#x27;,
	        s : &#x27;noen sekunder&#x27;,
	        ss : &#x27;%d sekunder&#x27;,
	        m : &#x27;ett minutt&#x27;,
	        mm : &#x27;%d minutter&#x27;,
	        h : &#x27;en time&#x27;,
	        hh : &#x27;%d timer&#x27;,
	        d : &#x27;en dag&#x27;,
	        dd : &#x27;%d dager&#x27;,
	        M : &#x27;en måned&#x27;,
	        MM : &#x27;%d måneder&#x27;,
	        y : &#x27;ett år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nb;

	})));


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;१&#x27;,
	    &#x27;2&#x27;: &#x27;२&#x27;,
	    &#x27;3&#x27;: &#x27;३&#x27;,
	    &#x27;4&#x27;: &#x27;४&#x27;,
	    &#x27;5&#x27;: &#x27;५&#x27;,
	    &#x27;6&#x27;: &#x27;६&#x27;,
	    &#x27;7&#x27;: &#x27;७&#x27;,
	    &#x27;8&#x27;: &#x27;८&#x27;,
	    &#x27;9&#x27;: &#x27;९&#x27;,
	    &#x27;0&#x27;: &#x27;०&#x27;
	},
	numberMap &#x3D; {
	    &#x27;१&#x27;: &#x27;1&#x27;,
	    &#x27;२&#x27;: &#x27;2&#x27;,
	    &#x27;३&#x27;: &#x27;3&#x27;,
	    &#x27;४&#x27;: &#x27;4&#x27;,
	    &#x27;५&#x27;: &#x27;5&#x27;,
	    &#x27;६&#x27;: &#x27;6&#x27;,
	    &#x27;७&#x27;: &#x27;7&#x27;,
	    &#x27;८&#x27;: &#x27;8&#x27;,
	    &#x27;९&#x27;: &#x27;9&#x27;,
	    &#x27;०&#x27;: &#x27;0&#x27;
	};

	var ne &#x3D; moment.defineLocale(&#x27;ne&#x27;, {
	    months : &#x27;जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;आ._सो._मं._बु._बि._शु._श.&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;Aको h:mm बजे&#x27;,
	        LTS : &#x27;Aको h:mm:ss बजे&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, Aको h:mm बजे&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, Aको h:mm बजे&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;राति&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;बिहान&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;दिउँसो&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;साँझ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 3) {
	            return &#x27;राति&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;बिहान&#x27;;
	        } else if (hour &lt; 16) {
	            return &#x27;दिउँसो&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;साँझ&#x27;;
	        } else {
	            return &#x27;राति&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[आज] LT&#x27;,
	        nextDay : &#x27;[भोलि] LT&#x27;,
	        nextWeek : &#x27;[आउँदो] dddd[,] LT&#x27;,
	        lastDay : &#x27;[हिजो] LT&#x27;,
	        lastWeek : &#x27;[गएको] dddd[,] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%sमा&#x27;,
	        past : &#x27;%s अगाडि&#x27;,
	        s : &#x27;केही क्षण&#x27;,
	        ss : &#x27;%d सेकेण्ड&#x27;,
	        m : &#x27;एक मिनेट&#x27;,
	        mm : &#x27;%d मिनेट&#x27;,
	        h : &#x27;एक घण्टा&#x27;,
	        hh : &#x27;%d घण्टा&#x27;,
	        d : &#x27;एक दिन&#x27;,
	        dd : &#x27;%d दिन&#x27;,
	        M : &#x27;एक महिना&#x27;,
	        MM : &#x27;%d महिना&#x27;,
	        y : &#x27;एक बर्ष&#x27;,
	        yy : &#x27;%d बर्ष&#x27;
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ne;

	})));


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortWithDots &#x3D; &#x27;jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsShortWithoutDots &#x3D; &#x27;jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;);

	var monthsParse &#x3D; [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex &#x3D; /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nl &#x3D; moment.defineLocale(&#x27;nl&#x27;, {
	    months : &#x27;januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : &#x27;zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;zo._ma._di._wo._do._vr._za.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;zo_ma_di_wo_do_vr_za&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD-MM-YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[vandaag om] LT&#x27;,
	        nextDay: &#x27;[morgen om] LT&#x27;,
	        nextWeek: &#x27;dddd [om] LT&#x27;,
	        lastDay: &#x27;[gisteren om] LT&#x27;,
	        lastWeek: &#x27;[afgelopen] dddd [om] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;over %s&#x27;,
	        past : &#x27;%s geleden&#x27;,
	        s : &#x27;een paar seconden&#x27;,
	        ss : &#x27;%d seconden&#x27;,
	        m : &#x27;één minuut&#x27;,
	        mm : &#x27;%d minuten&#x27;,
	        h : &#x27;één uur&#x27;,
	        hh : &#x27;%d uur&#x27;,
	        d : &#x27;één dag&#x27;,
	        dd : &#x27;%d dagen&#x27;,
	        M : &#x27;één maand&#x27;,
	        MM : &#x27;%d maanden&#x27;,
	        y : &#x27;één jaar&#x27;,
	        yy : &#x27;%d jaar&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number &#x3D;&#x3D;&#x3D; 1 || number &#x3D;&#x3D;&#x3D; 8 || number &gt;&#x3D; 20) ? &#x27;ste&#x27; : &#x27;de&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nl;

	})));


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsShortWithDots &#x3D; &#x27;jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsShortWithoutDots &#x3D; &#x27;jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;);

	var monthsParse &#x3D; [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex &#x3D; /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nlBe &#x3D; moment.defineLocale(&#x27;nl-be&#x27;, {
	    months : &#x27;januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : &#x27;zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;zo._ma._di._wo._do._vr._za.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;zo_ma_di_wo_do_vr_za&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[vandaag om] LT&#x27;,
	        nextDay: &#x27;[morgen om] LT&#x27;,
	        nextWeek: &#x27;dddd [om] LT&#x27;,
	        lastDay: &#x27;[gisteren om] LT&#x27;,
	        lastWeek: &#x27;[afgelopen] dddd [om] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;over %s&#x27;,
	        past : &#x27;%s geleden&#x27;,
	        s : &#x27;een paar seconden&#x27;,
	        ss : &#x27;%d seconden&#x27;,
	        m : &#x27;één minuut&#x27;,
	        mm : &#x27;%d minuten&#x27;,
	        h : &#x27;één uur&#x27;,
	        hh : &#x27;%d uur&#x27;,
	        d : &#x27;één dag&#x27;,
	        dd : &#x27;%d dagen&#x27;,
	        M : &#x27;één maand&#x27;,
	        MM : &#x27;%d maanden&#x27;,
	        y : &#x27;één jaar&#x27;,
	        yy : &#x27;%d jaar&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number &#x3D;&#x3D;&#x3D; 1 || number &#x3D;&#x3D;&#x3D; 8 || number &gt;&#x3D; 20) ? &#x27;ste&#x27; : &#x27;de&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nlBe;

	})));


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var nn &#x3D; moment.defineLocale(&#x27;nn&#x27;, {
	    months : &#x27;januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sun_mån_tys_ons_tor_fre_lau&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;su_må_ty_on_to_fr_lø&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY [kl.] H:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY [kl.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[I dag klokka] LT&#x27;,
	        nextDay: &#x27;[I morgon klokka] LT&#x27;,
	        nextWeek: &#x27;dddd [klokka] LT&#x27;,
	        lastDay: &#x27;[I går klokka] LT&#x27;,
	        lastWeek: &#x27;[Føregåande] dddd [klokka] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;%s sidan&#x27;,
	        s : &#x27;nokre sekund&#x27;,
	        ss : &#x27;%d sekund&#x27;,
	        m : &#x27;eit minutt&#x27;,
	        mm : &#x27;%d minutt&#x27;,
	        h : &#x27;ein time&#x27;,
	        hh : &#x27;%d timar&#x27;,
	        d : &#x27;ein dag&#x27;,
	        dd : &#x27;%d dagar&#x27;,
	        M : &#x27;ein månad&#x27;,
	        MM : &#x27;%d månader&#x27;,
	        y : &#x27;eit år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nn;

	})));


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;੧&#x27;,
	    &#x27;2&#x27;: &#x27;੨&#x27;,
	    &#x27;3&#x27;: &#x27;੩&#x27;,
	    &#x27;4&#x27;: &#x27;੪&#x27;,
	    &#x27;5&#x27;: &#x27;੫&#x27;,
	    &#x27;6&#x27;: &#x27;੬&#x27;,
	    &#x27;7&#x27;: &#x27;੭&#x27;,
	    &#x27;8&#x27;: &#x27;੮&#x27;,
	    &#x27;9&#x27;: &#x27;੯&#x27;,
	    &#x27;0&#x27;: &#x27;੦&#x27;
	},
	numberMap &#x3D; {
	    &#x27;੧&#x27;: &#x27;1&#x27;,
	    &#x27;੨&#x27;: &#x27;2&#x27;,
	    &#x27;੩&#x27;: &#x27;3&#x27;,
	    &#x27;੪&#x27;: &#x27;4&#x27;,
	    &#x27;੫&#x27;: &#x27;5&#x27;,
	    &#x27;੬&#x27;: &#x27;6&#x27;,
	    &#x27;੭&#x27;: &#x27;7&#x27;,
	    &#x27;੮&#x27;: &#x27;8&#x27;,
	    &#x27;੯&#x27;: &#x27;9&#x27;,
	    &#x27;੦&#x27;: &#x27;0&#x27;
	};

	var paIn &#x3D; moment.defineLocale(&#x27;pa-in&#x27;, {
	    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	    months : &#x27;ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm ਵਜੇ&#x27;,
	        LTS : &#x27;A h:mm:ss ਵਜੇ&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm ਵਜੇ&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm ਵਜੇ&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[ਅਜ] LT&#x27;,
	        nextDay : &#x27;[ਕਲ] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[ਕਲ] LT&#x27;,
	        lastWeek : &#x27;[ਪਿਛਲੇ] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s ਵਿੱਚ&#x27;,
	        past : &#x27;%s ਪਿਛਲੇ&#x27;,
	        s : &#x27;ਕੁਝ ਸਕਿੰਟ&#x27;,
	        ss : &#x27;%d ਸਕਿੰਟ&#x27;,
	        m : &#x27;ਇਕ ਮਿੰਟ&#x27;,
	        mm : &#x27;%d ਮਿੰਟ&#x27;,
	        h : &#x27;ਇੱਕ ਘੰਟਾ&#x27;,
	        hh : &#x27;%d ਘੰਟੇ&#x27;,
	        d : &#x27;ਇੱਕ ਦਿਨ&#x27;,
	        dd : &#x27;%d ਦਿਨ&#x27;,
	        M : &#x27;ਇੱਕ ਮਹੀਨਾ&#x27;,
	        MM : &#x27;%d ਮਹੀਨੇ&#x27;,
	        y : &#x27;ਇੱਕ ਸਾਲ&#x27;,
	        yy : &#x27;%d ਸਾਲ&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a &#x27;Pahar&#x27; it is not used as rigidly in modern Punjabi.
	    meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ਰਾਤ&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ਸਵੇਰ&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ਦੁਪਹਿਰ&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ਸ਼ਾਮ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ਰਾਤ&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ਸਵੇਰ&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;ਦੁਪਹਿਰ&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;ਸ਼ਾਮ&#x27;;
	        } else {
	            return &#x27;ਰਾਤ&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return paIn;

	})));


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var monthsNominative &#x3D; &#x27;styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień&#x27;.split(&#x27;_&#x27;),
	    monthsSubjective &#x3D; &#x27;stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia&#x27;.split(&#x27;_&#x27;);
	function plural(n) {
	    return (n % 10 &lt; 5) &amp;&amp; (n % 10 &gt; 1) &amp;&amp; ((~~(n / 10) % 10) !&#x3D;&#x3D; 1);
	}
	function translate(number, withoutSuffix, key) {
	    var result &#x3D; number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;ss&#x27;:
	            return result + (plural(number) ? &#x27;sekundy&#x27; : &#x27;sekund&#x27;);
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;minuta&#x27; : &#x27;minutę&#x27;;
	        case &#x27;mm&#x27;:
	            return result + (plural(number) ? &#x27;minuty&#x27; : &#x27;minut&#x27;);
	        case &#x27;h&#x27;:
	            return withoutSuffix  ? &#x27;godzina&#x27;  : &#x27;godzinę&#x27;;
	        case &#x27;hh&#x27;:
	            return result + (plural(number) ? &#x27;godziny&#x27; : &#x27;godzin&#x27;);
	        case &#x27;MM&#x27;:
	            return result + (plural(number) ? &#x27;miesiące&#x27; : &#x27;miesięcy&#x27;);
	        case &#x27;yy&#x27;:
	            return result + (plural(number) ? &#x27;lata&#x27; : &#x27;lat&#x27;);
	    }
	}

	var pl &#x3D; moment.defineLocale(&#x27;pl&#x27;, {
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return monthsNominative;
	        } else if (format &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
	            // Hack: if format empty we know this is used to generate
	            // RegExp by moment. Give then back both valid forms of months
	            // in RegExp ready format.
	            return &#x27;(&#x27; + monthsSubjective[momentToFormat.month()] + &#x27;|&#x27; + monthsNominative[momentToFormat.month()] + &#x27;)&#x27;;
	        } else if (/D MMMM/.test(format)) {
	            return monthsSubjective[momentToFormat.month()];
	        } else {
	            return monthsNominative[momentToFormat.month()];
	        }
	    },
	    monthsShort : &#x27;sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ndz_pon_wt_śr_czw_pt_sob&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Nd_Pn_Wt_Śr_Cz_Pt_So&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Dziś o] LT&#x27;,
	        nextDay: &#x27;[Jutro o] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[W niedzielę o] LT&#x27;;

	                case 2:
	                    return &#x27;[We wtorek o] LT&#x27;;

	                case 3:
	                    return &#x27;[W środę o] LT&#x27;;

	                case 6:
	                    return &#x27;[W sobotę o] LT&#x27;;

	                default:
	                    return &#x27;[W] dddd [o] LT&#x27;;
	            }
	        },
	        lastDay: &#x27;[Wczoraj o] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[W zeszłą niedzielę o] LT&#x27;;
	                case 3:
	                    return &#x27;[W zeszłą środę o] LT&#x27;;
	                case 6:
	                    return &#x27;[W zeszłą sobotę o] LT&#x27;;
	                default:
	                    return &#x27;[W zeszły] dddd [o] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past : &#x27;%s temu&#x27;,
	        s : &#x27;kilka sekund&#x27;,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : &#x27;1 dzień&#x27;,
	        dd : &#x27;%d dni&#x27;,
	        M : &#x27;miesiąc&#x27;,
	        MM : translate,
	        y : &#x27;rok&#x27;,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pl;

	})));


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var pt &#x3D; moment.defineLocale(&#x27;pt&#x27;, {
	    months : &#x27;janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dom_Seg_Ter_Qua_Qui_Sex_Sáb&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Do_2ª_3ª_4ª_5ª_6ª_Sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Hoje às] LT&#x27;,
	        nextDay: &#x27;[Amanhã às] LT&#x27;,
	        nextWeek: &#x27;dddd [às] LT&#x27;,
	        lastDay: &#x27;[Ontem às] LT&#x27;,
	        lastWeek: function () {
	            return (this.day() &#x3D;&#x3D;&#x3D; 0 || this.day() &#x3D;&#x3D;&#x3D; 6) ?
	                &#x27;[Último] dddd [às] LT&#x27; : // Saturday + Sunday
	                &#x27;[Última] dddd [às] LT&#x27;; // Monday - Friday
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;em %s&#x27;,
	        past : &#x27;há %s&#x27;,
	        s : &#x27;segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;um minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;uma hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;um dia&#x27;,
	        dd : &#x27;%d dias&#x27;,
	        M : &#x27;um mês&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;um ano&#x27;,
	        yy : &#x27;%d anos&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pt;

	})));


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ptBr &#x3D; moment.defineLocale(&#x27;pt-br&#x27;, {
	    months : &#x27;janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dom_Seg_Ter_Qua_Qui_Sex_Sáb&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Do_2ª_3ª_4ª_5ª_6ª_Sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D [de] MMMM [de] YYYY&#x27;,
	        LLL : &#x27;D [de] MMMM [de] YYYY [às] HH:mm&#x27;,
	        LLLL : &#x27;dddd, D [de] MMMM [de] YYYY [às] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Hoje às] LT&#x27;,
	        nextDay: &#x27;[Amanhã às] LT&#x27;,
	        nextWeek: &#x27;dddd [às] LT&#x27;,
	        lastDay: &#x27;[Ontem às] LT&#x27;,
	        lastWeek: function () {
	            return (this.day() &#x3D;&#x3D;&#x3D; 0 || this.day() &#x3D;&#x3D;&#x3D; 6) ?
	                &#x27;[Último] dddd [às] LT&#x27; : // Saturday + Sunday
	                &#x27;[Última] dddd [às] LT&#x27;; // Monday - Friday
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;em %s&#x27;,
	        past : &#x27;há %s&#x27;,
	        s : &#x27;poucos segundos&#x27;,
	        ss : &#x27;%d segundos&#x27;,
	        m : &#x27;um minuto&#x27;,
	        mm : &#x27;%d minutos&#x27;,
	        h : &#x27;uma hora&#x27;,
	        hh : &#x27;%d horas&#x27;,
	        d : &#x27;um dia&#x27;,
	        dd : &#x27;%d dias&#x27;,
	        M : &#x27;um mês&#x27;,
	        MM : &#x27;%d meses&#x27;,
	        y : &#x27;um ano&#x27;,
	        yy : &#x27;%d anos&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal : &#x27;%dº&#x27;
	});

	return ptBr;

	})));


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format &#x3D; {
	            &#x27;ss&#x27;: &#x27;secunde&#x27;,
	            &#x27;mm&#x27;: &#x27;minute&#x27;,
	            &#x27;hh&#x27;: &#x27;ore&#x27;,
	            &#x27;dd&#x27;: &#x27;zile&#x27;,
	            &#x27;MM&#x27;: &#x27;luni&#x27;,
	            &#x27;yy&#x27;: &#x27;ani&#x27;
	        },
	        separator &#x3D; &#x27; &#x27;;
	    if (number % 100 &gt;&#x3D; 20 || (number &gt;&#x3D; 100 &amp;&amp; number % 100 &#x3D;&#x3D;&#x3D; 0)) {
	        separator &#x3D; &#x27; de &#x27;;
	    }
	    return number + separator + format[key];
	}

	var ro &#x3D; moment.defineLocale(&#x27;ro&#x27;, {
	    months : &#x27;ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;duminică_luni_marți_miercuri_joi_vineri_sâmbătă&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dum_Lun_Mar_Mie_Joi_Vin_Sâm&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Du_Lu_Ma_Mi_Jo_Vi_Sâ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[azi la] LT&#x27;,
	        nextDay: &#x27;[mâine la] LT&#x27;,
	        nextWeek: &#x27;dddd [la] LT&#x27;,
	        lastDay: &#x27;[ieri la] LT&#x27;,
	        lastWeek: &#x27;[fosta] dddd [la] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;peste %s&#x27;,
	        past : &#x27;%s în urmă&#x27;,
	        s : &#x27;câteva secunde&#x27;,
	        ss : relativeTimeWithPlural,
	        m : &#x27;un minut&#x27;,
	        mm : relativeTimeWithPlural,
	        h : &#x27;o oră&#x27;,
	        hh : relativeTimeWithPlural,
	        d : &#x27;o zi&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;o lună&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;un an&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ro;

	})));


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(word, num) {
	    var forms &#x3D; word.split(&#x27;_&#x27;);
	    return num % 10 &#x3D;&#x3D;&#x3D; 1 &amp;&amp; num % 100 !&#x3D;&#x3D; 11 ? forms[0] : (num % 10 &gt;&#x3D; 2 &amp;&amp; num % 10 &lt;&#x3D; 4 &amp;&amp; (num % 100 &lt; 10 || num % 100 &gt;&#x3D; 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format &#x3D; {
	        &#x27;ss&#x27;: withoutSuffix ? &#x27;секунда_секунды_секунд&#x27; : &#x27;секунду_секунды_секунд&#x27;,
	        &#x27;mm&#x27;: withoutSuffix ? &#x27;минута_минуты_минут&#x27; : &#x27;минуту_минуты_минут&#x27;,
	        &#x27;hh&#x27;: &#x27;час_часа_часов&#x27;,
	        &#x27;dd&#x27;: &#x27;день_дня_дней&#x27;,
	        &#x27;MM&#x27;: &#x27;месяц_месяца_месяцев&#x27;,
	        &#x27;yy&#x27;: &#x27;год_года_лет&#x27;
	    };
	    if (key &#x3D;&#x3D;&#x3D; &#x27;m&#x27;) {
	        return withoutSuffix ? &#x27;минута&#x27; : &#x27;минуту&#x27;;
	    }
	    else {
	        return number + &#x27; &#x27; + plural(format[key], +number);
	    }
	}
	var monthsParse &#x3D; [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

	// http://new.gramota.ru/spravka/rules/139-prop : § 103
	// Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s&#x3D;242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	var ru &#x3D; moment.defineLocale(&#x27;ru&#x27;, {
	    months : {
	        format: &#x27;января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : {
	        // по CLDR именно &quot;июл.&quot; и &quot;июн.&quot;, но какой смысл менять букву на точку ?
	        format: &#x27;янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.&#x27;.split(&#x27;_&#x27;),
	        standalone: &#x27;янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.&#x27;.split(&#x27;_&#x27;)
	    },
	    weekdays : {
	        standalone: &#x27;воскресенье_понедельник_вторник_среда_четверг_пятница_суббота&#x27;.split(&#x27;_&#x27;),
	        format: &#x27;воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу&#x27;.split(&#x27;_&#x27;),
	        isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
	    },
	    weekdaysShort : &#x27;вс_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;вс_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
	    monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // копия предыдущего
	    monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // полные названия с падежами
	    monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

	    // Выражение, которое соотвествует только сокращённым формам
	    monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY г.&#x27;,
	        LLL : &#x27;D MMMM YYYY г., H:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY г., H:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Сегодня в] LT&#x27;,
	        nextDay: &#x27;[Завтра в] LT&#x27;,
	        lastDay: &#x27;[Вчера в] LT&#x27;,
	        nextWeek: function (now) {
	            if (now.week() !&#x3D;&#x3D; this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return &#x27;[В следующее] dddd [в] LT&#x27;;
	                    case 1:
	                    case 2:
	                    case 4:
	                        return &#x27;[В следующий] dddd [в] LT&#x27;;
	                    case 3:
	                    case 5:
	                    case 6:
	                        return &#x27;[В следующую] dddd [в] LT&#x27;;
	                }
	            } else {
	                if (this.day() &#x3D;&#x3D;&#x3D; 2) {
	                    return &#x27;[Во] dddd [в] LT&#x27;;
	                } else {
	                    return &#x27;[В] dddd [в] LT&#x27;;
	                }
	            }
	        },
	        lastWeek: function (now) {
	            if (now.week() !&#x3D;&#x3D; this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return &#x27;[В прошлое] dddd [в] LT&#x27;;
	                    case 1:
	                    case 2:
	                    case 4:
	                        return &#x27;[В прошлый] dddd [в] LT&#x27;;
	                    case 3:
	                    case 5:
	                    case 6:
	                        return &#x27;[В прошлую] dddd [в] LT&#x27;;
	                }
	            } else {
	                if (this.day() &#x3D;&#x3D;&#x3D; 2) {
	                    return &#x27;[Во] dddd [в] LT&#x27;;
	                } else {
	                    return &#x27;[В] dddd [в] LT&#x27;;
	                }
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;через %s&#x27;,
	        past : &#x27;%s назад&#x27;,
	        s : &#x27;несколько секунд&#x27;,
	        ss : relativeTimeWithPlural,
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : &#x27;час&#x27;,
	        hh : relativeTimeWithPlural,
	        d : &#x27;день&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;месяц&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;год&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночи|утра|дня|вечера/i,
	    isPM : function (input) {
	        return /^(дня|вечера)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ночи&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;утра&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;дня&#x27;;
	        } else {
	            return &#x27;вечера&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;M&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;-й&#x27;;
	            case &#x27;D&#x27;:
	                return number + &#x27;-го&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;-я&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ru;

	})));


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months &#x3D; [
	    &#x27;جنوري&#x27;,
	    &#x27;فيبروري&#x27;,
	    &#x27;مارچ&#x27;,
	    &#x27;اپريل&#x27;,
	    &#x27;مئي&#x27;,
	    &#x27;جون&#x27;,
	    &#x27;جولاءِ&#x27;,
	    &#x27;آگسٽ&#x27;,
	    &#x27;سيپٽمبر&#x27;,
	    &#x27;آڪٽوبر&#x27;,
	    &#x27;نومبر&#x27;,
	    &#x27;ڊسمبر&#x27;
	];
	var days &#x3D; [
	    &#x27;آچر&#x27;,
	    &#x27;سومر&#x27;,
	    &#x27;اڱارو&#x27;,
	    &#x27;اربع&#x27;,
	    &#x27;خميس&#x27;,
	    &#x27;جمع&#x27;,
	    &#x27;ڇنڇر&#x27;
	];

	var sd &#x3D; moment.defineLocale(&#x27;sd&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd، D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /صبح|شام/,
	    isPM : function (input) {
	        return &#x27;شام&#x27; &#x3D;&#x3D;&#x3D; input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;صبح&#x27;;
	        }
	        return &#x27;شام&#x27;;
	    },
	    calendar : {
	        sameDay : &#x27;[اڄ] LT&#x27;,
	        nextDay : &#x27;[سڀاڻي] LT&#x27;,
	        nextWeek : &#x27;dddd [اڳين هفتي تي] LT&#x27;,
	        lastDay : &#x27;[ڪالهه] LT&#x27;,
	        lastWeek : &#x27;[گزريل هفتي] dddd [تي] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s پوء&#x27;,
	        past : &#x27;%s اڳ&#x27;,
	        s : &#x27;چند سيڪنڊ&#x27;,
	        ss : &#x27;%d سيڪنڊ&#x27;,
	        m : &#x27;هڪ منٽ&#x27;,
	        mm : &#x27;%d منٽ&#x27;,
	        h : &#x27;هڪ ڪلاڪ&#x27;,
	        hh : &#x27;%d ڪلاڪ&#x27;,
	        d : &#x27;هڪ ڏينهن&#x27;,
	        dd : &#x27;%d ڏينهن&#x27;,
	        M : &#x27;هڪ مهينو&#x27;,
	        MM : &#x27;%d مهينا&#x27;,
	        y : &#x27;هڪ سال&#x27;,
	        yy : &#x27;%d سال&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sd;

	})));


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var se &#x3D; moment.defineLocale(&#x27;se&#x27;, {
	    months : &#x27;ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sotn_vuos_maŋ_gask_duor_bear_láv&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;s_v_m_g_d_b_L&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;MMMM D. [b.] YYYY&#x27;,
	        LLL : &#x27;MMMM D. [b.] YYYY [ti.] HH:mm&#x27;,
	        LLLL : &#x27;dddd, MMMM D. [b.] YYYY [ti.] HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[otne ti] LT&#x27;,
	        nextDay: &#x27;[ihttin ti] LT&#x27;,
	        nextWeek: &#x27;dddd [ti] LT&#x27;,
	        lastDay: &#x27;[ikte ti] LT&#x27;,
	        lastWeek: &#x27;[ovddit] dddd [ti] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s geažes&#x27;,
	        past : &#x27;maŋit %s&#x27;,
	        s : &#x27;moadde sekunddat&#x27;,
	        ss: &#x27;%d sekunddat&#x27;,
	        m : &#x27;okta minuhta&#x27;,
	        mm : &#x27;%d minuhtat&#x27;,
	        h : &#x27;okta diimmu&#x27;,
	        hh : &#x27;%d diimmut&#x27;,
	        d : &#x27;okta beaivi&#x27;,
	        dd : &#x27;%d beaivvit&#x27;,
	        M : &#x27;okta mánnu&#x27;,
	        MM : &#x27;%d mánut&#x27;,
	        y : &#x27;okta jahki&#x27;,
	        yy : &#x27;%d jagit&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return se;

	})));


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	/*jshint -W100*/
	var si &#x3D; moment.defineLocale(&#x27;si&#x27;, {
	    months : &#x27;ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ඉ_ස_අ_බ_බ්‍ර_සි_සෙ&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;a h:mm&#x27;,
	        LTS : &#x27;a h:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY MMMM D&#x27;,
	        LLL : &#x27;YYYY MMMM D, a h:mm&#x27;,
	        LLLL : &#x27;YYYY MMMM D [වැනි] dddd, a h:mm:ss&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[අද] LT[ට]&#x27;,
	        nextDay : &#x27;[හෙට] LT[ට]&#x27;,
	        nextWeek : &#x27;dddd LT[ට]&#x27;,
	        lastDay : &#x27;[ඊයේ] LT[ට]&#x27;,
	        lastWeek : &#x27;[පසුගිය] dddd LT[ට]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%sකින්&#x27;,
	        past : &#x27;%sකට පෙර&#x27;,
	        s : &#x27;තත්පර කිහිපය&#x27;,
	        ss : &#x27;තත්පර %d&#x27;,
	        m : &#x27;මිනිත්තුව&#x27;,
	        mm : &#x27;මිනිත්තු %d&#x27;,
	        h : &#x27;පැය&#x27;,
	        hh : &#x27;පැය %d&#x27;,
	        d : &#x27;දිනය&#x27;,
	        dd : &#x27;දින %d&#x27;,
	        M : &#x27;මාසය&#x27;,
	        MM : &#x27;මාස %d&#x27;,
	        y : &#x27;වසර&#x27;,
	        yy : &#x27;වසර %d&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
	    ordinal : function (number) {
	        return number + &#x27; වැනි&#x27;;
	    },
	    meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
	    isPM : function (input) {
	        return input &#x3D;&#x3D;&#x3D; &#x27;ප.ව.&#x27; || input &#x3D;&#x3D;&#x3D; &#x27;පස් වරු&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;ප.ව.&#x27; : &#x27;පස් වරු&#x27;;
	        } else {
	            return isLower ? &#x27;පෙ.ව.&#x27; : &#x27;පෙර වරු&#x27;;
	        }
	    }
	});

	return si;

	})));


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months &#x3D; &#x27;január_február_marec_apríl_máj_jún_júl_august_september_október_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort &#x3D; &#x27;jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;);
	function plural(n) {
	    return (n &gt; 1) &amp;&amp; (n &lt; 5);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result &#x3D; number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? &#x27;pár sekúnd&#x27; : &#x27;pár sekundami&#x27;;
	        case &#x27;ss&#x27;: // 9 seconds / in 9 seconds / 9 seconds ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;sekundy&#x27; : &#x27;sekúnd&#x27;);
	            } else {
	                return result + &#x27;sekundami&#x27;;
	            }
	            break;
	        case &#x27;m&#x27;:  // a minute / in a minute / a minute ago
	            return withoutSuffix ? &#x27;minúta&#x27; : (isFuture ? &#x27;minútu&#x27; : &#x27;minútou&#x27;);
	        case &#x27;mm&#x27;: // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;minúty&#x27; : &#x27;minút&#x27;);
	            } else {
	                return result + &#x27;minútami&#x27;;
	            }
	            break;
	        case &#x27;h&#x27;:  // an hour / in an hour / an hour ago
	            return withoutSuffix ? &#x27;hodina&#x27; : (isFuture ? &#x27;hodinu&#x27; : &#x27;hodinou&#x27;);
	        case &#x27;hh&#x27;: // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;hodiny&#x27; : &#x27;hodín&#x27;);
	            } else {
	                return result + &#x27;hodinami&#x27;;
	            }
	            break;
	        case &#x27;d&#x27;:  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? &#x27;deň&#x27; : &#x27;dňom&#x27;;
	        case &#x27;dd&#x27;: // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;dni&#x27; : &#x27;dní&#x27;);
	            } else {
	                return result + &#x27;dňami&#x27;;
	            }
	            break;
	        case &#x27;M&#x27;:  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? &#x27;mesiac&#x27; : &#x27;mesiacom&#x27;;
	        case &#x27;MM&#x27;: // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;mesiace&#x27; : &#x27;mesiacov&#x27;);
	            } else {
	                return result + &#x27;mesiacmi&#x27;;
	            }
	            break;
	        case &#x27;y&#x27;:  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? &#x27;rok&#x27; : &#x27;rokom&#x27;;
	        case &#x27;yy&#x27;: // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? &#x27;roky&#x27; : &#x27;rokov&#x27;);
	            } else {
	                return result + &#x27;rokmi&#x27;;
	            }
	            break;
	    }
	}

	var sk &#x3D; moment.defineLocale(&#x27;sk&#x27;, {
	    months : months,
	    monthsShort : monthsShort,
	    weekdays : &#x27;nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ne_po_ut_st_št_pi_so&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_ut_st_št_pi_so&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[dnes o] LT&#x27;,
	        nextDay: &#x27;[zajtra o] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[v nedeľu o] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[v] dddd [o] LT&#x27;;
	                case 3:
	                    return &#x27;[v stredu o] LT&#x27;;
	                case 4:
	                    return &#x27;[vo štvrtok o] LT&#x27;;
	                case 5:
	                    return &#x27;[v piatok o] LT&#x27;;
	                case 6:
	                    return &#x27;[v sobotu o] LT&#x27;;
	            }
	        },
	        lastDay: &#x27;[včera o] LT&#x27;,
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[minulú nedeľu o] LT&#x27;;
	                case 1:
	                case 2:
	                    return &#x27;[minulý] dddd [o] LT&#x27;;
	                case 3:
	                    return &#x27;[minulú stredu o] LT&#x27;;
	                case 4:
	                case 5:
	                    return &#x27;[minulý] dddd [o] LT&#x27;;
	                case 6:
	                    return &#x27;[minulú sobotu o] LT&#x27;;
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past : &#x27;pred %s&#x27;,
	        s : translate,
	        ss : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sk;

	})));


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var result &#x3D; number + &#x27; &#x27;;
	    switch (key) {
	        case &#x27;s&#x27;:
	            return withoutSuffix || isFuture ? &#x27;nekaj sekund&#x27; : &#x27;nekaj sekundami&#x27;;
	        case &#x27;ss&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; withoutSuffix ? &#x27;sekundo&#x27; : &#x27;sekundi&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;sekundi&#x27; : &#x27;sekundah&#x27;;
	            } else if (number &lt; 5) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;sekunde&#x27; : &#x27;sekundah&#x27;;
	            } else {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;sekund&#x27; : &#x27;sekund&#x27;;
	            }
	            return result;
	        case &#x27;m&#x27;:
	            return withoutSuffix ? &#x27;ena minuta&#x27; : &#x27;eno minuto&#x27;;
	        case &#x27;mm&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; withoutSuffix ? &#x27;minuta&#x27; : &#x27;minuto&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;minuti&#x27; : &#x27;minutama&#x27;;
	            } else if (number &lt; 5) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;minute&#x27; : &#x27;minutami&#x27;;
	            } else {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;minut&#x27; : &#x27;minutami&#x27;;
	            }
	            return result;
	        case &#x27;h&#x27;:
	            return withoutSuffix ? &#x27;ena ura&#x27; : &#x27;eno uro&#x27;;
	        case &#x27;hh&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; withoutSuffix ? &#x27;ura&#x27; : &#x27;uro&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;uri&#x27; : &#x27;urama&#x27;;
	            } else if (number &lt; 5) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;ure&#x27; : &#x27;urami&#x27;;
	            } else {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;ur&#x27; : &#x27;urami&#x27;;
	            }
	            return result;
	        case &#x27;d&#x27;:
	            return withoutSuffix || isFuture ? &#x27;en dan&#x27; : &#x27;enim dnem&#x27;;
	        case &#x27;dd&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;dan&#x27; : &#x27;dnem&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;dni&#x27; : &#x27;dnevoma&#x27;;
	            } else {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;dni&#x27; : &#x27;dnevi&#x27;;
	            }
	            return result;
	        case &#x27;M&#x27;:
	            return withoutSuffix || isFuture ? &#x27;en mesec&#x27; : &#x27;enim mesecem&#x27;;
	        case &#x27;MM&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;mesec&#x27; : &#x27;mesecem&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;meseca&#x27; : &#x27;mesecema&#x27;;
	            } else if (number &lt; 5) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;mesece&#x27; : &#x27;meseci&#x27;;
	            } else {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;mesecev&#x27; : &#x27;meseci&#x27;;
	            }
	            return result;
	        case &#x27;y&#x27;:
	            return withoutSuffix || isFuture ? &#x27;eno leto&#x27; : &#x27;enim letom&#x27;;
	        case &#x27;yy&#x27;:
	            if (number &#x3D;&#x3D;&#x3D; 1) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;leto&#x27; : &#x27;letom&#x27;;
	            } else if (number &#x3D;&#x3D;&#x3D; 2) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;leti&#x27; : &#x27;letoma&#x27;;
	            } else if (number &lt; 5) {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;leta&#x27; : &#x27;leti&#x27;;
	            } else {
	                result +&#x3D; withoutSuffix || isFuture ? &#x27;let&#x27; : &#x27;leti&#x27;;
	            }
	            return result;
	    }
	}

	var sl &#x3D; moment.defineLocale(&#x27;sl&#x27;, {
	    months : &#x27;januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ned._pon._tor._sre._čet._pet._sob.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ne_po_to_sr_če_pe_so&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM YYYY&#x27;,
	        LLL : &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL : &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar : {
	        sameDay  : &#x27;[danes ob] LT&#x27;,
	        nextDay  : &#x27;[jutri ob] LT&#x27;,

	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[v] [nedeljo] [ob] LT&#x27;;
	                case 3:
	                    return &#x27;[v] [sredo] [ob] LT&#x27;;
	                case 6:
	                    return &#x27;[v] [soboto] [ob] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[v] dddd [ob] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[včeraj ob] LT&#x27;,
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[prejšnjo] [nedeljo] [ob] LT&#x27;;
	                case 3:
	                    return &#x27;[prejšnjo] [sredo] [ob] LT&#x27;;
	                case 6:
	                    return &#x27;[prejšnjo] [soboto] [ob] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[prejšnji] dddd [ob] LT&#x27;;
	            }
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;čez %s&#x27;,
	        past   : &#x27;pred %s&#x27;,
	        s      : processRelativeTime,
	        ss     : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : processRelativeTime,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sl;

	})));


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var sq &#x3D; moment.defineLocale(&#x27;sq&#x27;, {
	    months : &#x27;Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Die_Hën_Mar_Mër_Enj_Pre_Sht&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;D_H_Ma_Më_E_P_Sh&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    meridiemParse: /PD|MD/,
	    isPM: function (input) {
	        return input.charAt(0) &#x3D;&#x3D;&#x3D; &#x27;M&#x27;;
	    },
	    meridiem : function (hours, minutes, isLower) {
	        return hours &lt; 12 ? &#x27;PD&#x27; : &#x27;MD&#x27;;
	    },
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Sot në] LT&#x27;,
	        nextDay : &#x27;[Nesër në] LT&#x27;,
	        nextWeek : &#x27;dddd [në] LT&#x27;,
	        lastDay : &#x27;[Dje në] LT&#x27;,
	        lastWeek : &#x27;dddd [e kaluar në] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;në %s&#x27;,
	        past : &#x27;%s më parë&#x27;,
	        s : &#x27;disa sekonda&#x27;,
	        ss : &#x27;%d sekonda&#x27;,
	        m : &#x27;një minutë&#x27;,
	        mm : &#x27;%d minuta&#x27;,
	        h : &#x27;një orë&#x27;,
	        hh : &#x27;%d orë&#x27;,
	        d : &#x27;një ditë&#x27;,
	        dd : &#x27;%d ditë&#x27;,
	        M : &#x27;një muaj&#x27;,
	        MM : &#x27;%d muaj&#x27;,
	        y : &#x27;një vit&#x27;,
	        yy : &#x27;%d vite&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sq;

	})));


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var translator &#x3D; {
	    words: { //Different grammatical cases
	        ss: [&#x27;sekunda&#x27;, &#x27;sekunde&#x27;, &#x27;sekundi&#x27;],
	        m: [&#x27;jedan minut&#x27;, &#x27;jedne minute&#x27;],
	        mm: [&#x27;minut&#x27;, &#x27;minute&#x27;, &#x27;minuta&#x27;],
	        h: [&#x27;jedan sat&#x27;, &#x27;jednog sata&#x27;],
	        hh: [&#x27;sat&#x27;, &#x27;sata&#x27;, &#x27;sati&#x27;],
	        dd: [&#x27;dan&#x27;, &#x27;dana&#x27;, &#x27;dana&#x27;],
	        MM: [&#x27;mesec&#x27;, &#x27;meseca&#x27;, &#x27;meseci&#x27;],
	        yy: [&#x27;godina&#x27;, &#x27;godine&#x27;, &#x27;godina&#x27;]
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number &#x3D;&#x3D;&#x3D; 1 ? wordKey[0] : (number &gt;&#x3D; 2 &amp;&amp; number &lt;&#x3D; 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey &#x3D; translator.words[key];
	        if (key.length &#x3D;&#x3D;&#x3D; 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + &#x27; &#x27; + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var sr &#x3D; moment.defineLocale(&#x27;sr&#x27;, {
	    months: &#x27;januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays: &#x27;nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;ned._pon._uto._sre._čet._pet._sub.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;ne_po_ut_sr_če_pe_su&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[danas u] LT&#x27;,
	        nextDay: &#x27;[sutra u] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[u] [nedelju] [u] LT&#x27;;
	                case 3:
	                    return &#x27;[u] [sredu] [u] LT&#x27;;
	                case 6:
	                    return &#x27;[u] [subotu] [u] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[u] dddd [u] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[juče u] LT&#x27;,
	        lastWeek : function () {
	            var lastWeekDays &#x3D; [
	                &#x27;[prošle] [nedelje] [u] LT&#x27;,
	                &#x27;[prošlog] [ponedeljka] [u] LT&#x27;,
	                &#x27;[prošlog] [utorka] [u] LT&#x27;,
	                &#x27;[prošle] [srede] [u] LT&#x27;,
	                &#x27;[prošlog] [četvrtka] [u] LT&#x27;,
	                &#x27;[prošlog] [petka] [u] LT&#x27;,
	                &#x27;[prošle] [subote] [u] LT&#x27;
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;za %s&#x27;,
	        past   : &#x27;pre %s&#x27;,
	        s      : &#x27;nekoliko sekundi&#x27;,
	        ss     : translator.translate,
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : &#x27;dan&#x27;,
	        dd     : translator.translate,
	        M      : &#x27;mesec&#x27;,
	        MM     : translator.translate,
	        y      : &#x27;godinu&#x27;,
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sr;

	})));


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var translator &#x3D; {
	    words: { //Different grammatical cases
	        ss: [&#x27;секунда&#x27;, &#x27;секунде&#x27;, &#x27;секунди&#x27;],
	        m: [&#x27;један минут&#x27;, &#x27;једне минуте&#x27;],
	        mm: [&#x27;минут&#x27;, &#x27;минуте&#x27;, &#x27;минута&#x27;],
	        h: [&#x27;један сат&#x27;, &#x27;једног сата&#x27;],
	        hh: [&#x27;сат&#x27;, &#x27;сата&#x27;, &#x27;сати&#x27;],
	        dd: [&#x27;дан&#x27;, &#x27;дана&#x27;, &#x27;дана&#x27;],
	        MM: [&#x27;месец&#x27;, &#x27;месеца&#x27;, &#x27;месеци&#x27;],
	        yy: [&#x27;година&#x27;, &#x27;године&#x27;, &#x27;година&#x27;]
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number &#x3D;&#x3D;&#x3D; 1 ? wordKey[0] : (number &gt;&#x3D; 2 &amp;&amp; number &lt;&#x3D; 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey &#x3D; translator.words[key];
	        if (key.length &#x3D;&#x3D;&#x3D; 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + &#x27; &#x27; + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var srCyrl &#x3D; moment.defineLocale(&#x27;sr-cyrl&#x27;, {
	    months: &#x27;јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар&#x27;.split(&#x27;_&#x27;),
	    monthsShort: &#x27;јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays: &#x27;недеља_понедељак_уторак_среда_четвртак_петак_субота&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort: &#x27;нед._пон._уто._сре._чет._пет._суб.&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;не_по_ут_ср_че_пе_су&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L: &#x27;DD.MM.YYYY&#x27;,
	        LL: &#x27;D. MMMM YYYY&#x27;,
	        LLL: &#x27;D. MMMM YYYY H:mm&#x27;,
	        LLLL: &#x27;dddd, D. MMMM YYYY H:mm&#x27;
	    },
	    calendar: {
	        sameDay: &#x27;[данас у] LT&#x27;,
	        nextDay: &#x27;[сутра у] LT&#x27;,
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return &#x27;[у] [недељу] [у] LT&#x27;;
	                case 3:
	                    return &#x27;[у] [среду] [у] LT&#x27;;
	                case 6:
	                    return &#x27;[у] [суботу] [у] LT&#x27;;
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return &#x27;[у] dddd [у] LT&#x27;;
	            }
	        },
	        lastDay  : &#x27;[јуче у] LT&#x27;,
	        lastWeek : function () {
	            var lastWeekDays &#x3D; [
	                &#x27;[прошле] [недеље] [у] LT&#x27;,
	                &#x27;[прошлог] [понедељка] [у] LT&#x27;,
	                &#x27;[прошлог] [уторка] [у] LT&#x27;,
	                &#x27;[прошле] [среде] [у] LT&#x27;,
	                &#x27;[прошлог] [четвртка] [у] LT&#x27;,
	                &#x27;[прошлог] [петка] [у] LT&#x27;,
	                &#x27;[прошле] [суботе] [у] LT&#x27;
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;за %s&#x27;,
	        past   : &#x27;пре %s&#x27;,
	        s      : &#x27;неколико секунди&#x27;,
	        ss     : translator.translate,
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : &#x27;дан&#x27;,
	        dd     : translator.translate,
	        M      : &#x27;месец&#x27;,
	        MM     : translator.translate,
	        y      : &#x27;годину&#x27;,
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return srCyrl;

	})));


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ss &#x3D; moment.defineLocale(&#x27;ss&#x27;, {
	    months : &quot;Bhimbidvwane_Indlovana_Indlov&#x27;lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni&quot;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Lis_Umb_Lsb_Les_Lsi_Lsh_Umg&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Li_Us_Lb_Lt_Ls_Lh_Ug&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Namuhla nga] LT&#x27;,
	        nextDay : &#x27;[Kusasa nga] LT&#x27;,
	        nextWeek : &#x27;dddd [nga] LT&#x27;,
	        lastDay : &#x27;[Itolo nga] LT&#x27;,
	        lastWeek : &#x27;dddd [leliphelile] [nga] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;nga %s&#x27;,
	        past : &#x27;wenteka nga %s&#x27;,
	        s : &#x27;emizuzwana lomcane&#x27;,
	        ss : &#x27;%d mzuzwana&#x27;,
	        m : &#x27;umzuzu&#x27;,
	        mm : &#x27;%d emizuzu&#x27;,
	        h : &#x27;lihora&#x27;,
	        hh : &#x27;%d emahora&#x27;,
	        d : &#x27;lilanga&#x27;,
	        dd : &#x27;%d emalanga&#x27;,
	        M : &#x27;inyanga&#x27;,
	        MM : &#x27;%d tinyanga&#x27;,
	        y : &#x27;umnyaka&#x27;,
	        yy : &#x27;%d iminyaka&#x27;
	    },
	    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 11) {
	            return &#x27;ekuseni&#x27;;
	        } else if (hours &lt; 15) {
	            return &#x27;emini&#x27;;
	        } else if (hours &lt; 19) {
	            return &#x27;entsambama&#x27;;
	        } else {
	            return &#x27;ebusuku&#x27;;
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ekuseni&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;emini&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;entsambama&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;ebusuku&#x27;) {
	            if (hour &#x3D;&#x3D;&#x3D; 0) {
	                return 0;
	            }
	            return hour + 12;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : &#x27;%d&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ss;

	})));


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var sv &#x3D; moment.defineLocale(&#x27;sv&#x27;, {
	    months : &#x27;januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;sön_mån_tis_ons_tor_fre_lör&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;sö_må_ti_on_to_fr_lö&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY-MM-DD&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY [kl.] HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY [kl.] HH:mm&#x27;,
	        lll : &#x27;D MMM YYYY HH:mm&#x27;,
	        llll : &#x27;ddd D MMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Idag] LT&#x27;,
	        nextDay: &#x27;[Imorgon] LT&#x27;,
	        lastDay: &#x27;[Igår] LT&#x27;,
	        nextWeek: &#x27;[På] dddd LT&#x27;,
	        lastWeek: &#x27;[I] dddd[s] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;om %s&#x27;,
	        past : &#x27;för %s sedan&#x27;,
	        s : &#x27;några sekunder&#x27;,
	        ss : &#x27;%d sekunder&#x27;,
	        m : &#x27;en minut&#x27;,
	        mm : &#x27;%d minuter&#x27;,
	        h : &#x27;en timme&#x27;,
	        hh : &#x27;%d timmar&#x27;,
	        d : &#x27;en dag&#x27;,
	        dd : &#x27;%d dagar&#x27;,
	        M : &#x27;en månad&#x27;,
	        MM : &#x27;%d månader&#x27;,
	        y : &#x27;ett år&#x27;,
	        yy : &#x27;%d år&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;e&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;a&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;a&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;e&#x27; : &#x27;e&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sv;

	})));


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var sw &#x3D; moment.defineLocale(&#x27;sw&#x27;, {
	    months : &#x27;Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;J2_J3_J4_J5_Al_Ij_J1&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[leo saa] LT&#x27;,
	        nextDay : &#x27;[kesho saa] LT&#x27;,
	        nextWeek : &#x27;[wiki ijayo] dddd [saat] LT&#x27;,
	        lastDay : &#x27;[jana] LT&#x27;,
	        lastWeek : &#x27;[wiki iliyopita] dddd [saat] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s baadaye&#x27;,
	        past : &#x27;tokea %s&#x27;,
	        s : &#x27;hivi punde&#x27;,
	        ss : &#x27;sekunde %d&#x27;,
	        m : &#x27;dakika moja&#x27;,
	        mm : &#x27;dakika %d&#x27;,
	        h : &#x27;saa limoja&#x27;,
	        hh : &#x27;masaa %d&#x27;,
	        d : &#x27;siku moja&#x27;,
	        dd : &#x27;masiku %d&#x27;,
	        M : &#x27;mwezi mmoja&#x27;,
	        MM : &#x27;miezi %d&#x27;,
	        y : &#x27;mwaka mmoja&#x27;,
	        yy : &#x27;miaka %d&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sw;

	})));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var symbolMap &#x3D; {
	    &#x27;1&#x27;: &#x27;௧&#x27;,
	    &#x27;2&#x27;: &#x27;௨&#x27;,
	    &#x27;3&#x27;: &#x27;௩&#x27;,
	    &#x27;4&#x27;: &#x27;௪&#x27;,
	    &#x27;5&#x27;: &#x27;௫&#x27;,
	    &#x27;6&#x27;: &#x27;௬&#x27;,
	    &#x27;7&#x27;: &#x27;௭&#x27;,
	    &#x27;8&#x27;: &#x27;௮&#x27;,
	    &#x27;9&#x27;: &#x27;௯&#x27;,
	    &#x27;0&#x27;: &#x27;௦&#x27;
	}, numberMap &#x3D; {
	    &#x27;௧&#x27;: &#x27;1&#x27;,
	    &#x27;௨&#x27;: &#x27;2&#x27;,
	    &#x27;௩&#x27;: &#x27;3&#x27;,
	    &#x27;௪&#x27;: &#x27;4&#x27;,
	    &#x27;௫&#x27;: &#x27;5&#x27;,
	    &#x27;௬&#x27;: &#x27;6&#x27;,
	    &#x27;௭&#x27;: &#x27;7&#x27;,
	    &#x27;௮&#x27;: &#x27;8&#x27;,
	    &#x27;௯&#x27;: &#x27;9&#x27;,
	    &#x27;௦&#x27;: &#x27;0&#x27;
	};

	var ta &#x3D; moment.defineLocale(&#x27;ta&#x27;, {
	    months : &#x27;ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ஞா_தி_செ_பு_வி_வெ_ச&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[இன்று] LT&#x27;,
	        nextDay : &#x27;[நாளை] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[நேற்று] LT&#x27;,
	        lastWeek : &#x27;[கடந்த வாரம்] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s இல்&#x27;,
	        past : &#x27;%s முன்&#x27;,
	        s : &#x27;ஒரு சில விநாடிகள்&#x27;,
	        ss : &#x27;%d விநாடிகள்&#x27;,
	        m : &#x27;ஒரு நிமிடம்&#x27;,
	        mm : &#x27;%d நிமிடங்கள்&#x27;,
	        h : &#x27;ஒரு மணி நேரம்&#x27;,
	        hh : &#x27;%d மணி நேரம்&#x27;,
	        d : &#x27;ஒரு நாள்&#x27;,
	        dd : &#x27;%d நாட்கள்&#x27;,
	        M : &#x27;ஒரு மாதம்&#x27;,
	        MM : &#x27;%d மாதங்கள்&#x27;,
	        y : &#x27;ஒரு வருடம்&#x27;,
	        yy : &#x27;%d ஆண்டுகள்&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}வது/,
	    ordinal : function (number) {
	        return number + &#x27;வது&#x27;;
	    },
	    preparse: function (string) {
	        return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // refer http://ta.wikipedia.org/s/1er1
	    meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 2) {
	            return &#x27; யாமம்&#x27;;
	        } else if (hour &lt; 6) {
	            return &#x27; வைகறை&#x27;;  // வைகறை
	        } else if (hour &lt; 10) {
	            return &#x27; காலை&#x27;; // காலை
	        } else if (hour &lt; 14) {
	            return &#x27; நண்பகல்&#x27;; // நண்பகல்
	        } else if (hour &lt; 18) {
	            return &#x27; எற்பாடு&#x27;; // எற்பாடு
	        } else if (hour &lt; 22) {
	            return &#x27; மாலை&#x27;; // மாலை
	        } else {
	            return &#x27; யாமம்&#x27;;
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;யாமம்&#x27;) {
	            return hour &lt; 2 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;வைகறை&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;காலை&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;நண்பகல்&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else {
	            return hour + 12;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ta;

	})));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var te &#x3D; moment.defineLocale(&#x27;te&#x27;, {
	    months : &#x27;జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ఆ_సో_మం_బు_గు_శు_శ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;A h:mm&#x27;,
	        LTS : &#x27;A h:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY, A h:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY, A h:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[నేడు] LT&#x27;,
	        nextDay : &#x27;[రేపు] LT&#x27;,
	        nextWeek : &#x27;dddd, LT&#x27;,
	        lastDay : &#x27;[నిన్న] LT&#x27;,
	        lastWeek : &#x27;[గత] dddd, LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s లో&#x27;,
	        past : &#x27;%s క్రితం&#x27;,
	        s : &#x27;కొన్ని క్షణాలు&#x27;,
	        ss : &#x27;%d సెకన్లు&#x27;,
	        m : &#x27;ఒక నిమిషం&#x27;,
	        mm : &#x27;%d నిమిషాలు&#x27;,
	        h : &#x27;ఒక గంట&#x27;,
	        hh : &#x27;%d గంటలు&#x27;,
	        d : &#x27;ఒక రోజు&#x27;,
	        dd : &#x27;%d రోజులు&#x27;,
	        M : &#x27;ఒక నెల&#x27;,
	        MM : &#x27;%d నెలలు&#x27;,
	        y : &#x27;ఒక సంవత్సరం&#x27;,
	        yy : &#x27;%d సంవత్సరాలు&#x27;
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}వ/,
	    ordinal : &#x27;%dవ&#x27;,
	    meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;రాత్రి&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;ఉదయం&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;మధ్యాహ్నం&#x27;) {
	            return hour &gt;&#x3D; 10 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;సాయంత్రం&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;రాత్రి&#x27;;
	        } else if (hour &lt; 10) {
	            return &#x27;ఉదయం&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;మధ్యాహ్నం&#x27;;
	        } else if (hour &lt; 20) {
	            return &#x27;సాయంత్రం&#x27;;
	        } else {
	            return &#x27;రాత్రి&#x27;;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return te;

	})));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tet &#x3D; moment.defineLocale(&#x27;tet&#x27;, {
	    months : &#x27;Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Dom_Seg_Ters_Kua_Kint_Sest_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Do_Seg_Te_Ku_Ki_Ses_Sa&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Ohin iha] LT&#x27;,
	        nextDay: &#x27;[Aban iha] LT&#x27;,
	        nextWeek: &#x27;dddd [iha] LT&#x27;,
	        lastDay: &#x27;[Horiseik iha] LT&#x27;,
	        lastWeek: &#x27;dddd [semana kotuk] [iha] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;iha %s&#x27;,
	        past : &#x27;%s liuba&#x27;,
	        s : &#x27;minutu balun&#x27;,
	        ss : &#x27;minutu %d&#x27;,
	        m : &#x27;minutu ida&#x27;,
	        mm : &#x27;minutu %d&#x27;,
	        h : &#x27;oras ida&#x27;,
	        hh : &#x27;oras %d&#x27;,
	        d : &#x27;loron ida&#x27;,
	        dd : &#x27;loron %d&#x27;,
	        M : &#x27;fulan ida&#x27;,
	        MM : &#x27;fulan %d&#x27;,
	        y : &#x27;tinan ida&#x27;,
	        yy : &#x27;tinan %d&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tet;

	})));


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var suffixes &#x3D; {
	    0: &#x27;-ум&#x27;,
	    1: &#x27;-ум&#x27;,
	    2: &#x27;-юм&#x27;,
	    3: &#x27;-юм&#x27;,
	    4: &#x27;-ум&#x27;,
	    5: &#x27;-ум&#x27;,
	    6: &#x27;-ум&#x27;,
	    7: &#x27;-ум&#x27;,
	    8: &#x27;-ум&#x27;,
	    9: &#x27;-ум&#x27;,
	    10: &#x27;-ум&#x27;,
	    12: &#x27;-ум&#x27;,
	    13: &#x27;-ум&#x27;,
	    20: &#x27;-ум&#x27;,
	    30: &#x27;-юм&#x27;,
	    40: &#x27;-ум&#x27;,
	    50: &#x27;-ум&#x27;,
	    60: &#x27;-ум&#x27;,
	    70: &#x27;-ум&#x27;,
	    80: &#x27;-ум&#x27;,
	    90: &#x27;-ум&#x27;,
	    100: &#x27;-ум&#x27;
	};

	var tg &#x3D; moment.defineLocale(&#x27;tg&#x27;, {
	    months : &#x27;январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;яшб_дшб_сшб_чшб_пшб_ҷум_шнб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;яш_дш_сш_чш_пш_ҷм_шб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Имрӯз соати] LT&#x27;,
	        nextDay : &#x27;[Пагоҳ соати] LT&#x27;,
	        lastDay : &#x27;[Дирӯз соати] LT&#x27;,
	        nextWeek : &#x27;dddd[и] [ҳафтаи оянда соати] LT&#x27;,
	        lastWeek : &#x27;dddd[и] [ҳафтаи гузашта соати] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;баъди %s&#x27;,
	        past : &#x27;%s пеш&#x27;,
	        s : &#x27;якчанд сония&#x27;,
	        m : &#x27;як дақиқа&#x27;,
	        mm : &#x27;%d дақиқа&#x27;,
	        h : &#x27;як соат&#x27;,
	        hh : &#x27;%d соат&#x27;,
	        d : &#x27;як рӯз&#x27;,
	        dd : &#x27;%d рӯз&#x27;,
	        M : &#x27;як моҳ&#x27;,
	        MM : &#x27;%d моҳ&#x27;,
	        y : &#x27;як сол&#x27;,
	        yy : &#x27;%d сол&#x27;
	    },
	    meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;шаб&#x27;) {
	            return hour &lt; 4 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;субҳ&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;рӯз&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;бегоҳ&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;шаб&#x27;;
	        } else if (hour &lt; 11) {
	            return &#x27;субҳ&#x27;;
	        } else if (hour &lt; 16) {
	            return &#x27;рӯз&#x27;;
	        } else if (hour &lt; 19) {
	            return &#x27;бегоҳ&#x27;;
	        } else {
	            return &#x27;шаб&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
	    ordinal: function (number) {
	        var a &#x3D; number % 10,
	            b &#x3D; number &gt;&#x3D; 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1th is the first week of the year.
	    }
	});

	return tg;

	})));


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var th &#x3D; moment.defineLocale(&#x27;th&#x27;, {
	    months : &#x27;มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact: true,
	    weekdays : &#x27;อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์&#x27;.split(&#x27;_&#x27;), // yes, three characters difference
	    weekdaysMin : &#x27;อา._จ._อ._พ._พฤ._ศ._ส.&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;H:mm&#x27;,
	        LTS : &#x27;H:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY เวลา H:mm&#x27;,
	        LLLL : &#x27;วันddddที่ D MMMM YYYY เวลา H:mm&#x27;
	    },
	    meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	    isPM: function (input) {
	        return input &#x3D;&#x3D;&#x3D; &#x27;หลังเที่ยง&#x27;;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;ก่อนเที่ยง&#x27;;
	        } else {
	            return &#x27;หลังเที่ยง&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[วันนี้ เวลา] LT&#x27;,
	        nextDay : &#x27;[พรุ่งนี้ เวลา] LT&#x27;,
	        nextWeek : &#x27;dddd[หน้า เวลา] LT&#x27;,
	        lastDay : &#x27;[เมื่อวานนี้ เวลา] LT&#x27;,
	        lastWeek : &#x27;[วัน]dddd[ที่แล้ว เวลา] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;อีก %s&#x27;,
	        past : &#x27;%sที่แล้ว&#x27;,
	        s : &#x27;ไม่กี่วินาที&#x27;,
	        ss : &#x27;%d วินาที&#x27;,
	        m : &#x27;1 นาที&#x27;,
	        mm : &#x27;%d นาที&#x27;,
	        h : &#x27;1 ชั่วโมง&#x27;,
	        hh : &#x27;%d ชั่วโมง&#x27;,
	        d : &#x27;1 วัน&#x27;,
	        dd : &#x27;%d วัน&#x27;,
	        M : &#x27;1 เดือน&#x27;,
	        MM : &#x27;%d เดือน&#x27;,
	        y : &#x27;1 ปี&#x27;,
	        yy : &#x27;%d ปี&#x27;
	    }
	});

	return th;

	})));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tlPh &#x3D; moment.defineLocale(&#x27;tl-ph&#x27;, {
	    months : &#x27;Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Lin_Lun_Mar_Miy_Huw_Biy_Sab&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Li_Lu_Ma_Mi_Hu_Bi_Sab&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;MM/D/YYYY&#x27;,
	        LL : &#x27;MMMM D, YYYY&#x27;,
	        LLL : &#x27;MMMM D, YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, MMMM DD, YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;LT [ngayong araw]&#x27;,
	        nextDay: &#x27;[Bukas ng] LT&#x27;,
	        nextWeek: &#x27;LT [sa susunod na] dddd&#x27;,
	        lastDay: &#x27;LT [kahapon]&#x27;,
	        lastWeek: &#x27;LT [noong nakaraang] dddd&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;sa loob ng %s&#x27;,
	        past : &#x27;%s ang nakalipas&#x27;,
	        s : &#x27;ilang segundo&#x27;,
	        ss : &#x27;%d segundo&#x27;,
	        m : &#x27;isang minuto&#x27;,
	        mm : &#x27;%d minuto&#x27;,
	        h : &#x27;isang oras&#x27;,
	        hh : &#x27;%d oras&#x27;,
	        d : &#x27;isang araw&#x27;,
	        dd : &#x27;%d araw&#x27;,
	        M : &#x27;isang buwan&#x27;,
	        MM : &#x27;%d buwan&#x27;,
	        y : &#x27;isang taon&#x27;,
	        yy : &#x27;%d taon&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlPh;

	})));


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var numbersNouns &#x3D; &#x27;pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut&#x27;.split(&#x27;_&#x27;);

	function translateFuture(output) {
	    var time &#x3D; output;
	    time &#x3D; (output.indexOf(&#x27;jaj&#x27;) !&#x3D;&#x3D; -1) ?
	    time.slice(0, -3) + &#x27;leS&#x27; :
	    (output.indexOf(&#x27;jar&#x27;) !&#x3D;&#x3D; -1) ?
	    time.slice(0, -3) + &#x27;waQ&#x27; :
	    (output.indexOf(&#x27;DIS&#x27;) !&#x3D;&#x3D; -1) ?
	    time.slice(0, -3) + &#x27;nem&#x27; :
	    time + &#x27; pIq&#x27;;
	    return time;
	}

	function translatePast(output) {
	    var time &#x3D; output;
	    time &#x3D; (output.indexOf(&#x27;jaj&#x27;) !&#x3D;&#x3D; -1) ?
	    time.slice(0, -3) + &#x27;Hu’&#x27; :
	    (output.indexOf(&#x27;jar&#x27;) !&#x3D;&#x3D; -1) ?
	    time.slice(0, -3) + &#x27;wen&#x27; :
	    (output.indexOf(&#x27;DIS&#x27;) !&#x3D;&#x3D; -1) ?
	    time.slice(0, -3) + &#x27;ben&#x27; :
	    time + &#x27; ret&#x27;;
	    return time;
	}

	function translate(number, withoutSuffix, string, isFuture) {
	    var numberNoun &#x3D; numberAsNoun(number);
	    switch (string) {
	        case &#x27;ss&#x27;:
	            return numberNoun + &#x27; lup&#x27;;
	        case &#x27;mm&#x27;:
	            return numberNoun + &#x27; tup&#x27;;
	        case &#x27;hh&#x27;:
	            return numberNoun + &#x27; rep&#x27;;
	        case &#x27;dd&#x27;:
	            return numberNoun + &#x27; jaj&#x27;;
	        case &#x27;MM&#x27;:
	            return numberNoun + &#x27; jar&#x27;;
	        case &#x27;yy&#x27;:
	            return numberNoun + &#x27; DIS&#x27;;
	    }
	}

	function numberAsNoun(number) {
	    var hundred &#x3D; Math.floor((number % 1000) / 100),
	    ten &#x3D; Math.floor((number % 100) / 10),
	    one &#x3D; number % 10,
	    word &#x3D; &#x27;&#x27;;
	    if (hundred &gt; 0) {
	        word +&#x3D; numbersNouns[hundred] + &#x27;vatlh&#x27;;
	    }
	    if (ten &gt; 0) {
	        word +&#x3D; ((word !&#x3D;&#x3D; &#x27;&#x27;) ? &#x27; &#x27; : &#x27;&#x27;) + numbersNouns[ten] + &#x27;maH&#x27;;
	    }
	    if (one &gt; 0) {
	        word +&#x3D; ((word !&#x3D;&#x3D; &#x27;&#x27;) ? &#x27; &#x27; : &#x27;&#x27;) + numbersNouns[one];
	    }
	    return (word &#x3D;&#x3D;&#x3D; &#x27;&#x27;) ? &#x27;pagh&#x27; : word;
	}

	var tlh &#x3D; moment.defineLocale(&#x27;tlh&#x27;, {
	    months : &#x27;tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[DaHjaj] LT&#x27;,
	        nextDay: &#x27;[wa’leS] LT&#x27;,
	        nextWeek: &#x27;LLL&#x27;,
	        lastDay: &#x27;[wa’Hu’] LT&#x27;,
	        lastWeek: &#x27;LLL&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : translateFuture,
	        past : translatePast,
	        s : &#x27;puS lup&#x27;,
	        ss : translate,
	        m : &#x27;wa’ tup&#x27;,
	        mm : translate,
	        h : &#x27;wa’ rep&#x27;,
	        hh : translate,
	        d : &#x27;wa’ jaj&#x27;,
	        dd : translate,
	        M : &#x27;wa’ jar&#x27;,
	        MM : translate,
	        y : &#x27;wa’ DIS&#x27;,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlh;

	})));


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;

	var suffixes &#x3D; {
	    1: &#x27;\&#x27;inci&#x27;,
	    5: &#x27;\&#x27;inci&#x27;,
	    8: &#x27;\&#x27;inci&#x27;,
	    70: &#x27;\&#x27;inci&#x27;,
	    80: &#x27;\&#x27;inci&#x27;,
	    2: &#x27;\&#x27;nci&#x27;,
	    7: &#x27;\&#x27;nci&#x27;,
	    20: &#x27;\&#x27;nci&#x27;,
	    50: &#x27;\&#x27;nci&#x27;,
	    3: &#x27;\&#x27;üncü&#x27;,
	    4: &#x27;\&#x27;üncü&#x27;,
	    100: &#x27;\&#x27;üncü&#x27;,
	    6: &#x27;\&#x27;ncı&#x27;,
	    9: &#x27;\&#x27;uncu&#x27;,
	    10: &#x27;\&#x27;uncu&#x27;,
	    30: &#x27;\&#x27;uncu&#x27;,
	    60: &#x27;\&#x27;ıncı&#x27;,
	    90: &#x27;\&#x27;ıncı&#x27;
	};

	var tr &#x3D; moment.defineLocale(&#x27;tr&#x27;, {
	    months : &#x27;Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Paz_Pts_Sal_Çar_Per_Cum_Cts&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Pz_Pt_Sa_Ça_Pe_Cu_Ct&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[bugün saat] LT&#x27;,
	        nextDay : &#x27;[yarın saat] LT&#x27;,
	        nextWeek : &#x27;[gelecek] dddd [saat] LT&#x27;,
	        lastDay : &#x27;[dün] LT&#x27;,
	        lastWeek : &#x27;[geçen] dddd [saat] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s sonra&#x27;,
	        past : &#x27;%s önce&#x27;,
	        s : &#x27;birkaç saniye&#x27;,
	        ss : &#x27;%d saniye&#x27;,
	        m : &#x27;bir dakika&#x27;,
	        mm : &#x27;%d dakika&#x27;,
	        h : &#x27;bir saat&#x27;,
	        hh : &#x27;%d saat&#x27;,
	        d : &#x27;bir gün&#x27;,
	        dd : &#x27;%d gün&#x27;,
	        M : &#x27;bir ay&#x27;,
	        MM : &#x27;%d ay&#x27;,
	        y : &#x27;bir yıl&#x27;,
	        yy : &#x27;%d yıl&#x27;
	    },
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;Do&#x27;:
	            case &#x27;DD&#x27;:
	                return number;
	            default:
	                if (number &#x3D;&#x3D;&#x3D; 0) {  // special case for zero
	                    return number + &#x27;\&#x27;ıncı&#x27;;
	                }
	                var a &#x3D; number % 10,
	                    b &#x3D; number % 100 - a,
	                    c &#x3D; number &gt;&#x3D; 100 ? 100 : null;
	                return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tr;

	})));


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	var tzl &#x3D; moment.defineLocale(&#x27;tzl&#x27;, {
	    months : &#x27;Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Súl_Lún_Mai_Már_Xhú_Vié_Sát&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Sú_Lú_Ma_Má_Xh_Vi_Sá&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH.mm&#x27;,
	        LTS : &#x27;HH.mm.ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D. MMMM [dallas] YYYY&#x27;,
	        LLL : &#x27;D. MMMM [dallas] YYYY HH.mm&#x27;,
	        LLLL : &#x27;dddd, [li] D. MMMM [dallas] YYYY HH.mm&#x27;
	    },
	    meridiemParse: /d\&#x27;o|d\&#x27;a/i,
	    isPM : function (input) {
	        return &#x27;d\&#x27;o&#x27; &#x3D;&#x3D;&#x3D; input.toLowerCase();
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &gt; 11) {
	            return isLower ? &#x27;d\&#x27;o&#x27; : &#x27;D\&#x27;O&#x27;;
	        } else {
	            return isLower ? &#x27;d\&#x27;a&#x27; : &#x27;D\&#x27;A&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[oxhi à] LT&#x27;,
	        nextDay : &#x27;[demà à] LT&#x27;,
	        nextWeek : &#x27;dddd [à] LT&#x27;,
	        lastDay : &#x27;[ieiri à] LT&#x27;,
	        lastWeek : &#x27;[sür el] dddd [lasteu à] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;osprei %s&#x27;,
	        past : &#x27;ja%s&#x27;,
	        s : processRelativeTime,
	        ss : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : &#x27;%d.&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format &#x3D; {
	        &#x27;s&#x27;: [&#x27;viensas secunds&#x27;, &#x27;\&#x27;iensas secunds&#x27;],
	        &#x27;ss&#x27;: [number + &#x27; secunds&#x27;, &#x27;&#x27; + number + &#x27; secunds&#x27;],
	        &#x27;m&#x27;: [&#x27;\&#x27;n míut&#x27;, &#x27;\&#x27;iens míut&#x27;],
	        &#x27;mm&#x27;: [number + &#x27; míuts&#x27;, &#x27;&#x27; + number + &#x27; míuts&#x27;],
	        &#x27;h&#x27;: [&#x27;\&#x27;n þora&#x27;, &#x27;\&#x27;iensa þora&#x27;],
	        &#x27;hh&#x27;: [number + &#x27; þoras&#x27;, &#x27;&#x27; + number + &#x27; þoras&#x27;],
	        &#x27;d&#x27;: [&#x27;\&#x27;n ziua&#x27;, &#x27;\&#x27;iensa ziua&#x27;],
	        &#x27;dd&#x27;: [number + &#x27; ziuas&#x27;, &#x27;&#x27; + number + &#x27; ziuas&#x27;],
	        &#x27;M&#x27;: [&#x27;\&#x27;n mes&#x27;, &#x27;\&#x27;iens mes&#x27;],
	        &#x27;MM&#x27;: [number + &#x27; mesen&#x27;, &#x27;&#x27; + number + &#x27; mesen&#x27;],
	        &#x27;y&#x27;: [&#x27;\&#x27;n ar&#x27;, &#x27;\&#x27;iens ar&#x27;],
	        &#x27;yy&#x27;: [number + &#x27; ars&#x27;, &#x27;&#x27; + number + &#x27; ars&#x27;]
	    };
	    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}

	return tzl;

	})));


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tzm &#x3D; moment.defineLocale(&#x27;tzm&#x27;, {
	    months : &#x27;ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[ⴰⵙⴷⵅ ⴴ] LT&#x27;,
	        nextDay: &#x27;[ⴰⵙⴽⴰ ⴴ] LT&#x27;,
	        nextWeek: &#x27;dddd [ⴴ] LT&#x27;,
	        lastDay: &#x27;[ⴰⵚⴰⵏⵜ ⴴ] LT&#x27;,
	        lastWeek: &#x27;dddd [ⴴ] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s&#x27;,
	        past : &#x27;ⵢⴰⵏ %s&#x27;,
	        s : &#x27;ⵉⵎⵉⴽ&#x27;,
	        ss : &#x27;%d ⵉⵎⵉⴽ&#x27;,
	        m : &#x27;ⵎⵉⵏⵓⴺ&#x27;,
	        mm : &#x27;%d ⵎⵉⵏⵓⴺ&#x27;,
	        h : &#x27;ⵙⴰⵄⴰ&#x27;,
	        hh : &#x27;%d ⵜⴰⵙⵙⴰⵄⵉⵏ&#x27;,
	        d : &#x27;ⴰⵙⵙ&#x27;,
	        dd : &#x27;%d oⵙⵙⴰⵏ&#x27;,
	        M : &#x27;ⴰⵢoⵓⵔ&#x27;,
	        MM : &#x27;%d ⵉⵢⵢⵉⵔⵏ&#x27;,
	        y : &#x27;ⴰⵙⴳⴰⵙ&#x27;,
	        yy : &#x27;%d ⵉⵙⴳⴰⵙⵏ&#x27;
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzm;

	})));


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var tzmLatn &#x3D; moment.defineLocale(&#x27;tzm-latn&#x27;, {
	    months : &#x27;innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[asdkh g] LT&#x27;,
	        nextDay: &#x27;[aska g] LT&#x27;,
	        nextWeek: &#x27;dddd [g] LT&#x27;,
	        lastDay: &#x27;[assant g] LT&#x27;,
	        lastWeek: &#x27;dddd [g] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;dadkh s yan %s&#x27;,
	        past : &#x27;yan %s&#x27;,
	        s : &#x27;imik&#x27;,
	        ss : &#x27;%d imik&#x27;,
	        m : &#x27;minuḍ&#x27;,
	        mm : &#x27;%d minuḍ&#x27;,
	        h : &#x27;saɛa&#x27;,
	        hh : &#x27;%d tassaɛin&#x27;,
	        d : &#x27;ass&#x27;,
	        dd : &#x27;%d ossan&#x27;,
	        M : &#x27;ayowr&#x27;,
	        MM : &#x27;%d iyyirn&#x27;,
	        y : &#x27;asgas&#x27;,
	        yy : &#x27;%d isgasn&#x27;
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzmLatn;

	})));


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js language configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var ugCn &#x3D; moment.defineLocale(&#x27;ug-cn&#x27;, {
	    months: &#x27;يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر&#x27;.split(
	        &#x27;_&#x27;
	    ),
	    monthsShort: &#x27;يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر&#x27;.split(
	        &#x27;_&#x27;
	    ),
	    weekdays: &#x27;يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە&#x27;.split(
	        &#x27;_&#x27;
	    ),
	    weekdaysShort: &#x27;يە_دۈ_سە_چا_پە_جۈ_شە&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin: &#x27;يە_دۈ_سە_چا_پە_جۈ_شە&#x27;.split(&#x27;_&#x27;),
	    longDateFormat: {
	        LT: &#x27;HH:mm&#x27;,
	        LTS: &#x27;HH:mm:ss&#x27;,
	        L: &#x27;YYYY-MM-DD&#x27;,
	        LL: &#x27;YYYY-يىلىM-ئاينىڭD-كۈنى&#x27;,
	        LLL: &#x27;YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm&#x27;,
	        LLLL: &#x27;dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm&#x27;
	    },
	    meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (
	            meridiem &#x3D;&#x3D;&#x3D; &#x27;يېرىم كېچە&#x27; ||
	            meridiem &#x3D;&#x3D;&#x3D; &#x27;سەھەر&#x27; ||
	            meridiem &#x3D;&#x3D;&#x3D; &#x27;چۈشتىن بۇرۇن&#x27;
	        ) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;چۈشتىن كېيىن&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;كەچ&#x27;) {
	            return hour + 12;
	        } else {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        var hm &#x3D; hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;يېرىم كېچە&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;سەھەر&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;چۈشتىن بۇرۇن&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;چۈش&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;چۈشتىن كېيىن&#x27;;
	        } else {
	            return &#x27;كەچ&#x27;;
	        }
	    },
	    calendar: {
	        sameDay: &#x27;[بۈگۈن سائەت] LT&#x27;,
	        nextDay: &#x27;[ئەتە سائەت] LT&#x27;,
	        nextWeek: &#x27;[كېلەركى] dddd [سائەت] LT&#x27;,
	        lastDay: &#x27;[تۆنۈگۈن] LT&#x27;,
	        lastWeek: &#x27;[ئالدىنقى] dddd [سائەت] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime: {
	        future: &#x27;%s كېيىن&#x27;,
	        past: &#x27;%s بۇرۇن&#x27;,
	        s: &#x27;نەچچە سېكونت&#x27;,
	        ss: &#x27;%d سېكونت&#x27;,
	        m: &#x27;بىر مىنۇت&#x27;,
	        mm: &#x27;%d مىنۇت&#x27;,
	        h: &#x27;بىر سائەت&#x27;,
	        hh: &#x27;%d سائەت&#x27;,
	        d: &#x27;بىر كۈن&#x27;,
	        dd: &#x27;%d كۈن&#x27;,
	        M: &#x27;بىر ئاي&#x27;,
	        MM: &#x27;%d ئاي&#x27;,
	        y: &#x27;بىر يىل&#x27;,
	        yy: &#x27;%d يىل&#x27;
	    },

	    dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;-كۈنى&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;-ھەپتە&#x27;;
	            default:
	                return number;
	        }
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week: {
	        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	        dow: 1, // Monday is the first day of the week.
	        doy: 7 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ugCn;

	})));


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	function plural(word, num) {
	    var forms &#x3D; word.split(&#x27;_&#x27;);
	    return num % 10 &#x3D;&#x3D;&#x3D; 1 &amp;&amp; num % 100 !&#x3D;&#x3D; 11 ? forms[0] : (num % 10 &gt;&#x3D; 2 &amp;&amp; num % 10 &lt;&#x3D; 4 &amp;&amp; (num % 100 &lt; 10 || num % 100 &gt;&#x3D; 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format &#x3D; {
	        &#x27;ss&#x27;: withoutSuffix ? &#x27;секунда_секунди_секунд&#x27; : &#x27;секунду_секунди_секунд&#x27;,
	        &#x27;mm&#x27;: withoutSuffix ? &#x27;хвилина_хвилини_хвилин&#x27; : &#x27;хвилину_хвилини_хвилин&#x27;,
	        &#x27;hh&#x27;: withoutSuffix ? &#x27;година_години_годин&#x27; : &#x27;годину_години_годин&#x27;,
	        &#x27;dd&#x27;: &#x27;день_дні_днів&#x27;,
	        &#x27;MM&#x27;: &#x27;місяць_місяці_місяців&#x27;,
	        &#x27;yy&#x27;: &#x27;рік_роки_років&#x27;
	    };
	    if (key &#x3D;&#x3D;&#x3D; &#x27;m&#x27;) {
	        return withoutSuffix ? &#x27;хвилина&#x27; : &#x27;хвилину&#x27;;
	    }
	    else if (key &#x3D;&#x3D;&#x3D; &#x27;h&#x27;) {
	        return withoutSuffix ? &#x27;година&#x27; : &#x27;годину&#x27;;
	    }
	    else {
	        return number + &#x27; &#x27; + plural(format[key], +number);
	    }
	}
	function weekdaysCaseReplace(m, format) {
	    var weekdays &#x3D; {
	        &#x27;nominative&#x27;: &#x27;неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота&#x27;.split(&#x27;_&#x27;),
	        &#x27;accusative&#x27;: &#x27;неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу&#x27;.split(&#x27;_&#x27;),
	        &#x27;genitive&#x27;: &#x27;неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи&#x27;.split(&#x27;_&#x27;)
	    };

	    if (!m) {
	        return weekdays[&#x27;nominative&#x27;];
	    }

	    var nounCase &#x3D; (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	        &#x27;accusative&#x27; :
	        ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	            &#x27;genitive&#x27; :
	            &#x27;nominative&#x27;);
	    return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
	    return function () {
	        return str + &#x27;о&#x27; + (this.hours() &#x3D;&#x3D;&#x3D; 11 ? &#x27;б&#x27; : &#x27;&#x27;) + &#x27;] LT&#x27;;
	    };
	}

	var uk &#x3D; moment.defineLocale(&#x27;uk&#x27;, {
	    months : {
	        &#x27;format&#x27;: &#x27;січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня&#x27;.split(&#x27;_&#x27;),
	        &#x27;standalone&#x27;: &#x27;січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень&#x27;.split(&#x27;_&#x27;)
	    },
	    monthsShort : &#x27;січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд&#x27;.split(&#x27;_&#x27;),
	    weekdays : weekdaysCaseReplace,
	    weekdaysShort : &#x27;нд_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;нд_пн_вт_ср_чт_пт_сб&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD.MM.YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY р.&#x27;,
	        LLL : &#x27;D MMMM YYYY р., HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY р., HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: processHoursFunction(&#x27;[Сьогодні &#x27;),
	        nextDay: processHoursFunction(&#x27;[Завтра &#x27;),
	        lastDay: processHoursFunction(&#x27;[Вчора &#x27;),
	        nextWeek: processHoursFunction(&#x27;[У] dddd [&#x27;),
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction(&#x27;[Минулої] dddd [&#x27;).call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction(&#x27;[Минулого] dddd [&#x27;).call(this);
	            }
	        },
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;за %s&#x27;,
	        past : &#x27;%s тому&#x27;,
	        s : &#x27;декілька секунд&#x27;,
	        ss : relativeTimeWithPlural,
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : &#x27;годину&#x27;,
	        hh : relativeTimeWithPlural,
	        d : &#x27;день&#x27;,
	        dd : relativeTimeWithPlural,
	        M : &#x27;місяць&#x27;,
	        MM : relativeTimeWithPlural,
	        y : &#x27;рік&#x27;,
	        yy : relativeTimeWithPlural
	    },
	    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	    meridiemParse: /ночі|ранку|дня|вечора/,
	    isPM: function (input) {
	        return /^(дня|вечора)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 4) {
	            return &#x27;ночі&#x27;;
	        } else if (hour &lt; 12) {
	            return &#x27;ранку&#x27;;
	        } else if (hour &lt; 17) {
	            return &#x27;дня&#x27;;
	        } else {
	            return &#x27;вечора&#x27;;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case &#x27;M&#x27;:
	            case &#x27;d&#x27;:
	            case &#x27;DDD&#x27;:
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;-й&#x27;;
	            case &#x27;D&#x27;:
	                return number + &#x27;-го&#x27;;
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uk;

	})));


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var months &#x3D; [
	    &#x27;جنوری&#x27;,
	    &#x27;فروری&#x27;,
	    &#x27;مارچ&#x27;,
	    &#x27;اپریل&#x27;,
	    &#x27;مئی&#x27;,
	    &#x27;جون&#x27;,
	    &#x27;جولائی&#x27;,
	    &#x27;اگست&#x27;,
	    &#x27;ستمبر&#x27;,
	    &#x27;اکتوبر&#x27;,
	    &#x27;نومبر&#x27;,
	    &#x27;دسمبر&#x27;
	];
	var days &#x3D; [
	    &#x27;اتوار&#x27;,
	    &#x27;پیر&#x27;,
	    &#x27;منگل&#x27;,
	    &#x27;بدھ&#x27;,
	    &#x27;جمعرات&#x27;,
	    &#x27;جمعہ&#x27;,
	    &#x27;ہفتہ&#x27;
	];

	var ur &#x3D; moment.defineLocale(&#x27;ur&#x27;, {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd، D MMMM YYYY HH:mm&#x27;
	    },
	    meridiemParse: /صبح|شام/,
	    isPM : function (input) {
	        return &#x27;شام&#x27; &#x3D;&#x3D;&#x3D; input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour &lt; 12) {
	            return &#x27;صبح&#x27;;
	        }
	        return &#x27;شام&#x27;;
	    },
	    calendar : {
	        sameDay : &#x27;[آج بوقت] LT&#x27;,
	        nextDay : &#x27;[کل بوقت] LT&#x27;,
	        nextWeek : &#x27;dddd [بوقت] LT&#x27;,
	        lastDay : &#x27;[گذشتہ روز بوقت] LT&#x27;,
	        lastWeek : &#x27;[گذشتہ] dddd [بوقت] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s بعد&#x27;,
	        past : &#x27;%s قبل&#x27;,
	        s : &#x27;چند سیکنڈ&#x27;,
	        ss : &#x27;%d سیکنڈ&#x27;,
	        m : &#x27;ایک منٹ&#x27;,
	        mm : &#x27;%d منٹ&#x27;,
	        h : &#x27;ایک گھنٹہ&#x27;,
	        hh : &#x27;%d گھنٹے&#x27;,
	        d : &#x27;ایک دن&#x27;,
	        dd : &#x27;%d دن&#x27;,
	        M : &#x27;ایک ماہ&#x27;,
	        MM : &#x27;%d ماہ&#x27;,
	        y : &#x27;ایک سال&#x27;,
	        yy : &#x27;%d سال&#x27;
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, &#x27;,&#x27;);
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, &#x27;،&#x27;);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ur;

	})));


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var uz &#x3D; moment.defineLocale(&#x27;uz&#x27;, {
	    months : &#x27;январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Якш_Душ_Сеш_Чор_Пай_Жум_Шан&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Як_Ду_Се_Чо_Па_Жу_Ша&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;D MMMM YYYY, dddd HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Бугун соат] LT [да]&#x27;,
	        nextDay : &#x27;[Эртага] LT [да]&#x27;,
	        nextWeek : &#x27;dddd [куни соат] LT [да]&#x27;,
	        lastDay : &#x27;[Кеча соат] LT [да]&#x27;,
	        lastWeek : &#x27;[Утган] dddd [куни соат] LT [да]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;Якин %s ичида&#x27;,
	        past : &#x27;Бир неча %s олдин&#x27;,
	        s : &#x27;фурсат&#x27;,
	        ss : &#x27;%d фурсат&#x27;,
	        m : &#x27;бир дакика&#x27;,
	        mm : &#x27;%d дакика&#x27;,
	        h : &#x27;бир соат&#x27;,
	        hh : &#x27;%d соат&#x27;,
	        d : &#x27;бир кун&#x27;,
	        dd : &#x27;%d кун&#x27;,
	        M : &#x27;бир ой&#x27;,
	        MM : &#x27;%d ой&#x27;,
	        y : &#x27;бир йил&#x27;,
	        yy : &#x27;%d йил&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return uz;

	})));


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var uzLatn &#x3D; moment.defineLocale(&#x27;uz-latn&#x27;, {
	    months : &#x27;Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Yak_Dush_Sesh_Chor_Pay_Jum_Shan&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Ya_Du_Se_Cho_Pa_Ju_Sha&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;D MMMM YYYY, dddd HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Bugun soat] LT [da]&#x27;,
	        nextDay : &#x27;[Ertaga] LT [da]&#x27;,
	        nextWeek : &#x27;dddd [kuni soat] LT [da]&#x27;,
	        lastDay : &#x27;[Kecha soat] LT [da]&#x27;,
	        lastWeek : &#x27;[O\&#x27;tgan] dddd [kuni soat] LT [da]&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;Yaqin %s ichida&#x27;,
	        past : &#x27;Bir necha %s oldin&#x27;,
	        s : &#x27;soniya&#x27;,
	        ss : &#x27;%d soniya&#x27;,
	        m : &#x27;bir daqiqa&#x27;,
	        mm : &#x27;%d daqiqa&#x27;,
	        h : &#x27;bir soat&#x27;,
	        hh : &#x27;%d soat&#x27;,
	        d : &#x27;bir kun&#x27;,
	        dd : &#x27;%d kun&#x27;,
	        M : &#x27;bir oy&#x27;,
	        MM : &#x27;%d oy&#x27;,
	        y : &#x27;bir yil&#x27;,
	        yy : &#x27;%d yil&#x27;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uzLatn;

	})));


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var vi &#x3D; moment.defineLocale(&#x27;vi&#x27;, {
	    months : &#x27;tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;CN_T2_T3_T4_T5_T6_T7&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;CN_T2_T3_T4_T5_T6_T7&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    meridiemParse: /sa|ch/i,
	    isPM : function (input) {
	        return /^ch$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours &lt; 12) {
	            return isLower ? &#x27;sa&#x27; : &#x27;SA&#x27;;
	        } else {
	            return isLower ? &#x27;ch&#x27; : &#x27;CH&#x27;;
	        }
	    },
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM [năm] YYYY&#x27;,
	        LLL : &#x27;D MMMM [năm] YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM [năm] YYYY HH:mm&#x27;,
	        l : &#x27;DD/M/YYYY&#x27;,
	        ll : &#x27;D MMM YYYY&#x27;,
	        lll : &#x27;D MMM YYYY HH:mm&#x27;,
	        llll : &#x27;ddd, D MMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay: &#x27;[Hôm nay lúc] LT&#x27;,
	        nextDay: &#x27;[Ngày mai lúc] LT&#x27;,
	        nextWeek: &#x27;dddd [tuần tới lúc] LT&#x27;,
	        lastDay: &#x27;[Hôm qua lúc] LT&#x27;,
	        lastWeek: &#x27;dddd [tuần rồi lúc] LT&#x27;,
	        sameElse: &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;%s tới&#x27;,
	        past : &#x27;%s trước&#x27;,
	        s : &#x27;vài giây&#x27;,
	        ss : &#x27;%d giây&#x27; ,
	        m : &#x27;một phút&#x27;,
	        mm : &#x27;%d phút&#x27;,
	        h : &#x27;một giờ&#x27;,
	        hh : &#x27;%d giờ&#x27;,
	        d : &#x27;một ngày&#x27;,
	        dd : &#x27;%d ngày&#x27;,
	        M : &#x27;một tháng&#x27;,
	        MM : &#x27;%d tháng&#x27;,
	        y : &#x27;một năm&#x27;,
	        yy : &#x27;%d năm&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return vi;

	})));


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var xPseudo &#x3D; moment.defineLocale(&#x27;x-pseudo&#x27;, {
	    months : &#x27;J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc&#x27;.split(&#x27;_&#x27;),
	    monthsParseExact : true,
	    weekdays : &#x27;S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá&#x27;.split(&#x27;_&#x27;),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY HH:mm&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY HH:mm&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[T~ódá~ý át] LT&#x27;,
	        nextDay : &#x27;[T~ómó~rró~w át] LT&#x27;,
	        nextWeek : &#x27;dddd [át] LT&#x27;,
	        lastDay : &#x27;[Ý~ést~érdá~ý át] LT&#x27;,
	        lastWeek : &#x27;[L~ást] dddd [át] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;í~ñ %s&#x27;,
	        past : &#x27;%s á~gó&#x27;,
	        s : &#x27;á ~féw ~sécó~ñds&#x27;,
	        ss : &#x27;%d s~écóñ~ds&#x27;,
	        m : &#x27;á ~míñ~úté&#x27;,
	        mm : &#x27;%d m~íñú~tés&#x27;,
	        h : &#x27;á~ñ hó~úr&#x27;,
	        hh : &#x27;%d h~óúrs&#x27;,
	        d : &#x27;á ~dáý&#x27;,
	        dd : &#x27;%d d~áýs&#x27;,
	        M : &#x27;á ~móñ~th&#x27;,
	        MM : &#x27;%d m~óñt~hs&#x27;,
	        y : &#x27;á ~ýéár&#x27;,
	        yy : &#x27;%d ý~éárs&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b &#x3D; number % 10,
	            output &#x3D; (~~(number % 100 / 10) &#x3D;&#x3D;&#x3D; 1) ? &#x27;th&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 1) ? &#x27;st&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 2) ? &#x27;nd&#x27; :
	            (b &#x3D;&#x3D;&#x3D; 3) ? &#x27;rd&#x27; : &#x27;th&#x27;;
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return xPseudo;

	})));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var yo &#x3D; moment.defineLocale(&#x27;yo&#x27;, {
	    months : &#x27;Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;h:mm A&#x27;,
	        LTS : &#x27;h:mm:ss A&#x27;,
	        L : &#x27;DD/MM/YYYY&#x27;,
	        LL : &#x27;D MMMM YYYY&#x27;,
	        LLL : &#x27;D MMMM YYYY h:mm A&#x27;,
	        LLLL : &#x27;dddd, D MMMM YYYY h:mm A&#x27;
	    },
	    calendar : {
	        sameDay : &#x27;[Ònì ni] LT&#x27;,
	        nextDay : &#x27;[Ọ̀la ni] LT&#x27;,
	        nextWeek : &#x27;dddd [Ọsẹ̀ tón\&#x27;bọ] [ni] LT&#x27;,
	        lastDay : &#x27;[Àna ni] LT&#x27;,
	        lastWeek : &#x27;dddd [Ọsẹ̀ tólọ́] [ni] LT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    relativeTime : {
	        future : &#x27;ní %s&#x27;,
	        past : &#x27;%s kọjá&#x27;,
	        s : &#x27;ìsẹjú aayá die&#x27;,
	        ss :&#x27;aayá %d&#x27;,
	        m : &#x27;ìsẹjú kan&#x27;,
	        mm : &#x27;ìsẹjú %d&#x27;,
	        h : &#x27;wákati kan&#x27;,
	        hh : &#x27;wákati %d&#x27;,
	        d : &#x27;ọjọ́ kan&#x27;,
	        dd : &#x27;ọjọ́ %d&#x27;,
	        M : &#x27;osù kan&#x27;,
	        MM : &#x27;osù %d&#x27;,
	        y : &#x27;ọdún kan&#x27;,
	        yy : &#x27;ọdún %d&#x27;
	    },
	    dayOfMonthOrdinalParse : /ọjọ́\s\d{1,2}/,
	    ordinal : &#x27;ọjọ́ %d&#x27;,
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return yo;

	})));


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var zhCn &#x3D; moment.defineLocale(&#x27;zh-cn&#x27;, {
	    months : &#x27;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;星期日_星期一_星期二_星期三_星期四_星期五_星期六&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;周日_周一_周二_周三_周四_周五_周六&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_一_二_三_四_五_六&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日Ah点mm分&#x27;,
	        LLLL : &#x27;YYYY年M月D日ddddAh点mm分&#x27;,
	        l : &#x27;YYYY/M/D&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日dddd HH:mm&#x27;
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;凌晨&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;早上&#x27; ||
	                meridiem &#x3D;&#x3D;&#x3D; &#x27;上午&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;下午&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;晚上&#x27;) {
	            return hour + 12;
	        } else {
	            // &#x27;中午&#x27;
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm &#x3D; hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;凌晨&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;早上&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;上午&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;中午&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;下午&#x27;;
	        } else {
	            return &#x27;晚上&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今天]LT&#x27;,
	        nextDay : &#x27;[明天]LT&#x27;,
	        nextWeek : &#x27;[下]ddddLT&#x27;,
	        lastDay : &#x27;[昨天]LT&#x27;,
	        lastWeek : &#x27;[上]ddddLT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27;:
	            case &#x27;D&#x27;:
	            case &#x27;DDD&#x27;:
	                return number + &#x27;日&#x27;;
	            case &#x27;M&#x27;:
	                return number + &#x27;月&#x27;;
	            case &#x27;w&#x27;:
	            case &#x27;W&#x27;:
	                return number + &#x27;周&#x27;;
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s内&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;几秒&#x27;,
	        ss : &#x27;%d 秒&#x27;,
	        m : &#x27;1 分钟&#x27;,
	        mm : &#x27;%d 分钟&#x27;,
	        h : &#x27;1 小时&#x27;,
	        hh : &#x27;%d 小时&#x27;,
	        d : &#x27;1 天&#x27;,
	        dd : &#x27;%d 天&#x27;,
	        M : &#x27;1 个月&#x27;,
	        MM : &#x27;%d 个月&#x27;,
	        y : &#x27;1 年&#x27;,
	        yy : &#x27;%d 年&#x27;
	    },
	    week : {
	        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return zhCn;

	})));


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var zhHk &#x3D; moment.defineLocale(&#x27;zh-hk&#x27;, {
	    months : &#x27;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;星期日_星期一_星期二_星期三_星期四_星期五_星期六&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;週日_週一_週二_週三_週四_週五_週六&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_一_二_三_四_五_六&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        LLLL : &#x27;YYYY年M月D日dddd HH:mm&#x27;,
	        l : &#x27;YYYY/M/D&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日dddd HH:mm&#x27;
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;凌晨&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;早上&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;上午&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;中午&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;下午&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;晚上&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm &#x3D; hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;凌晨&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;早上&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;上午&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;中午&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;下午&#x27;;
	        } else {
	            return &#x27;晚上&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今天]LT&#x27;,
	        nextDay : &#x27;[明天]LT&#x27;,
	        nextWeek : &#x27;[下]ddddLT&#x27;,
	        lastDay : &#x27;[昨天]LT&#x27;,
	        lastWeek : &#x27;[上]ddddLT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27; :
	            case &#x27;D&#x27; :
	            case &#x27;DDD&#x27; :
	                return number + &#x27;日&#x27;;
	            case &#x27;M&#x27; :
	                return number + &#x27;月&#x27;;
	            case &#x27;w&#x27; :
	            case &#x27;W&#x27; :
	                return number + &#x27;週&#x27;;
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s內&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;幾秒&#x27;,
	        ss : &#x27;%d 秒&#x27;,
	        m : &#x27;1 分鐘&#x27;,
	        mm : &#x27;%d 分鐘&#x27;,
	        h : &#x27;1 小時&#x27;,
	        hh : &#x27;%d 小時&#x27;,
	        d : &#x27;1 天&#x27;,
	        dd : &#x27;%d 天&#x27;,
	        M : &#x27;1 個月&#x27;,
	        MM : &#x27;%d 個月&#x27;,
	        y : &#x27;1 年&#x27;,
	        yy : &#x27;%d 年&#x27;
	    }
	});

	return zhHk;

	})));


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration

	;(function (global, factory) {
	    true ? factory(__webpack_require__(72)) :
	   typeof define &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp; define.amd ? define([&#x27;../moment&#x27;], factory) :
	   factory(global.moment)
	}(this, (function (moment) { &#x27;use strict&#x27;;


	var zhTw &#x3D; moment.defineLocale(&#x27;zh-tw&#x27;, {
	    months : &#x27;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&#x27;.split(&#x27;_&#x27;),
	    monthsShort : &#x27;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&#x27;.split(&#x27;_&#x27;),
	    weekdays : &#x27;星期日_星期一_星期二_星期三_星期四_星期五_星期六&#x27;.split(&#x27;_&#x27;),
	    weekdaysShort : &#x27;週日_週一_週二_週三_週四_週五_週六&#x27;.split(&#x27;_&#x27;),
	    weekdaysMin : &#x27;日_一_二_三_四_五_六&#x27;.split(&#x27;_&#x27;),
	    longDateFormat : {
	        LT : &#x27;HH:mm&#x27;,
	        LTS : &#x27;HH:mm:ss&#x27;,
	        L : &#x27;YYYY/MM/DD&#x27;,
	        LL : &#x27;YYYY年M月D日&#x27;,
	        LLL : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        LLLL : &#x27;YYYY年M月D日dddd HH:mm&#x27;,
	        l : &#x27;YYYY/M/D&#x27;,
	        ll : &#x27;YYYY年M月D日&#x27;,
	        lll : &#x27;YYYY年M月D日 HH:mm&#x27;,
	        llll : &#x27;YYYY年M月D日dddd HH:mm&#x27;
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour &#x3D;&#x3D;&#x3D; 12) {
	            hour &#x3D; 0;
	        }
	        if (meridiem &#x3D;&#x3D;&#x3D; &#x27;凌晨&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;早上&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;上午&#x27;) {
	            return hour;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;中午&#x27;) {
	            return hour &gt;&#x3D; 11 ? hour : hour + 12;
	        } else if (meridiem &#x3D;&#x3D;&#x3D; &#x27;下午&#x27; || meridiem &#x3D;&#x3D;&#x3D; &#x27;晚上&#x27;) {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm &#x3D; hour * 100 + minute;
	        if (hm &lt; 600) {
	            return &#x27;凌晨&#x27;;
	        } else if (hm &lt; 900) {
	            return &#x27;早上&#x27;;
	        } else if (hm &lt; 1130) {
	            return &#x27;上午&#x27;;
	        } else if (hm &lt; 1230) {
	            return &#x27;中午&#x27;;
	        } else if (hm &lt; 1800) {
	            return &#x27;下午&#x27;;
	        } else {
	            return &#x27;晚上&#x27;;
	        }
	    },
	    calendar : {
	        sameDay : &#x27;[今天]LT&#x27;,
	        nextDay : &#x27;[明天]LT&#x27;,
	        nextWeek : &#x27;[下]ddddLT&#x27;,
	        lastDay : &#x27;[昨天]LT&#x27;,
	        lastWeek : &#x27;[上]ddddLT&#x27;,
	        sameElse : &#x27;L&#x27;
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case &#x27;d&#x27; :
	            case &#x27;D&#x27; :
	            case &#x27;DDD&#x27; :
	                return number + &#x27;日&#x27;;
	            case &#x27;M&#x27; :
	                return number + &#x27;月&#x27;;
	            case &#x27;w&#x27; :
	            case &#x27;W&#x27; :
	                return number + &#x27;週&#x27;;
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : &#x27;%s內&#x27;,
	        past : &#x27;%s前&#x27;,
	        s : &#x27;幾秒&#x27;,
	        ss : &#x27;%d 秒&#x27;,
	        m : &#x27;1 分鐘&#x27;,
	        mm : &#x27;%d 分鐘&#x27;,
	        h : &#x27;1 小時&#x27;,
	        hh : &#x27;%d 小時&#x27;,
	        d : &#x27;1 天&#x27;,
	        dd : &#x27;%d 天&#x27;,
	        M : &#x27;1 個月&#x27;,
	        MM : &#x27;%d 個月&#x27;,
	        y : &#x27;1 年&#x27;,
	        yy : &#x27;%d 年&#x27;
	    }
	});

	return zhTw;

	})));


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var elements &#x3D; __webpack_require__(48);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;bar&#x27;, {
		hover: {
			mode: &#x27;label&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;category&#x27;,

				// Specific to Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// offset settings
				offset: true,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}],

			yAxes: [{
				type: &#x27;linear&#x27;
			}]
		}
	});

	defaults._set(&#x27;horizontalBar&#x27;, {
		hover: {
			mode: &#x27;index&#x27;,
			axis: &#x27;y&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;linear&#x27;,
				position: &#x27;bottom&#x27;
			}],

			yAxes: [{
				position: &#x27;left&#x27;,
				type: &#x27;category&#x27;,

				// Specific to Horizontal Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// offset settings
				offset: true,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}]
		},

		elements: {
			rectangle: {
				borderSkipped: &#x27;left&#x27;
			}
		},

		tooltips: {
			callbacks: {
				title: function(item, data) {
					// Pick first xLabel for now
					var title &#x3D; &#x27;&#x27;;

					if (item.length &gt; 0) {
						if (item[0].yLabel) {
							title &#x3D; item[0].yLabel;
						} else if (data.labels.length &gt; 0 &amp;&amp; item[0].index &lt; data.labels.length) {
							title &#x3D; data.labels[item[0].index];
						}
					}

					return title;
				},

				label: function(item, data) {
					var datasetLabel &#x3D; data.datasets[item.datasetIndex].label || &#x27;&#x27;;
					return datasetLabel + &#x27;: &#x27; + item.xLabel;
				}
			},
			mode: &#x27;index&#x27;,
			axis: &#x27;y&#x27;
		}
	});

	/**
	 * Computes the &quot;optimal&quot; sample size to maintain bars equally sized while preventing overlap.
	 * @private
	 */
	function computeMinSampleSize(scale, pixels) {
		var min &#x3D; scale.isHorizontal() ? scale.width : scale.height;
		var ticks &#x3D; scale.getTicks();
		var prev, curr, i, ilen;

		for (i &#x3D; 1, ilen &#x3D; pixels.length; i &lt; ilen; ++i) {
			min &#x3D; Math.min(min, pixels[i] - pixels[i - 1]);
		}

		for (i &#x3D; 0, ilen &#x3D; ticks.length; i &lt; ilen; ++i) {
			curr &#x3D; scale.getPixelForTick(i);
			min &#x3D; i &gt; 0 ? Math.min(min, curr - prev) : min;
			prev &#x3D; curr;
		}

		return min;
	}

	/**
	 * Computes an &quot;ideal&quot; category based on the absolute bar thickness or, if undefined or null,
	 * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
	 * mode currently always generates bars equally sized (until we introduce scriptable options?).
	 * @private
	 */
	function computeFitCategoryTraits(index, ruler, options) {
		var thickness &#x3D; options.barThickness;
		var count &#x3D; ruler.stackCount;
		var curr &#x3D; ruler.pixels[index];
		var size, ratio;

		if (helpers.isNullOrUndef(thickness)) {
			size &#x3D; ruler.min * options.categoryPercentage;
			ratio &#x3D; options.barPercentage;
		} else {
			// When bar thickness is enforced, category and bar percentages are ignored.
			// Note(SB): we could add support for relative bar thickness (e.g. barThickness: &#x27;50%&#x27;)
			// and deprecate barPercentage since this value is ignored when thickness is absolute.
			size &#x3D; thickness * count;
			ratio &#x3D; 1;
		}

		return {
			chunk: size / count,
			ratio: ratio,
			start: curr - (size / 2)
		};
	}

	/**
	 * Computes an &quot;optimal&quot; category that globally arranges bars side by side (no gap when
	 * percentage options are 1), based on the previous and following categories. This mode
	 * generates bars with different widths when data are not evenly spaced.
	 * @private
	 */
	function computeFlexCategoryTraits(index, ruler, options) {
		var pixels &#x3D; ruler.pixels;
		var curr &#x3D; pixels[index];
		var prev &#x3D; index &gt; 0 ? pixels[index - 1] : null;
		var next &#x3D; index &lt; pixels.length - 1 ? pixels[index + 1] : null;
		var percent &#x3D; options.categoryPercentage;
		var start, size;

		if (prev &#x3D;&#x3D;&#x3D; null) {
			// first data: its size is double based on the next point or,
			// if it&#x27;s also the last data, we use the scale end extremity.
			prev &#x3D; curr - (next &#x3D;&#x3D;&#x3D; null ? ruler.end - curr : next - curr);
		}

		if (next &#x3D;&#x3D;&#x3D; null) {
			// last data: its size is also double based on the previous point.
			next &#x3D; curr + curr - prev;
		}

		start &#x3D; curr - ((curr - prev) / 2) * percent;
		size &#x3D; ((next - prev) / 2) * percent;

		return {
			chunk: size / ruler.stackCount,
			ratio: options.barPercentage,
			start: start
		};
	}

	module.exports &#x3D; function(Chart) {

		Chart.controllers.bar &#x3D; Chart.DatasetController.extend({

			dataElementType: elements.Rectangle,

			initialize: function() {
				var me &#x3D; this;
				var meta;

				Chart.DatasetController.prototype.initialize.apply(me, arguments);

				meta &#x3D; me.getMeta();
				meta.stack &#x3D; me.getDataset().stack;
				meta.bar &#x3D; true;
			},

			update: function(reset) {
				var me &#x3D; this;
				var rects &#x3D; me.getMeta().data;
				var i, ilen;

				me._ruler &#x3D; me.getRuler();

				for (i &#x3D; 0, ilen &#x3D; rects.length; i &lt; ilen; ++i) {
					me.updateElement(rects[i], i, reset);
				}
			},

			updateElement: function(rectangle, index, reset) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var meta &#x3D; me.getMeta();
				var dataset &#x3D; me.getDataset();
				var custom &#x3D; rectangle.custom || {};
				var rectangleOptions &#x3D; chart.options.elements.rectangle;

				rectangle._xScale &#x3D; me.getScaleForId(meta.xAxisID);
				rectangle._yScale &#x3D; me.getScaleForId(meta.yAxisID);
				rectangle._datasetIndex &#x3D; me.index;
				rectangle._index &#x3D; index;

				rectangle._model &#x3D; {
					datasetLabel: dataset.label,
					label: chart.data.labels[index],
					borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
				};

				me.updateElementGeometry(rectangle, index, reset);

				rectangle.pivot();
			},

			/**
			 * @private
			 */
			updateElementGeometry: function(rectangle, index, reset) {
				var me &#x3D; this;
				var model &#x3D; rectangle._model;
				var vscale &#x3D; me.getValueScale();
				var base &#x3D; vscale.getBasePixel();
				var horizontal &#x3D; vscale.isHorizontal();
				var ruler &#x3D; me._ruler || me.getRuler();
				var vpixels &#x3D; me.calculateBarValuePixels(me.index, index);
				var ipixels &#x3D; me.calculateBarIndexPixels(me.index, index, ruler);

				model.horizontal &#x3D; horizontal;
				model.base &#x3D; reset ? base : vpixels.base;
				model.x &#x3D; horizontal ? reset ? base : vpixels.head : ipixels.center;
				model.y &#x3D; horizontal ? ipixels.center : reset ? base : vpixels.head;
				model.height &#x3D; horizontal ? ipixels.size : undefined;
				model.width &#x3D; horizontal ? undefined : ipixels.size;
			},

			/**
			 * @private
			 */
			getValueScaleId: function() {
				return this.getMeta().yAxisID;
			},

			/**
			 * @private
			 */
			getIndexScaleId: function() {
				return this.getMeta().xAxisID;
			},

			/**
			 * @private
			 */
			getValueScale: function() {
				return this.getScaleForId(this.getValueScaleId());
			},

			/**
			 * @private
			 */
			getIndexScale: function() {
				return this.getScaleForId(this.getIndexScaleId());
			},

			/**
			 * Returns the stacks based on groups and bar visibility.
			 * @param {Number} [last] - The dataset index
			 * @returns {Array} The stack list
			 * @private
			 */
			_getStacks: function(last) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var scale &#x3D; me.getIndexScale();
				var stacked &#x3D; scale.options.stacked;
				var ilen &#x3D; last &#x3D;&#x3D;&#x3D; undefined ? chart.data.datasets.length : last + 1;
				var stacks &#x3D; [];
				var i, meta;

				for (i &#x3D; 0; i &lt; ilen; ++i) {
					meta &#x3D; chart.getDatasetMeta(i);
					if (meta.bar &amp;&amp; chart.isDatasetVisible(i) &amp;&amp;
						(stacked &#x3D;&#x3D;&#x3D; false ||
						(stacked &#x3D;&#x3D;&#x3D; true &amp;&amp; stacks.indexOf(meta.stack) &#x3D;&#x3D;&#x3D; -1) ||
						(stacked &#x3D;&#x3D;&#x3D; undefined &amp;&amp; (meta.stack &#x3D;&#x3D;&#x3D; undefined || stacks.indexOf(meta.stack) &#x3D;&#x3D;&#x3D; -1)))) {
						stacks.push(meta.stack);
					}
				}

				return stacks;
			},

			/**
			 * Returns the effective number of stacks based on groups and bar visibility.
			 * @private
			 */
			getStackCount: function() {
				return this._getStacks().length;
			},

			/**
			 * Returns the stack index for the given dataset based on groups and bar visibility.
			 * @param {Number} [datasetIndex] - The dataset index
			 * @param {String} [name] - The stack name to find
			 * @returns {Number} The stack index
			 * @private
			 */
			getStackIndex: function(datasetIndex, name) {
				var stacks &#x3D; this._getStacks(datasetIndex);
				var index &#x3D; (name !&#x3D;&#x3D; undefined)
					? stacks.indexOf(name)
					: -1; // indexOf returns -1 if element is not present

				return (index &#x3D;&#x3D;&#x3D; -1)
					? stacks.length - 1
					: index;
			},

			/**
			 * @private
			 */
			getRuler: function() {
				var me &#x3D; this;
				var scale &#x3D; me.getIndexScale();
				var stackCount &#x3D; me.getStackCount();
				var datasetIndex &#x3D; me.index;
				var isHorizontal &#x3D; scale.isHorizontal();
				var start &#x3D; isHorizontal ? scale.left : scale.top;
				var end &#x3D; start + (isHorizontal ? scale.width : scale.height);
				var pixels &#x3D; [];
				var i, ilen, min;

				for (i &#x3D; 0, ilen &#x3D; me.getMeta().data.length; i &lt; ilen; ++i) {
					pixels.push(scale.getPixelForValue(null, i, datasetIndex));
				}

				min &#x3D; helpers.isNullOrUndef(scale.options.barThickness)
					? computeMinSampleSize(scale, pixels)
					: -1;

				return {
					min: min,
					pixels: pixels,
					start: start,
					end: end,
					stackCount: stackCount,
					scale: scale
				};
			},

			/**
			 * Note: pixel values are not clamped to the scale area.
			 * @private
			 */
			calculateBarValuePixels: function(datasetIndex, index) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var meta &#x3D; me.getMeta();
				var scale &#x3D; me.getValueScale();
				var datasets &#x3D; chart.data.datasets;
				var value &#x3D; scale.getRightValue(datasets[datasetIndex].data[index]);
				var stacked &#x3D; scale.options.stacked;
				var stack &#x3D; meta.stack;
				var start &#x3D; 0;
				var i, imeta, ivalue, base, head, size;

				if (stacked || (stacked &#x3D;&#x3D;&#x3D; undefined &amp;&amp; stack !&#x3D;&#x3D; undefined)) {
					for (i &#x3D; 0; i &lt; datasetIndex; ++i) {
						imeta &#x3D; chart.getDatasetMeta(i);

						if (imeta.bar &amp;&amp;
							imeta.stack &#x3D;&#x3D;&#x3D; stack &amp;&amp;
							imeta.controller.getValueScaleId() &#x3D;&#x3D;&#x3D; scale.id &amp;&amp;
							chart.isDatasetVisible(i)) {

							ivalue &#x3D; scale.getRightValue(datasets[i].data[index]);
							if ((value &lt; 0 &amp;&amp; ivalue &lt; 0) || (value &gt;&#x3D; 0 &amp;&amp; ivalue &gt; 0)) {
								start +&#x3D; ivalue;
							}
						}
					}
				}

				base &#x3D; scale.getPixelForValue(start);
				head &#x3D; scale.getPixelForValue(start + value);
				size &#x3D; (head - base) / 2;

				return {
					size: size,
					base: base,
					head: head,
					center: head + size / 2
				};
			},

			/**
			 * @private
			 */
			calculateBarIndexPixels: function(datasetIndex, index, ruler) {
				var me &#x3D; this;
				var options &#x3D; ruler.scale.options;
				var range &#x3D; options.barThickness &#x3D;&#x3D;&#x3D; &#x27;flex&#x27;
					? computeFlexCategoryTraits(index, ruler, options)
					: computeFitCategoryTraits(index, ruler, options);

				var stackIndex &#x3D; me.getStackIndex(datasetIndex, me.getMeta().stack);
				var center &#x3D; range.start + (range.chunk * stackIndex) + (range.chunk / 2);
				var size &#x3D; Math.min(
					helpers.valueOrDefault(options.maxBarThickness, Infinity),
					range.chunk * range.ratio);

				return {
					base: center - size / 2,
					head: center + size / 2,
					center: center,
					size: size
				};
			},

			draw: function() {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var scale &#x3D; me.getValueScale();
				var rects &#x3D; me.getMeta().data;
				var dataset &#x3D; me.getDataset();
				var ilen &#x3D; rects.length;
				var i &#x3D; 0;

				helpers.canvas.clipArea(chart.ctx, chart.chartArea);

				for (; i &lt; ilen; ++i) {
					if (!isNaN(scale.getRightValue(dataset.data[i]))) {
						rects[i].draw();
					}
				}

				helpers.canvas.unclipArea(chart.ctx);
			},

			setHoverStyle: function(rectangle) {
				var dataset &#x3D; this.chart.data.datasets[rectangle._datasetIndex];
				var index &#x3D; rectangle._index;
				var custom &#x3D; rectangle.custom || {};
				var model &#x3D; rectangle._model;

				model.backgroundColor &#x3D; custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor &#x3D; custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth &#x3D; custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(rectangle) {
				var dataset &#x3D; this.chart.data.datasets[rectangle._datasetIndex];
				var index &#x3D; rectangle._index;
				var custom &#x3D; rectangle.custom || {};
				var model &#x3D; rectangle._model;
				var rectangleElementOptions &#x3D; this.chart.options.elements.rectangle;

				model.backgroundColor &#x3D; custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
				model.borderColor &#x3D; custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
				model.borderWidth &#x3D; custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
			}
		});

		Chart.controllers.horizontalBar &#x3D; Chart.controllers.bar.extend({
			/**
			 * @private
			 */
			getValueScaleId: function() {
				return this.getMeta().xAxisID;
			},

			/**
			 * @private
			 */
			getIndexScaleId: function() {
				return this.getMeta().yAxisID;
			}
		});
	};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var elements &#x3D; __webpack_require__(48);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;bubble&#x27;, {
		hover: {
			mode: &#x27;single&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;linear&#x27;, // bubble should probably use a linear scale by default
				position: &#x27;bottom&#x27;,
				id: &#x27;x-axis-0&#x27; // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: &#x27;linear&#x27;,
				position: &#x27;left&#x27;,
				id: &#x27;y-axis-0&#x27;
			}]
		},

		tooltips: {
			callbacks: {
				title: function() {
					// Title doesn&#x27;t make sense for scatter since we format the data as a point
					return &#x27;&#x27;;
				},
				label: function(item, data) {
					var datasetLabel &#x3D; data.datasets[item.datasetIndex].label || &#x27;&#x27;;
					var dataPoint &#x3D; data.datasets[item.datasetIndex].data[item.index];
					return datasetLabel + &#x27;: (&#x27; + item.xLabel + &#x27;, &#x27; + item.yLabel + &#x27;, &#x27; + dataPoint.r + &#x27;)&#x27;;
				}
			}
		}
	});


	module.exports &#x3D; function(Chart) {

		Chart.controllers.bubble &#x3D; Chart.DatasetController.extend({
			/**
			 * @protected
			 */
			dataElementType: elements.Point,

			/**
			 * @protected
			 */
			update: function(reset) {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var points &#x3D; meta.data;

				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				});
			},

			/**
			 * @protected
			 */
			updateElement: function(point, index, reset) {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var custom &#x3D; point.custom || {};
				var xScale &#x3D; me.getScaleForId(meta.xAxisID);
				var yScale &#x3D; me.getScaleForId(meta.yAxisID);
				var options &#x3D; me._resolveElementOptions(point, index);
				var data &#x3D; me.getDataset().data[index];
				var dsIndex &#x3D; me.index;

				var x &#x3D; reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? data : NaN, index, dsIndex);
				var y &#x3D; reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

				point._xScale &#x3D; xScale;
				point._yScale &#x3D; yScale;
				point._options &#x3D; options;
				point._datasetIndex &#x3D; dsIndex;
				point._index &#x3D; index;
				point._model &#x3D; {
					backgroundColor: options.backgroundColor,
					borderColor: options.borderColor,
					borderWidth: options.borderWidth,
					hitRadius: options.hitRadius,
					pointStyle: options.pointStyle,
					radius: reset ? 0 : options.radius,
					skip: custom.skip || isNaN(x) || isNaN(y),
					x: x,
					y: y,
				};

				point.pivot();
			},

			/**
			 * @protected
			 */
			setHoverStyle: function(point) {
				var model &#x3D; point._model;
				var options &#x3D; point._options;

				model.backgroundColor &#x3D; helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
				model.borderColor &#x3D; helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
				model.borderWidth &#x3D; helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
				model.radius &#x3D; options.radius + options.hoverRadius;
			},

			/**
			 * @protected
			 */
			removeHoverStyle: function(point) {
				var model &#x3D; point._model;
				var options &#x3D; point._options;

				model.backgroundColor &#x3D; options.backgroundColor;
				model.borderColor &#x3D; options.borderColor;
				model.borderWidth &#x3D; options.borderWidth;
				model.radius &#x3D; options.radius;
			},

			/**
			 * @private
			 */
			_resolveElementOptions: function(point, index) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var datasets &#x3D; chart.data.datasets;
				var dataset &#x3D; datasets[me.index];
				var custom &#x3D; point.custom || {};
				var options &#x3D; chart.options.elements.point;
				var resolve &#x3D; helpers.options.resolve;
				var data &#x3D; dataset.data[index];
				var values &#x3D; {};
				var i, ilen, key;

				// Scriptable options
				var context &#x3D; {
					chart: chart,
					dataIndex: index,
					dataset: dataset,
					datasetIndex: me.index
				};

				var keys &#x3D; [
					&#x27;backgroundColor&#x27;,
					&#x27;borderColor&#x27;,
					&#x27;borderWidth&#x27;,
					&#x27;hoverBackgroundColor&#x27;,
					&#x27;hoverBorderColor&#x27;,
					&#x27;hoverBorderWidth&#x27;,
					&#x27;hoverRadius&#x27;,
					&#x27;hitRadius&#x27;,
					&#x27;pointStyle&#x27;
				];

				for (i &#x3D; 0, ilen &#x3D; keys.length; i &lt; ilen; ++i) {
					key &#x3D; keys[i];
					values[key] &#x3D; resolve([
						custom[key],
						dataset[key],
						options[key]
					], context, index);
				}

				// Custom radius resolution
				values.radius &#x3D; resolve([
					custom.radius,
					data ? data.r : undefined,
					dataset.radius,
					options.radius
				], context, index);

				return values;
			}
		});
	};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var elements &#x3D; __webpack_require__(48);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;doughnut&#x27;, {
		animation: {
			// Boolean - Whether we animate the rotation of the Doughnut
			animateRotate: true,
			// Boolean - Whether we animate scaling the Doughnut from the centre
			animateScale: false
		},
		hover: {
			mode: &#x27;single&#x27;
		},
		legendCallback: function(chart) {
			var text &#x3D; [];
			text.push(&#x27;&lt;ul class&#x3D;&quot;&#x27; + chart.id + &#x27;-legend&quot;&gt;&#x27;);

			var data &#x3D; chart.data;
			var datasets &#x3D; data.datasets;
			var labels &#x3D; data.labels;

			if (datasets.length) {
				for (var i &#x3D; 0; i &lt; datasets[0].data.length; ++i) {
					text.push(&#x27;&lt;li&gt;&lt;span style&#x3D;&quot;background-color:&#x27; + datasets[0].backgroundColor[i] + &#x27;&quot;&gt;&lt;/span&gt;&#x27;);
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push(&#x27;&lt;/li&gt;&#x27;);
				}
			}

			text.push(&#x27;&lt;/ul&gt;&#x27;);
			return text.join(&#x27;&#x27;);
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data &#x3D; chart.data;
					if (data.labels.length &amp;&amp; data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta &#x3D; chart.getDatasetMeta(0);
							var ds &#x3D; data.datasets[0];
							var arc &#x3D; meta.data[i];
							var custom &#x3D; arc &amp;&amp; arc.custom || {};
							var valueAtIndexOrDefault &#x3D; helpers.valueAtIndexOrDefault;
							var arcOpts &#x3D; chart.options.elements.arc;
							var fill &#x3D; custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke &#x3D; custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw &#x3D; custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index &#x3D; legendItem.index;
				var chart &#x3D; this.chart;
				var i, ilen, meta;

				for (i &#x3D; 0, ilen &#x3D; (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					meta &#x3D; chart.getDatasetMeta(i);
					// toggle visibility of index if exists
					if (meta.data[index]) {
						meta.data[index].hidden &#x3D; !meta.data[index].hidden;
					}
				}

				chart.update();
			}
		},

		// The percentage of the chart that we cut out of the middle.
		cutoutPercentage: 50,

		// The rotation of the chart, where the first data arc begins.
		rotation: Math.PI * -0.5,

		// The total circumference of the chart.
		circumference: Math.PI * 2.0,

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return &#x27;&#x27;;
				},
				label: function(tooltipItem, data) {
					var dataLabel &#x3D; data.labels[tooltipItem.index];
					var value &#x3D; &#x27;: &#x27; + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

					if (helpers.isArray(dataLabel)) {
						// show value on first line of multiline label
						// need to clone because we are changing the value
						dataLabel &#x3D; dataLabel.slice();
						dataLabel[0] +&#x3D; value;
					} else {
						dataLabel +&#x3D; value;
					}

					return dataLabel;
				}
			}
		}
	});

	defaults._set(&#x27;pie&#x27;, helpers.clone(defaults.doughnut));
	defaults._set(&#x27;pie&#x27;, {
		cutoutPercentage: 0
	});

	module.exports &#x3D; function(Chart) {

		Chart.controllers.doughnut &#x3D; Chart.controllers.pie &#x3D; Chart.DatasetController.extend({

			dataElementType: elements.Arc,

			linkScales: helpers.noop,

			// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
			getRingIndex: function(datasetIndex) {
				var ringIndex &#x3D; 0;

				for (var j &#x3D; 0; j &lt; datasetIndex; ++j) {
					if (this.chart.isDatasetVisible(j)) {
						++ringIndex;
					}
				}

				return ringIndex;
			},

			update: function(reset) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var chartArea &#x3D; chart.chartArea;
				var opts &#x3D; chart.options;
				var arcOpts &#x3D; opts.elements.arc;
				var availableWidth &#x3D; chartArea.right - chartArea.left - arcOpts.borderWidth;
				var availableHeight &#x3D; chartArea.bottom - chartArea.top - arcOpts.borderWidth;
				var minSize &#x3D; Math.min(availableWidth, availableHeight);
				var offset &#x3D; {x: 0, y: 0};
				var meta &#x3D; me.getMeta();
				var cutoutPercentage &#x3D; opts.cutoutPercentage;
				var circumference &#x3D; opts.circumference;

				// If the chart&#x27;s circumference isn&#x27;t a full circle, calculate minSize as a ratio of the width/height of the arc
				if (circumference &lt; Math.PI * 2.0) {
					var startAngle &#x3D; opts.rotation % (Math.PI * 2.0);
					startAngle +&#x3D; Math.PI * 2.0 * (startAngle &gt;&#x3D; Math.PI ? -1 : startAngle &lt; -Math.PI ? 1 : 0);
					var endAngle &#x3D; startAngle + circumference;
					var start &#x3D; {x: Math.cos(startAngle), y: Math.sin(startAngle)};
					var end &#x3D; {x: Math.cos(endAngle), y: Math.sin(endAngle)};
					var contains0 &#x3D; (startAngle &lt;&#x3D; 0 &amp;&amp; endAngle &gt;&#x3D; 0) || (startAngle &lt;&#x3D; Math.PI * 2.0 &amp;&amp; Math.PI * 2.0 &lt;&#x3D; endAngle);
					var contains90 &#x3D; (startAngle &lt;&#x3D; Math.PI * 0.5 &amp;&amp; Math.PI * 0.5 &lt;&#x3D; endAngle) || (startAngle &lt;&#x3D; Math.PI * 2.5 &amp;&amp; Math.PI * 2.5 &lt;&#x3D; endAngle);
					var contains180 &#x3D; (startAngle &lt;&#x3D; -Math.PI &amp;&amp; -Math.PI &lt;&#x3D; endAngle) || (startAngle &lt;&#x3D; Math.PI &amp;&amp; Math.PI &lt;&#x3D; endAngle);
					var contains270 &#x3D; (startAngle &lt;&#x3D; -Math.PI * 0.5 &amp;&amp; -Math.PI * 0.5 &lt;&#x3D; endAngle) || (startAngle &lt;&#x3D; Math.PI * 1.5 &amp;&amp; Math.PI * 1.5 &lt;&#x3D; endAngle);
					var cutout &#x3D; cutoutPercentage / 100.0;
					var min &#x3D; {x: contains180 ? -1 : Math.min(start.x * (start.x &lt; 0 ? 1 : cutout), end.x * (end.x &lt; 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y &lt; 0 ? 1 : cutout), end.y * (end.y &lt; 0 ? 1 : cutout))};
					var max &#x3D; {x: contains0 ? 1 : Math.max(start.x * (start.x &gt; 0 ? 1 : cutout), end.x * (end.x &gt; 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y &gt; 0 ? 1 : cutout), end.y * (end.y &gt; 0 ? 1 : cutout))};
					var size &#x3D; {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
					minSize &#x3D; Math.min(availableWidth / size.width, availableHeight / size.height);
					offset &#x3D; {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
				}

				chart.borderWidth &#x3D; me.getMaxBorderWidth(meta.data);
				chart.outerRadius &#x3D; Math.max((minSize - chart.borderWidth) / 2, 0);
				chart.innerRadius &#x3D; Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
				chart.radiusLength &#x3D; (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
				chart.offsetX &#x3D; offset.x * chart.outerRadius;
				chart.offsetY &#x3D; offset.y * chart.outerRadius;

				meta.total &#x3D; me.calculateTotal();

				me.outerRadius &#x3D; chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
				me.innerRadius &#x3D; Math.max(me.outerRadius - chart.radiusLength, 0);

				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},

			updateElement: function(arc, index, reset) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var chartArea &#x3D; chart.chartArea;
				var opts &#x3D; chart.options;
				var animationOpts &#x3D; opts.animation;
				var centerX &#x3D; (chartArea.left + chartArea.right) / 2;
				var centerY &#x3D; (chartArea.top + chartArea.bottom) / 2;
				var startAngle &#x3D; opts.rotation; // non reset case handled later
				var endAngle &#x3D; opts.rotation; // non reset case handled later
				var dataset &#x3D; me.getDataset();
				var circumference &#x3D; reset &amp;&amp; animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
				var innerRadius &#x3D; reset &amp;&amp; animationOpts.animateScale ? 0 : me.innerRadius;
				var outerRadius &#x3D; reset &amp;&amp; animationOpts.animateScale ? 0 : me.outerRadius;
				var valueAtIndexOrDefault &#x3D; helpers.valueAtIndexOrDefault;

				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,

					// Desired view properties
					_model: {
						x: centerX + chart.offsetX,
						y: centerY + chart.offsetY,
						startAngle: startAngle,
						endAngle: endAngle,
						circumference: circumference,
						outerRadius: outerRadius,
						innerRadius: innerRadius,
						label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
					}
				});

				var model &#x3D; arc._model;
				// Resets the visual styles
				this.removeHoverStyle(arc);

				// Set correct angles if not resetting
				if (!reset || !animationOpts.animateRotate) {
					if (index &#x3D;&#x3D;&#x3D; 0) {
						model.startAngle &#x3D; opts.rotation;
					} else {
						model.startAngle &#x3D; me.getMeta().data[index - 1]._model.endAngle;
					}

					model.endAngle &#x3D; model.startAngle + model.circumference;
				}

				arc.pivot();
			},

			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},

			calculateTotal: function() {
				var dataset &#x3D; this.getDataset();
				var meta &#x3D; this.getMeta();
				var total &#x3D; 0;
				var value;

				helpers.each(meta.data, function(element, index) {
					value &#x3D; dataset.data[index];
					if (!isNaN(value) &amp;&amp; !element.hidden) {
						total +&#x3D; Math.abs(value);
					}
				});

				/* if (total &#x3D;&#x3D;&#x3D; 0) {
					total &#x3D; NaN;
				}*/

				return total;
			},

			calculateCircumference: function(value) {
				var total &#x3D; this.getMeta().total;
				if (total &gt; 0 &amp;&amp; !isNaN(value)) {
					return (Math.PI * 2.0) * (Math.abs(value) / total);
				}
				return 0;
			},

			// gets the max border or hover width to properly scale pie charts
			getMaxBorderWidth: function(arcs) {
				var max &#x3D; 0;
				var index &#x3D; this.index;
				var length &#x3D; arcs.length;
				var borderWidth;
				var hoverWidth;

				for (var i &#x3D; 0; i &lt; length; i++) {
					borderWidth &#x3D; arcs[i]._model ? arcs[i]._model.borderWidth : 0;
					hoverWidth &#x3D; arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

					max &#x3D; borderWidth &gt; max ? borderWidth : max;
					max &#x3D; hoverWidth &gt; max ? hoverWidth : max;
				}
				return max;
			}
		});
	};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var elements &#x3D; __webpack_require__(48);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;line&#x27;, {
		showLines: true,
		spanGaps: false,

		hover: {
			mode: &#x27;label&#x27;
		},

		scales: {
			xAxes: [{
				type: &#x27;category&#x27;,
				id: &#x27;x-axis-0&#x27;
			}],
			yAxes: [{
				type: &#x27;linear&#x27;,
				id: &#x27;y-axis-0&#x27;
			}]
		}
	});

	module.exports &#x3D; function(Chart) {

		function lineEnabled(dataset, options) {
			return helpers.valueOrDefault(dataset.showLine, options.showLines);
		}

		Chart.controllers.line &#x3D; Chart.DatasetController.extend({

			datasetElementType: elements.Line,

			dataElementType: elements.Point,

			update: function(reset) {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var line &#x3D; meta.dataset;
				var points &#x3D; meta.data || [];
				var options &#x3D; me.chart.options;
				var lineElementOptions &#x3D; options.elements.line;
				var scale &#x3D; me.getScaleForId(meta.yAxisID);
				var i, ilen, custom;
				var dataset &#x3D; me.getDataset();
				var showLine &#x3D; lineEnabled(dataset, options);

				// Update Line
				if (showLine) {
					custom &#x3D; line.custom || {};

					// Compatibility: If the properties are defined with only the old name, use those values
					if ((dataset.tension !&#x3D;&#x3D; undefined) &amp;&amp; (dataset.lineTension &#x3D;&#x3D;&#x3D; undefined)) {
						dataset.lineTension &#x3D; dataset.tension;
					}

					// Utility
					line._scale &#x3D; scale;
					line._datasetIndex &#x3D; me.index;
					// Data
					line._children &#x3D; points;
					// Model
					line._model &#x3D; {
						// Appearance
						// The default behavior of lines is to break at null values, according
						// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
						// This option gives lines the ability to span gaps
						spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
						fill: custom.fill ? custom.fill : (dataset.fill !&#x3D;&#x3D; undefined ? dataset.fill : lineElementOptions.fill),
						steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
						cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
					};

					line.pivot();
				}

				// Update Points
				for (i &#x3D; 0, ilen &#x3D; points.length; i &lt; ilen; ++i) {
					me.updateElement(points[i], i, reset);
				}

				if (showLine &amp;&amp; line._model.tension !&#x3D;&#x3D; 0) {
					me.updateBezierControlPoints();
				}

				// Now pivot the point for animation
				for (i &#x3D; 0, ilen &#x3D; points.length; i &lt; ilen; ++i) {
					points[i].pivot();
				}
			},

			getPointBackgroundColor: function(point, index) {
				var backgroundColor &#x3D; this.chart.options.elements.point.backgroundColor;
				var dataset &#x3D; this.getDataset();
				var custom &#x3D; point.custom || {};

				if (custom.backgroundColor) {
					backgroundColor &#x3D; custom.backgroundColor;
				} else if (dataset.pointBackgroundColor) {
					backgroundColor &#x3D; helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
				} else if (dataset.backgroundColor) {
					backgroundColor &#x3D; dataset.backgroundColor;
				}

				return backgroundColor;
			},

			getPointBorderColor: function(point, index) {
				var borderColor &#x3D; this.chart.options.elements.point.borderColor;
				var dataset &#x3D; this.getDataset();
				var custom &#x3D; point.custom || {};

				if (custom.borderColor) {
					borderColor &#x3D; custom.borderColor;
				} else if (dataset.pointBorderColor) {
					borderColor &#x3D; helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
				} else if (dataset.borderColor) {
					borderColor &#x3D; dataset.borderColor;
				}

				return borderColor;
			},

			getPointBorderWidth: function(point, index) {
				var borderWidth &#x3D; this.chart.options.elements.point.borderWidth;
				var dataset &#x3D; this.getDataset();
				var custom &#x3D; point.custom || {};

				if (!isNaN(custom.borderWidth)) {
					borderWidth &#x3D; custom.borderWidth;
				} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
					borderWidth &#x3D; helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
				} else if (!isNaN(dataset.borderWidth)) {
					borderWidth &#x3D; dataset.borderWidth;
				}

				return borderWidth;
			},

			updateElement: function(point, index, reset) {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var custom &#x3D; point.custom || {};
				var dataset &#x3D; me.getDataset();
				var datasetIndex &#x3D; me.index;
				var value &#x3D; dataset.data[index];
				var yScale &#x3D; me.getScaleForId(meta.yAxisID);
				var xScale &#x3D; me.getScaleForId(meta.xAxisID);
				var pointOptions &#x3D; me.chart.options.elements.point;
				var x, y;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !&#x3D;&#x3D; undefined) &amp;&amp; (dataset.pointRadius &#x3D;&#x3D;&#x3D; undefined)) {
					dataset.pointRadius &#x3D; dataset.radius;
				}
				if ((dataset.hitRadius !&#x3D;&#x3D; undefined) &amp;&amp; (dataset.pointHitRadius &#x3D;&#x3D;&#x3D; undefined)) {
					dataset.pointHitRadius &#x3D; dataset.hitRadius;
				}

				x &#x3D; xScale.getPixelForValue(typeof value &#x3D;&#x3D;&#x3D; &#x27;object&#x27; ? value : NaN, index, datasetIndex);
				y &#x3D; reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

				// Utility
				point._xScale &#x3D; xScale;
				point._yScale &#x3D; yScale;
				point._datasetIndex &#x3D; datasetIndex;
				point._index &#x3D; index;

				// Desired view properties
				point._model &#x3D; {
					x: x,
					y: y,
					skip: custom.skip || isNaN(x) || isNaN(y),
					// Appearance
					radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
					pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
					backgroundColor: me.getPointBackgroundColor(point, index),
					borderColor: me.getPointBorderColor(point, index),
					borderWidth: me.getPointBorderWidth(point, index),
					tension: meta.dataset._model ? meta.dataset._model.tension : 0,
					steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
					// Tooltip
					hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
				};
			},

			calculatePointY: function(value, index, datasetIndex) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var meta &#x3D; me.getMeta();
				var yScale &#x3D; me.getScaleForId(meta.yAxisID);
				var sumPos &#x3D; 0;
				var sumNeg &#x3D; 0;
				var i, ds, dsMeta;

				if (yScale.options.stacked) {
					for (i &#x3D; 0; i &lt; datasetIndex; i++) {
						ds &#x3D; chart.data.datasets[i];
						dsMeta &#x3D; chart.getDatasetMeta(i);
						if (dsMeta.type &#x3D;&#x3D;&#x3D; &#x27;line&#x27; &amp;&amp; dsMeta.yAxisID &#x3D;&#x3D;&#x3D; yScale.id &amp;&amp; chart.isDatasetVisible(i)) {
							var stackedRightValue &#x3D; Number(yScale.getRightValue(ds.data[index]));
							if (stackedRightValue &lt; 0) {
								sumNeg +&#x3D; stackedRightValue || 0;
							} else {
								sumPos +&#x3D; stackedRightValue || 0;
							}
						}
					}

					var rightValue &#x3D; Number(yScale.getRightValue(value));
					if (rightValue &lt; 0) {
						return yScale.getPixelForValue(sumNeg + rightValue);
					}
					return yScale.getPixelForValue(sumPos + rightValue);
				}

				return yScale.getPixelForValue(value);
			},

			updateBezierControlPoints: function() {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var area &#x3D; me.chart.chartArea;
				var points &#x3D; (meta.data || []);
				var i, ilen, point, model, controlPoints;

				// Only consider points that are drawn in case the spanGaps option is used
				if (meta.dataset._model.spanGaps) {
					points &#x3D; points.filter(function(pt) {
						return !pt._model.skip;
					});
				}

				function capControlPoint(pt, min, max) {
					return Math.max(Math.min(pt, max), min);
				}

				if (meta.dataset._model.cubicInterpolationMode &#x3D;&#x3D;&#x3D; &#x27;monotone&#x27;) {
					helpers.splineCurveMonotone(points);
				} else {
					for (i &#x3D; 0, ilen &#x3D; points.length; i &lt; ilen; ++i) {
						point &#x3D; points[i];
						model &#x3D; point._model;
						controlPoints &#x3D; helpers.splineCurve(
							helpers.previousItem(points, i)._model,
							model,
							helpers.nextItem(points, i)._model,
							meta.dataset._model.tension
						);
						model.controlPointPreviousX &#x3D; controlPoints.previous.x;
						model.controlPointPreviousY &#x3D; controlPoints.previous.y;
						model.controlPointNextX &#x3D; controlPoints.next.x;
						model.controlPointNextY &#x3D; controlPoints.next.y;
					}
				}

				if (me.chart.options.elements.line.capBezierPoints) {
					for (i &#x3D; 0, ilen &#x3D; points.length; i &lt; ilen; ++i) {
						model &#x3D; points[i]._model;
						model.controlPointPreviousX &#x3D; capControlPoint(model.controlPointPreviousX, area.left, area.right);
						model.controlPointPreviousY &#x3D; capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
						model.controlPointNextX &#x3D; capControlPoint(model.controlPointNextX, area.left, area.right);
						model.controlPointNextY &#x3D; capControlPoint(model.controlPointNextY, area.top, area.bottom);
					}
				}
			},

			draw: function() {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var meta &#x3D; me.getMeta();
				var points &#x3D; meta.data || [];
				var area &#x3D; chart.chartArea;
				var ilen &#x3D; points.length;
				var i &#x3D; 0;

				helpers.canvas.clipArea(chart.ctx, area);

				if (lineEnabled(me.getDataset(), chart.options)) {
					meta.dataset.draw();
				}

				helpers.canvas.unclipArea(chart.ctx);

				// Draw the points
				for (; i &lt; ilen; ++i) {
					points[i].draw(area);
				}
			},

			setHoverStyle: function(point) {
				// Point
				var dataset &#x3D; this.chart.data.datasets[point._datasetIndex];
				var index &#x3D; point._index;
				var custom &#x3D; point.custom || {};
				var model &#x3D; point._model;

				model.radius &#x3D; custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor &#x3D; custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor &#x3D; custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth &#x3D; custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(point) {
				var me &#x3D; this;
				var dataset &#x3D; me.chart.data.datasets[point._datasetIndex];
				var index &#x3D; point._index;
				var custom &#x3D; point.custom || {};
				var model &#x3D; point._model;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !&#x3D;&#x3D; undefined) &amp;&amp; (dataset.pointRadius &#x3D;&#x3D;&#x3D; undefined)) {
					dataset.pointRadius &#x3D; dataset.radius;
				}

				model.radius &#x3D; custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
				model.backgroundColor &#x3D; me.getPointBackgroundColor(point, index);
				model.borderColor &#x3D; me.getPointBorderColor(point, index);
				model.borderWidth &#x3D; me.getPointBorderWidth(point, index);
			}
		});
	};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var elements &#x3D; __webpack_require__(48);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;polarArea&#x27;, {
		scale: {
			type: &#x27;radialLinear&#x27;,
			angleLines: {
				display: false
			},
			gridLines: {
				circular: true
			},
			pointLabels: {
				display: false
			},
			ticks: {
				beginAtZero: true
			}
		},

		// Boolean - Whether to animate the rotation of the chart
		animation: {
			animateRotate: true,
			animateScale: true
		},

		startAngle: -0.5 * Math.PI,
		legendCallback: function(chart) {
			var text &#x3D; [];
			text.push(&#x27;&lt;ul class&#x3D;&quot;&#x27; + chart.id + &#x27;-legend&quot;&gt;&#x27;);

			var data &#x3D; chart.data;
			var datasets &#x3D; data.datasets;
			var labels &#x3D; data.labels;

			if (datasets.length) {
				for (var i &#x3D; 0; i &lt; datasets[0].data.length; ++i) {
					text.push(&#x27;&lt;li&gt;&lt;span style&#x3D;&quot;background-color:&#x27; + datasets[0].backgroundColor[i] + &#x27;&quot;&gt;&lt;/span&gt;&#x27;);
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push(&#x27;&lt;/li&gt;&#x27;);
				}
			}

			text.push(&#x27;&lt;/ul&gt;&#x27;);
			return text.join(&#x27;&#x27;);
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data &#x3D; chart.data;
					if (data.labels.length &amp;&amp; data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta &#x3D; chart.getDatasetMeta(0);
							var ds &#x3D; data.datasets[0];
							var arc &#x3D; meta.data[i];
							var custom &#x3D; arc.custom || {};
							var valueAtIndexOrDefault &#x3D; helpers.valueAtIndexOrDefault;
							var arcOpts &#x3D; chart.options.elements.arc;
							var fill &#x3D; custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke &#x3D; custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw &#x3D; custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index &#x3D; legendItem.index;
				var chart &#x3D; this.chart;
				var i, ilen, meta;

				for (i &#x3D; 0, ilen &#x3D; (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					meta &#x3D; chart.getDatasetMeta(i);
					meta.data[index].hidden &#x3D; !meta.data[index].hidden;
				}

				chart.update();
			}
		},

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return &#x27;&#x27;;
				},
				label: function(item, data) {
					return data.labels[item.index] + &#x27;: &#x27; + item.yLabel;
				}
			}
		}
	});

	module.exports &#x3D; function(Chart) {

		Chart.controllers.polarArea &#x3D; Chart.DatasetController.extend({

			dataElementType: elements.Arc,

			linkScales: helpers.noop,

			update: function(reset) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var chartArea &#x3D; chart.chartArea;
				var meta &#x3D; me.getMeta();
				var opts &#x3D; chart.options;
				var arcOpts &#x3D; opts.elements.arc;
				var minSize &#x3D; Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
				chart.outerRadius &#x3D; Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
				chart.innerRadius &#x3D; Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
				chart.radiusLength &#x3D; (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

				me.outerRadius &#x3D; chart.outerRadius - (chart.radiusLength * me.index);
				me.innerRadius &#x3D; me.outerRadius - chart.radiusLength;

				meta.count &#x3D; me.countVisibleElements();

				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},

			updateElement: function(arc, index, reset) {
				var me &#x3D; this;
				var chart &#x3D; me.chart;
				var dataset &#x3D; me.getDataset();
				var opts &#x3D; chart.options;
				var animationOpts &#x3D; opts.animation;
				var scale &#x3D; chart.scale;
				var labels &#x3D; chart.data.labels;

				var circumference &#x3D; me.calculateCircumference(dataset.data[index]);
				var centerX &#x3D; scale.xCenter;
				var centerY &#x3D; scale.yCenter;

				// If there is NaN data before us, we need to calculate the starting angle correctly.
				// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
				var visibleCount &#x3D; 0;
				var meta &#x3D; me.getMeta();
				for (var i &#x3D; 0; i &lt; index; ++i) {
					if (!isNaN(dataset.data[i]) &amp;&amp; !meta.data[i].hidden) {
						++visibleCount;
					}
				}

				// var negHalfPI &#x3D; -0.5 * Math.PI;
				var datasetStartAngle &#x3D; opts.startAngle;
				var distance &#x3D; arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
				var startAngle &#x3D; datasetStartAngle + (circumference * visibleCount);
				var endAngle &#x3D; startAngle + (arc.hidden ? 0 : circumference);

				var resetRadius &#x3D; animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,

					// Desired view properties
					_model: {
						x: centerX,
						y: centerY,
						innerRadius: 0,
						outerRadius: reset ? resetRadius : distance,
						startAngle: reset &amp;&amp; animationOpts.animateRotate ? datasetStartAngle : startAngle,
						endAngle: reset &amp;&amp; animationOpts.animateRotate ? datasetStartAngle : endAngle,
						label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
					}
				});

				// Apply border and fill style
				me.removeHoverStyle(arc);

				arc.pivot();
			},

			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},

			countVisibleElements: function() {
				var dataset &#x3D; this.getDataset();
				var meta &#x3D; this.getMeta();
				var count &#x3D; 0;

				helpers.each(meta.data, function(element, index) {
					if (!isNaN(dataset.data[index]) &amp;&amp; !element.hidden) {
						count++;
					}
				});

				return count;
			},

			calculateCircumference: function(value) {
				var count &#x3D; this.getMeta().count;
				if (count &gt; 0 &amp;&amp; !isNaN(value)) {
					return (2 * Math.PI) / count;
				}
				return 0;
			}
		});
	};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var elements &#x3D; __webpack_require__(48);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;radar&#x27;, {
		scale: {
			type: &#x27;radialLinear&#x27;
		},
		elements: {
			line: {
				tension: 0 // no bezier in radar
			}
		}
	});

	module.exports &#x3D; function(Chart) {

		Chart.controllers.radar &#x3D; Chart.DatasetController.extend({

			datasetElementType: elements.Line,

			dataElementType: elements.Point,

			linkScales: helpers.noop,

			update: function(reset) {
				var me &#x3D; this;
				var meta &#x3D; me.getMeta();
				var line &#x3D; meta.dataset;
				var points &#x3D; meta.data;
				var custom &#x3D; line.custom || {};
				var dataset &#x3D; me.getDataset();
				var lineElementOptions &#x3D; me.chart.options.elements.line;
				var scale &#x3D; me.chart.scale;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.tension !&#x3D;&#x3D; undefined) &amp;&amp; (dataset.lineTension &#x3D;&#x3D;&#x3D; undefined)) {
					dataset.lineTension &#x3D; dataset.tension;
				}

				helpers.extend(meta.dataset, {
					// Utility
					_datasetIndex: me.index,
					_scale: scale,
					// Data
					_children: points,
					_loop: true,
					// Model
					_model: {
						// Appearance
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						fill: custom.fill ? custom.fill : (dataset.fill !&#x3D;&#x3D; undefined ? dataset.fill : lineElementOptions.fill),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
					}
				});

				meta.dataset.pivot();

				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				}, me);

				// Update bezier control points
				me.updateBezierControlPoints();
			},
			updateElement: function(point, index, reset) {
				var me &#x3D; this;
				var custom &#x3D; point.custom || {};
				var dataset &#x3D; me.getDataset();
				var scale &#x3D; me.chart.scale;
				var pointElementOptions &#x3D; me.chart.options.elements.point;
				var pointPosition &#x3D; scale.getPointPositionForValue(index, dataset.data[index]);

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !&#x3D;&#x3D; undefined) &amp;&amp; (dataset.pointRadius &#x3D;&#x3D;&#x3D; undefined)) {
					dataset.pointRadius &#x3D; dataset.radius;
				}
				if ((dataset.hitRadius !&#x3D;&#x3D; undefined) &amp;&amp; (dataset.pointHitRadius &#x3D;&#x3D;&#x3D; undefined)) {
					dataset.pointHitRadius &#x3D; dataset.hitRadius;
				}

				helpers.extend(point, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,

					// Desired view properties
					_model: {
						x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
						y: reset ? scale.yCenter : pointPosition.y,

						// Appearance
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
						radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
						borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
						pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

						// Tooltip
						hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
					}
				});

				point._model.skip &#x3D; custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
			},
			updateBezierControlPoints: function() {
				var chartArea &#x3D; this.chart.chartArea;
				var meta &#x3D; this.getMeta();

				helpers.each(meta.data, function(point, index) {
					var model &#x3D; point._model;
					var controlPoints &#x3D; helpers.splineCurve(
						helpers.previousItem(meta.data, index, true)._model,
						model,
						helpers.nextItem(meta.data, index, true)._model,
						model.tension
					);

					// Prevent the bezier going outside of the bounds of the graph
					model.controlPointPreviousX &#x3D; Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
					model.controlPointPreviousY &#x3D; Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

					model.controlPointNextX &#x3D; Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
					model.controlPointNextY &#x3D; Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

					// Now pivot the point for animation
					point.pivot();
				});
			},

			setHoverStyle: function(point) {
				// Point
				var dataset &#x3D; this.chart.data.datasets[point._datasetIndex];
				var custom &#x3D; point.custom || {};
				var index &#x3D; point._index;
				var model &#x3D; point._model;

				model.radius &#x3D; custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor &#x3D; custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor &#x3D; custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth &#x3D; custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(point) {
				var dataset &#x3D; this.chart.data.datasets[point._datasetIndex];
				var custom &#x3D; point.custom || {};
				var index &#x3D; point._index;
				var model &#x3D; point._model;
				var pointElementOptions &#x3D; this.chart.options.elements.point;

				model.radius &#x3D; custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
				model.backgroundColor &#x3D; custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
				model.borderColor &#x3D; custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
				model.borderWidth &#x3D; custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
			}
		});
	};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);

	defaults._set(&#x27;scatter&#x27;, {
		hover: {
			mode: &#x27;single&#x27;
		},

		scales: {
			xAxes: [{
				id: &#x27;x-axis-1&#x27;,    // need an ID so datasets can reference the scale
				type: &#x27;linear&#x27;,    // scatter should not use a category axis
				position: &#x27;bottom&#x27;
			}],
			yAxes: [{
				id: &#x27;y-axis-1&#x27;,
				type: &#x27;linear&#x27;,
				position: &#x27;left&#x27;
			}]
		},

		showLines: false,

		tooltips: {
			callbacks: {
				title: function() {
					return &#x27;&#x27;;     // doesn&#x27;t make sense for scatter since data are formatted as a point
				},
				label: function(item) {
					return &#x27;(&#x27; + item.xLabel + &#x27;, &#x27; + item.yLabel + &#x27;)&#x27;;
				}
			}
		}
	});

	module.exports &#x3D; function(Chart) {

		// Scatter charts use line controllers
		Chart.controllers.scatter &#x3D; Chart.controllers.line;

	};


/***/ }),
/* 204 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {

		Chart.Bar &#x3D; function(context, config) {
			config.type &#x3D; &#x27;bar&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 205 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {

		Chart.Bubble &#x3D; function(context, config) {
			config.type &#x3D; &#x27;bubble&#x27;;
			return new Chart(context, config);
		};

	};


/***/ }),
/* 206 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {

		Chart.Doughnut &#x3D; function(context, config) {
			config.type &#x3D; &#x27;doughnut&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 207 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {

		Chart.Line &#x3D; function(context, config) {
			config.type &#x3D; &#x27;line&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 208 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {

		Chart.PolarArea &#x3D; function(context, config) {
			config.type &#x3D; &#x27;polarArea&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 209 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {

		Chart.Radar &#x3D; function(context, config) {
			config.type &#x3D; &#x27;radar&#x27;;

			return new Chart(context, config);
		};

	};


/***/ }),
/* 210 */
/***/ (function(module, exports) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; function(Chart) {
		Chart.Scatter &#x3D; function(context, config) {
			config.type &#x3D; &#x27;scatter&#x27;;
			return new Chart(context, config);
		};
	};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	module.exports &#x3D; {};
	module.exports.filler &#x3D; __webpack_require__(212);
	module.exports.legend &#x3D; __webpack_require__(213);
	module.exports.title &#x3D; __webpack_require__(214);


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Plugin based on discussion from the following Chart.js issues:
	 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
	 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
	 */

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var elements &#x3D; __webpack_require__(48);
	var helpers &#x3D; __webpack_require__(36);

	defaults._set(&#x27;global&#x27;, {
		plugins: {
			filler: {
				propagate: true
			}
		}
	});

	var mappers &#x3D; {
		dataset: function(source) {
			var index &#x3D; source.fill;
			var chart &#x3D; source.chart;
			var meta &#x3D; chart.getDatasetMeta(index);
			var visible &#x3D; meta &amp;&amp; chart.isDatasetVisible(index);
			var points &#x3D; (visible &amp;&amp; meta.dataset._children) || [];
			var length &#x3D; points.length || 0;

			return !length ? null : function(point, i) {
				return (i &lt; length &amp;&amp; points[i]._view) || null;
			};
		},

		boundary: function(source) {
			var boundary &#x3D; source.boundary;
			var x &#x3D; boundary ? boundary.x : null;
			var y &#x3D; boundary ? boundary.y : null;

			return function(point) {
				return {
					x: x &#x3D;&#x3D;&#x3D; null ? point.x : x,
					y: y &#x3D;&#x3D;&#x3D; null ? point.y : y,
				};
			};
		}
	};

	// @todo if (fill[0] &#x3D;&#x3D;&#x3D; &#x27;#&#x27;)
	function decodeFill(el, index, count) {
		var model &#x3D; el._model || {};
		var fill &#x3D; model.fill;
		var target;

		if (fill &#x3D;&#x3D;&#x3D; undefined) {
			fill &#x3D; !!model.backgroundColor;
		}

		if (fill &#x3D;&#x3D;&#x3D; false || fill &#x3D;&#x3D;&#x3D; null) {
			return false;
		}

		if (fill &#x3D;&#x3D;&#x3D; true) {
			return &#x27;origin&#x27;;
		}

		target &#x3D; parseFloat(fill, 10);
		if (isFinite(target) &amp;&amp; Math.floor(target) &#x3D;&#x3D;&#x3D; target) {
			if (fill[0] &#x3D;&#x3D;&#x3D; &#x27;-&#x27; || fill[0] &#x3D;&#x3D;&#x3D; &#x27;+&#x27;) {
				target &#x3D; index + target;
			}

			if (target &#x3D;&#x3D;&#x3D; index || target &lt; 0 || target &gt;&#x3D; count) {
				return false;
			}

			return target;
		}

		switch (fill) {
		// compatibility
		case &#x27;bottom&#x27;:
			return &#x27;start&#x27;;
		case &#x27;top&#x27;:
			return &#x27;end&#x27;;
		case &#x27;zero&#x27;:
			return &#x27;origin&#x27;;
		// supported boundaries
		case &#x27;origin&#x27;:
		case &#x27;start&#x27;:
		case &#x27;end&#x27;:
			return fill;
		// invalid fill values
		default:
			return false;
		}
	}

	function computeBoundary(source) {
		var model &#x3D; source.el._model || {};
		var scale &#x3D; source.el._scale || {};
		var fill &#x3D; source.fill;
		var target &#x3D; null;
		var horizontal;

		if (isFinite(fill)) {
			return null;
		}

		// Backward compatibility: until v3, we still need to support boundary values set on
		// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
		// controllers might still use it (e.g. the Smith chart).

		if (fill &#x3D;&#x3D;&#x3D; &#x27;start&#x27;) {
			target &#x3D; model.scaleBottom &#x3D;&#x3D;&#x3D; undefined ? scale.bottom : model.scaleBottom;
		} else if (fill &#x3D;&#x3D;&#x3D; &#x27;end&#x27;) {
			target &#x3D; model.scaleTop &#x3D;&#x3D;&#x3D; undefined ? scale.top : model.scaleTop;
		} else if (model.scaleZero !&#x3D;&#x3D; undefined) {
			target &#x3D; model.scaleZero;
		} else if (scale.getBasePosition) {
			target &#x3D; scale.getBasePosition();
		} else if (scale.getBasePixel) {
			target &#x3D; scale.getBasePixel();
		}

		if (target !&#x3D;&#x3D; undefined &amp;&amp; target !&#x3D;&#x3D; null) {
			if (target.x !&#x3D;&#x3D; undefined &amp;&amp; target.y !&#x3D;&#x3D; undefined) {
				return target;
			}

			if (typeof target &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; isFinite(target)) {
				horizontal &#x3D; scale.isHorizontal();
				return {
					x: horizontal ? target : null,
					y: horizontal ? null : target
				};
			}
		}

		return null;
	}

	function resolveTarget(sources, index, propagate) {
		var source &#x3D; sources[index];
		var fill &#x3D; source.fill;
		var visited &#x3D; [index];
		var target;

		if (!propagate) {
			return fill;
		}

		while (fill !&#x3D;&#x3D; false &amp;&amp; visited.indexOf(fill) &#x3D;&#x3D;&#x3D; -1) {
			if (!isFinite(fill)) {
				return fill;
			}

			target &#x3D; sources[fill];
			if (!target) {
				return false;
			}

			if (target.visible) {
				return fill;
			}

			visited.push(fill);
			fill &#x3D; target.fill;
		}

		return false;
	}

	function createMapper(source) {
		var fill &#x3D; source.fill;
		var type &#x3D; &#x27;dataset&#x27;;

		if (fill &#x3D;&#x3D;&#x3D; false) {
			return null;
		}

		if (!isFinite(fill)) {
			type &#x3D; &#x27;boundary&#x27;;
		}

		return mappers[type](source);
	}

	function isDrawable(point) {
		return point &amp;&amp; !point.skip;
	}

	function drawArea(ctx, curve0, curve1, len0, len1) {
		var i;

		if (!len0 || !len1) {
			return;
		}

		// building first area curve (normal)
		ctx.moveTo(curve0[0].x, curve0[0].y);
		for (i &#x3D; 1; i &lt; len0; ++i) {
			helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
		}

		// joining the two area curves
		ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

		// building opposite area curve (reverse)
		for (i &#x3D; len1 - 1; i &gt; 0; --i) {
			helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
		}
	}

	function doFill(ctx, points, mapper, view, color, loop) {
		var count &#x3D; points.length;
		var span &#x3D; view.spanGaps;
		var curve0 &#x3D; [];
		var curve1 &#x3D; [];
		var len0 &#x3D; 0;
		var len1 &#x3D; 0;
		var i, ilen, index, p0, p1, d0, d1;

		ctx.beginPath();

		for (i &#x3D; 0, ilen &#x3D; (count + !!loop); i &lt; ilen; ++i) {
			index &#x3D; i % count;
			p0 &#x3D; points[index]._view;
			p1 &#x3D; mapper(p0, index, view);
			d0 &#x3D; isDrawable(p0);
			d1 &#x3D; isDrawable(p1);

			if (d0 &amp;&amp; d1) {
				len0 &#x3D; curve0.push(p0);
				len1 &#x3D; curve1.push(p1);
			} else if (len0 &amp;&amp; len1) {
				if (!span) {
					drawArea(ctx, curve0, curve1, len0, len1);
					len0 &#x3D; len1 &#x3D; 0;
					curve0 &#x3D; [];
					curve1 &#x3D; [];
				} else {
					if (d0) {
						curve0.push(p0);
					}
					if (d1) {
						curve1.push(p1);
					}
				}
			}
		}

		drawArea(ctx, curve0, curve1, len0, len1);

		ctx.closePath();
		ctx.fillStyle &#x3D; color;
		ctx.fill();
	}

	module.exports &#x3D; {
		id: &#x27;filler&#x27;,

		afterDatasetsUpdate: function(chart, options) {
			var count &#x3D; (chart.data.datasets || []).length;
			var propagate &#x3D; options.propagate;
			var sources &#x3D; [];
			var meta, i, el, source;

			for (i &#x3D; 0; i &lt; count; ++i) {
				meta &#x3D; chart.getDatasetMeta(i);
				el &#x3D; meta.dataset;
				source &#x3D; null;

				if (el &amp;&amp; el._model &amp;&amp; el instanceof elements.Line) {
					source &#x3D; {
						visible: chart.isDatasetVisible(i),
						fill: decodeFill(el, i, count),
						chart: chart,
						el: el
					};
				}

				meta.$filler &#x3D; source;
				sources.push(source);
			}

			for (i &#x3D; 0; i &lt; count; ++i) {
				source &#x3D; sources[i];
				if (!source) {
					continue;
				}

				source.fill &#x3D; resolveTarget(sources, i, propagate);
				source.boundary &#x3D; computeBoundary(source);
				source.mapper &#x3D; createMapper(source);
			}
		},

		beforeDatasetDraw: function(chart, args) {
			var meta &#x3D; args.meta.$filler;
			if (!meta) {
				return;
			}

			var ctx &#x3D; chart.ctx;
			var el &#x3D; meta.el;
			var view &#x3D; el._view;
			var points &#x3D; el._children || [];
			var mapper &#x3D; meta.mapper;
			var color &#x3D; view.backgroundColor || defaults.global.defaultColor;

			if (mapper &amp;&amp; color &amp;&amp; points.length) {
				helpers.canvas.clipArea(ctx, chart.chartArea);
				doFill(ctx, points, mapper, view, color, el._loop);
				helpers.canvas.unclipArea(ctx);
			}
		}
	};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);
	var layouts &#x3D; __webpack_require__(54);

	var noop &#x3D; helpers.noop;

	defaults._set(&#x27;global&#x27;, {
		legend: {
			display: true,
			position: &#x27;top&#x27;,
			fullWidth: true,
			reverse: false,
			weight: 1000,

			// a callback that will handle
			onClick: function(e, legendItem) {
				var index &#x3D; legendItem.datasetIndex;
				var ci &#x3D; this.chart;
				var meta &#x3D; ci.getDatasetMeta(index);

				// See controller.isDatasetVisible comment
				meta.hidden &#x3D; meta.hidden &#x3D;&#x3D;&#x3D; null ? !ci.data.datasets[index].hidden : null;

				// We hid a dataset ... rerender the chart
				ci.update();
			},

			onHover: null,

			labels: {
				boxWidth: 40,
				padding: 10,
				// Generates labels shown in the legend
				// Valid properties to return:
				// text : text to display
				// fillStyle : fill of coloured box
				// strokeStyle: stroke of coloured box
				// hidden : if this legend item refers to a hidden item
				// lineCap : cap style for line
				// lineDash
				// lineDashOffset :
				// lineJoin :
				// lineWidth :
				generateLabels: function(chart) {
					var data &#x3D; chart.data;
					return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
						return {
							text: dataset.label,
							fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
							hidden: !chart.isDatasetVisible(i),
							lineCap: dataset.borderCapStyle,
							lineDash: dataset.borderDash,
							lineDashOffset: dataset.borderDashOffset,
							lineJoin: dataset.borderJoinStyle,
							lineWidth: dataset.borderWidth,
							strokeStyle: dataset.borderColor,
							pointStyle: dataset.pointStyle,

							// Below is extra data used for toggling the datasets
							datasetIndex: i
						};
					}, this) : [];
				}
			}
		},

		legendCallback: function(chart) {
			var text &#x3D; [];
			text.push(&#x27;&lt;ul class&#x3D;&quot;&#x27; + chart.id + &#x27;-legend&quot;&gt;&#x27;);
			for (var i &#x3D; 0; i &lt; chart.data.datasets.length; i++) {
				text.push(&#x27;&lt;li&gt;&lt;span style&#x3D;&quot;background-color:&#x27; + chart.data.datasets[i].backgroundColor + &#x27;&quot;&gt;&lt;/span&gt;&#x27;);
				if (chart.data.datasets[i].label) {
					text.push(chart.data.datasets[i].label);
				}
				text.push(&#x27;&lt;/li&gt;&#x27;);
			}
			text.push(&#x27;&lt;/ul&gt;&#x27;);
			return text.join(&#x27;&#x27;);
		}
	});

	/**
	 * Helper function to get the box width based on the usePointStyle option
	 * @param labelopts {Object} the label options on the legend
	 * @param fontSize {Number} the label font size
	 * @return {Number} width of the color box area
	 */
	function getBoxWidth(labelOpts, fontSize) {
		return labelOpts.usePointStyle ?
			fontSize * Math.SQRT2 :
			labelOpts.boxWidth;
	}

	/**
	 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
	 */
	var Legend &#x3D; Element.extend({

		initialize: function(config) {
			helpers.extend(this, config);

			// Contains hit boxes for each dataset (in dataset order)
			this.legendHitBoxes &#x3D; [];

			// Are we in doughnut mode which has a different data type
			this.doughnutMode &#x3D; false;
		},

		// These methods are ordered by lifecycle. Utilities then follow.
		// Any function defined here is inherited by all legend types.
		// Any function can be extended by the legend type

		beforeUpdate: noop,
		update: function(maxWidth, maxHeight, margins) {
			var me &#x3D; this;

			// Update Lifecycle - Probably don&#x27;t want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth &#x3D; maxWidth;
			me.maxHeight &#x3D; maxHeight;
			me.margins &#x3D; margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;
		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function() {
			var me &#x3D; this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width &#x3D; me.maxWidth;
				me.left &#x3D; 0;
				me.right &#x3D; me.width;
			} else {
				me.height &#x3D; me.maxHeight;

				// Reset position before calculating rotation
				me.top &#x3D; 0;
				me.bottom &#x3D; me.height;
			}

			// Reset padding
			me.paddingLeft &#x3D; 0;
			me.paddingTop &#x3D; 0;
			me.paddingRight &#x3D; 0;
			me.paddingBottom &#x3D; 0;

			// Reset minSize
			me.minSize &#x3D; {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: function() {
			var me &#x3D; this;
			var labelOpts &#x3D; me.options.labels || {};
			var legendItems &#x3D; helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

			if (labelOpts.filter) {
				legendItems &#x3D; legendItems.filter(function(item) {
					return labelOpts.filter(item, me.chart.data);
				});
			}

			if (me.options.reverse) {
				legendItems.reverse();
			}

			me.legendItems &#x3D; legendItems;
		},
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function() {
			var me &#x3D; this;
			var opts &#x3D; me.options;
			var labelOpts &#x3D; opts.labels;
			var display &#x3D; opts.display;

			var ctx &#x3D; me.ctx;

			var globalDefault &#x3D; defaults.global;
			var valueOrDefault &#x3D; helpers.valueOrDefault;
			var fontSize &#x3D; valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
			var fontStyle &#x3D; valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
			var fontFamily &#x3D; valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
			var labelFont &#x3D; helpers.fontString(fontSize, fontStyle, fontFamily);

			// Reset hit boxes
			var hitboxes &#x3D; me.legendHitBoxes &#x3D; [];

			var minSize &#x3D; me.minSize;
			var isHorizontal &#x3D; me.isHorizontal();

			if (isHorizontal) {
				minSize.width &#x3D; me.maxWidth; // fill all the width
				minSize.height &#x3D; display ? 10 : 0;
			} else {
				minSize.width &#x3D; display ? 10 : 0;
				minSize.height &#x3D; me.maxHeight; // fill all the height
			}

			// Increase sizes here
			if (display) {
				ctx.font &#x3D; labelFont;

				if (isHorizontal) {
					// Labels

					// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
					var lineWidths &#x3D; me.lineWidths &#x3D; [0];
					var totalHeight &#x3D; me.legendItems.length ? fontSize + (labelOpts.padding) : 0;

					ctx.textAlign &#x3D; &#x27;left&#x27;;
					ctx.textBaseline &#x3D; &#x27;top&#x27;;

					helpers.each(me.legendItems, function(legendItem, i) {
						var boxWidth &#x3D; getBoxWidth(labelOpts, fontSize);
						var width &#x3D; boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

						if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding &gt;&#x3D; me.width) {
							totalHeight +&#x3D; fontSize + (labelOpts.padding);
							lineWidths[lineWidths.length] &#x3D; me.left;
						}

						// Store the hitbox width and height here. Final position will be updated in &#x60;draw&#x60;
						hitboxes[i] &#x3D; {
							left: 0,
							top: 0,
							width: width,
							height: fontSize
						};

						lineWidths[lineWidths.length - 1] +&#x3D; width + labelOpts.padding;
					});

					minSize.height +&#x3D; totalHeight;

				} else {
					var vPadding &#x3D; labelOpts.padding;
					var columnWidths &#x3D; me.columnWidths &#x3D; [];
					var totalWidth &#x3D; labelOpts.padding;
					var currentColWidth &#x3D; 0;
					var currentColHeight &#x3D; 0;
					var itemHeight &#x3D; fontSize + vPadding;

					helpers.each(me.legendItems, function(legendItem, i) {
						var boxWidth &#x3D; getBoxWidth(labelOpts, fontSize);
						var itemWidth &#x3D; boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

						// If too tall, go to new column
						if (currentColHeight + itemHeight &gt; minSize.height) {
							totalWidth +&#x3D; currentColWidth + labelOpts.padding;
							columnWidths.push(currentColWidth); // previous column width

							currentColWidth &#x3D; 0;
							currentColHeight &#x3D; 0;
						}

						// Get max width
						currentColWidth &#x3D; Math.max(currentColWidth, itemWidth);
						currentColHeight +&#x3D; itemHeight;

						// Store the hitbox width and height here. Final position will be updated in &#x60;draw&#x60;
						hitboxes[i] &#x3D; {
							left: 0,
							top: 0,
							width: itemWidth,
							height: fontSize
						};
					});

					totalWidth +&#x3D; currentColWidth;
					columnWidths.push(currentColWidth);
					minSize.width +&#x3D; totalWidth;
				}
			}

			me.width &#x3D; minSize.width;
			me.height &#x3D; minSize.height;
		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function() {
			return this.options.position &#x3D;&#x3D;&#x3D; &#x27;top&#x27; || this.options.position &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;;
		},

		// Actually draw the legend on the canvas
		draw: function() {
			var me &#x3D; this;
			var opts &#x3D; me.options;
			var labelOpts &#x3D; opts.labels;
			var globalDefault &#x3D; defaults.global;
			var lineDefault &#x3D; globalDefault.elements.line;
			var legendWidth &#x3D; me.width;
			var lineWidths &#x3D; me.lineWidths;

			if (opts.display) {
				var ctx &#x3D; me.ctx;
				var valueOrDefault &#x3D; helpers.valueOrDefault;
				var fontColor &#x3D; valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
				var fontSize &#x3D; valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
				var fontStyle &#x3D; valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
				var fontFamily &#x3D; valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
				var labelFont &#x3D; helpers.fontString(fontSize, fontStyle, fontFamily);
				var cursor;

				// Canvas setup
				ctx.textAlign &#x3D; &#x27;left&#x27;;
				ctx.textBaseline &#x3D; &#x27;middle&#x27;;
				ctx.lineWidth &#x3D; 0.5;
				ctx.strokeStyle &#x3D; fontColor; // for strikethrough effect
				ctx.fillStyle &#x3D; fontColor; // render in correct colour
				ctx.font &#x3D; labelFont;

				var boxWidth &#x3D; getBoxWidth(labelOpts, fontSize);
				var hitboxes &#x3D; me.legendHitBoxes;

				// current position
				var drawLegendBox &#x3D; function(x, y, legendItem) {
					if (isNaN(boxWidth) || boxWidth &lt;&#x3D; 0) {
						return;
					}

					// Set the ctx for the box
					ctx.save();

					ctx.fillStyle &#x3D; valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
					ctx.lineCap &#x3D; valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
					ctx.lineDashOffset &#x3D; valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
					ctx.lineJoin &#x3D; valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
					ctx.lineWidth &#x3D; valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
					ctx.strokeStyle &#x3D; valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
					var isLineWidthZero &#x3D; (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) &#x3D;&#x3D;&#x3D; 0);

					if (ctx.setLineDash) {
						// IE 9 and 10 do not support line dash
						ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
					}

					if (opts.labels &amp;&amp; opts.labels.usePointStyle) {
						// Recalculate x and y for drawPoint() because its expecting
						// x and y to be center of figure (instead of top left)
						var radius &#x3D; fontSize * Math.SQRT2 / 2;
						var offSet &#x3D; radius / Math.SQRT2;
						var centerX &#x3D; x + offSet;
						var centerY &#x3D; y + offSet;

						// Draw pointStyle as legend symbol
						helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
					} else {
						// Draw box as legend symbol
						if (!isLineWidthZero) {
							ctx.strokeRect(x, y, boxWidth, fontSize);
						}
						ctx.fillRect(x, y, boxWidth, fontSize);
					}

					ctx.restore();
				};
				var fillText &#x3D; function(x, y, legendItem, textWidth) {
					var halfFontSize &#x3D; fontSize / 2;
					var xLeft &#x3D; boxWidth + halfFontSize + x;
					var yMiddle &#x3D; y + halfFontSize;

					ctx.fillText(legendItem.text, xLeft, yMiddle);

					if (legendItem.hidden) {
						// Strikethrough the text if hidden
						ctx.beginPath();
						ctx.lineWidth &#x3D; 2;
						ctx.moveTo(xLeft, yMiddle);
						ctx.lineTo(xLeft + textWidth, yMiddle);
						ctx.stroke();
					}
				};

				// Horizontal
				var isHorizontal &#x3D; me.isHorizontal();
				if (isHorizontal) {
					cursor &#x3D; {
						x: me.left + ((legendWidth - lineWidths[0]) / 2),
						y: me.top + labelOpts.padding,
						line: 0
					};
				} else {
					cursor &#x3D; {
						x: me.left + labelOpts.padding,
						y: me.top + labelOpts.padding,
						line: 0
					};
				}

				var itemHeight &#x3D; fontSize + labelOpts.padding;
				helpers.each(me.legendItems, function(legendItem, i) {
					var textWidth &#x3D; ctx.measureText(legendItem.text).width;
					var width &#x3D; boxWidth + (fontSize / 2) + textWidth;
					var x &#x3D; cursor.x;
					var y &#x3D; cursor.y;

					if (isHorizontal) {
						if (x + width &gt;&#x3D; legendWidth) {
							y &#x3D; cursor.y +&#x3D; itemHeight;
							cursor.line++;
							x &#x3D; cursor.x &#x3D; me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
						}
					} else if (y + itemHeight &gt; me.bottom) {
						x &#x3D; cursor.x &#x3D; x + me.columnWidths[cursor.line] + labelOpts.padding;
						y &#x3D; cursor.y &#x3D; me.top + labelOpts.padding;
						cursor.line++;
					}

					drawLegendBox(x, y, legendItem);

					hitboxes[i].left &#x3D; x;
					hitboxes[i].top &#x3D; y;

					// Fill the actual label
					fillText(x, y, legendItem, textWidth);

					if (isHorizontal) {
						cursor.x +&#x3D; width + (labelOpts.padding);
					} else {
						cursor.y +&#x3D; itemHeight;
					}

				});
			}
		},

		/**
		 * Handle an event
		 * @private
		 * @param {IEvent} event - The event to handle
		 * @return {Boolean} true if a change occured
		 */
		handleEvent: function(e) {
			var me &#x3D; this;
			var opts &#x3D; me.options;
			var type &#x3D; e.type &#x3D;&#x3D;&#x3D; &#x27;mouseup&#x27; ? &#x27;click&#x27; : e.type;
			var changed &#x3D; false;

			if (type &#x3D;&#x3D;&#x3D; &#x27;mousemove&#x27;) {
				if (!opts.onHover) {
					return;
				}
			} else if (type &#x3D;&#x3D;&#x3D; &#x27;click&#x27;) {
				if (!opts.onClick) {
					return;
				}
			} else {
				return;
			}

			// Chart event already has relative position in it
			var x &#x3D; e.x;
			var y &#x3D; e.y;

			if (x &gt;&#x3D; me.left &amp;&amp; x &lt;&#x3D; me.right &amp;&amp; y &gt;&#x3D; me.top &amp;&amp; y &lt;&#x3D; me.bottom) {
				// See if we are touching one of the dataset boxes
				var lh &#x3D; me.legendHitBoxes;
				for (var i &#x3D; 0; i &lt; lh.length; ++i) {
					var hitBox &#x3D; lh[i];

					if (x &gt;&#x3D; hitBox.left &amp;&amp; x &lt;&#x3D; hitBox.left + hitBox.width &amp;&amp; y &gt;&#x3D; hitBox.top &amp;&amp; y &lt;&#x3D; hitBox.top + hitBox.height) {
						// Touching an element
						if (type &#x3D;&#x3D;&#x3D; &#x27;click&#x27;) {
							// use e.native for backwards compatibility
							opts.onClick.call(me, e.native, me.legendItems[i]);
							changed &#x3D; true;
							break;
						} else if (type &#x3D;&#x3D;&#x3D; &#x27;mousemove&#x27;) {
							// use e.native for backwards compatibility
							opts.onHover.call(me, e.native, me.legendItems[i]);
							changed &#x3D; true;
							break;
						}
					}
				}
			}

			return changed;
		}
	});

	function createNewLegendAndAttach(chart, legendOpts) {
		var legend &#x3D; new Legend({
			ctx: chart.ctx,
			options: legendOpts,
			chart: chart
		});

		layouts.configure(chart, legend, legendOpts);
		layouts.addBox(chart, legend);
		chart.legend &#x3D; legend;
	}

	module.exports &#x3D; {
		id: &#x27;legend&#x27;,

		/**
		 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
		 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
		 * the plugin, which one will be re-exposed in the chart.js file.
		 * https://github.com/chartjs/Chart.js/pull/2640
		 * @private
		 */
		_element: Legend,

		beforeInit: function(chart) {
			var legendOpts &#x3D; chart.options.legend;

			if (legendOpts) {
				createNewLegendAndAttach(chart, legendOpts);
			}
		},

		beforeUpdate: function(chart) {
			var legendOpts &#x3D; chart.options.legend;
			var legend &#x3D; chart.legend;

			if (legendOpts) {
				helpers.mergeIf(legendOpts, defaults.global.legend);

				if (legend) {
					layouts.configure(chart, legend, legendOpts);
					legend.options &#x3D; legendOpts;
				} else {
					createNewLegendAndAttach(chart, legendOpts);
				}
			} else if (legend) {
				layouts.removeBox(chart, legend);
				delete chart.legend;
			}
		},

		afterEvent: function(chart, e) {
			var legend &#x3D; chart.legend;
			if (legend) {
				legend.handleEvent(e);
			}
		}
	};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	&#x27;use strict&#x27;;

	var defaults &#x3D; __webpack_require__(35);
	var Element &#x3D; __webpack_require__(47);
	var helpers &#x3D; __webpack_require__(36);
	var layouts &#x3D; __webpack_require__(54);

	var noop &#x3D; helpers.noop;

	defaults._set(&#x27;global&#x27;, {
		title: {
			display: false,
			fontStyle: &#x27;bold&#x27;,
			fullWidth: true,
			lineHeight: 1.2,
			padding: 10,
			position: &#x27;top&#x27;,
			text: &#x27;&#x27;,
			weight: 2000         // by default greater than legend (1000) to be above
		}
	});

	/**
	 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
	 */
	var Title &#x3D; Element.extend({
		initialize: function(config) {
			var me &#x3D; this;
			helpers.extend(me, config);

			// Contains hit boxes for each dataset (in dataset order)
			me.legendHitBoxes &#x3D; [];
		},

		// These methods are ordered by lifecycle. Utilities then follow.

		beforeUpdate: noop,
		update: function(maxWidth, maxHeight, margins) {
			var me &#x3D; this;

			// Update Lifecycle - Probably don&#x27;t want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth &#x3D; maxWidth;
			me.maxHeight &#x3D; maxHeight;
			me.margins &#x3D; margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;

		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function() {
			var me &#x3D; this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width &#x3D; me.maxWidth;
				me.left &#x3D; 0;
				me.right &#x3D; me.width;
			} else {
				me.height &#x3D; me.maxHeight;

				// Reset position before calculating rotation
				me.top &#x3D; 0;
				me.bottom &#x3D; me.height;
			}

			// Reset padding
			me.paddingLeft &#x3D; 0;
			me.paddingTop &#x3D; 0;
			me.paddingRight &#x3D; 0;
			me.paddingBottom &#x3D; 0;

			// Reset minSize
			me.minSize &#x3D; {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: noop,
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function() {
			var me &#x3D; this;
			var valueOrDefault &#x3D; helpers.valueOrDefault;
			var opts &#x3D; me.options;
			var display &#x3D; opts.display;
			var fontSize &#x3D; valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
			var minSize &#x3D; me.minSize;
			var lineCount &#x3D; helpers.isArray(opts.text) ? opts.text.length : 1;
			var lineHeight &#x3D; helpers.options.toLineHeight(opts.lineHeight, fontSize);
			var textSize &#x3D; display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;

			if (me.isHorizontal()) {
				minSize.width &#x3D; me.maxWidth; // fill all the width
				minSize.height &#x3D; textSize;
			} else {
				minSize.width &#x3D; textSize;
				minSize.height &#x3D; me.maxHeight; // fill all the height
			}

			me.width &#x3D; minSize.width;
			me.height &#x3D; minSize.height;

		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function() {
			var pos &#x3D; this.options.position;
			return pos &#x3D;&#x3D;&#x3D; &#x27;top&#x27; || pos &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;;
		},

		// Actually draw the title block on the canvas
		draw: function() {
			var me &#x3D; this;
			var ctx &#x3D; me.ctx;
			var valueOrDefault &#x3D; helpers.valueOrDefault;
			var opts &#x3D; me.options;
			var globalDefaults &#x3D; defaults.global;

			if (opts.display) {
				var fontSize &#x3D; valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
				var fontStyle &#x3D; valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
				var fontFamily &#x3D; valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
				var titleFont &#x3D; helpers.fontString(fontSize, fontStyle, fontFamily);
				var lineHeight &#x3D; helpers.options.toLineHeight(opts.lineHeight, fontSize);
				var offset &#x3D; lineHeight / 2 + opts.padding;
				var rotation &#x3D; 0;
				var top &#x3D; me.top;
				var left &#x3D; me.left;
				var bottom &#x3D; me.bottom;
				var right &#x3D; me.right;
				var maxWidth, titleX, titleY;

				ctx.fillStyle &#x3D; valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
				ctx.font &#x3D; titleFont;

				// Horizontal
				if (me.isHorizontal()) {
					titleX &#x3D; left + ((right - left) / 2); // midpoint of the width
					titleY &#x3D; top + offset;
					maxWidth &#x3D; right - left;
				} else {
					titleX &#x3D; opts.position &#x3D;&#x3D;&#x3D; &#x27;left&#x27; ? left + offset : right - offset;
					titleY &#x3D; top + ((bottom - top) / 2);
					maxWidth &#x3D; bottom - top;
					rotation &#x3D; Math.PI * (opts.position &#x3D;&#x3D;&#x3D; &#x27;left&#x27; ? -0.5 : 0.5);
				}

				ctx.save();
				ctx.translate(titleX, titleY);
				ctx.rotate(rotation);
				ctx.textAlign &#x3D; &#x27;center&#x27;;
				ctx.textBaseline &#x3D; &#x27;middle&#x27;;

				var text &#x3D; opts.text;
				if (helpers.isArray(text)) {
					var y &#x3D; 0;
					for (var i &#x3D; 0; i &lt; text.length; ++i) {
						ctx.fillText(text[i], 0, y, maxWidth);
						y +&#x3D; lineHeight;
					}
				} else {
					ctx.fillText(text, 0, 0, maxWidth);
				}

				ctx.restore();
			}
		}
	});

	function createNewTitleBlockAndAttach(chart, titleOpts) {
		var title &#x3D; new Title({
			ctx: chart.ctx,
			options: titleOpts,
			chart: chart
		});

		layouts.configure(chart, title, titleOpts);
		layouts.addBox(chart, title);
		chart.titleBlock &#x3D; title;
	}

	module.exports &#x3D; {
		id: &#x27;title&#x27;,

		/**
		 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
		 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
		 * the plugin, which one will be re-exposed in the chart.js file.
		 * https://github.com/chartjs/Chart.js/pull/2640
		 * @private
		 */
		_element: Title,

		beforeInit: function(chart) {
			var titleOpts &#x3D; chart.options.title;

			if (titleOpts) {
				createNewTitleBlockAndAttach(chart, titleOpts);
			}
		},

		beforeUpdate: function(chart) {
			var titleOpts &#x3D; chart.options.title;
			var titleBlock &#x3D; chart.titleBlock;

			if (titleOpts) {
				helpers.mergeIf(titleOpts, defaults.global.title);

				if (titleBlock) {
					layouts.configure(chart, titleBlock, titleOpts);
					titleBlock.options &#x3D; titleOpts;
				} else {
					createNewTitleBlockAndAttach(chart, titleOpts);
				}
			} else if (titleBlock) {
				layouts.removeBox(chart, titleBlock);
				delete chart.titleBlock;
			}
		}
	};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(216);

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ($(&#x27;.circular-progressbar&#x27;).length) {
	        enableCircularProgressbars();
	        // Check If Knob Is In Viewport
	        $(window).bind(&#x27;scroll load resize&#x27;, function () {
	            enableCircularProgressbars();
	        });
	    }
	});


	// Enable Circular Progressbars
	function enableCircularProgressbars() {

	    // Initialize Circular Progressbars
	    initCircularProgressbars();

	    $(&#x27;.circular-progressbar&#x27;).each(function () {
	        /* Knob Elements */
	        var knob &#x3D; $(this).find(&#x27;.circular-progressbar-inner input&#x27;);
	        var knob_percent &#x3D; knob.parents(&#x27;.circular-progressbar-inner&#x27;).find(&#x27;span.knob-percent&#x27;);

	        /* Knob Variables */
	        var value &#x3D; knob.data(&#x27;value&#x27;);
	        var knob_val &#x3D; knob.data(&#x27;value&#x27;);
	        var knob_animated &#x3D; knob.hasClass(&#x27;knob-animated&#x27;);

	        // Animate Knob If In Viewport
	        if (isElementInViewport(knob) &amp;&amp; !knob_animated) {

	            knob.addClass(&#x27;knob-animated&#x27;);
	            $({startVal: 0}).animate({startVal: knob_val},
	                {
	                    duration: 1000,
	                    easing: &#x27;swing&#x27;,
	                    step: function () {
	                        knob.val(Math.ceil(this.startVal)).trigger(&#x27;change&#x27;);
	                        knob_percent.html(Math.ceil(this.startVal) + &#x27;&lt;span&gt;%&lt;/span&gt;&#x27;);
	                    }
	                }
	            );

	        }

	    });
	}

	// init Circular ProgressBars
	function initCircularProgressbars() {
	    $(&#x27;.circular-progressbar&gt;input&#x27;).each(function () {
	        var knob &#x3D; $(this);
	        knob.wrap(&#x27;&lt;div class&#x3D;&quot;circular-progressbar-inner&quot;&gt;&lt;/div&gt;&#x27;);
	        knob.parent().append(&#x27;&lt;span class&#x3D;&quot;knob-percent&quot;&gt;&lt;/span&gt;&#x27;);

	        // Set the value
	        var value &#x3D; $(this).val();
	        $(this).data(&#x27;value&#x27;, value);

	        var size &#x3D; 120;
	        if ($(this).data(&#x27;size&#x27;)) {
	            size &#x3D; $(this).data(&#x27;size&#x27;);
	        }
	        // Initialize Knob
	        $(this).knob({
	            min: 0,
	            max: 100,
	            width: size,
	            height: size,
	            readOnly: true,
	            displayInput: false
	        });

	        // Set The Start Value to 0
	        $(this).val(0).trigger(&#x27;change&#x27;);

	    });
	}


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(e){if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ &#x3D; [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D; (e), __WEBPACK_AMD_DEFINE_RESULT__ &#x3D; (typeof __WEBPACK_AMD_DEFINE_FACTORY__ &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !&#x3D;&#x3D; undefined &amp;&amp; (module.exports &#x3D; __WEBPACK_AMD_DEFINE_RESULT__))}else{e(jQuery)}})(function(e){&quot;use strict&quot;;var t&#x3D;{},n&#x3D;Math.max,r&#x3D;Math.min;t.c&#x3D;{};t.c.d&#x3D;e(document);t.c.t&#x3D;function(e){return e.originalEvent.touches.length-1};t.o&#x3D;function(){var n&#x3D;this;this.o&#x3D;null;this.$&#x3D;null;this.i&#x3D;null;this.g&#x3D;null;this.v&#x3D;null;this.cv&#x3D;null;this.x&#x3D;0;this.y&#x3D;0;this.w&#x3D;0;this.h&#x3D;0;this.$c&#x3D;null;this.c&#x3D;null;this.t&#x3D;0;this.isInit&#x3D;false;this.fgColor&#x3D;null;this.pColor&#x3D;null;this.dH&#x3D;null;this.cH&#x3D;null;this.eH&#x3D;null;this.rH&#x3D;null;this.scale&#x3D;1;this.relative&#x3D;false;this.relativeWidth&#x3D;false;this.relativeHeight&#x3D;false;this.$div&#x3D;null;this.run&#x3D;function(){var t&#x3D;function(e,t){var r;for(r in t){n.o[r]&#x3D;t[r]}n._carve().init();n._configure()._draw()};if(this.$.data(&quot;kontroled&quot;))return;this.$.data(&quot;kontroled&quot;,true);this.extend();this.o&#x3D;e.extend({min:this.$.data(&quot;min&quot;)!&#x3D;&#x3D;undefined?this.$.data(&quot;min&quot;):0,max:this.$.data(&quot;max&quot;)!&#x3D;&#x3D;undefined?this.$.data(&quot;max&quot;):100,stopper:true,readOnly:this.$.data(&quot;readonly&quot;)||this.$.attr(&quot;readonly&quot;)&#x3D;&#x3D;&#x3D;&quot;readonly&quot;,cursor:this.$.data(&quot;cursor&quot;)&#x3D;&#x3D;&#x3D;true&amp;&amp;30||this.$.data(&quot;cursor&quot;)||0,thickness:this.$.data(&quot;thickness&quot;)&amp;&amp;Math.max(Math.min(this.$.data(&quot;thickness&quot;),1),.01)||.35,lineCap:this.$.data(&quot;linecap&quot;)||&quot;butt&quot;,width:this.$.data(&quot;width&quot;)||200,height:this.$.data(&quot;height&quot;)||200,displayInput:this.$.data(&quot;displayinput&quot;)&#x3D;&#x3D;null||this.$.data(&quot;displayinput&quot;),displayPrevious:this.$.data(&quot;displayprevious&quot;),fgColor:this.$.data(&quot;fgcolor&quot;)||&quot;#87CEEB&quot;,inputColor:this.$.data(&quot;inputcolor&quot;),font:this.$.data(&quot;font&quot;)||&quot;Arial&quot;,fontWeight:this.$.data(&quot;font-weight&quot;)||&quot;bold&quot;,inline:false,step:this.$.data(&quot;step&quot;)||1,rotation:this.$.data(&quot;rotation&quot;),draw:null,change:null,cancel:null,release:null,format:function(e){return e},parse:function(e){return parseFloat(e)}},this.o);this.o.flip&#x3D;this.o.rotation&#x3D;&#x3D;&#x3D;&quot;anticlockwise&quot;||this.o.rotation&#x3D;&#x3D;&#x3D;&quot;acw&quot;;if(!this.o.inputColor){this.o.inputColor&#x3D;this.o.fgColor}if(this.$.is(&quot;fieldset&quot;)){this.v&#x3D;{};this.i&#x3D;this.$.find(&quot;input&quot;);this.i.each(function(t){var r&#x3D;e(this);n.i[t]&#x3D;r;n.v[t]&#x3D;n.o.parse(r.val());r.bind(&quot;change blur&quot;,function(){var e&#x3D;{};e[t]&#x3D;r.val();n.val(n._validate(e))})});this.$.find(&quot;legend&quot;).remove()}else{this.i&#x3D;this.$;this.v&#x3D;this.o.parse(this.$.val());this.v&#x3D;&#x3D;&#x3D;&quot;&quot;&amp;&amp;(this.v&#x3D;this.o.min);this.$.bind(&quot;change blur&quot;,function(){n.val(n._validate(n.o.parse(n.$.val())))})}!this.o.displayInput&amp;&amp;this.$.hide();this.$c&#x3D;e(document.createElement(&quot;canvas&quot;)).attr({width:this.o.width,height:this.o.height});this.$div&#x3D;e(&#x27;&lt;div style&#x3D;&quot;&#x27;+(this.o.inline?&quot;display:inline;&quot;:&quot;&quot;)+&quot;width:&quot;+this.o.width+&quot;px;height:&quot;+this.o.height+&quot;px;&quot;+&#x27;&quot;&gt;&lt;/div&gt;&#x27;);this.$.wrap(this.$div).before(this.$c);this.$div&#x3D;this.$.parent();if(typeof G_vmlCanvasManager!&#x3D;&#x3D;&quot;undefined&quot;){G_vmlCanvasManager.initElement(this.$c[0])}this.c&#x3D;this.$c[0].getContext?this.$c[0].getContext(&quot;2d&quot;):null;if(!this.c){throw{name:&quot;CanvasNotSupportedException&quot;,message:&quot;Canvas not supported. Please use excanvas on IE8.0.&quot;,toString:function(){return this.name+&quot;: &quot;+this.message}}}this.scale&#x3D;(window.devicePixelRatio||1)/(this.c.webkitBackingStorePixelRatio||this.c.mozBackingStorePixelRatio||this.c.msBackingStorePixelRatio||this.c.oBackingStorePixelRatio||this.c.backingStorePixelRatio||1);this.relativeWidth&#x3D;this.o.width%1!&#x3D;&#x3D;0&amp;&amp;this.o.width.indexOf(&quot;%&quot;);this.relativeHeight&#x3D;this.o.height%1!&#x3D;&#x3D;0&amp;&amp;this.o.height.indexOf(&quot;%&quot;);this.relative&#x3D;this.relativeWidth||this.relativeHeight;this._carve();if(this.v instanceof Object){this.cv&#x3D;{};this.copy(this.v,this.cv)}else{this.cv&#x3D;this.v}this.$.bind(&quot;configure&quot;,t).parent().bind(&quot;configure&quot;,t);this._listen()._configure()._xy().init();this.isInit&#x3D;true;this.$.val(this.o.format(this.v));this._draw();return this};this._carve&#x3D;function(){if(this.relative){var e&#x3D;this.relativeWidth?this.$div.parent().width()*parseInt(this.o.width)/100:this.$div.parent().width(),t&#x3D;this.relativeHeight?this.$div.parent().height()*parseInt(this.o.height)/100:this.$div.parent().height();this.w&#x3D;this.h&#x3D;Math.min(e,t)}else{this.w&#x3D;this.o.width;this.h&#x3D;this.o.height}this.$div.css({width:this.w+&quot;px&quot;,height:this.h+&quot;px&quot;});this.$c.attr({width:this.w,height:this.h});if(this.scale!&#x3D;&#x3D;1){this.$c[0].width&#x3D;this.$c[0].width*this.scale;this.$c[0].height&#x3D;this.$c[0].height*this.scale;this.$c.width(this.w);this.$c.height(this.h)}return this};this._draw&#x3D;function(){var e&#x3D;true;n.g&#x3D;n.c;n.clear();n.dH&amp;&amp;(e&#x3D;n.dH());e!&#x3D;&#x3D;false&amp;&amp;n.draw()};this._touch&#x3D;function(e){var r&#x3D;function(e){var t&#x3D;n.xy2val(e.originalEvent.touches[n.t].pageX,e.originalEvent.touches[n.t].pageY);if(t&#x3D;&#x3D;n.cv)return;if(n.cH&amp;&amp;n.cH(t)&#x3D;&#x3D;&#x3D;false)return;n.change(n._validate(t));n._draw()};this.t&#x3D;t.c.t(e);r(e);t.c.d.bind(&quot;touchmove.k&quot;,r).bind(&quot;touchend.k&quot;,function(){t.c.d.unbind(&quot;touchmove.k touchend.k&quot;);n.val(n.cv)});return this};this._mouse&#x3D;function(e){var r&#x3D;function(e){var t&#x3D;n.xy2val(e.pageX,e.pageY);if(t&#x3D;&#x3D;n.cv)return;if(n.cH&amp;&amp;n.cH(t)&#x3D;&#x3D;&#x3D;false)return;n.change(n._validate(t));n._draw()};r(e);t.c.d.bind(&quot;mousemove.k&quot;,r).bind(&quot;keyup.k&quot;,function(e){if(e.keyCode&#x3D;&#x3D;&#x3D;27){t.c.d.unbind(&quot;mouseup.k mousemove.k keyup.k&quot;);if(n.eH&amp;&amp;n.eH()&#x3D;&#x3D;&#x3D;false)return;n.cancel()}}).bind(&quot;mouseup.k&quot;,function(e){t.c.d.unbind(&quot;mousemove.k mouseup.k keyup.k&quot;);n.val(n.cv)});return this};this._xy&#x3D;function(){var e&#x3D;this.$c.offset();this.x&#x3D;e.left;this.y&#x3D;e.top;return this};this._listen&#x3D;function(){if(!this.o.readOnly){this.$c.bind(&quot;mousedown&quot;,function(e){e.preventDefault();n._xy()._mouse(e)}).bind(&quot;touchstart&quot;,function(e){e.preventDefault();n._xy()._touch(e)});this.listen()}else{this.$.attr(&quot;readonly&quot;,&quot;readonly&quot;)}if(this.relative){e(window).resize(function(){n._carve().init();n._draw()})}return this};this._configure&#x3D;function(){if(this.o.draw)this.dH&#x3D;this.o.draw;if(this.o.change)this.cH&#x3D;this.o.change;if(this.o.cancel)this.eH&#x3D;this.o.cancel;if(this.o.release)this.rH&#x3D;this.o.release;if(this.o.displayPrevious){this.pColor&#x3D;this.h2rgba(this.o.fgColor,&quot;0.4&quot;);this.fgColor&#x3D;this.h2rgba(this.o.fgColor,&quot;0.6&quot;)}else{this.fgColor&#x3D;this.o.fgColor}return this};this._clear&#x3D;function(){this.$c[0].width&#x3D;this.$c[0].width};this._validate&#x3D;function(e){var t&#x3D;~~((e&lt;0?-.5:.5)+e/this.o.step)*this.o.step;return Math.round(t*100)/100};this.listen&#x3D;function(){};this.extend&#x3D;function(){};this.init&#x3D;function(){};this.change&#x3D;function(e){};this.val&#x3D;function(e){};this.xy2val&#x3D;function(e,t){};this.draw&#x3D;function(){};this.clear&#x3D;function(){this._clear()};this.h2rgba&#x3D;function(e,t){var n;e&#x3D;e.substring(1,7);n&#x3D;[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)];return&quot;rgba(&quot;+n[0]+&quot;,&quot;+n[1]+&quot;,&quot;+n[2]+&quot;,&quot;+t+&quot;)&quot;};this.copy&#x3D;function(e,t){for(var n in e){t[n]&#x3D;e[n]}}};t.Dial&#x3D;function(){t.o.call(this);this.startAngle&#x3D;null;this.xy&#x3D;null;this.radius&#x3D;null;this.lineWidth&#x3D;null;this.cursorExt&#x3D;null;this.w2&#x3D;null;this.PI2&#x3D;2*Math.PI;this.extend&#x3D;function(){this.o&#x3D;e.extend({bgColor:this.$.data(&quot;bgcolor&quot;)||&quot;#EEEEEE&quot;,angleOffset:this.$.data(&quot;angleoffset&quot;)||0,angleArc:this.$.data(&quot;anglearc&quot;)||360,inline:true},this.o)};this.val&#x3D;function(e,t){if(null!&#x3D;e){e&#x3D;this.o.parse(e);if(t!&#x3D;&#x3D;false&amp;&amp;e!&#x3D;this.v&amp;&amp;this.rH&amp;&amp;this.rH(e)&#x3D;&#x3D;&#x3D;false){return}this.cv&#x3D;this.o.stopper?n(r(e,this.o.max),this.o.min):e;this.v&#x3D;this.cv;this.$.val(this.o.format(this.v));this._draw()}else{return this.v}};this.xy2val&#x3D;function(e,t){var i,s;i&#x3D;Math.atan2(e-(this.x+this.w2),-(t-this.y-this.w2))-this.angleOffset;if(this.o.flip){i&#x3D;this.angleArc-i-this.PI2}if(this.angleArc!&#x3D;this.PI2&amp;&amp;i&lt;0&amp;&amp;i&gt;-.5){i&#x3D;0}else if(i&lt;0){i+&#x3D;this.PI2}s&#x3D;i*(this.o.max-this.o.min)/this.angleArc+this.o.min;this.o.stopper&amp;&amp;(s&#x3D;n(r(s,this.o.max),this.o.min));return s};this.listen&#x3D;function(){var t&#x3D;this,i,s,o&#x3D;function(e){e.preventDefault();var o&#x3D;e.originalEvent,u&#x3D;o.detail||o.wheelDeltaX,a&#x3D;o.detail||o.wheelDeltaY,f&#x3D;t._validate(t.o.parse(t.$.val()))+(u&gt;0||a&gt;0?t.o.step:u&lt;0||a&lt;0?-t.o.step:0);f&#x3D;n(r(f,t.o.max),t.o.min);t.val(f,false);if(t.rH){clearTimeout(i);i&#x3D;setTimeout(function(){t.rH(f);i&#x3D;null},100);if(!s){s&#x3D;setTimeout(function(){if(i)t.rH(f);s&#x3D;null},200)}}},u,a,f&#x3D;1,l&#x3D;{37:-t.o.step,38:t.o.step,39:t.o.step,40:-t.o.step};this.$.bind(&quot;keydown&quot;,function(i){var s&#x3D;i.keyCode;if(s&gt;&#x3D;96&amp;&amp;s&lt;&#x3D;105){s&#x3D;i.keyCode&#x3D;s-48}u&#x3D;parseInt(String.fromCharCode(s));if(isNaN(u)){s!&#x3D;&#x3D;13&amp;&amp;s!&#x3D;&#x3D;8&amp;&amp;s!&#x3D;&#x3D;9&amp;&amp;s!&#x3D;&#x3D;189&amp;&amp;(s!&#x3D;&#x3D;190||t.$.val().match(/\./))&amp;&amp;i.preventDefault();if(e.inArray(s,[37,38,39,40])&gt;-1){i.preventDefault();var o&#x3D;t.o.parse(t.$.val())+l[s]*f;t.o.stopper&amp;&amp;(o&#x3D;n(r(o,t.o.max),t.o.min));t.change(t._validate(o));t._draw();a&#x3D;window.setTimeout(function(){f*&#x3D;2},30)}}}).bind(&quot;keyup&quot;,function(e){if(isNaN(u)){if(a){window.clearTimeout(a);a&#x3D;null;f&#x3D;1;t.val(t.$.val())}}else{t.$.val()&gt;t.o.max&amp;&amp;t.$.val(t.o.max)||t.$.val()&lt;t.o.min&amp;&amp;t.$.val(t.o.min)}});this.$c.bind(&quot;mousewheel DOMMouseScroll&quot;,o);this.$.bind(&quot;mousewheel DOMMouseScroll&quot;,o)};this.init&#x3D;function(){if(this.v&lt;this.o.min||this.v&gt;this.o.max){this.v&#x3D;this.o.min}this.$.val(this.v);this.w2&#x3D;this.w/2;this.cursorExt&#x3D;this.o.cursor/100;this.xy&#x3D;this.w2*this.scale;this.lineWidth&#x3D;this.xy*this.o.thickness;this.lineCap&#x3D;this.o.lineCap;this.radius&#x3D;this.xy-this.lineWidth/2;this.o.angleOffset&amp;&amp;(this.o.angleOffset&#x3D;isNaN(this.o.angleOffset)?0:this.o.angleOffset);this.o.angleArc&amp;&amp;(this.o.angleArc&#x3D;isNaN(this.o.angleArc)?this.PI2:this.o.angleArc);this.angleOffset&#x3D;this.o.angleOffset*Math.PI/180;this.angleArc&#x3D;this.o.angleArc*Math.PI/180;this.startAngle&#x3D;1.5*Math.PI+this.angleOffset;this.endAngle&#x3D;1.5*Math.PI+this.angleOffset+this.angleArc;var e&#x3D;n(String(Math.abs(this.o.max)).length,String(Math.abs(this.o.min)).length,2)+2;this.o.displayInput&amp;&amp;this.i.css({width:(this.w/2+4&gt;&gt;0)+&quot;px&quot;,height:(this.w/3&gt;&gt;0)+&quot;px&quot;,position:&quot;absolute&quot;,&quot;vertical-align&quot;:&quot;middle&quot;,&quot;margin-top&quot;:(this.w/3&gt;&gt;0)+&quot;px&quot;,&quot;margin-left&quot;:&quot;-&quot;+(this.w*3/4+2&gt;&gt;0)+&quot;px&quot;,border:0,background:&quot;none&quot;,font:this.o.fontWeight+&quot; &quot;+(this.w/e&gt;&gt;0)+&quot;px &quot;+this.o.font,&quot;text-align&quot;:&quot;center&quot;,color:this.o.inputColor||this.o.fgColor,padding:&quot;0px&quot;,&quot;-webkit-appearance&quot;:&quot;none&quot;})||this.i.css({width:&quot;0px&quot;,visibility:&quot;hidden&quot;})};this.change&#x3D;function(e){this.cv&#x3D;e;this.$.val(this.o.format(e))};this.angle&#x3D;function(e){return(e-this.o.min)*this.angleArc/(this.o.max-this.o.min)};this.arc&#x3D;function(e){var t,n;e&#x3D;this.angle(e);if(this.o.flip){t&#x3D;this.endAngle+1e-5;n&#x3D;t-e-1e-5}else{t&#x3D;this.startAngle-1e-5;n&#x3D;t+e+1e-5}this.o.cursor&amp;&amp;(t&#x3D;n-this.cursorExt)&amp;&amp;(n&#x3D;n+this.cursorExt);return{s:t,e:n,d:this.o.flip&amp;&amp;!this.o.cursor}};this.draw&#x3D;function(){var e&#x3D;this.g,t&#x3D;this.arc(this.cv),n,r&#x3D;1;e.lineWidth&#x3D;this.lineWidth;e.lineCap&#x3D;this.lineCap;if(this.o.bgColor!&#x3D;&#x3D;&quot;none&quot;){e.beginPath();e.strokeStyle&#x3D;this.o.bgColor;e.arc(this.xy,this.xy,this.radius,this.endAngle-1e-5,this.startAngle+1e-5,true);e.stroke()}if(this.o.displayPrevious){n&#x3D;this.arc(this.v);e.beginPath();e.strokeStyle&#x3D;this.pColor;e.arc(this.xy,this.xy,this.radius,n.s,n.e,n.d);e.stroke();r&#x3D;this.cv&#x3D;&#x3D;this.v}e.beginPath();e.strokeStyle&#x3D;r?this.o.fgColor:this.fgColor;e.arc(this.xy,this.xy,this.radius,t.s,t.e,t.d);e.stroke()};this.cancel&#x3D;function(){this.val(this.v)}};e.fn.dial&#x3D;e.fn.knob&#x3D;function(n){return this.each(function(){var r&#x3D;new t.Dial;r.o&#x3D;n;r.$&#x3D;e(this);r.run()}).parent()}})

/***/ }),
/* 217 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ($(&#x27;.g-map&#x27;).length) {
	        $(&#x27;.g-map&#x27;).each(function (index, element) {
	            var map_selector &#x3D; $(this).data(&#x27;id&#x27;),
	                mapAddress &#x3D; $(this).data(&#x27;address&#x27;),
	                mapType &#x3D; $(this).data(&#x27;maptype&#x27;),
	                zoomLvl &#x3D; $(this).data(&#x27;zoomlvl&#x27;),
	                mapPin &#x3D; $(this).data(&#x27;mapPin&#x27;);
	            
	            $(this).attr(&#x27;id&#x27;, map_selector);
	            mapRender(map_selector, mapAddress, mapType, zoomLvl,mapPin);
	        });
	    }
	    function mapRender(selector, address, type, zoom_lvl,mapPin) {
	        // Specify features and elements to define styles.
	        var styleArray &#x3D; [{
	            featureType: &quot;all&quot;,
	            stylers: [{
	                saturation: -80
	            }]
	        }, {
	            featureType: &quot;road.arterial&quot;,
	            elementType: &quot;geometry&quot;,
	            stylers: [{
	                hue: &quot;#00ffee&quot;
	            }, {
	                saturation: 50
	            }]
	        }, {
	            featureType: &quot;poi.business&quot;,
	            elementType: &quot;labels&quot;,
	            stylers: [{
	                visibility: &quot;off&quot;
	            }]
	        }];
	        var map &#x3D; new google.maps.Map(document.getElementById(selector), {
	            mapTypeId:type,
	            styles: styleArray,
	            scrollwheel: false,
	            draggable: false,
	            zoom: zoom_lvl,
	            mapTypeControl: false,
	        });

	        var map_pin &#x3D; &quot;assets/img/basic/pin.png&quot;;

	        if(mapPin){
	            map_pin &#x3D; mapPin;
	        }

	        var geocoder &#x3D; new google.maps.Geocoder();
	        geocoder.geocode({
	                &#x27;address&#x27;: address
	            },
	            function (results, status) {
	                if (status &#x3D;&#x3D;&#x3D; google.maps.GeocoderStatus.OK) {
	                    new google.maps.Marker({
	                        position: results[0].geometry.location,
	                        map: map,
	                        icon: map_pin
	                    });
	                    map.setCenter(results[0].geometry.location);
	                }
	            });
	    }
	});

/***/ }),
/* 218 */
/***/ (function(module, exports) {

	(function () {
	    &#x27;use strict&#x27;;
	    $(&quot;body&quot;).on(&quot;click&quot;, &quot;.closePromotions&quot;, function (e) {
	        e.preventDefault();
	        var $this &#x3D; $(this);
	        $this.parent().slideUp();
	    });
	}());

/***/ }),
/* 219 */
/***/ (function(module, exports) {

	jQuery(document).ready(function ($) {
	    //set animation timing
	    var animationDelay &#x3D; 2500,
	        //loading bar effect
	        barAnimationDelay &#x3D; 3800,
	        barWaiting &#x3D; barAnimationDelay - 3000, //3000 is the duration of the transition on the loading bar - set in the scss/css file
	        //letters effect
	        lettersDelay &#x3D; 50,
	        //type effect
	        typeLettersDelay &#x3D; 150,
	        selectionDuration &#x3D; 500,
	        typeAnimationDelay &#x3D; selectionDuration + 800,
	        //clip effect 
	        revealDuration &#x3D; 600,
	        revealAnimationDelay &#x3D; 1500;

	    initHeadline();


	    function initHeadline() {
	        //insert &lt;i&gt; element for each letter of a changing word
	        singleLetters($(&#x27;.cd-headline.letters&#x27;).find(&#x27;b&#x27;));
	        //initialise headline animation
	        animateHeadline($(&#x27;.cd-headline&#x27;));
	    }

	    function singleLetters($words) {
	        $words.each(function () {
	            var word &#x3D; $(this),
	                letters &#x3D; word.text().split(&#x27;&#x27;),
	                selected &#x3D; word.hasClass(&#x27;is-visible&#x27;);
	            for (i in letters) {
	                if (word.parents(&#x27;.rotate-2&#x27;).length &gt; 0) letters[i] &#x3D; &#x27;&lt;em&gt;&#x27; + letters[i] + &#x27;&lt;/em&gt;&#x27;;
	                letters[i] &#x3D; (selected) ? &#x27;&lt;i class&#x3D;&quot;in&quot;&gt;&#x27; + letters[i] + &#x27;&lt;/i&gt;&#x27; : &#x27;&lt;i&gt;&#x27; + letters[i] + &#x27;&lt;/i&gt;&#x27;;
	            }
	            var newLetters &#x3D; letters.join(&#x27;&#x27;);
	            word.html(newLetters).css(&#x27;opacity&#x27;, 1);
	        });
	    }

	    function animateHeadline($headlines) {
	        var duration &#x3D; animationDelay;
	        $headlines.each(function () {
	            var headline &#x3D; $(this);

	            if (headline.hasClass(&#x27;loading-bar&#x27;)) {
	                duration &#x3D; barAnimationDelay;
	                setTimeout(function () {
	                    headline.find(&#x27;.cd-words-wrapper&#x27;).addClass(&#x27;is-loading&#x27;)
	                }, barWaiting);
	            } else if (headline.hasClass(&#x27;clip&#x27;)) {
	                var spanWrapper &#x3D; headline.find(&#x27;.cd-words-wrapper&#x27;),
	                    newWidth &#x3D; spanWrapper.width() + 10;
	                spanWrapper.css(&#x27;width&#x27;, newWidth);
	            } else if (!headline.hasClass(&#x27;type&#x27;)) {
	                //assign to .cd-words-wrapper the width of its longest word
	                var words &#x3D; headline.find(&#x27;.cd-words-wrapper b&#x27;),
	                    width &#x3D; 0;
	                words.each(function () {
	                    var wordWidth &#x3D; $(this).width();
	                    if (wordWidth &gt; width) width &#x3D; wordWidth;
	                });
	                headline.find(&#x27;.cd-words-wrapper&#x27;).css(&#x27;width&#x27;, width);
	            }
	            //trigger animation
	            setTimeout(function () {
	                hideWord(headline.find(&#x27;.is-visible&#x27;).eq(0))
	            }, duration);
	        });
	    }

	    function hideWord($word) {
	        var nextWord &#x3D; takeNext($word);

	        if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;type&#x27;)) {
	            var parentSpan &#x3D; $word.parent(&#x27;.cd-words-wrapper&#x27;);
	            parentSpan.addClass(&#x27;selected&#x27;).removeClass(&#x27;waiting&#x27;);
	            setTimeout(function () {
	                parentSpan.removeClass(&#x27;selected&#x27;);
	                $word.removeClass(&#x27;is-visible&#x27;).addClass(&#x27;is-hidden&#x27;).children(&#x27;i&#x27;).removeClass(&#x27;in&#x27;).addClass(&#x27;out&#x27;);
	            }, selectionDuration);
	            setTimeout(function () {
	                showWord(nextWord, typeLettersDelay)
	            }, typeAnimationDelay);

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;letters&#x27;)) {
	            var bool &#x3D; ($word.children(&#x27;i&#x27;).length &gt;&#x3D; nextWord.children(&#x27;i&#x27;).length) ? true : false;
	            hideLetter($word.find(&#x27;i&#x27;).eq(0), $word, bool, lettersDelay);
	            showLetter(nextWord.find(&#x27;i&#x27;).eq(0), nextWord, bool, lettersDelay);

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;clip&#x27;)) {
	            $word.parents(&#x27;.cd-words-wrapper&#x27;).animate({width: &#x27;2px&#x27;}, revealDuration, function () {
	                switchWord($word, nextWord);
	                showWord(nextWord);
	            });

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;loading-bar&#x27;)) {
	            $word.parents(&#x27;.cd-words-wrapper&#x27;).removeClass(&#x27;is-loading&#x27;);
	            switchWord($word, nextWord);
	            setTimeout(function () {
	                hideWord(nextWord)
	            }, barAnimationDelay);
	            setTimeout(function () {
	                $word.parents(&#x27;.cd-words-wrapper&#x27;).addClass(&#x27;is-loading&#x27;)
	            }, barWaiting);

	        } else {
	            switchWord($word, nextWord);
	            setTimeout(function () {
	                hideWord(nextWord)
	            }, animationDelay);
	        }
	    }

	    function showWord($word, $duration) {
	        if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;type&#x27;)) {
	            showLetter($word.find(&#x27;i&#x27;).eq(0), $word, false, $duration);
	            $word.addClass(&#x27;is-visible&#x27;).removeClass(&#x27;is-hidden&#x27;);

	        } else if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;clip&#x27;)) {
	            $word.parents(&#x27;.cd-words-wrapper&#x27;).animate({&#x27;width&#x27;: $word.width() + 10}, revealDuration, function () {
	                setTimeout(function () {
	                    hideWord($word)
	                }, revealAnimationDelay);
	            });
	        }
	    }

	    function hideLetter($letter, $word, $bool, $duration) {
	        $letter.removeClass(&#x27;in&#x27;).addClass(&#x27;out&#x27;);

	        if (!$letter.is(&#x27;:last-child&#x27;)) {
	            setTimeout(function () {
	                hideLetter($letter.next(), $word, $bool, $duration);
	            }, $duration);
	        } else if ($bool) {
	            setTimeout(function () {
	                hideWord(takeNext($word))
	            }, animationDelay);
	        }

	        if ($letter.is(&#x27;:last-child&#x27;) &amp;&amp; $(&#x27;html&#x27;).hasClass(&#x27;no-csstransitions&#x27;)) {
	            var nextWord &#x3D; takeNext($word);
	            switchWord($word, nextWord);
	        }
	    }

	    function showLetter($letter, $word, $bool, $duration) {
	        $letter.addClass(&#x27;in&#x27;).removeClass(&#x27;out&#x27;);

	        if (!$letter.is(&#x27;:last-child&#x27;)) {
	            setTimeout(function () {
	                showLetter($letter.next(), $word, $bool, $duration);
	            }, $duration);
	        } else {
	            if ($word.parents(&#x27;.cd-headline&#x27;).hasClass(&#x27;type&#x27;)) {
	                setTimeout(function () {
	                    $word.parents(&#x27;.cd-words-wrapper&#x27;).addClass(&#x27;waiting&#x27;);
	                }, 200);
	            }
	            if (!$bool) {
	                setTimeout(function () {
	                    hideWord($word)
	                }, animationDelay)
	            }
	        }
	    }

	    function takeNext($word) {
	        return (!$word.is(&#x27;:last-child&#x27;)) ? $word.next() : $word.parent().children().eq(0);
	    }

	    function takePrev($word) {
	        return (!$word.is(&#x27;:first-child&#x27;)) ? $word.prev() : $word.parent().children().last();
	    }

	    function switchWord($oldWord, $newWord) {
	        $oldWord.removeClass(&#x27;is-visible&#x27;).addClass(&#x27;is-hidden&#x27;);
	        $newWord.removeClass(&#x27;is-hidden&#x27;).addClass(&#x27;is-visible&#x27;);
	    }
	});

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(221);

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    var xv_ww &#x3D; $(window).width(),
	        xv_slideshow &#x3D; true;

	    menuInit();

	    // Check If Counter In Viewport
	    $(window).on(&#x27;load resize&#x27;, function () {
	        menuInit();
	    });

	    function menuInit() {
	        xv_ww &#x3D; $(window).width();
	        if ($(&#x27;.nav-offcanvas&#x27;).length) {
	            $(&#x27;.paper-nav-toggle&#x27;).removeClass(&#x27;dl-trigger&#x27;);
	        }

	        if (($(&#x27;.nav-offcanvas&#x27;).length &amp;&amp; xv_ww &lt;&#x3D; 1030) || $(&#x27;.nav-offcanvas-desktop&#x27;).length) {
	            $(&#x27;body&#x27;).addClass(&#x27;sidebar-collapse&#x27;);
	            $(&#x27;.dl-menu&#x27;).addClass(&quot;dl-menuopen&quot;);
	            $(&#x27;.paper-nav-toggle&#x27;).removeClass(&#x27;dl-trigger&#x27;);
	            $(&#x27;.nav-offcanvas .paper_menu&#x27;).addClass(&#x27;main-sidebar shadow1 fixed offcanvas&#x27;);
	        } else {
	            $(&#x27;.nav-offcanvas .paper_menu&#x27;).removeClass(&#x27;main-sidebar shadow1 fixed offcanvas&#x27;);
	        }


	        if (xv_ww &lt;&#x3D; 1030 || $(&#x27;.mini-nav&#x27;).length) {
	            $(&#x27;.responsive-menu&#x27;).removeClass(&#x27;xv-menuwrapper&#x27;).addClass(&#x27;dl-menuwrapper&#x27;);
	            $(&#x27;.user-avatar&#x27;).removeClass(&#x27;pull-right&#x27;);
	            $(&#x27;.lg-submenu&#x27;).addClass(&quot;dl-submenu&quot;);
	        } else {
	            $(&#x27;.responsive-menu&#x27;).removeClass(&#x27;dl-menuwrapper&#x27;).addClass(&#x27;xv-menuwrapper&#x27;);
	            $(&#x27;.lg-submenu&#x27;).removeClass(&quot;dl-submenu&quot;);
	            $(&#x27;.user-avatar&#x27;).addClass(&#x27;pull-right&#x27;);
	        }
	    }
	    $(&#x27;#dl-menu&#x27;).dlmenu({
	        animationClasses: {
	            classin: &#x27;dl-animate-in-2&#x27;,
	            classout: &#x27;dl-animate-out-2&#x27;
	        }
	    });
	});

/***/ }),
/* 221 */
/***/ (function(module, exports) {

	/**
	 * jquery.dlmenu.js v1.0.1
	 * http://www.codrops.com
	 */
	;(function ($, window, undefined) {

	    &#x27;use strict&#x27;;

	    // global
	    var Modernizr &#x3D; window.Modernizr, $body &#x3D; $(&#x27;body&#x27;);

	    $.DLMenu &#x3D; function (options, element) {
	        this.$el &#x3D; $(element);
	        this._init(options);
	    };

	    // the options
	    $.DLMenu.defaults &#x3D; {
	        // classes for the animation effects
	        animationClasses: {classin: &#x27;dl-animate-in-1&#x27;, classout: &#x27;dl-animate-out-1&#x27;},
	        // callback: click a link that has a sub menu
	        // el is the link element (li); name is the level name
	        onLevelClick: function (el, name) {
	            return false;
	        },
	        // callback: click a link that does not have a sub menu
	        // el is the link element (li); ev is the event obj
	        onLinkClick: function (el, ev) {
	            return false;
	        }
	    };

	    $.DLMenu.prototype &#x3D; {
	        _init: function (options) {

	            // options
	            this.options &#x3D; $.extend(true, {}, $.DLMenu.defaults, options);
	            // cache some elements and initialize some variables
	            this._config();

	            var animEndEventNames &#x3D; {
	                    &#x27;WebkitAnimation&#x27;: &#x27;webkitAnimationEnd&#x27;,
	                    &#x27;OAnimation&#x27;: &#x27;oAnimationEnd&#x27;,
	                    &#x27;msAnimation&#x27;: &#x27;MSAnimationEnd&#x27;,
	                    &#x27;animation&#x27;: &#x27;animationend&#x27;
	                },
	                transEndEventNames &#x3D; {
	                    &#x27;WebkitTransition&#x27;: &#x27;webkitTransitionEnd&#x27;,
	                    &#x27;MozTransition&#x27;: &#x27;transitionend&#x27;,
	                    &#x27;OTransition&#x27;: &#x27;oTransitionEnd&#x27;,
	                    &#x27;msTransition&#x27;: &#x27;MSTransitionEnd&#x27;,
	                    &#x27;transition&#x27;: &#x27;transitionend&#x27;
	                };
	            // animation end event name
	            this.animEndEventName &#x3D; animEndEventNames[Modernizr.prefixed(&#x27;animation&#x27;)] + &#x27;.dlmenu&#x27;;
	            // transition end event name
	            this.transEndEventName &#x3D; transEndEventNames[Modernizr.prefixed(&#x27;transition&#x27;)] + &#x27;.dlmenu&#x27;,
	                // support for css animations and css transitions
	                this.supportAnimations &#x3D; Modernizr.cssanimations,
	                this.supportTransitions &#x3D; Modernizr.csstransitions;

	            this._initEvents();

	        },
	        _config: function () {
	            this.open &#x3D; false;
	            this.$trigger &#x3D; $(&#x27;.dl-trigger&#x27;);
	            this.$menu &#x3D; this.$el.children(&#x27;ul.dl-menu&#x27;);
	            this.$menuitems &#x3D; this.$menu.find(&#x27;li:not(.dl-back)&#x27;);
	            this.$el.find(&#x27;ul.dl-submenu,ul.lg-submenu&#x27;).prepend(&#x27;&lt;li class&#x3D;&quot;dl-back&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;back&lt;/a&gt;&lt;/li&gt;&#x27;);
	            this.$back &#x3D; this.$menu.find(&#x27;li.dl-back&#x27;);
	        },
	        _initEvents: function () {

	            var self &#x3D; this;

	            this.$trigger.on(&#x27;click.dlmenu&#x27;, function () {

	                if (self.open) {
	                    self._closeMenu();
	                }
	                else {
	                    self._openMenu();
	                }
	                return false;

	            });

	            this.$menuitems.on(&#x27;click.dlmenu&#x27;, function (event) {

	                if (!$(this).find(&#x27;a&#x27;).slice(0, 1).data(&#x27;toggle&#x27;)) {

	                    event.stopPropagation();
	                }

	                var $item &#x3D; $(this),
	                    $submenu &#x3D; $item.children(&#x27;ul.dl-submenu&#x27;);

	                if ($submenu.length &gt; 0) {

	                    var $flyin &#x3D; $submenu.clone().css(&#x27;opacity&#x27;, 0).insertAfter(self.$menu),
	                        onAnimationEndFn &#x3D; function () {
	                            self.$menu.off(self.animEndEventName).removeClass(self.options.animationClasses.classout).addClass(&#x27;dl-subview&#x27;);
	                            $item.addClass(&#x27;dl-subviewopen&#x27;).parents(&#x27;.dl-subviewopen:first&#x27;).removeClass(&#x27;dl-subviewopen&#x27;).addClass(&#x27;dl-subview&#x27;);
	                            $flyin.remove();
	                        };

	                    setTimeout(function () {
	                        $flyin.addClass(self.options.animationClasses.classin);
	                        self.$menu.addClass(self.options.animationClasses.classout);
	                        if (self.supportAnimations) {
	                            self.$menu.on(self.animEndEventName, onAnimationEndFn);
	                        }
	                        else {
	                            onAnimationEndFn.call();
	                        }

	                        self.options.onLevelClick($item, $item.children(&#x27;a:first&#x27;).text());
	                    });

	                    return false;

	                }
	                else {
	                    self.options.onLinkClick($item, event);
	                }

	            });

	            this.$back.on(&#x27;click.dlmenu&#x27;, function (event) {

	                var $this &#x3D; $(this),
	                    $submenu &#x3D; $this.parents(&#x27;ul.dl-submenu:first&#x27;),
	                    $item &#x3D; $submenu.parent(),

	                    $flyin &#x3D; $submenu.clone().insertAfter(self.$menu);

	                var onAnimationEndFn &#x3D; function () {
	                    self.$menu.off(self.animEndEventName).removeClass(self.options.animationClasses.classin);
	                    $flyin.remove();
	                };

	                setTimeout(function () {
	                    $flyin.addClass(self.options.animationClasses.classout);
	                    self.$menu.addClass(self.options.animationClasses.classin);
	                    if (self.supportAnimations) {
	                        self.$menu.on(self.animEndEventName, onAnimationEndFn);
	                    }
	                    else {
	                        onAnimationEndFn.call();
	                    }

	                    $item.removeClass(&#x27;dl-subviewopen&#x27;);

	                    var $subview &#x3D; $this.parents(&#x27;.dl-subview:first&#x27;);
	                    if ($subview.is(&#x27;li&#x27;)) {
	                        $subview.addClass(&#x27;dl-subviewopen&#x27;);
	                    }
	                    $subview.removeClass(&#x27;dl-subview&#x27;);
	                });

	                return false;

	            });

	        },
	        closeMenu: function () {
	            if (this.open) {
	                this._closeMenu();

	            }
	        },
	        _closeMenu: function () {
	            var self &#x3D; this,
	                onTransitionEndFn &#x3D; function () {
	                    self.$menu.off(self.transEndEventName);
	                    self._resetMenu();
	                };

	            this.$menu.removeClass(&#x27;dl-menuopen&#x27;);
	            this.$menu.addClass(&#x27;dl-menu-toggle&#x27;);
	            this.$trigger.removeClass(&#x27;dl-active&#x27;);

	            if (this.supportTransitions) {
	                this.$menu.on(this.transEndEventName, onTransitionEndFn);
	            }
	            else {
	                onTransitionEndFn.call();
	            }

	            this.open &#x3D; false;
	        },
	        openMenu: function () {
	            if (!this.open) {
	                this._openMenu();
	            }
	        },
	        _openMenu: function () {
	            var self &#x3D; this;
	            // clicking somewhere else makes the menu close
	            $body.off(&#x27;click&#x27;).on(&#x27;click.dlmenu&#x27;, function () {
	                self._closeMenu();
	            });
	            this.$menu.addClass(&#x27;dl-menuopen dl-menu-toggle&#x27;).on(this.transEndEventName, function () {
	                $(this).removeClass(&#x27;dl-menu-toggle&#x27;);
	            });
	            this.$trigger.addClass(&#x27;dl-active&#x27;);
	            this.open &#x3D; true;
	        },
	        // resets the menu to its original state (first level of options)
	        _resetMenu: function () {
	            this.$menu.removeClass(&#x27;dl-subview&#x27;);
	            this.$menuitems.removeClass(&#x27;dl-subview dl-subviewopen&#x27;);
	        }
	    };

	    var logError &#x3D; function (message) {
	        if (window.console) {
	            window.console.error(message);
	        }
	    };

	    $.fn.dlmenu &#x3D; function (options) {
	        if (typeof options &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
	            var args &#x3D; Array.prototype.slice.call(arguments, 1);
	            this.each(function () {
	                var instance &#x3D; $.data(this, &#x27;dlmenu&#x27;);
	                if (!instance) {
	                    logError(&quot;cannot call methods on dlmenu prior to initialization; &quot; +
	                        &quot;attempted to call method &#x27;&quot; + options + &quot;&#x27;&quot;);
	                    return;
	                }
	                if (!$.isFunction(instance[options]) || options.charAt(0) &#x3D;&#x3D;&#x3D; &quot;_&quot;) {
	                    logError(&quot;no such method &#x27;&quot; + options + &quot;&#x27; for dlmenu instance&quot;);
	                    return;
	                }
	                instance[options].apply(instance, args);
	            });
	        }
	        else {
	            this.each(function () {
	                var instance &#x3D; $.data(this, &#x27;dlmenu&#x27;);
	                if (instance) {
	                    instance._init();
	                }
	                else {
	                    instance &#x3D; $.data(this, &#x27;dlmenu&#x27;, new $.DLMenu(options, this));
	                }
	            });
	        }
	        return this;
	    };

	})(jQuery, window);

/***/ }),
/* 222 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    /*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
	     Hero Section
	     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*/
	    if ($(&#x27;section.hero-header&#x27;).length &gt; 0) {
	        var $mainnav &#x3D; $(&#x27;.mainnav&#x27;).height();
	        $(&#x27;section.hero-header&#x27;).height($(window).height());
	        // Window Resize
	        $(window).resize(function () {
	            $(&#x27;section.hero-header&#x27;).height($(window).height());
	        });
	    }
	    /*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
	     Cut Section
	     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*/
	    if ($(&#x27;.cut&#x27;).length &gt; 0) {
	        $(&#x27;.cut&#x27;).each(function () {
	            if ($(this).hasClass(&#x27;cut-top&#x27;))
	                $(this).css(&#x27;border-right-width&#x27;, $(this).parent().width() + &quot;px&quot;);
	            else if ($(this).hasClass(&#x27;cut-bottom&#x27;))
	                $(this).css(&#x27;border-left-width&#x27;, $(this).parent().width() + &quot;px&quot;);
	        });

	    }
	});

/***/ }),
/* 223 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    var type,
	        w3c,
	        start,
	        webkit,
	        opacity,
	        banner_overlay &#x3D; &#x27;.overlay&#x27;,
	        color_start,
	        color_end,
	        orientation;


	    var overlay &#x3D; $(banner_overlay);

	    overlay.each(function () {
	        var $this &#x3D; $(this),
	            color_start &#x3D; $this.data(&#x27;start&#x27;),
	            color_end &#x3D; $this.data(&#x27;end&#x27;),
	            orientation &#x3D; $this.data(&#x27;orientation&#x27;),
	            opacity &#x3D; $this.data(&#x27;opacity&#x27;);

	        apply_gradient($this, color_start, color_end, orientation, opacity);

	    });


	    function apply_gradient(ele, color_start, color_end, orientation, opacity) {

	        switch (orientation) {
	            case &#x27;tobottomright&#x27;:
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to bottom right&quot;;
	                start &#x3D; &quot;top left&quot;;
	                webkit &#x3D; &quot;left top, right bottom&quot;;
	                break;
	            case &#x27;tobottom&#x27;        :
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to bottom&quot;;
	                start &#x3D; &quot;top&quot;;
	                webkit &#x3D; &quot;left top, left bottom&quot;;
	                break;
	            case &#x27;tobottomleft&#x27;    :
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to bottom left&quot;;
	                start &#x3D; &quot;top right&quot;;
	                webkit &#x3D; &quot;right top, left bottom&quot;;
	                break;
	            case &#x27;toright&#x27;        :
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to right&quot;;
	                start &#x3D; &quot;left&quot;;
	                webkit &#x3D; &quot;left top, right top&quot;;
	                break;
	            case &#x27;toleft&#x27;        :
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to left&quot;;
	                start &#x3D; &quot;right&quot;;
	                webkit &#x3D; &quot;right top, left top&quot;;
	                break;
	            case &#x27;totopright&#x27;    :
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to top right&quot;;
	                start &#x3D; &quot;bottom left&quot;;
	                webkit &#x3D; &quot;left bottom, right top&quot;;
	                break;
	            case &#x27;totop&#x27;        :
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to top&quot;;
	                start &#x3D; &quot;bottom&quot;;
	                webkit &#x3D; &quot;left bottom, left top&quot;;
	                break;
	            case &#x27;totopleft&#x27;    :
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to top left&quot;;
	                start &#x3D; &quot;bottom right&quot;;
	                webkit &#x3D; &quot;right bottom, left top&quot;;
	                break;
	            case &#x27;circulartopleft&#x27;        :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at left top&quot;;
	                start &#x3D; &quot;left top, circle farthest-side&quot;;
	                webkit &#x3D; &quot;left top, 0, left top, 973&quot;;
	                break;
	            case &#x27;circulartopcenter&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at center top&quot;;
	                start &#x3D; &quot;center top, circle farthest-side&quot;;
	                webkit &#x3D; &quot;center top, 0, center top, 487&quot;;
	                break;
	            case &#x27;circulartopright&#x27;        :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at right top&quot;;
	                start &#x3D; &quot;right top, circle farthest-side&quot;;
	                webkit &#x3D; &quot;right top, 0, right top, 973&quot;;
	                break;
	            case &#x27;circularmiddleleft&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at left center&quot;;
	                start &#x3D; &quot;left center, circle farthest-side&quot;;
	                webkit &#x3D; &quot;left center, 0, left center, 973&quot;;
	                break;
	            case &#x27;circularmiddlecenter&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at center&quot;;
	                start &#x3D; &quot;center, circle farthest-side&quot;;
	                webkit &#x3D; &quot;center center, 0, center center, 487&quot;;
	                break;
	            case &#x27;circularmiddleright&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at right center&quot;;
	                start &#x3D; &quot;right center, circle farthest-side&quot;;
	                webkit &#x3D; &quot;right center, 0, right center&quot;;
	                break;
	            case &#x27;circularbottomleft&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at left bottom&quot;;
	                start &#x3D; &quot;left bottom, circle farthest-side&quot;;
	                webkit &#x3D; &quot;left bottom, 0, left bottom, 973&quot;;
	                break;
	            case &#x27;circularbottomcenter&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at center bottom&quot;;
	                start &#x3D; &quot;center bottom, circle farthest-side&quot;;
	                webkit &#x3D; &quot;center bottom, 0, center bottom, 487&quot;;
	                break;
	            case &#x27;circularbottomright&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;circle farthest-side at right bottom&quot;;
	                start &#x3D; &quot;right bottom, circle farthest-side&quot;;
	                webkit &#x3D; &quot;right bottom, 0, right bottom, 973&quot;;
	                break;
	            case &#x27;ellipsetopleft&#x27;        :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at left top&quot;;
	                start &#x3D; &quot;left top, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;left top, 0, left top, 973&quot;;
	                break;
	            case &#x27;ellipsetopcenter&#x27;        :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at center top&quot;;
	                start &#x3D; &quot;center top, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;center top, 0, center top, 487&quot;;
	                break;
	            case &#x27;ellipsetopright&#x27;        :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at right top&quot;;
	                start &#x3D; &quot;right top, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;right top, 0, right top, 973&quot;;
	                break;
	            case &#x27;ellipsemiddleleft&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at left center&quot;;
	                start &#x3D; &quot;left center, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;left center, 0, left center, 973&quot;;
	                break;
	            case &#x27;ellipsemiddlecenter&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at center&quot;;
	                start &#x3D; &quot;center, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;center center, 0, center center, 487&quot;;
	                break;
	            case &#x27;ellipsemiddleright&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at right center&quot;;
	                start &#x3D; &quot;right center, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;right center, 0, right center&quot;;
	                break;
	            case &#x27;ellipsebottomleft&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at left bottom&quot;;
	                start &#x3D; &quot;left bottom, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;left bottom, 0, left bottom, 973&quot;;
	                break;
	            case &#x27;ellipsebottomcenter&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at center bottom&quot;;
	                start &#x3D; &quot;center bottom, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;center bottom, 0, center bottom, 487&quot;;
	                break;
	            case &#x27;ellipsebottomright&#x27;    :
	                type &#x3D; &quot;radial&quot;;
	                w3c &#x3D; &quot;ellipse farthest-side at right bottom&quot;;
	                start &#x3D; &quot;right bottom, ellipse farthest-side&quot;;
	                webkit &#x3D; &quot;right bottom, 0, right bottom, 973&quot;;
	                break;

	            default:
	                type &#x3D; &quot;linear&quot;;
	                w3c &#x3D; &quot;to right&quot;;
	                start &#x3D; &quot;left&quot;;
	                webkit &#x3D; &quot;left top, right top&quot;;
	                break;
	        }

	        if (color_end) {
	            jQuery(ele).css({&#x27;background&#x27;: color_start, &#x27;opacity&#x27;: opacity});
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-moz-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-webkit-gradient(&#x27; + type + &#x27;, &#x27; + webkit + &#x27;, color-stop(0, &#x27; + color_start + &#x27;), color-stop(1, &#x27; + color_end + &#x27;))&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-webkit-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-o-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;-ms-&#x27; + type + &#x27;-gradient(&#x27; + start + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;&#x27; + type + &#x27;-gradient(&#x27; + w3c + &#x27;, &#x27; + color_start + &#x27; 0%, &#x27; + color_end + &#x27; 100%)&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	            jQuery(ele).css({
	                &#x27;background&#x27;: &#x27;filter: progid:DXImageTransform.Microsoft.gradient( startColorstr&#x3D;\&#x27;&#x27; + color_start + &#x27;\&#x27;, endColorstr&#x3D;\&#x27;&#x27; + color_end + &#x27;\&#x27;,GradientType&#x3D;1 )&#x27;,
	                &#x27;opacity&#x27;: opacity
	            });
	        }

	        else {
	            jQuery(ele).css({&#x27;background&#x27;: color_start, &#x27;opacity&#x27;: opacity});
	        }
	    }

	});


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(225);
	jQuery(function ($) {
	    &quot;use strict&quot;;
	    $(&#x27;.parallax&#x27;).stellar({
	        horizontalScrolling: false,
	        verticalOffset: 40,
	        responsive: true
	    });
	});

/***/ }),
/* 225 */
/***/ (function(module, exports) {

	/*! Stellar.js v0.6.2 | Copyright 2014, Mark Dalgleish | http://markdalgleish.com/projects/stellar.js | http://markdalgleish.mit-license.org */
	!function(a,b,c,d){function e(b,c){this.element&#x3D;b,this.options&#x3D;a.extend({},g,c),this._defaults&#x3D;g,this._name&#x3D;f,this.init()}var f&#x3D;&quot;stellar&quot;,g&#x3D;{scrollProperty:&quot;scroll&quot;,positionProperty:&quot;position&quot;,horizontalScrolling:!0,verticalScrolling:!0,horizontalOffset:0,verticalOffset:0,responsive:!1,parallaxBackgrounds:!0,parallaxElements:!0,hideDistantElements:!0,hideElement:function(a){a.hide()},showElement:function(a){a.show()}},h&#x3D;{scroll:{getLeft:function(a){return a.scrollLeft()},setLeft:function(a,b){a.scrollLeft(b)},getTop:function(a){return a.scrollTop()},setTop:function(a,b){a.scrollTop(b)}},position:{getLeft:function(a){return-1*parseInt(a.css(&quot;left&quot;),10)},getTop:function(a){return-1*parseInt(a.css(&quot;top&quot;),10)}},margin:{getLeft:function(a){return-1*parseInt(a.css(&quot;margin-left&quot;),10)},getTop:function(a){return-1*parseInt(a.css(&quot;margin-top&quot;),10)}},transform:{getLeft:function(a){var b&#x3D;getComputedStyle(a[0])[k];return&quot;none&quot;!&#x3D;&#x3D;b?-1*parseInt(b.match(/(-?[0-9]+)/g)[4],10):0},getTop:function(a){var b&#x3D;getComputedStyle(a[0])[k];return&quot;none&quot;!&#x3D;&#x3D;b?-1*parseInt(b.match(/(-?[0-9]+)/g)[5],10):0}}},i&#x3D;{position:{setLeft:function(a,b){a.css(&quot;left&quot;,b)},setTop:function(a,b){a.css(&quot;top&quot;,b)}},transform:{setPosition:function(a,b,c,d,e){a[0].style[k]&#x3D;&quot;translate3d(&quot;+(b-c)+&quot;px, &quot;+(d-e)+&quot;px, 0)&quot;}}},j&#x3D;function(){var b,c&#x3D;/^(Moz|Webkit|Khtml|O|ms|Icab)(?&#x3D;[A-Z])/,d&#x3D;a(&quot;script&quot;)[0].style,e&#x3D;&quot;&quot;;for(b in d)if(c.test(b)){e&#x3D;b.match(c)[0];break}return&quot;WebkitOpacity&quot;in d&amp;&amp;(e&#x3D;&quot;Webkit&quot;),&quot;KhtmlOpacity&quot;in d&amp;&amp;(e&#x3D;&quot;Khtml&quot;),function(a){return e+(e.length&gt;0?a.charAt(0).toUpperCase()+a.slice(1):a)}}(),k&#x3D;j(&quot;transform&quot;),l&#x3D;a(&quot;&lt;div /&gt;&quot;,{style:&quot;background:#fff&quot;}).css(&quot;background-position-x&quot;)!&#x3D;&#x3D;d,m&#x3D;l?function(a,b,c){a.css({&quot;background-position-x&quot;:b,&quot;background-position-y&quot;:c})}:function(a,b,c){a.css(&quot;background-position&quot;,b+&quot; &quot;+c)},n&#x3D;l?function(a){return[a.css(&quot;background-position-x&quot;),a.css(&quot;background-position-y&quot;)]}:function(a){return a.css(&quot;background-position&quot;).split(&quot; &quot;)},o&#x3D;b.requestAnimationFrame||b.webkitRequestAnimationFrame||b.mozRequestAnimationFrame||b.oRequestAnimationFrame||b.msRequestAnimationFrame||function(a){setTimeout(a,1e3/60)};e.prototype&#x3D;{init:function(){this.options.name&#x3D;f+&quot;_&quot;+Math.floor(1e9*Math.random()),this._defineElements(),this._defineGetters(),this._defineSetters(),this._handleWindowLoadAndResize(),this._detectViewport(),this.refresh({firstLoad:!0}),&quot;scroll&quot;&#x3D;&#x3D;&#x3D;this.options.scrollProperty?this._handleScrollEvent():this._startAnimationLoop()},_defineElements:function(){this.element&#x3D;&#x3D;&#x3D;c.body&amp;&amp;(this.element&#x3D;b),this.$scrollElement&#x3D;a(this.element),this.$element&#x3D;this.element&#x3D;&#x3D;&#x3D;b?a(&quot;body&quot;):this.$scrollElement,this.$viewportElement&#x3D;this.options.viewportElement!&#x3D;&#x3D;d?a(this.options.viewportElement):this.$scrollElement[0]&#x3D;&#x3D;&#x3D;b||&quot;scroll&quot;&#x3D;&#x3D;&#x3D;this.options.scrollProperty?this.$scrollElement:this.$scrollElement.parent()},_defineGetters:function(){var a&#x3D;this,b&#x3D;h[a.options.scrollProperty];this._getScrollLeft&#x3D;function(){return b.getLeft(a.$scrollElement)},this._getScrollTop&#x3D;function(){return b.getTop(a.$scrollElement)}},_defineSetters:function(){var b&#x3D;this,c&#x3D;h[b.options.scrollProperty],d&#x3D;i[b.options.positionProperty],e&#x3D;c.setLeft,f&#x3D;c.setTop;this._setScrollLeft&#x3D;&quot;function&quot;&#x3D;&#x3D;typeof e?function(a){e(b.$scrollElement,a)}:a.noop,this._setScrollTop&#x3D;&quot;function&quot;&#x3D;&#x3D;typeof f?function(a){f(b.$scrollElement,a)}:a.noop,this._setPosition&#x3D;d.setPosition||function(a,c,e,f,g){b.options.horizontalScrolling&amp;&amp;d.setLeft(a,c,e),b.options.verticalScrolling&amp;&amp;d.setTop(a,f,g)}},_handleWindowLoadAndResize:function(){var c&#x3D;this,d&#x3D;a(b);c.options.responsive&amp;&amp;d.bind(&quot;load.&quot;+this.name,function(){c.refresh()}),d.bind(&quot;resize.&quot;+this.name,function(){c._detectViewport(),c.options.responsive&amp;&amp;c.refresh()})},refresh:function(c){var d&#x3D;this,e&#x3D;d._getScrollLeft(),f&#x3D;d._getScrollTop();c&amp;&amp;c.firstLoad||this._reset(),this._setScrollLeft(0),this._setScrollTop(0),this._setOffsets(),this._findParticles(),this._findBackgrounds(),c&amp;&amp;c.firstLoad&amp;&amp;/WebKit/.test(navigator.userAgent)&amp;&amp;a(b).load(function(){var a&#x3D;d._getScrollLeft(),b&#x3D;d._getScrollTop();d._setScrollLeft(a+1),d._setScrollTop(b+1),d._setScrollLeft(a),d._setScrollTop(b)}),this._setScrollLeft(e),this._setScrollTop(f)},_detectViewport:function(){var a&#x3D;this.$viewportElement.offset(),b&#x3D;null!&#x3D;&#x3D;a&amp;&amp;a!&#x3D;&#x3D;d;this.viewportWidth&#x3D;this.$viewportElement.width(),this.viewportHeight&#x3D;this.$viewportElement.height(),this.viewportOffsetTop&#x3D;b?a.top:0,this.viewportOffsetLeft&#x3D;b?a.left:0},_findParticles:function(){{var b&#x3D;this;this._getScrollLeft(),this._getScrollTop()}if(this.particles!&#x3D;&#x3D;d)for(var c&#x3D;this.particles.length-1;c&gt;&#x3D;0;c--)this.particles[c].$element.data(&quot;stellar-elementIsActive&quot;,d);this.particles&#x3D;[],this.options.parallaxElements&amp;&amp;this.$element.find(&quot;[data-stellar-ratio]&quot;).each(function(){var c,e,f,g,h,i,j,k,l,m&#x3D;a(this),n&#x3D;0,o&#x3D;0,p&#x3D;0,q&#x3D;0;if(m.data(&quot;stellar-elementIsActive&quot;)){if(m.data(&quot;stellar-elementIsActive&quot;)!&#x3D;&#x3D;this)return}else m.data(&quot;stellar-elementIsActive&quot;,this);b.options.showElement(m),m.data(&quot;stellar-startingLeft&quot;)?(m.css(&quot;left&quot;,m.data(&quot;stellar-startingLeft&quot;)),m.css(&quot;top&quot;,m.data(&quot;stellar-startingTop&quot;))):(m.data(&quot;stellar-startingLeft&quot;,m.css(&quot;left&quot;)),m.data(&quot;stellar-startingTop&quot;,m.css(&quot;top&quot;))),f&#x3D;m.position().left,g&#x3D;m.position().top,h&#x3D;&quot;auto&quot;&#x3D;&#x3D;&#x3D;m.css(&quot;margin-left&quot;)?0:parseInt(m.css(&quot;margin-left&quot;),10),i&#x3D;&quot;auto&quot;&#x3D;&#x3D;&#x3D;m.css(&quot;margin-top&quot;)?0:parseInt(m.css(&quot;margin-top&quot;),10),k&#x3D;m.offset().left-h,l&#x3D;m.offset().top-i,m.parents().each(function(){var b&#x3D;a(this);return b.data(&quot;stellar-offset-parent&quot;)&#x3D;&#x3D;&#x3D;!0?(n&#x3D;p,o&#x3D;q,j&#x3D;b,!1):(p+&#x3D;b.position().left,void(q+&#x3D;b.position().top))}),c&#x3D;m.data(&quot;stellar-horizontal-offset&quot;)!&#x3D;&#x3D;d?m.data(&quot;stellar-horizontal-offset&quot;):j!&#x3D;&#x3D;d&amp;&amp;j.data(&quot;stellar-horizontal-offset&quot;)!&#x3D;&#x3D;d?j.data(&quot;stellar-horizontal-offset&quot;):b.horizontalOffset,e&#x3D;m.data(&quot;stellar-vertical-offset&quot;)!&#x3D;&#x3D;d?m.data(&quot;stellar-vertical-offset&quot;):j!&#x3D;&#x3D;d&amp;&amp;j.data(&quot;stellar-vertical-offset&quot;)!&#x3D;&#x3D;d?j.data(&quot;stellar-vertical-offset&quot;):b.verticalOffset,b.particles.push({$element:m,$offsetParent:j,isFixed:&quot;fixed&quot;&#x3D;&#x3D;&#x3D;m.css(&quot;position&quot;),horizontalOffset:c,verticalOffset:e,startingPositionLeft:f,startingPositionTop:g,startingOffsetLeft:k,startingOffsetTop:l,parentOffsetLeft:n,parentOffsetTop:o,stellarRatio:m.data(&quot;stellar-ratio&quot;)!&#x3D;&#x3D;d?m.data(&quot;stellar-ratio&quot;):1,width:m.outerWidth(!0),height:m.outerHeight(!0),isHidden:!1})})},_findBackgrounds:function(){var b,c&#x3D;this,e&#x3D;this._getScrollLeft(),f&#x3D;this._getScrollTop();this.backgrounds&#x3D;[],this.options.parallaxBackgrounds&amp;&amp;(b&#x3D;this.$element.find(&quot;[data-stellar-background-ratio]&quot;),this.$element.data(&quot;stellar-background-ratio&quot;)&amp;&amp;(b&#x3D;b.add(this.$element)),b.each(function(){var b,g,h,i,j,k,l,o&#x3D;a(this),p&#x3D;n(o),q&#x3D;0,r&#x3D;0,s&#x3D;0,t&#x3D;0;if(o.data(&quot;stellar-backgroundIsActive&quot;)){if(o.data(&quot;stellar-backgroundIsActive&quot;)!&#x3D;&#x3D;this)return}else o.data(&quot;stellar-backgroundIsActive&quot;,this);o.data(&quot;stellar-backgroundStartingLeft&quot;)?m(o,o.data(&quot;stellar-backgroundStartingLeft&quot;),o.data(&quot;stellar-backgroundStartingTop&quot;)):(o.data(&quot;stellar-backgroundStartingLeft&quot;,p[0]),o.data(&quot;stellar-backgroundStartingTop&quot;,p[1])),h&#x3D;&quot;auto&quot;&#x3D;&#x3D;&#x3D;o.css(&quot;margin-left&quot;)?0:parseInt(o.css(&quot;margin-left&quot;),10),i&#x3D;&quot;auto&quot;&#x3D;&#x3D;&#x3D;o.css(&quot;margin-top&quot;)?0:parseInt(o.css(&quot;margin-top&quot;),10),j&#x3D;o.offset().left-h-e,k&#x3D;o.offset().top-i-f,o.parents().each(function(){var b&#x3D;a(this);return b.data(&quot;stellar-offset-parent&quot;)&#x3D;&#x3D;&#x3D;!0?(q&#x3D;s,r&#x3D;t,l&#x3D;b,!1):(s+&#x3D;b.position().left,void(t+&#x3D;b.position().top))}),b&#x3D;o.data(&quot;stellar-horizontal-offset&quot;)!&#x3D;&#x3D;d?o.data(&quot;stellar-horizontal-offset&quot;):l!&#x3D;&#x3D;d&amp;&amp;l.data(&quot;stellar-horizontal-offset&quot;)!&#x3D;&#x3D;d?l.data(&quot;stellar-horizontal-offset&quot;):c.horizontalOffset,g&#x3D;o.data(&quot;stellar-vertical-offset&quot;)!&#x3D;&#x3D;d?o.data(&quot;stellar-vertical-offset&quot;):l!&#x3D;&#x3D;d&amp;&amp;l.data(&quot;stellar-vertical-offset&quot;)!&#x3D;&#x3D;d?l.data(&quot;stellar-vertical-offset&quot;):c.verticalOffset,c.backgrounds.push({$element:o,$offsetParent:l,isFixed:&quot;fixed&quot;&#x3D;&#x3D;&#x3D;o.css(&quot;background-attachment&quot;),horizontalOffset:b,verticalOffset:g,startingValueLeft:p[0],startingValueTop:p[1],startingBackgroundPositionLeft:isNaN(parseInt(p[0],10))?0:parseInt(p[0],10),startingBackgroundPositionTop:isNaN(parseInt(p[1],10))?0:parseInt(p[1],10),startingPositionLeft:o.position().left,startingPositionTop:o.position().top,startingOffsetLeft:j,startingOffsetTop:k,parentOffsetLeft:q,parentOffsetTop:r,stellarRatio:o.data(&quot;stellar-background-ratio&quot;)&#x3D;&#x3D;&#x3D;d?1:o.data(&quot;stellar-background-ratio&quot;)})}))},_reset:function(){var a,b,c,d,e;for(e&#x3D;this.particles.length-1;e&gt;&#x3D;0;e--)a&#x3D;this.particles[e],b&#x3D;a.$element.data(&quot;stellar-startingLeft&quot;),c&#x3D;a.$element.data(&quot;stellar-startingTop&quot;),this._setPosition(a.$element,b,b,c,c),this.options.showElement(a.$element),a.$element.data(&quot;stellar-startingLeft&quot;,null).data(&quot;stellar-elementIsActive&quot;,null).data(&quot;stellar-backgroundIsActive&quot;,null);for(e&#x3D;this.backgrounds.length-1;e&gt;&#x3D;0;e--)d&#x3D;this.backgrounds[e],d.$element.data(&quot;stellar-backgroundStartingLeft&quot;,null).data(&quot;stellar-backgroundStartingTop&quot;,null),m(d.$element,d.startingValueLeft,d.startingValueTop)},destroy:function(){this._reset(),this.$scrollElement.unbind(&quot;resize.&quot;+this.name).unbind(&quot;scroll.&quot;+this.name),this._animationLoop&#x3D;a.noop,a(b).unbind(&quot;load.&quot;+this.name).unbind(&quot;resize.&quot;+this.name)},_setOffsets:function(){var c&#x3D;this,d&#x3D;a(b);d.unbind(&quot;resize.horizontal-&quot;+this.name).unbind(&quot;resize.vertical-&quot;+this.name),&quot;function&quot;&#x3D;&#x3D;typeof this.options.horizontalOffset?(this.horizontalOffset&#x3D;this.options.horizontalOffset(),d.bind(&quot;resize.horizontal-&quot;+this.name,function(){c.horizontalOffset&#x3D;c.options.horizontalOffset()})):this.horizontalOffset&#x3D;this.options.horizontalOffset,&quot;function&quot;&#x3D;&#x3D;typeof this.options.verticalOffset?(this.verticalOffset&#x3D;this.options.verticalOffset(),d.bind(&quot;resize.vertical-&quot;+this.name,function(){c.verticalOffset&#x3D;c.options.verticalOffset()})):this.verticalOffset&#x3D;this.options.verticalOffset},_repositionElements:function(){var a,b,c,d,e,f,g,h,i,j,k&#x3D;this._getScrollLeft(),l&#x3D;this._getScrollTop(),n&#x3D;!0,o&#x3D;!0;if(this.currentScrollLeft!&#x3D;&#x3D;k||this.currentScrollTop!&#x3D;&#x3D;l||this.currentWidth!&#x3D;&#x3D;this.viewportWidth||this.currentHeight!&#x3D;&#x3D;this.viewportHeight){for(this.currentScrollLeft&#x3D;k,this.currentScrollTop&#x3D;l,this.currentWidth&#x3D;this.viewportWidth,this.currentHeight&#x3D;this.viewportHeight,j&#x3D;this.particles.length-1;j&gt;&#x3D;0;j--)a&#x3D;this.particles[j],b&#x3D;a.isFixed?1:0,this.options.horizontalScrolling?(f&#x3D;(k+a.horizontalOffset+this.viewportOffsetLeft+a.startingPositionLeft-a.startingOffsetLeft+a.parentOffsetLeft)*-(a.stellarRatio+b-1)+a.startingPositionLeft,h&#x3D;f-a.startingPositionLeft+a.startingOffsetLeft):(f&#x3D;a.startingPositionLeft,h&#x3D;a.startingOffsetLeft),this.options.verticalScrolling?(g&#x3D;(l+a.verticalOffset+this.viewportOffsetTop+a.startingPositionTop-a.startingOffsetTop+a.parentOffsetTop)*-(a.stellarRatio+b-1)+a.startingPositionTop,i&#x3D;g-a.startingPositionTop+a.startingOffsetTop):(g&#x3D;a.startingPositionTop,i&#x3D;a.startingOffsetTop),this.options.hideDistantElements&amp;&amp;(o&#x3D;!this.options.horizontalScrolling||h+a.width&gt;(a.isFixed?0:k)&amp;&amp;h&lt;(a.isFixed?0:k)+this.viewportWidth+this.viewportOffsetLeft,n&#x3D;!this.options.verticalScrolling||i+a.height&gt;(a.isFixed?0:l)&amp;&amp;i&lt;(a.isFixed?0:l)+this.viewportHeight+this.viewportOffsetTop),o&amp;&amp;n?(a.isHidden&amp;&amp;(this.options.showElement(a.$element),a.isHidden&#x3D;!1),this._setPosition(a.$element,f,a.startingPositionLeft,g,a.startingPositionTop)):a.isHidden||(this.options.hideElement(a.$element),a.isHidden&#x3D;!0);for(j&#x3D;this.backgrounds.length-1;j&gt;&#x3D;0;j--)c&#x3D;this.backgrounds[j],b&#x3D;c.isFixed?0:1,d&#x3D;this.options.horizontalScrolling?(k+c.horizontalOffset-this.viewportOffsetLeft-c.startingOffsetLeft+c.parentOffsetLeft-c.startingBackgroundPositionLeft)*(b-c.stellarRatio)+&quot;px&quot;:c.startingValueLeft,e&#x3D;this.options.verticalScrolling?(l+c.verticalOffset-this.viewportOffsetTop-c.startingOffsetTop+c.parentOffsetTop-c.startingBackgroundPositionTop)*(b-c.stellarRatio)+&quot;px&quot;:c.startingValueTop,m(c.$element,d,e)}},_handleScrollEvent:function(){var a&#x3D;this,b&#x3D;!1,c&#x3D;function(){a._repositionElements(),b&#x3D;!1},d&#x3D;function(){b||(o(c),b&#x3D;!0)};this.$scrollElement.bind(&quot;scroll.&quot;+this.name,d),d()},_startAnimationLoop:function(){var a&#x3D;this;this._animationLoop&#x3D;function(){o(a._animationLoop),a._repositionElements()},this._animationLoop()}},a.fn[f]&#x3D;function(b){var c&#x3D;arguments;return b&#x3D;&#x3D;&#x3D;d||&quot;object&quot;&#x3D;&#x3D;typeof b?this.each(function(){a.data(this,&quot;plugin_&quot;+f)||a.data(this,&quot;plugin_&quot;+f,new e(this,b))}):&quot;string&quot;&#x3D;&#x3D;typeof b&amp;&amp;&quot;_&quot;!&#x3D;&#x3D;b[0]&amp;&amp;&quot;init&quot;!&#x3D;&#x3D;b?this.each(function(){var d&#x3D;a.data(this,&quot;plugin_&quot;+f);d instanceof e&amp;&amp;&quot;function&quot;&#x3D;&#x3D;typeof d[b]&amp;&amp;d[b].apply(d,Array.prototype.slice.call(c,1)),&quot;destroy&quot;&#x3D;&#x3D;&#x3D;b&amp;&amp;a.data(this,&quot;plugin_&quot;+f,null)}):void 0},a[f]&#x3D;function(){var c&#x3D;a(b);return c.stellar.apply(c,Array.prototype.slice.call(arguments,0))},a[f].scrollProperty&#x3D;h,a[f].positionProperty&#x3D;i,b.Stellar&#x3D;e}(jQuery,this,document);

/***/ }),
/* 226 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    window.addEventListener(&quot;load&quot;, function () {
	        var form &#x3D; document.getElementById(&quot;contactform&quot;);
	        form.addEventListener(&quot;submit&quot;, function (event) {

	            if (form.checkValidity() &#x3D;&#x3D; false) {
	                event.preventDefault();
	                event.stopPropagation();
	            }else{
	                $.ajax({
	                    type: &quot;POST&quot;,
	                    url: &quot;assets/php/submit.php&quot;,
	                    data: form.serialize(),
	                    success: function () {
	                        $(&#x27;#valid-issue&#x27;).addClass(&#x27;alert-success&#x27;).html(&#x27;Your message has been sent,&lt;BR&gt; We will contact you back with in next 24 hours.&#x27;).show();
	                    }
	                });
	            }

	            form.classList.add(&quot;was-validated&quot;);
	        }, false);
	    }, false);
	});

	jQuery(function ($) {
	    &quot;use strict&quot;;
	    if ( $(&quot;#contactform&quot;)) {
	        $(&quot;#contactform&quot;).submit(function (e) {
	            e.preventDefault();
	            var name &#x3D; $(&quot;#name&quot;).val(),
	                email &#x3D; $(&quot;#email&quot;).val(),
	                subject &#x3D; $(&quot;#subject&quot;).val(),
	                message &#x3D; $(&quot;#message&quot;).val(),
	                dataString &#x3D; &#x27;name&#x3D;&#x27; + name + &#x27;&amp;email&#x3D;&#x27; + email + &#x27;&amp;subject&#x3D;&#x27; + subject + &#x27;&amp;message&#x3D;&#x27; + message;

	            if (name &#x3D;&#x3D;&#x3D; &#x27;&#x27; || !IsEmail(email) || message &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
	                $(&#x27;#valid-issue&#x27;).addClass(&#x27;alert-danger&#x27;).html(&#x27;Please Provide Valid Information&#x27;).slideDown();
	            } else {
	                $.ajax({
	                    type: &quot;POST&quot;,
	                    url: &quot;assets/php/submit.php&quot;,
	                    data: $(&quot;form&quot;).serialize(),
	                    success: function () {
	                        $(&#x27;#contactform&#x27;).slideUp();
	                        $(&#x27;#valid-issue&#x27;).addClass(&#x27;alert-success&#x27;).html(&#x27;Your message has been sent,&lt;BR&gt; We will contact you back with in next 24 hours.&#x27;).show();
	                    }
	                });
	            }
	        });
	    }
	});


	function IsEmail(email) {
	    var regex &#x3D; /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
	    return regex.test(email);
	}




/***/ }),
/* 227 */
/***/ (function(module, exports) {

	jQuery(function ($) {

	    var $logoSticky, $logo;
	    $logo &#x3D; $(&#x27;.navbar-brand img&#x27;).attr(&#x27;src&#x27;);

	    window.onscroll &#x3D; function () {
	        var $ele &#x3D; $(&#x27;.nav-sticky&#x27;);
	        var $classes;
	        if ($ele.length &gt; 0) {
	            $classes &#x3D; ($ele.data(&#x27;nav-sticky-classes&#x27;)) ? $ele.data(&#x27;nav-sticky-classes&#x27;) : &#x27;white&#x27;;
	            if ($(window).scrollTop() &gt; 50) {
	                if ($logoSticky &#x3D; $ele.data(&#x27;nav-sticky-logo&#x27;)) {
	                    $(&#x27;.navbar-brand img&#x27;).attr(&#x27;src&#x27;, $logoSticky)
	                }
	                $ele.addClass(&#x27;sticky shadow &#x27; + $classes);
	            } else {
	                $ele.removeClass(&#x27;sticky shadow &#x27; + $classes);
	                $(&#x27;.navbar-brand img&#x27;).attr(&#x27;src&#x27;, $logo);
	            }
	        }
	    };
	});

/***/ })
/******/ ]);
		</script>
	</body>
</html>
